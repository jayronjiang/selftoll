###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:03
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Global.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Global.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\Global.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\Global.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Global.c
      1          /*******************************************************************************************************
      2          *
      3          *                                 (c) Copyright 2004-2007, John Tonny
      4          *
      5          *                                           All Rights Reserved
      6          *
      7          ********************************************************************************************************
      8          *
      9          *--------------文件信息---------------------------------------------------------------------------------
     10          *文   件   名: Global.C
     11          *创   建   人: John Tonny
     12          *最后修改日期: 2009年11月01日
     13          *描        述:
     14          *
     15          *--------------历史版本信息-----------------------------------------------------------------------------
     16          * 创建人: John Tonny
     17          * 版  本: V1.0
     18          * 日　期: 2009年11月01日
     19          * 描　述: 原始版本
     20          *
     21          *-------------------------------------------------------------------------------------------------------
     22          * 修改人:
     23          * 版  本:
     24          * 日　期:
     25          * 描　述:
     26          *
     27          *--------------当前版本修订-----------------------------------------------------------------------------
     28          * 修改人:
     29          * 日　期:
     30          * 描　述:
     31          *
     32          *-------------------------------------------------------------------------------------------------------
     33          *******************************************************************************************************/
     34          
     35          #define GLOBAL_GLOBALS
     36          #include "includes.h"

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucScanOpenTime
   \                     g_ucScanOpenTime:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucScanCloseTime
   \                     g_ucScanCloseTime:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute SCAN g_usrScan
   \                     g_usrScan:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucLedMode
   \                     g_ucLedMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucLedErrMode
   \                     g_ucLedErrMode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute SOUNDBUZZ g_usrBuzz
   \                     g_usrBuzz:
   \   00000000                      DS8 12

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucBoxCurSelected
   \                     g_ucBoxCurSelected:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U m_ucBoxCurWorking
   \                     m_ucBoxCurWorking:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U m_ucMachineAddr
   \                     m_ucMachineAddr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U m_ucBoxAddr
   \                     m_ucBoxAddr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U m_ucDMotoRetrys
   \                     m_ucDMotoRetrys:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute KEYVALUE g_usrGetKey
   \                     g_usrGetKey:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
   \   __absolute INT32U m_ulKeyOutput
   \                     m_ulKeyOutput:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute KEYVALUE g_usrGetKey1
   \                     g_usrGetKey1:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
   \   __absolute INT8U m_strVersion[32]
   \                     m_strVersion:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
   \   __absolute GLOBAL_FLAGS g_usrGlobalFlag
   \                     g_usrGlobalFlag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute MODUAL_FLAGS m_usrGlobalFlag
   \                     m_usrGlobalFlag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute BOXINFO m_usrBoxInfo[3]
   \                     m_usrBoxInfo:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \   __absolute INT8U m_ucCardBoxTxSeq
   \                     m_ucCardBoxTxSeq:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucGKeyTime
   \                     g_ucGKeyTime:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucGInState
   \                     g_ucGInState:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8U m_ucDMotoBit[8]
   \                     m_ucDMotoBit:
   \   00000000                      DS8 8

   \                                 In section .bss, align 2
   \   __absolute INT8U m_ucSMotoBit[2]
   \                     m_ucSMotoBit:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute INT8U m_ucUartBit[3]
   \                     m_ucUartBit:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8U m_ucKeyBit[32]
   \                     m_ucKeyBit:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
   \   __absolute INT8U m_ucBoxBit[4]
   \                     m_ucBoxBit:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT16U m_uiDMotoPwm[4]
   \                     m_uiDMotoPwm:
   \   00000000                      DS8 8

   \                                 In section .bss, align 2
   \   __absolute INT8U m_ucSMotoFreq[2]
   \                     m_ucSMotoFreq:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute DMOTO g_usrDMoto[4]
   \                     g_usrDMoto:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute SMOTO g_usrSMoto[2]
   \                     g_usrSMoto:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute MOTO_FLAGS g_usrMotoFlags
   \                     g_usrMotoFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \   __absolute INT8U g_ucCommTime
   \                     g_ucCommTime:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INTERRUPT_FLAGS g_usrInterruptFlags[4]
   \                     g_usrInterruptFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute ERROR_FLAGS m_usrErrorFlags
   \                     m_usrErrorFlags:
   \   00000000                      DS8 4
     37          
     38          

   \                                 In section .data, align 4
     39          INT8U  m_ucKey_GROUP_SMALL_ZIN_TYPE[]={ 4, 5,26, 3,24,25, 8, 7, 6, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23, 0, 1, 2,27,28,29,30,31,
   \                     m_ucKey_GROUP_SMALL_ZIN_TYPE:
   \   00000000   0x04 0x05          DC8 4, 5, 26, 3, 24, 25, 8, 7, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18
   \              0x1A 0x03    
   \              0x18 0x19    
   \              0x08 0x07    
   \              0x06 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x11    
   \              0x12         
   \   00000013   0x13 0x14          DC8 19, 20, 21, 22, 23, 0, 1, 2, 27, 28, 29, 30, 31, 12, 13, 2, 11, 4
   \              0x15 0x16    
   \              0x17 0x00    
   \              0x01 0x02    
   \              0x1B 0x1C    
   \              0x1D 0x1E    
   \              0x1F 0x0C    
   \              0x0D 0x02    
   \              0x0B 0x04    
   \   00000025   0x05 0x1A          DC8 5, 26, 7, 14, 24, 25, 3, 0, 1, 8, 15, 16, 17, 18, 19, 20, 21, 22
   \              0x07 0x0E    
   \              0x18 0x19    
   \              0x03 0x00    
   \              0x01 0x08    
   \              0x0F 0x10    
   \              0x11 0x12    
   \              0x13 0x14    
   \              0x15 0x16    
   \   00000037   0x17 0x08          DC8 23, 8, 9, 10, 27, 28, 29, 30, 31, 20, 21, 2, 19, 4, 5, 6, 7, 22, 9
   \              0x09 0x0A    
   \              0x1B 0x1C    
   \              0x1D 0x1E    
   \              0x1F 0x14    
   \              0x15 0x02    
   \              0x13 0x04    
   \              0x05 0x06    
   \              0x07 0x16    
   \              0x09         
   \   0000004A   0x0A 0x0B          DC8 10, 11, 12, 13, 14, 15, 24, 25, 26, 3, 0, 1, 8, 23, 16, 17, 18, 27
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x18 0x19    
   \              0x1A 0x03    
   \              0x00 0x01    
   \              0x08 0x17    
   \              0x10 0x11    
   \              0x12 0x1B    
   \   0000005C   0x1C 0x1D          DC8 28, 29, 30, 31
   \              0x1E 0x1F    
     40                                                 
     41                                                 12,13, 2,11, 4, 5,26, 7,14,24,25, 3, 0, 1, 8,15,16,17,18,19,20,21,22,23, 8, 9,10,27,28,29,30,31,
     42                                                 
     43                                                 20,21, 2,19, 4, 5, 6, 7,22, 9,10,11,12,13,14,15,24,25,26, 3, 0, 1, 8,23,16,17,18,27,28,29,30,31};
     44          
     45          
     46          /********************************************************************************************************
     47          ** 函数名称: LPC17xx_TIMER0_IntHandler
     48          ** 功能描述:
     49          ** 输 　 入:
     50          **
     51          ** 输　  出:
     52          **
     53          ** 全局变量:
     54          ** 调用模块:
     55          **
     56          ** 作　  者: John Tonny
     57          ** 日　  期: 2005年05月01日
     58          **------------------------------------------------------------------------------------------------------
     59          ** 修 改 人:
     60          ** 日　  期:
     61          **------------------------------------------------------------------------------------------------------
     62          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     63          static  void  LPC17xx_TIMER0_IntHandler (void  *p_arg)
     64          {
   \                     LPC17xx_TIMER0_IntHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     65            T0IR = T0IR | 0x01;					                                    // ??3y?D??±ê??	                	 
   \   00000004   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000E   0xF05F 0x2140      MOVS     R1,#+1073758208
   \   00000012   0x6008             STR      R0,[R1, #+0]
     66          
     67            DMotoSwitchStop();
   \   00000014   0x.... 0x....      BL       DMotoSwitchStop
     68          
     69          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     70          
     71          /********************************************************************************************************
     72          ** 函数名称: LPC17xx_TIMER0_IntHandler
     73          ** 功能描述:
     74          ** 输 　 入:
     75          **
     76          ** 输　  出:
     77          **
     78          ** 全局变量:
     79          ** 调用模块:
     80          **
     81          ** 作　  者: John Tonny
     82          ** 日　  期: 2005年05月01日
     83          **------------------------------------------------------------------------------------------------------
     84          ** 修 改 人:
     85          ** 日　  期:
     86          **------------------------------------------------------------------------------------------------------
     87          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          static  void  LPC17xx_TIMER1_IntHandler (void  *p_arg)
     89          {
   \                     LPC17xx_TIMER1_IntHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90            T1IR = T1IR | 0x01;					                                    // ??3y?D??±ê??	                	 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40008000
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x40008000
   \   00000012   0x6008             STR      R0,[R1, #+0]
     91            
     92            SMotoHook();    
   \   00000014   0x.... 0x....      BL       SMotoHook
     93          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
     94          
     95          /********************************************************************************************************
     96          ** 函数名称: LPC17xx_TIMER2_IntHandler
     97          ** 功能描述:
     98          ** 输 　 入:
     99          **
    100          ** 输　  出:
    101          **
    102          ** 全局变量:
    103          ** 调用模块:
    104          **
    105          ** 作　  者: John Tonny
    106          ** 日　  期: 2005年05月01日
    107          **------------------------------------------------------------------------------------------------------
    108          ** 修 改 人:
    109          ** 日　  期:
    110          **------------------------------------------------------------------------------------------------------
    111          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    112          static  void  LPC17xx_TIMER2_IntHandler (void  *p_arg)
    113          {
   \                     LPC17xx_TIMER2_IntHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    114            /*if(T2IR & 0x01){
    115              T2IR = T2IR | 0x01;					                                    // MR0中断	                	 
    116              BSP_LED_On(4);
    117            }else if( T2IR & 0x02){
    118              T2IR = T2IR | 0x01;					                                    // MR1中断
    119              BSP_LED_Off(4);
    120            }else{
    121              T2IR = T2IR | 0x0FF;					                            //	                	 
    122              //BSP_LED_Off(4);
    123            }
    124            T2IR = T2IR | 0x0FF;					                            //	                	 
    125            */
    126            
    127            T2IR = T2IR | 0x01;					                                    // ??3y?D??±ê??	                	 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40090000
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0x40090000
   \   00000012   0x6008             STR      R0,[R1, #+0]
    128            BSP_LED_Toggle(4);  
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x.... 0x....      BL       BSP_LED_Toggle
    129          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    130          
    131          /********************************************************************************************************
    132          ** 函数名称: LPC17xx_TIMER3_IntHandler
    133          ** 功能描述:
    134          ** 输 　 入:
    135          **
    136          ** 输　  出:
    137          **
    138          ** 全局变量:
    139          ** 调用模块:
    140          **
    141          ** 作　  者: John Tonny
    142          ** 日　  期: 2005年05月01日
    143          **------------------------------------------------------------------------------------------------------
    144          ** 修 改 人:
    145          ** 日　  期:
    146          **------------------------------------------------------------------------------------------------------
    147          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          static  void  LPC17xx_TIMER3_IntHandler (void  *p_arg)
    149          {
   \                     LPC17xx_TIMER3_IntHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    150            T3IR = T3IR | 0x01;					                                    // ??3y?D??±ê??	                	 
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40094000
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable19_2  ;; 0x40094000
   \   00000012   0x6008             STR      R0,[R1, #+0]
    151            MotoTime();  
   \   00000014   0x.... 0x....      BL       MotoTime
    152          }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    153          
    154          /********************************************************************************************************
    155          ** 函数名称: LPC17xx_PWM1_IntHandler
    156          ** 功能描述:
    157          ** 输 　 入:
    158          **
    159          ** 输　  出:
    160          **
    161          ** 全局变量:
    162          ** 调用模块:
    163          **
    164          ** 作　  者: John Tonny
    165          ** 日　  期: 2005年05月01日
    166          **------------------------------------------------------------------------------------------------------
    167          ** 修 改 人:
    168          ** 日　  期:
    169          **------------------------------------------------------------------------------------------------------
    170          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    171          static  void  LPC17xx_PWM1_IntHandler (void  *p_arg)
    172          {
   \                     LPC17xx_PWM1_IntHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173            if(PWM1IR & (0x1<<0)){	//for step moto clk and timeout test
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40018000
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD50A             BPL.N    ??LPC17xx_PWM1_IntHandler_0
    174              PWM1IR  = PWM1IR | (0x1<<0);		/* clear interrupt flag */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40018000
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x40018000
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    175              DMotoHook();
   \   0000001E   0x.... 0x....      BL       DMotoHook
   \   00000022   0xE00E             B.N      ??LPC17xx_PWM1_IntHandler_1
    176            }else if(PWM1IR & (0x1<<1)){	//for step moto clk and timeout test
   \                     ??LPC17xx_PWM1_IntHandler_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40018000
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0780             LSLS     R0,R0,#+30
   \   0000002C   0xD509             BPL.N    ??LPC17xx_PWM1_IntHandler_1
    177              PWM1IR  = PWM1IR | (0x1<<1);		/* clear interrupt flag */
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40018000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x40018000
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    178              DMotoHook();
   \   0000003E   0x.... 0x....      BL       DMotoHook
    179            }		  
    180          }
   \                     ??LPC17xx_PWM1_IntHandler_1: (+1)
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    181          
    182          /********************************************************************************************************
    183          ** 函数名称: GlobalInit
    184          ** 功能描述:
    185          ** 输 　 入:
    186          **
    187          ** 输　  出:
    188          **
    189          ** 全局变量:
    190          ** 调用模块:
    191          **
    192          ** 作　  者: John Tonny
    193          ** 日　  期: 2005年05月01日
    194          **------------------------------------------------------------------------------------------------------
    195          ** 修 改 人:
    196          ** 日　  期:
    197          **------------------------------------------------------------------------------------------------------
    198          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    199          void GlobalInit(void)
    200          {
   \                     GlobalInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    201              
    202            BuzzInit();
   \   00000002   0x.... 0x....      BL       BuzzInit
    203              
    204            MotoInit();
   \   00000006   0x.... 0x....      BL       MotoInit
    205              
    206          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    207          
    208          /********************************************************************************************************
    209          ** 函数名称: Timer0Init
    210          ** 功能描述:
    211          ** 输 　 入:
    212          **
    213          ** 输　  出:
    214          **
    215          ** 全局变量:
    216          ** 调用模块:
    217          **
    218          ** 作　  者: John Tonny
    219          ** 日　  期: 2005年05月01日
    220          **------------------------------------------------------------------------------------------------------
    221          ** 修 改 人:
    222          ** 日　  期:
    223          **------------------------------------------------------------------------------------------------------
    224          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    225          void Timer0Init (void)
    226          {
   \                     Timer0Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    227            CPU_INT32U clk_freq = CSP_PM_PerClkFreqGet(CSP_PM_PER_CLK_NBR_TMR_00);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000008   0x0004             MOVS     R4,R0
    228          
    229            PCONP |= (0x1<<1);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400fc0c4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400fc0c4
   \   00000018   0x6008             STR      R0,[R1, #+0]
    230            T0TCR  = 0x02;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x40004004
   \   00000020   0x6008             STR      R0,[R1, #+0]
    231            T0IR   = 0xFF;
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0xF05F 0x2140      MOVS     R1,#+1073758208
   \   00000028   0x6008             STR      R0,[R1, #+0]
    232            T0CTCR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_2  ;; 0x40004070
   \   00000030   0x6008             STR      R0,[R1, #+0]
    233            T0TC   = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x40004008
   \   00000038   0x6008             STR      R0,[R1, #+0]
    234            T0PR   = clk_freq/100000-1;								// 10us
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x186a0
   \   0000003E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x4000400c
   \   00000048   0x6008             STR      R0,[R1, #+0]
    235            T0MR0  = 25-1;                                                 			// 25*10us            
   \   0000004A   0x2018             MOVS     R0,#+24
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x40004018
   \   00000050   0x6008             STR      R0,[R1, #+0]
    236            T0MCR  = 0x03;                                                                        // ?￥??oó2úéú?D???￠?′??             
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable18_2  ;; 0x40004014
   \   00000058   0x6008             STR      R0,[R1, #+0]
    237            T0TCR  = 0x01;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable17_1  ;; 0x40004004
   \   00000060   0x6008             STR      R0,[R1, #+0]
    238            
    239            CSP_IntVectReg(CSP_INT_CTRL_NBR_MAIN,CSP_INT_SRC_NBR_TMR_00,LPC17xx_TIMER0_IntHandler,0);
   \   00000062   0x2300             MOVS     R3,#+0
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable20
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       CSP_IntVectReg
    240            CSP_IntEn(CSP_INT_CTRL_NBR_MAIN, CSP_INT_SRC_NBR_TMR_00);
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       CSP_IntEn
    241            
    242          } 
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    243          
    244          /********************************************************************************************************
    245          ** 函数名称: Timer1Init
    246          ** 功能描述:
    247          ** 输 　 入:
    248          **
    249          ** 输　  出:
    250          **
    251          ** 全局变量:
    252          ** 调用模块:
    253          **
    254          ** 作　  者: John Tonny
    255          ** 日　  期: 2005年05月01日
    256          **------------------------------------------------------------------------------------------------------
    257          ** 修 改 人:
    258          ** 日　  期:
    259          **------------------------------------------------------------------------------------------------------
    260          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void Timer1Init (void)
    262          {
   \                     Timer1Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    263              CPU_INT32U clk_freq = CSP_PM_PerClkFreqGet(CSP_PM_PER_CLK_NBR_TMR_00);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000008   0x0004             MOVS     R4,R0
    264            
    265              PCONP |= (0x1<<2);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400fc0c4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400fc0c4
   \   00000018   0x6008             STR      R0,[R1, #+0]
    266              T1TCR  = 0x02;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable18_3  ;; 0x40008004
   \   00000020   0x6008             STR      R0,[R1, #+0]
    267              T1IR   = 0xFF;
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x40008000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    268              T1CTCR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable19_4  ;; 0x40008070
   \   00000030   0x6008             STR      R0,[R1, #+0]
    269              T1TC   = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable19_5  ;; 0x40008008
   \   00000038   0x6008             STR      R0,[R1, #+0]
    270              T1PR   = clk_freq/100000-1;                                         //10us		
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x186a0
   \   0000003E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable19_6  ;; 0x4000800c
   \   00000048   0x6008             STR      R0,[R1, #+0]
    271              T1MR0  = SMOTO_FREQ_700US-1;                                        // 70*10us            
   \   0000004A   0x2045             MOVS     R0,#+69
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable19_7  ;; 0x40008018
   \   00000050   0x6008             STR      R0,[R1, #+0]
    272              T1MCR  = 0x03;                                                      // ?￥??oó2úéú?D???￠?′??              
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable19_8  ;; 0x40008014
   \   00000058   0x6008             STR      R0,[R1, #+0]
    273              
    274              CSP_IntVectReg(CSP_INT_CTRL_NBR_MAIN,CSP_INT_SRC_NBR_TMR_01,LPC17xx_TIMER1_IntHandler,0);
   \   0000005A   0x2300             MOVS     R3,#+0
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable20_1
   \   00000060   0x2102             MOVS     R1,#+2
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       CSP_IntVectReg
    275              CSP_IntEn(CSP_INT_CTRL_NBR_MAIN, CSP_INT_SRC_NBR_TMR_01);
   \   00000068   0x2102             MOVS     R1,#+2
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       CSP_IntEn
    276          } 
   \   00000070   0xBD10             POP      {R4,PC}          ;; return
    277          
    278          /********************************************************************************************************
    279          ** 函数名称: Timer2Init
    280          ** 功能描述:
    281          ** 输 　 入:
    282          **
    283          ** 输　  出:
    284          **
    285          ** 全局变量:
    286          ** 调用模块:
    287          **
    288          ** 作　  者: John Tonny
    289          ** 日　  期: 2005年05月01日
    290          **------------------------------------------------------------------------------------------------------
    291          ** 修 改 人:
    292          ** 日　  期:
    293          **------------------------------------------------------------------------------------------------------
    294          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void Timer2Init (void)
    296          {
   \                     Timer2Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    297            CPU_INT32U clk_freq = CSP_PM_PerClkFreqGet(CSP_PM_PER_CLK_NBR_TMR_00);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000008   0x0004             MOVS     R4,R0
    298          
    299            PCONP |= (0x1<<22);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400fc0c4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400fc0c4
   \   00000018   0x6008             STR      R0,[R1, #+0]
    300            T2TCR  = 0x02;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40090004
   \   00000020   0x6008             STR      R0,[R1, #+0]
    301            T2IR   = 0xFF;
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0x40090000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    302            T2CTCR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable20_3  ;; 0x40090070
   \   00000030   0x6008             STR      R0,[R1, #+0]
    303            T2TC   = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable20_4  ;; 0x40090008
   \   00000038   0x6008             STR      R0,[R1, #+0]
    304            
    305            /*
    306            T2PR   = 0;					                        // 1us
    307            T2MR0  = 250-1;                                               	// (494/25)us            
    308            T2MR1  = 750-1;                                               	// 658/25(us)            
    309            T2MCR  = 0x01 | 0x18;                                                 //MR0产生中断，MR1复位TC     
    310            */
    311            
    312            T2PR   = clk_freq/1000000-1;                                         //1us										
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0xf4240
   \   0000003E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable20_6  ;; 0x4009000c
   \   00000048   0x6008             STR      R0,[R1, #+0]
    313            T2MR0  = 3000-1;                                                     //3000*1us             
   \   0000004A   0xF640 0x30B7      MOVW     R0,#+2999
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable20_7  ;; 0x40090018
   \   00000052   0x6008             STR      R0,[R1, #+0]
    314            T2MCR  = 0x03;                                                      //MR0产生中断，MR0复位TC              
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable20_8  ;; 0x40090014
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    315            
    316            T2TCR  = 0x00;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable20_2  ;; 0x40090004
   \   00000062   0x6008             STR      R0,[R1, #+0]
    317            
    318            CSP_IntVectReg(CSP_INT_CTRL_NBR_MAIN,CSP_INT_SRC_NBR_TMR_02,LPC17xx_TIMER2_IntHandler,0);
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       CSP_IntVectReg
    319            CSP_IntEn(CSP_INT_CTRL_NBR_MAIN, CSP_INT_SRC_NBR_TMR_02);
   \   00000072   0x2103             MOVS     R1,#+3
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x.... 0x....      BL       CSP_IntEn
    320            
    321          } 
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
    322          
    323          /********************************************************************************************************
    324          ** 函数名称: Timer3Init
    325          ** 功能描述:
    326          ** 输 　 入:
    327          **
    328          ** 输　  出:
    329          **
    330          ** 全局变量:
    331          ** 调用模块:
    332          **
    333          ** 作　  者: John Tonny
    334          ** 日　  期: 2005年05月01日
    335          **------------------------------------------------------------------------------------------------------
    336          ** 修 改 人:
    337          ** 日　  期:
    338          **------------------------------------------------------------------------------------------------------
    339          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    340          void Timer3Init (void)
    341          {
   \                     Timer3Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    342            CPU_INT32U clk_freq = CSP_PM_PerClkFreqGet(CSP_PM_PER_CLK_NBR_TMR_00);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000008   0x0004             MOVS     R4,R0
    343            
    344            PCONP |= (0x1<<23);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x400fc0c4
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x400fc0c4
   \   00000018   0x6008             STR      R0,[R1, #+0]
    345            T3TCR  = 0x02;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40094004
   \   00000020   0x6008             STR      R0,[R1, #+0]
    346            T3IR   = 0xFF;
   \   00000022   0x20FF             MOVS     R0,#+255
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable19_2  ;; 0x40094000
   \   00000028   0x6008             STR      R0,[R1, #+0]
    347            T3CTCR = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable21_2  ;; 0x40094070
   \   00000030   0x6008             STR      R0,[R1, #+0]
    348            T3TC   = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21_3  ;; 0x40094008
   \   00000038   0x6008             STR      R0,[R1, #+0]
    349            T3PR   = clk_freq/1000-1;						// 10us
   \   0000003A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable21_4  ;; 0x4009400c
   \   00000048   0x6008             STR      R0,[R1, #+0]
    350            T3MR0  = 10-1;                                                         // 100*10us            
   \   0000004A   0x2009             MOVS     R0,#+9
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable21_5  ;; 0x40094018
   \   00000050   0x6008             STR      R0,[R1, #+0]
    351            T3MCR  = 0x03;                                                      // ?￥??oó2úéú?D???￠?′??            
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable21_6  ;; 0x40094014
   \   00000058   0x6008             STR      R0,[R1, #+0]
    352            T3TCR  = 0x01;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable21_1  ;; 0x40094004
   \   00000060   0x6008             STR      R0,[R1, #+0]
    353            
    354            CSP_IntVectReg(CSP_INT_CTRL_NBR_MAIN,CSP_INT_SRC_NBR_TMR_03,LPC17xx_TIMER3_IntHandler,0);
   \   00000062   0x2300             MOVS     R3,#+0
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable21_7
   \   00000068   0x2104             MOVS     R1,#+4
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      BL       CSP_IntVectReg
    355            CSP_IntEn(CSP_INT_CTRL_NBR_MAIN, CSP_INT_SRC_NBR_TMR_03);  
   \   00000070   0x2104             MOVS     R1,#+4
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       CSP_IntEn
    356          } 
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
    357          
    358          /********************************************************************************************************
    359          ** 函数名称: PWM1Init
    360          ** 功能描述:
    361          ** 输 　 入:
    362          **
    363          ** 输　  出:
    364          **
    365          ** 全局变量:
    366          ** 调用模块:
    367          **
    368          ** 作　  者: John Tonny
    369          ** 日　  期: 2005年05月01日
    370          **------------------------------------------------------------------------------------------------------
    371          ** 修 改 人:
    372          ** 日　  期:
    373          **------------------------------------------------------------------------------------------------------
    374          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          void PWM1Init (void)
    376          {
   \                     PWM1Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    377            CPU_INT32U clk_freq = CSP_PM_PerClkFreqGet(CSP_PM_PER_CLK_NBR_TMR_00);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000008   0x0004             MOVS     R4,R0
    378          
    379            PWM1TCR  = 0x02;
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable21_8  ;; 0x40018004
   \   00000010   0x6008             STR      R0,[R1, #+0]
    380            PWM1IR   = 0xFF;
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable19_3  ;; 0x40018000
   \   00000018   0x6008             STR      R0,[R1, #+0]
    381            PWM1CTCR = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21_9  ;; 0x40018070
   \   00000020   0x6008             STR      R0,[R1, #+0]
    382            PWM1TC   = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable21_10  ;; 0x40018008
   \   00000028   0x6008             STR      R0,[R1, #+0]
    383            PWM1PR   = clk_freq/1000000-1;																		// 1us
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable20_5  ;; 0xf4240
   \   0000002E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21_11  ;; 0x4001800c
   \   00000038   0x6008             STR      R0,[R1, #+0]
    384            PWM1MR0  = 2000-1;                                               	// 2000us            
   \   0000003A   0xF240 0x70CF      MOVW     R0,#+1999
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable21_12  ;; 0x40018018
   \   00000042   0x6008             STR      R0,[R1, #+0]
    385            PWM1MR1  = 1000-1;                                               	// 1000us            
   \   00000044   0xF240 0x30E7      MOVW     R0,#+999
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable21_13  ;; 0x4001801c
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    386            PWM1MCR  = 0x0B;                                            	// ?￥??oó2úéú?D???￠?′??	
   \   0000004E   0x200B             MOVS     R0,#+11
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable21_14  ;; 0x40018014
   \   00000054   0x6008             STR      R0,[R1, #+0]
    387          
    388            CSP_IntVectReg(CSP_INT_CTRL_NBR_MAIN,CSP_INT_SRC_NBR_PWM_01,LPC17xx_PWM1_IntHandler,0);  
   \   00000056   0x2300             MOVS     R3,#+0
   \   00000058   0x.... 0x....      LDR.W    R2,??DataTable21_15
   \   0000005C   0x2109             MOVS     R1,#+9
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       CSP_IntVectReg
    389            CSP_IntEn(CSP_INT_CTRL_NBR_MAIN, CSP_INT_SRC_NBR_PWM_01);  
   \   00000064   0x2109             MOVS     R1,#+9
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      BL       CSP_IntEn
    390          } 
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    391          
    392          /********************************************************************************************************
    393          ** 函数名称: ScanInit
    394          ** 功能描述:
    395          ** 输 　 入:
    396          **
    397          ** 输　  出:
    398          **
    399          ** 全局变量:
    400          ** 调用模块:
    401          **
    402          ** 作　  者: John Tonny
    403          ** 日　  期: 2005年05月01日
    404          **------------------------------------------------------------------------------------------------------
    405          ** 修 改 人:
    406          ** 日　  期:
    407          **------------------------------------------------------------------------------------------------------
    408          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    409          void ScanInit (void)
    410          {
   \                     ScanInit: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    411            CSP_GPIO_Cfg(BSP_GPIO_SCAN_PORT,
    412                         BSP_GPIO_SCAN_OUT,
    413                         CSP_GPIO_DIR_OUT,
    414                         CSP_GPIO_FLAG_MODE_NONE,
    415                         DEF_NO,
    416                         0u,
    417                         CSP_GPIO_FNCT_00);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9002             STR      R0,[SP, #+8]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       CSP_GPIO_Cfg
    418            CSP_GPIO_BitSet(BSP_GPIO_SCAN_PORT,BSP_GPIO_SCAN_OUT);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       CSP_GPIO_BitSet
    419          } 
   \   00000022   0xBD07             POP      {R0-R2,PC}       ;; return
    420          
    421          /********************************************************************************************************
    422          ** 函数名称: RevCrc16Bytes
    423          ** 功能描述:
    424          ** 输 　 入:
    425          **
    426          ** 输　  出:
    427          **
    428          ** 全局变量:
    429          ** 调用模块:
    430          **
    431          ** 作　  者: John Tonny
    432          ** 日　  期: 2005年05月01日
    433          **------------------------------------------------------------------------------------------------------
    434          ** 修 改 人:
    435          ** 日　  期:
    436          **------------------------------------------------------------------------------------------------------
    437          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    438          int16u RevCrc16Bytes(int8u *pucData,int8u usrLength,int16u uiPolynomial)
    439          {
   \                     RevCrc16Bytes: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    440            int8u i=8;
   \   00000004   0x2408             MOVS     R4,#+8
    441            int16u uiCrc;
    442          
    443          #if CRC_INIT_VALUE>0
    444            uiCrc=0xFFFF;
   \   00000006   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000A   0x0028             MOVS     R0,R5
    445          #else
    446            uiCrc=0x0000;
    447          #endif
    448            
    449            do{
    450              uiCrc^=*pucData++;
   \                     ??RevCrc16Bytes_0: (+1)
   \   0000000C   0x781D             LDRB     R5,[R3, #+0]
   \   0000000E   0x4068             EORS     R0,R5,R0
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
    451              i=8;
   \   00000012   0x2508             MOVS     R5,#+8
   \   00000014   0x002C             MOVS     R4,R5
    452              do{
    453                if((uiCrc & 0x01) != 0){
   \                     ??RevCrc16Bytes_1: (+1)
   \   00000016   0x07C5             LSLS     R5,R0,#+31
   \   00000018   0xD503             BPL.N    ??RevCrc16Bytes_2
    454                  uiCrc>>=1;
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0x0840             LSRS     R0,R0,#+1
    455                  uiCrc^=uiPolynomial;
   \   0000001E   0x4050             EORS     R0,R2,R0
   \   00000020   0xE001             B.N      ??RevCrc16Bytes_3
    456                }else{
    457                  uiCrc>>=1;
   \                     ??RevCrc16Bytes_2: (+1)
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x0840             LSRS     R0,R0,#+1
    458                }
    459              }while(--i);
   \                     ??RevCrc16Bytes_3: (+1)
   \   00000026   0x1E64             SUBS     R4,R4,#+1
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD1F3             BNE.N    ??RevCrc16Bytes_1
    460            }while(--usrLength);
   \   0000002E   0x1E49             SUBS     R1,R1,#+1
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD1EA             BNE.N    ??RevCrc16Bytes_0
    461            return uiCrc;
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0xBC30             POP      {R4,R5}
   \   0000003A   0x4770             BX       LR               ;; return
    462          }
    463          
    464          /********************************************************************************************************
    465          ** 函数名称: BytesToAscs
    466          ** 功能描述:
    467          ** 输 　 入:
    468          **
    469          ** 输　  出:
    470          **
    471          ** 全局变量:
    472          ** 调用模块:
    473          **
    474          ** 作　  者: John Tonny
    475          ** 日　  期: 2005年05月01日
    476          **------------------------------------------------------------------------------------------------------
    477          ** 修 改 人:
    478          ** 日　  期:
    479          **------------------------------------------------------------------------------------------------------
    480          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          void BytesToAscs(INT8U *pucSource,INT8U ucLen,INT8U *pucDest)
    482          {
   \                     BytesToAscs: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0017             MOVS     R7,R2
    483            INT8U i;
    484            
    485            for(i=0;i<ucLen;i++){
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   \                     ??BytesToAscs_0: (+1)
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD210             BCS.N    ??BytesToAscs_1
    486              *pucDest++=ByteToAsc((*pucSource)>>4);
   \   00000018   0x7820             LDRB     R0,[R4, #+0]
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x0900             LSRS     R0,R0,#+4
   \   0000001E   0x.... 0x....      BL       ByteToAsc
   \   00000022   0x7038             STRB     R0,[R7, #+0]
   \   00000024   0x1C7F             ADDS     R7,R7,#+1
    487              *pucDest++=ByteToAsc((*pucSource++)&0x0F);
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000002C   0x.... 0x....      BL       ByteToAsc
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x7038             STRB     R0,[R7, #+0]
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
    488            }
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \   00000038   0xE7E8             B.N      ??BytesToAscs_0
    489          }
   \                     ??BytesToAscs_1: (+1)
   \   0000003A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    490          
    491          /********************************************************************************************************
    492          ** 函数名称: AscToByte
    493          ** 功能描述:
    494          ** 输 　 入:
    495          **
    496          ** 输　  出:
    497          **
    498          ** 全局变量:
    499          ** 调用模块:
    500          **
    501          ** 作　  者: John Tonny
    502          ** 日　  期: 2005年05月01日
    503          **------------------------------------------------------------------------------------------------------
    504          ** 修 改 人:
    505          ** 日　  期:
    506          **------------------------------------------------------------------------------------------------------
    507          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    508          INT8S AscToByte(INT8U ucData)
    509          {
   \                     AscToByte: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    510            if(ucData>=0x30 && ucData<=0x39){
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2930             CMP      R1,#+48
   \   00000006   0xDB06             BLT.N    ??AscToByte_0
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x293A             CMP      R1,#+58
   \   0000000C   0xDA03             BGE.N    ??AscToByte_0
    511              return ucData-0x30;
   \   0000000E   0xF1B1 0x0030      SUBS     R0,R1,#+48
   \   00000012   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000014   0xE00B             B.N      ??AscToByte_1
    512            }else if(ucData>=0x41 && ucData<=0x46){
   \                     ??AscToByte_0: (+1)
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2941             CMP      R1,#+65
   \   0000001A   0xDB06             BLT.N    ??AscToByte_2
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x2947             CMP      R1,#+71
   \   00000020   0xDA03             BGE.N    ??AscToByte_2
    513              return ucData-0x37;
   \   00000022   0xF1B1 0x0037      SUBS     R0,R1,#+55
   \   00000026   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000028   0xE001             B.N      ??AscToByte_1
    514            }else{
    515              return -1;
   \                     ??AscToByte_2: (+1)
   \   0000002A   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??AscToByte_1: (+1)
   \   0000002E   0x4770             BX       LR               ;; return
    516            }
    517          }
    518          
    519          /********************************************************************************************************
    520          ** 函数名称: ByteToAsc
    521          ** 功能描述:
    522          ** 输 　 入:
    523          **
    524          ** 输　  出:
    525          **
    526          ** 全局变量:
    527          ** 调用模块:
    528          **
    529          ** 作　  者: John Tonny
    530          ** 日　  期: 2005年05月01日
    531          **------------------------------------------------------------------------------------------------------
    532          ** 修 改 人:
    533          ** 日　  期:
    534          **------------------------------------------------------------------------------------------------------
    535          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          INT8S ByteToAsc(INT8U ucData)
    537          {
   \                     ByteToAsc: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    538            if(ucData<=9){
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xDA03             BGE.N    ??ByteToAsc_0
    539              return ucData+0x30;
   \   00000008   0xF111 0x0030      ADDS     R0,R1,#+48
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0xE00B             B.N      ??ByteToAsc_1
    540            }else if(ucData>=10 && ucData<=15){
   \                     ??ByteToAsc_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x290A             CMP      R1,#+10
   \   00000014   0xDB06             BLT.N    ??ByteToAsc_2
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0x2910             CMP      R1,#+16
   \   0000001A   0xDA03             BGE.N    ??ByteToAsc_2
    541              return ucData+0x37;
   \   0000001C   0xF111 0x0037      ADDS     R0,R1,#+55
   \   00000020   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000022   0xE001             B.N      ??ByteToAsc_1
    542            }else{
    543              return -1;
   \                     ??ByteToAsc_2: (+1)
   \   00000024   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??ByteToAsc_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    544            }
    545          }
    546          
    547          /********************************************************************************************************
    548          ** 函数名称: SprintF
    549          ** 功能描述:
    550          ** 输 　 入:
    551          **
    552          ** 输　  出:
    553          **
    554          ** 全局变量:
    555          ** 调用模块:
    556          **
    557          ** 作　  者: John Tonny
    558          ** 日　  期: 2005年05月01日
    559          **------------------------------------------------------------------------------------------------------
    560          ** 修 改 人:
    561          ** 日　  期:
    562          **------------------------------------------------------------------------------------------------------
    563          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    564          void SprintF(INT8U *pucData,INT8U ucLen,INT32U ulData)
    565          {
   \                     SprintF: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    566            INT8U i;
    567            INT8U ucData[10];
    568            INT32U ulTmp;
    569          
    570            for(i=0;i<10;i++){
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0007             MOVS     R7,R0
   \                     ??SprintF_0: (+1)
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F0A             CMP      R7,#+10
   \   00000014   0xDA0E             BGE.N    ??SprintF_1
    571              ulTmp=ulData%10;
   \   00000016   0x200A             MOVS     R0,#+10
   \   00000018   0xFBB6 0xF1F0      UDIV     R1,R6,R0
   \   0000001C   0xFB00 0x6011      MLS      R0,R0,R1,R6
   \   00000020   0x4680             MOV      R8,R0
    572              ucData[i]=(INT8U)ulTmp;
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000026   0xF800 0x8007      STRB     R8,[R0, R7]
    573              ulData=ulData/10;
   \   0000002A   0x200A             MOVS     R0,#+10
   \   0000002C   0xFBB6 0xF6F0      UDIV     R6,R6,R0
    574            }
   \   00000030   0x1C7F             ADDS     R7,R7,#+1
   \   00000032   0xE7ED             B.N      ??SprintF_0
    575          
    576            for(i=0;i<ucLen;i++){
   \                     ??SprintF_1: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x0007             MOVS     R7,R0
   \                     ??SprintF_2: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD20B             BCS.N    ??SprintF_3
    577              pucData[i]=ByteToAsc(ucData[ucLen-1-i]);
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x1E69             SUBS     R1,R5,#+1
   \   0000004A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004C   0x1BC9             SUBS     R1,R1,R7
   \   0000004E   0x5C40             LDRB     R0,[R0, R1]
   \   00000050   0x.... 0x....      BL       ByteToAsc
   \   00000054   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000056   0x55E0             STRB     R0,[R4, R7]
    578            }	
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \   0000005A   0xE7ED             B.N      ??SprintF_2
    579          }
   \                     ??SprintF_3: (+1)
   \   0000005C   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
    580          
    581          /********************************************************************************************************
    582          ** oˉêy??3?: CardBoxGetSelected
    583          ** 1|?ü?èê?:
    584          ** ê? ?? è?:
    585          **
    586          ** ê???  3?:
    587          **
    588          ** è???±?á?:
    589          ** μ÷ó??￡?é:
    590          **
    591          ** ×÷??  ??: John Tonny
    592          ** è???  ?ú: 2005?ê05??01è?
    593          **------------------------------------------------------------------------------------------------------
    594          ** DT ?? è?:
    595          ** è???  ?ú:
    596          **------------------------------------------------------------------------------------------------------
    597          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    598          INT8U CardBoxGetSelected(void)
    599          {
   \                     CardBoxGetSelected: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    600            return (((CSP_GPIO_Rd(BSP_GPIO_BOX1_SELECT_PORT)&BSP_GPIO_BOX1_SELECT)>>BSP_GPIO_BOX1_SELECT_BIT)|((CSP_GPIO_Rd(BSP_GPIO_BOX2_SELECT_PORT)&BSP_GPIO_BOX2_SELECT)>>(BSP_GPIO_BOX2_SELECT_BIT-1))|((CSP_GPIO_Rd(BSP_GPIO_BOX3_SELECT_PORT)&BSP_GPIO_BOX3_SELECT)>>(BSP_GPIO_BOX3_SELECT_BIT-2)))&0x07;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000010   0x0BA1             LSRS     R1,R4,#+14
   \   00000012   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000016   0x0B80             LSRS     R0,R0,#+14
   \   00000018   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   0000001C   0xEA50 0x0401      ORRS     R4,R0,R1
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000026   0x0BC0             LSRS     R0,R0,#+15
   \   00000028   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000002C   0x4320             ORRS     R0,R0,R4
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    601          }
    602          
    603          /********************************************************************************************************
    604          ** oˉêy??3?: CardBoxGetSelectedA
    605          ** 1|?ü?èê?:
    606          ** ê? ?? è?:
    607          **
    608          ** ê???  3?:
    609          **
    610          ** è???±?á?:
    611          ** μ÷ó??￡?é:
    612          **
    613          ** ×÷??  ??: John Tonny
    614          ** è???  ?ú: 2005?ê05??01è?
    615          **------------------------------------------------------------------------------------------------------
    616          ** DT ?? è?:
    617          ** è???  ?ú:
    618          **------------------------------------------------------------------------------------------------------
    619          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    620          INT8U CardBoxGetSelectedA(void)
    621          {
   \                     CardBoxGetSelectedA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    622            return (((CSP_GPIO_Rd(BSP_GPIO_BOX1_SELECT_PORT)&BSP_GPIO_BOX1_SELECT)>>BSP_GPIO_BOX1_SELECT_BIT<<1)|((CSP_GPIO_Rd(BSP_GPIO_BOX2_SELECT_PORT)&BSP_GPIO_BOX2_SELECT)>>(BSP_GPIO_BOX2_SELECT_BIT)))&0x03;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000008   0x0B84             LSRS     R4,R0,#+14
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000010   0x0BC0             LSRS     R0,R0,#+15
   \   00000012   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000016   0xEA50 0x0044      ORRS     R0,R0,R4, LSL #+1
   \   0000001A   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    623          }
    624          
    625          /********************************************************************************************************
    626          ** 函数名称: CardBoxSetSelected
    627          ** 功能描述:
    628          ** 输 　 入:
    629          **
    630          ** 输　  出:
    631          **
    632          ** 全局变量:
    633          ** 调用模块:
    634          **
    635          ** 作　  者: John Tonny
    636          ** 日　  期: 2005年05月01日
    637          **------------------------------------------------------------------------------------------------------
    638          ** 修 改 人:
    639          ** 日　  期:
    640          **------------------------------------------------------------------------------------------------------
    641          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    642          INT8U CardBoxSetSelected(INT8U ucSelected,INT8U ucMode)
    643          {
   \                     CardBoxSetSelected: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    644            INT8U i;
    645          #if BOARD_OLD_EN==0
    646            ucSelected=m_ucUartBit[ucSelected];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable21_16
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x5D86             LDRB     R6,[R0, R6]
    647            for(i=0;i<4;i++){
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
   \                     ??CardBoxSetSelected_0: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D04             CMP      R5,#+4
   \   00000016   0xDA6E             BGE.N    ??CardBoxSetSelected_1
    648              switch(ucSelected){
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD003             BEQ.N    ??CardBoxSetSelected_2
   \   0000001E   0x2E02             CMP      R6,#+2
   \   00000020   0xD032             BEQ.N    ??CardBoxSetSelected_3
   \   00000022   0xD318             BCC.N    ??CardBoxSetSelected_4
   \   00000024   0xE049             B.N      ??CardBoxSetSelected_5
    649                case 0:
    650                  if((CardBoxGetSelected()&0x01)==ucMode){
   \                     ??CardBoxSetSelected_2: (+1)
   \   00000026   0x.... 0x....      BL       CardBoxGetSelected
   \   0000002A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x42A0             CMP      R0,R4
   \   00000032   0xD101             BNE.N    ??CardBoxSetSelected_6
    651                    return TRUE;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE05F             B.N      ??CardBoxSetSelected_7
    652                  }
    653                  if(ucMode){
   \                     ??CardBoxSetSelected_6: (+1)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD005             BEQ.N    ??CardBoxSetSelected_8
    654                    CSP_GPIO_BitSet(BSP_GPIO_BOX1_SELECT_PORT,
    655                                    BSP_GPIO_BOX1_SELECT);
   \   0000003E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x.... 0x....      BL       CSP_GPIO_BitSet
   \   00000048   0xE004             B.N      ??CardBoxSetSelected_9
    656                  }else{
    657                    CSP_GPIO_BitClr(BSP_GPIO_BOX1_SELECT_PORT,
    658                                    BSP_GPIO_BOX1_SELECT);
   \                     ??CardBoxSetSelected_8: (+1)
   \   0000004A   0xF44F 0x4180      MOV      R1,#+16384
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x.... 0x....      BL       CSP_GPIO_BitClr
    659                  }
    660                  break;
   \                     ??CardBoxSetSelected_9: (+1)
   \   00000054   0xE046             B.N      ??CardBoxSetSelected_10
    661                case 1:
    662                  if(((CardBoxGetSelected()>>1)&0x01)==ucMode){
   \                     ??CardBoxSetSelected_4: (+1)
   \   00000056   0x.... 0x....      BL       CardBoxGetSelected
   \   0000005A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x42A0             CMP      R0,R4
   \   00000064   0xD101             BNE.N    ??CardBoxSetSelected_11
    663                    return TRUE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE046             B.N      ??CardBoxSetSelected_7
    664                  }
    665                  if(ucMode){
   \                     ??CardBoxSetSelected_11: (+1)
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x2C00             CMP      R4,#+0
   \   0000006E   0xD005             BEQ.N    ??CardBoxSetSelected_12
    666                    CSP_GPIO_BitSet(BSP_GPIO_BOX2_SELECT_PORT,
    667                                    BSP_GPIO_BOX2_SELECT);
   \   00000070   0xF44F 0x4100      MOV      R1,#+32768
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x.... 0x....      BL       CSP_GPIO_BitSet
   \   0000007A   0xE004             B.N      ??CardBoxSetSelected_13
    668                    
    669                  }else{
    670                    CSP_GPIO_BitClr(BSP_GPIO_BOX2_SELECT_PORT,
    671                                    BSP_GPIO_BOX2_SELECT);
   \                     ??CardBoxSetSelected_12: (+1)
   \   0000007C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      BL       CSP_GPIO_BitClr
    672                  }
    673                  break;
   \                     ??CardBoxSetSelected_13: (+1)
   \   00000086   0xE02D             B.N      ??CardBoxSetSelected_10
    674                case 2:
    675                  if(((CardBoxGetSelected()>>2)&0x01)==ucMode){
   \                     ??CardBoxSetSelected_3: (+1)
   \   00000088   0x.... 0x....      BL       CardBoxGetSelected
   \   0000008C   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0x42A0             CMP      R0,R4
   \   00000096   0xD101             BNE.N    ??CardBoxSetSelected_14
    676                    return TRUE;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE02D             B.N      ??CardBoxSetSelected_7
    677                  }
    678                  if(ucMode){
   \                     ??CardBoxSetSelected_14: (+1)
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2C00             CMP      R4,#+0
   \   000000A0   0xD005             BEQ.N    ??CardBoxSetSelected_15
    679                    CSP_GPIO_BitSet(BSP_GPIO_BOX3_SELECT_PORT,
    680                                    BSP_GPIO_BOX3_SELECT);
   \   000000A2   0xF45F 0x3100      MOVS     R1,#+131072
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x.... 0x....      BL       CSP_GPIO_BitSet
   \   000000AC   0xE004             B.N      ??CardBoxSetSelected_16
    681                    
    682                  }else{
    683                    CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    684                                    BSP_GPIO_BOX3_SELECT);
   \                     ??CardBoxSetSelected_15: (+1)
   \   000000AE   0xF45F 0x3100      MOVS     R1,#+131072
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0x.... 0x....      BL       CSP_GPIO_BitClr
    685                  }
    686                  break;
   \                     ??CardBoxSetSelected_16: (+1)
   \   000000B8   0xE014             B.N      ??CardBoxSetSelected_10
    687                default:
    688                  if(CardBoxGetSelected()==0){
   \                     ??CardBoxSetSelected_5: (+1)
   \   000000BA   0x.... 0x....      BL       CardBoxGetSelected
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD101             BNE.N    ??CardBoxSetSelected_17
    689                    return TRUE;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xE018             B.N      ??CardBoxSetSelected_7
    690                  }
    691                  CSP_GPIO_BitClr(BSP_GPIO_BOX1_SELECT_PORT,
    692                                  BSP_GPIO_BOX1_SELECT);
   \                     ??CardBoxSetSelected_17: (+1)
   \   000000C6   0xF44F 0x4180      MOV      R1,#+16384
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      BL       CSP_GPIO_BitClr
    693                  CSP_GPIO_BitClr(BSP_GPIO_BOX2_SELECT_PORT,
    694                                  BSP_GPIO_BOX2_SELECT);
   \   000000D0   0xF44F 0x4100      MOV      R1,#+32768
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x.... 0x....      BL       CSP_GPIO_BitClr
    695                  CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    696                                  BSP_GPIO_BOX3_SELECT);
   \   000000DA   0xF45F 0x3100      MOVS     R1,#+131072
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x.... 0x....      BL       CSP_GPIO_BitClr
    697                  break;
    698              }
    699              m_usrBoxInfo[ucSelected].ucTimes=1;
   \                     ??CardBoxSetSelected_10: (+1)
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable21_17
   \   000000EA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EC   0x0172             LSLS     R2,R6,#+5
   \   000000EE   0x4411             ADD      R1,R1,R2
   \   000000F0   0x7308             STRB     R0,[R1, #+12]
    700            }
   \   000000F2   0x1C6D             ADDS     R5,R5,#+1
   \   000000F4   0xE78D             B.N      ??CardBoxSetSelected_0
    701            return FALSE;
   \                     ??CardBoxSetSelected_1: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??CardBoxSetSelected_7: (+1)
   \   000000F8   0xBD70             POP      {R4-R6,PC}       ;; return
    702          #else
    703            INT8U ucTmp;
    704            for(i=0;i<4;i++){
    705              switch(ucSelected){
    706                case 0:
    707                  if(ucMode){
    708                    ucTmp=0x04;
    709                  }else{
    710                    ucTmp=0x00;
    711                  }
    712                  if(CardBoxGetSelected()==ucTmp){
    713                    return TRUE;
    714                  }
    715                  CSP_GPIO_BitClr(BSP_GPIO_BOX1_SELECT_PORT,
    716                                  BSP_GPIO_BOX1_SELECT);
    717                  CSP_GPIO_BitClr(BSP_GPIO_BOX2_SELECT_PORT,
    718                                  BSP_GPIO_BOX2_SELECT);
    719                  if(ucMode){
    720                    CSP_GPIO_BitSet(BSP_GPIO_BOX3_SELECT_PORT,
    721                                    BSP_GPIO_BOX3_SELECT);
    722                  }else{
    723                    CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    724                                    BSP_GPIO_BOX3_SELECT);
    725                  }
    726                  break;
    727                case 1:
    728                  if(ucMode){
    729                    ucTmp=0x06;
    730                  }else{
    731                    ucTmp=0x02;
    732                  }
    733                  if(CardBoxGetSelected()==ucTmp){
    734                    return TRUE;
    735                  }
    736                  CSP_GPIO_BitClr(BSP_GPIO_BOX1_SELECT_PORT,
    737                                  BSP_GPIO_BOX1_SELECT);
    738                  CSP_GPIO_BitSet(BSP_GPIO_BOX2_SELECT_PORT,
    739                                  BSP_GPIO_BOX2_SELECT);
    740                  if(ucMode){
    741                    CSP_GPIO_BitSet(BSP_GPIO_BOX3_SELECT_PORT,
    742                                    BSP_GPIO_BOX3_SELECT);
    743                  }else{
    744                    CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    745                                    BSP_GPIO_BOX3_SELECT);
    746                  }
    747                  break;
    748                case 2:
    749                  if(ucMode){
    750                    ucTmp=0x05;
    751                  }else{
    752                    ucTmp=0x01;
    753                  }
    754                  if(CardBoxGetSelected()==ucTmp){
    755                    return TRUE;
    756                  }
    757                  CSP_GPIO_BitSet(BSP_GPIO_BOX1_SELECT_PORT,
    758                                  BSP_GPIO_BOX1_SELECT);
    759                  CSP_GPIO_BitClr(BSP_GPIO_BOX2_SELECT_PORT,
    760                                  BSP_GPIO_BOX2_SELECT);
    761                  if(ucMode){
    762                    CSP_GPIO_BitSet(BSP_GPIO_BOX3_SELECT_PORT,
    763                                    BSP_GPIO_BOX3_SELECT);
    764                  }else{
    765                    CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    766                                    BSP_GPIO_BOX3_SELECT);
    767                  }
    768                  break;
    769                default:
    770                  ucTmp=0;
    771                  if(CardBoxGetSelected()==ucTmp){
    772                    return TRUE;
    773                  }
    774                  CSP_GPIO_BitClr(BSP_GPIO_BOX1_SELECT_PORT,
    775                                  BSP_GPIO_BOX1_SELECT);
    776                  CSP_GPIO_BitClr(BSP_GPIO_BOX2_SELECT_PORT,
    777                                  BSP_GPIO_BOX2_SELECT);
    778                  CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    779                                  BSP_GPIO_BOX3_SELECT);
    780                  break;
    781              } 
    782            }
    783            return FALSE;
    784          #endif
    785          }
    786          
    787          /********************************************************************************************************
    788          ** 函数名称: CardBoxPower
    789          ** 功能描述:
    790          ** 输 　 入:
    791          **
    792          ** 输　  出:
    793          **
    794          ** 全局变量:
    795          ** 调用模块:
    796          **
    797          ** 作　  者: John Tonny
    798          ** 日　  期: 2005年05月01日
    799          **------------------------------------------------------------------------------------------------------
    800          ** 修 改 人:
    801          ** 日　  期:
    802          **------------------------------------------------------------------------------------------------------
    803          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    804          INT8U CardBoxPower(INT8U ucMode)
    805          {
   \                     CardBoxPower: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    806            INT8U i;
    807            INT8U ucTmp;
    808            INT8U ucType=DEV_TYPE();
   \   00000004   0x.... 0x....      BL       DEV_TYPE
   \   00000008   0x0007             MOVS     R7,R0
    809            
    810            for(i=0;i<4;i++){
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x0005             MOVS     R5,R0
   \                     ??CardBoxPower_0: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D04             CMP      R5,#+4
   \   00000012   0xDA2C             BGE.N    ??CardBoxPower_1
    811              if(ucMode){
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD002             BEQ.N    ??CardBoxPower_2
    812                ucTmp=0x04;
   \   0000001A   0x2004             MOVS     R0,#+4
   \   0000001C   0x0006             MOVS     R6,R0
   \   0000001E   0xE001             B.N      ??CardBoxPower_3
    813              }else{
    814                ucTmp=0x00;
   \                     ??CardBoxPower_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0006             MOVS     R6,R0
    815              }
    816              
    817              if((CardBoxGetSelected()&0x04)==ucTmp){
   \                     ??CardBoxPower_3: (+1)
   \   00000024   0x.... 0x....      BL       CardBoxGetSelected
   \   00000028   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x42B0             CMP      R0,R6
   \   00000030   0xD101             BNE.N    ??CardBoxPower_4
    818                return TRUE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE01C             B.N      ??CardBoxPower_5
    819              }
    820              if(ucMode){
   \                     ??CardBoxPower_4: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD005             BEQ.N    ??CardBoxPower_6
    821                CSP_GPIO_BitSet(BSP_GPIO_BOX3_SELECT_PORT,
    822                                BSP_GPIO_BOX3_SELECT);
   \   0000003C   0xF45F 0x3100      MOVS     R1,#+131072
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       CSP_GPIO_BitSet
   \   00000046   0xE004             B.N      ??CardBoxPower_7
    823              }else{
    824                CSP_GPIO_BitClr(BSP_GPIO_BOX3_SELECT_PORT,
    825                                BSP_GPIO_BOX3_SELECT);
   \                     ??CardBoxPower_6: (+1)
   \   00000048   0xF45F 0x3100      MOVS     R1,#+131072
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      BL       CSP_GPIO_BitClr
    826              }
    827              if(ucType==LARGE_THICK_OUT_TYPE){
   \                     ??CardBoxPower_7: (+1)
   \   00000052   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000054   0x2F04             CMP      R7,#+4
   \   00000056   0xD104             BNE.N    ??CardBoxPower_8
    828                m_usrBoxInfo[BOX_FIRST].ucTimes=1;    
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable21_17
   \   0000005E   0x7308             STRB     R0,[R1, #+12]
   \   00000060   0xE003             B.N      ??CardBoxPower_9
    829              }else{
    830                m_usrBoxInfo[BOX_FIRST].ucTimes=2000/BOX_CONNECT_TIME_DEFAULT+1;    
   \                     ??CardBoxPower_8: (+1)
   \   00000062   0x2009             MOVS     R0,#+9
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable21_17
   \   00000068   0x7308             STRB     R0,[R1, #+12]
    831              }
    832            }
   \                     ??CardBoxPower_9: (+1)
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \   0000006C   0xE7CF             B.N      ??CardBoxPower_0
    833            return FALSE;
   \                     ??CardBoxPower_1: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??CardBoxPower_5: (+1)
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    834          }
    835          
    836          /********************************************************************************************************
    837          ** 函数名称: DMotoSelectGet
    838          ** 功能描述:
    839          ** 输 　 入:
    840          **
    841          ** 输　  出:
    842          **
    843          ** 全局变量:
    844          ** 调用模块:
    845          **
    846          ** 作　  者: John Tonny
    847          ** 日　  期: 2005年05月01日
    848          **------------------------------------------------------------------------------------------------------
    849          ** 修 改 人:
    850          ** 日　  期:
    851          **------------------------------------------------------------------------------------------------------
    852          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    853          void DMotoSelectGet(INT8U ucMode)
    854          {
   \                     DMotoSelectGet: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    855            INT8U i;
    856            INT8U j;
    857            INT8U ucData[8];
    858            INT8U ucMoto[8];
    859            INT8U ucErr;
    860          
    861            ucErr=1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x0007             MOVS     R7,R0
    862            if(EepromReadVerifyBytes(DMOTO_SELECT_ADDR,ucMoto,4)){
   \   0000000A   0x2204             MOVS     R2,#+4
   \   0000000C   0xA902             ADD      R1,SP,#+8
   \   0000000E   0x2048             MOVS     R0,#+72
   \   00000010   0x.... 0x....      BL       EepromReadVerifyBytes
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD05C             BEQ.N    ??DMotoSelectGet_0
    863              ucData[0]=ucMoto[0] & 0x0F;
   \   00000018   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000001C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000020   0xF88D 0x0000      STRB     R0,[SP, #+0]
    864              ucData[1]=(ucMoto[0]>>4) & 0x0F;
   \   00000024   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x0900             LSRS     R0,R0,#+4
   \   0000002C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    865              ucData[2]=ucMoto[1] & 0x0F;
   \   00000030   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000034   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000038   0xF88D 0x0002      STRB     R0,[SP, #+2]
    866              ucData[3]=(ucMoto[1]>>4) & 0x0F;
   \   0000003C   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x0900             LSRS     R0,R0,#+4
   \   00000044   0xF88D 0x0003      STRB     R0,[SP, #+3]
    867              ucData[4]=ucMoto[2] & 0x0F;
   \   00000048   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   0000004C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000050   0xF88D 0x0004      STRB     R0,[SP, #+4]
    868              ucData[5]=(ucMoto[2]>>4) & 0x0F;
   \   00000054   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x0900             LSRS     R0,R0,#+4
   \   0000005C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    869              ucData[6]=ucMoto[3] & 0x0F;
   \   00000060   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000064   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000068   0xF88D 0x0006      STRB     R0,[SP, #+6]
    870              ucData[7]=(ucMoto[3]>>4) & 0x0F;
   \   0000006C   0xF89D 0x000B      LDRB     R0,[SP, #+11]
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x0900             LSRS     R0,R0,#+4
   \   00000074   0xF88D 0x0007      STRB     R0,[SP, #+7]
    871              
    872              ucErr=0;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x0007             MOVS     R7,R0
    873              for(i=0;i<CARDMACHINE_DMOTO_NUMS;i++){
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0005             MOVS     R5,R0
   \                     ??DMotoSelectGet_1: (+1)
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D04             CMP      R5,#+4
   \   00000084   0xDA09             BGE.N    ??DMotoSelectGet_2
    874                if(ucData[i]>=CARDMACHINE_DMOTO_NUMS){
   \   00000086   0x4668             MOV      R0,SP
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x5D40             LDRB     R0,[R0, R5]
   \   0000008C   0x2804             CMP      R0,#+4
   \   0000008E   0xDB02             BLT.N    ??DMotoSelectGet_3
    875                  ucErr=1;
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x0007             MOVS     R7,R0
    876                  break;
   \   00000094   0xE001             B.N      ??DMotoSelectGet_2
    877                }
    878              }
   \                     ??DMotoSelectGet_3: (+1)
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   \   00000098   0xE7F2             B.N      ??DMotoSelectGet_1
    879              for(i=0;i<CARDMACHINE_DMOTO_NUMS;i++){
   \                     ??DMotoSelectGet_2: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0005             MOVS     R5,R0
   \                     ??DMotoSelectGet_4: (+1)
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0x2D04             CMP      R5,#+4
   \   000000A2   0xDA16             BGE.N    ??DMotoSelectGet_0
    880                for(j=i+1;j<CARDMACHINE_DMOTO_NUMS;j++){
   \   000000A4   0x1C68             ADDS     R0,R5,#+1
   \   000000A6   0x0006             MOVS     R6,R0
   \                     ??DMotoSelectGet_5: (+1)
   \   000000A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AA   0x2E04             CMP      R6,#+4
   \   000000AC   0xDA0C             BGE.N    ??DMotoSelectGet_6
    881                  if(ucData[i]==ucData[j]){
   \   000000AE   0x4668             MOV      R0,SP
   \   000000B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B2   0x5D40             LDRB     R0,[R0, R5]
   \   000000B4   0x4669             MOV      R1,SP
   \   000000B6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B8   0x5D89             LDRB     R1,[R1, R6]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD102             BNE.N    ??DMotoSelectGet_7
    882                    ucErr=1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x0007             MOVS     R7,R0
    883                    break;
   \   000000C2   0xE001             B.N      ??DMotoSelectGet_6
    884                  }
    885                }
   \                     ??DMotoSelectGet_7: (+1)
   \   000000C4   0x1C76             ADDS     R6,R6,#+1
   \   000000C6   0xE7EF             B.N      ??DMotoSelectGet_5
    886                if(ucErr){
   \                     ??DMotoSelectGet_6: (+1)
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x2F00             CMP      R7,#+0
   \   000000CC   0xD101             BNE.N    ??DMotoSelectGet_0
    887                  break;
    888                }
    889              }
   \                     ??DMotoSelectGet_8: (+1)
   \   000000CE   0x1C6D             ADDS     R5,R5,#+1
   \   000000D0   0xE7E5             B.N      ??DMotoSelectGet_4
    890            }
    891            if(ucErr){
   \                     ??DMotoSelectGet_0: (+1)
   \   000000D2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D4   0x2F00             CMP      R7,#+0
   \   000000D6   0xD04C             BEQ.N    ??DMotoSelectGet_9
    892              m_ucDMotoBit[0]=DMOTO_FIRST;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   000000DE   0x7008             STRB     R0,[R1, #+0]
    893              m_ucDMotoBit[1]=DMOTO_SECOND;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   000000E6   0x7048             STRB     R0,[R1, #+1]
    894              m_ucDMotoBit[2]=DMOTO_THIRD;
   \   000000E8   0x2002             MOVS     R0,#+2
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   000000EE   0x7088             STRB     R0,[R1, #+2]
    895              m_ucDMotoBit[3]=DMOTO_FOURTH;
   \   000000F0   0x2003             MOVS     R0,#+3
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   000000F6   0x70C8             STRB     R0,[R1, #+3]
    896              m_ucDMotoBit[4]=DMOTO_FIRST;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   000000FE   0x7108             STRB     R0,[R1, #+4]
    897              m_ucDMotoBit[5]=DMOTO_SECOND;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   00000106   0x7148             STRB     R0,[R1, #+5]
    898              m_ucDMotoBit[6]=DMOTO_THIRD;
   \   00000108   0x2002             MOVS     R0,#+2
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000010E   0x7188             STRB     R0,[R1, #+6]
    899              
    900              ucData[0]=(m_ucDMotoBit[0] & 0x0F) | ((m_ucDMotoBit[1]<<4) & 0xF0);
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000011E   0x7849             LDRB     R1,[R1, #+1]
   \   00000120   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000124   0xF88D 0x0000      STRB     R0,[SP, #+0]
    901              ucData[1]=(m_ucDMotoBit[2] & 0x0F) | ((m_ucDMotoBit[3]<<4) & 0xF0);
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   0000012C   0x7880             LDRB     R0,[R0, #+2]
   \   0000012E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   00000136   0x78C9             LDRB     R1,[R1, #+3]
   \   00000138   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000013C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    902              ucData[2]=(m_ucDMotoBit[4] & 0x0F) | ((m_ucDMotoBit[5]<<4) & 0xF0);
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   00000144   0x7900             LDRB     R0,[R0, #+4]
   \   00000146   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000014E   0x7949             LDRB     R1,[R1, #+5]
   \   00000150   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   00000154   0xF88D 0x0002      STRB     R0,[SP, #+2]
    903              ucData[3]=(m_ucDMotoBit[6] & 0x0F);
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   0000015C   0x7980             LDRB     R0,[R0, #+6]
   \   0000015E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000162   0xF88D 0x0003      STRB     R0,[SP, #+3]
    904              EepromWriteVerifyBytes(DMOTO_SELECT_ADDR,ucData,4);
   \   00000166   0x2204             MOVS     R2,#+4
   \   00000168   0x4669             MOV      R1,SP
   \   0000016A   0x2048             MOVS     R0,#+72
   \   0000016C   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000170   0xE00D             B.N      ??DMotoSelectGet_10
    905            }else{
    906              for(i=0;i<CARDMACHINE_DMOTO_NUMS+3;i++){
   \                     ??DMotoSelectGet_9: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x0005             MOVS     R5,R0
   \                     ??DMotoSelectGet_11: (+1)
   \   00000176   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000178   0x2D07             CMP      R5,#+7
   \   0000017A   0xDA08             BGE.N    ??DMotoSelectGet_10
    907                m_ucDMotoBit[i]=ucData[i];
   \   0000017C   0x4668             MOV      R0,SP
   \   0000017E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000180   0x5D40             LDRB     R0,[R0, R5]
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   00000186   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000188   0x5548             STRB     R0,[R1, R5]
    908              }
   \   0000018A   0x1C6D             ADDS     R5,R5,#+1
   \   0000018C   0xE7F3             B.N      ??DMotoSelectGet_11
    909            }
    910          }
   \                     ??DMotoSelectGet_10: (+1)
   \   0000018E   0xB005             ADD      SP,SP,#+20
   \   00000190   0xBDF0             POP      {R4-R7,PC}       ;; return
    911          
    912          /********************************************************************************************************
    913          ** 函数名称: SMotoSelectGet
    914          ** 功能描述:
    915          ** 输 　 入:
    916          **
    917          ** 输　  出:
    918          **
    919          ** 全局变量:
    920          ** 调用模块:
    921          **
    922          ** 作　  者: John Tonny
    923          ** 日　  期: 2005年05月01日
    924          **------------------------------------------------------------------------------------------------------
    925          ** 修 改 人:
    926          ** 日　  期:
    927          **------------------------------------------------------------------------------------------------------
    928          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    929          void SMotoSelectGet(INT8U ucMode)
    930          {
   \                     SMotoSelectGet: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    931            INT8U ucData[8];
    932            INT8U ucErr;
    933            
    934            ucErr=1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x0005             MOVS     R5,R0
    935            if(EepromReadVerifyBytes(SMOTO_SELECT_ADDR,ucData,2)){
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x2054             MOVS     R0,#+84
   \   00000010   0x.... 0x....      BL       EepromReadVerifyBytes
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD011             BEQ.N    ??SMotoSelectGet_0
    936              ucErr=0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    937              if(ucData[0]==ucData[1] || ucData[0]>1 || ucData[1]>1){
   \   0000001C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000020   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD007             BEQ.N    ??SMotoSelectGet_1
   \   00000028   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xDA03             BGE.N    ??SMotoSelectGet_1
   \   00000030   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xDB01             BLT.N    ??SMotoSelectGet_0
    938                ucErr=1;
   \                     ??SMotoSelectGet_1: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0005             MOVS     R5,R0
    939              }
    940            }
    941            if(ucErr){
   \                     ??SMotoSelectGet_0: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xD017             BEQ.N    ??SMotoSelectGet_2
    942              m_ucSMotoBit[0]=SMOTO_FIRST;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   00000048   0x7008             STRB     R0,[R1, #+0]
    943              m_ucSMotoBit[1]=SMOTO_SECOND;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   00000050   0x7048             STRB     R0,[R1, #+1]
    944              ucData[0]=m_ucSMotoBit[0];
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
    945              ucData[1]=m_ucSMotoBit[1];
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   00000060   0x7840             LDRB     R0,[R0, #+1]
   \   00000062   0xF88D 0x0001      STRB     R0,[SP, #+1]
    946              EepromWriteVerifyBytes(SMOTO_SELECT_ADDR,ucData,2);
   \   00000066   0x2202             MOVS     R2,#+2
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x2054             MOVS     R0,#+84
   \   0000006C   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000070   0xE009             B.N      ??SMotoSelectGet_3
    947            }else{
    948              m_ucSMotoBit[0]=ucData[0];
   \                     ??SMotoSelectGet_2: (+1)
   \   00000072   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
    949              m_ucSMotoBit[1]=ucData[1];
   \   0000007C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   00000084   0x7048             STRB     R0,[R1, #+1]
    950            }
    951          }
   \                     ??SMotoSelectGet_3: (+1)
   \   00000086   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    952          
    953          /********************************************************************************************************
    954          ** 函数名称: BoxSelectGet
    955          ** 功能描述:
    956          ** 输 　 入:
    957          **
    958          ** 输　  出:
    959          **
    960          ** 全局变量:
    961          ** 调用模块:
    962          **
    963          ** 作　  者: John Tonny
    964          ** 日　  期: 2005年05月01日
    965          **------------------------------------------------------------------------------------------------------
    966          ** 修 改 人:
    967          ** 日　  期:
    968          **------------------------------------------------------------------------------------------------------
    969          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    970          void BoxSelectGet(INT8U ucMode)
    971          {
   \                     BoxSelectGet: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    972            INT8U i;
    973            INT8U j;
    974            INT8U ucData[8];
    975            INT8U ucBox[2];
    976            INT8U ucErr;
    977            
    978            ucErr=1;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x0007             MOVS     R7,R0
    979            if(EepromReadVerifyBytes(BOX_SELECT_ADDR,ucBox,2)){
   \   00000008   0x2202             MOVS     R2,#+2
   \   0000000A   0xA902             ADD      R1,SP,#+8
   \   0000000C   0x2058             MOVS     R0,#+88
   \   0000000E   0x.... 0x....      BL       EepromReadVerifyBytes
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD041             BEQ.N    ??BoxSelectGet_0
    980              ucData[0]=ucBox[0] & 0x0F;
   \   00000016   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000001A   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    981              ucData[1]=(ucBox[0]>>4) & 0x0F;
   \   00000022   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x0900             LSRS     R0,R0,#+4
   \   0000002A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    982              ucData[2]=ucBox[1] & 0x0F;
   \   0000002E   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000032   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
    983              ucErr=0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0007             MOVS     R7,R0
    984              for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x0005             MOVS     R5,R0
   \                     ??BoxSelectGet_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D03             CMP      R5,#+3
   \   00000046   0xDA09             BGE.N    ??BoxSelectGet_2
    985                if(ucData[i]>=CARDMACHINE_CARDBOX_NUMS){
   \   00000048   0x4668             MOV      R0,SP
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x5D40             LDRB     R0,[R0, R5]
   \   0000004E   0x2803             CMP      R0,#+3
   \   00000050   0xDB02             BLT.N    ??BoxSelectGet_3
    986                  ucErr=1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x0007             MOVS     R7,R0
    987                  break;
   \   00000056   0xE001             B.N      ??BoxSelectGet_2
    988                }
    989              }
   \                     ??BoxSelectGet_3: (+1)
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0xE7F2             B.N      ??BoxSelectGet_1
    990              if(!ucErr){
   \                     ??BoxSelectGet_2: (+1)
   \   0000005C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD11B             BNE.N    ??BoxSelectGet_0
    991                for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x0005             MOVS     R5,R0
   \                     ??BoxSelectGet_4: (+1)
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x2D03             CMP      R5,#+3
   \   0000006A   0xDA16             BGE.N    ??BoxSelectGet_0
    992                  for(j=i+1;j<CARDMACHINE_CARDBOX_NUMS;j++){
   \   0000006C   0x1C68             ADDS     R0,R5,#+1
   \   0000006E   0x0006             MOVS     R6,R0
   \                     ??BoxSelectGet_5: (+1)
   \   00000070   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000072   0x2E03             CMP      R6,#+3
   \   00000074   0xDA0C             BGE.N    ??BoxSelectGet_6
    993                    if(ucData[i]==ucData[j]){
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x5D40             LDRB     R0,[R0, R5]
   \   0000007C   0x4669             MOV      R1,SP
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x5D89             LDRB     R1,[R1, R6]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD102             BNE.N    ??BoxSelectGet_7
    994                      ucErr=1;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x0007             MOVS     R7,R0
    995                      break;
   \   0000008A   0xE001             B.N      ??BoxSelectGet_6
    996                    }
    997                  }
   \                     ??BoxSelectGet_7: (+1)
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \   0000008E   0xE7EF             B.N      ??BoxSelectGet_5
    998                  if(ucErr==1){
   \                     ??BoxSelectGet_6: (+1)
   \   00000090   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000092   0x2F01             CMP      R7,#+1
   \   00000094   0xD001             BEQ.N    ??BoxSelectGet_0
    999                    break;
   1000                  }
   1001                }
   \                     ??BoxSelectGet_8: (+1)
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   \   00000098   0xE7E5             B.N      ??BoxSelectGet_4
   1002              }
   1003            }
   1004            if(ucErr){
   \                     ??BoxSelectGet_0: (+1)
   \   0000009A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009C   0x2F00             CMP      R7,#+0
   \   0000009E   0xD024             BEQ.N    ??BoxSelectGet_9
   1005              m_ucUartBit[0]=1;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   1006              m_ucUartBit[1]=0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000AE   0x7048             STRB     R0,[R1, #+1]
   1007              m_ucUartBit[2]=2;
   \   000000B0   0x2002             MOVS     R0,#+2
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000B6   0x7088             STRB     R0,[R1, #+2]
   1008              ucData[0]=(m_ucUartBit[0] & 0x0F) | ((m_ucUartBit[1]<<4) & 0xF0);
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable21_16
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000C6   0x7849             LDRB     R1,[R1, #+1]
   \   000000C8   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000CC   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1009              ucData[1]=(m_ucUartBit[2] & 0x0F);
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable21_16
   \   000000D4   0x7880             LDRB     R0,[R0, #+2]
   \   000000D6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000DA   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1010              EepromWriteVerifyBytes(BOX_SELECT_ADDR,ucData,2);
   \   000000DE   0x2202             MOVS     R2,#+2
   \   000000E0   0x4669             MOV      R1,SP
   \   000000E2   0x2058             MOVS     R0,#+88
   \   000000E4   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   000000E8   0xE00E             B.N      ??BoxSelectGet_10
   1011            }else{
   1012              m_ucUartBit[0]=ucData[0];
   \                     ??BoxSelectGet_9: (+1)
   \   000000EA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000F2   0x7008             STRB     R0,[R1, #+0]
   1013              m_ucUartBit[1]=ucData[1];
   \   000000F4   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   000000FC   0x7048             STRB     R0,[R1, #+1]
   1014              m_ucUartBit[2]=ucData[2];
   \   000000FE   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   00000106   0x7088             STRB     R0,[R1, #+2]
   1015            }
   1016          }
   \                     ??BoxSelectGet_10: (+1)
   \   00000108   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   1017          
   1018          /********************************************************************************************************
   1019          ** 函数名称: KeySelectGet
   1020          ** 功能描述:
   1021          ** 输 　 入:
   1022          **
   1023          ** 输　  出:
   1024          **
   1025          ** 全局变量:
   1026          ** 调用模块:
   1027          **
   1028          ** 作　  者: John Tonny
   1029          ** 日　  期: 2005年05月01日
   1030          **------------------------------------------------------------------------------------------------------
   1031          ** 修 改 人:
   1032          ** 日　  期:
   1033          **------------------------------------------------------------------------------------------------------
   1034          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1035          void KeySelectGet(INT8U ucMode)
   1036          {
   \                     KeySelectGet: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   1037            INT8U ucType=DEV_TYPE();
   \   00000008   0x.... 0x....      BL       DEV_TYPE
   \   0000000C   0x0005             MOVS     R5,R0
   1038            
   1039          #if BOARD_OLD_EN==0  
   1040            INT8U i;
   1041            INT8U j;
   1042            INT8U ucData[32];
   1043            INT8U ucErr;
   1044            INT8U ucErr1;
   1045            
   1046            INT8U ucGroup=GroupSelectGet();
   \   0000000E   0x.... 0x....      BL       GroupSelectGet
   \   00000012   0x4682             MOV      R10,R0
   1047            
   1048            for(i=0;i<4;i++){
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
   \                     ??KeySelectGet_0: (+1)
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E04             CMP      R6,#+4
   \   0000001C   0xDA14             BGE.N    ??KeySelectGet_1
   1049              ucErr1=1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x4681             MOV      R9,R0
   1050              if(EepromReadVerifyBytes(KEY0_SELECT_ADDR+i*8,&ucData[i*6],6)){
   \   00000022   0x2206             MOVS     R2,#+6
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2106             MOVS     R1,#+6
   \   0000002A   0xFB01 0xF106      MUL      R1,R1,R6
   \   0000002E   0x4401             ADD      R1,R0,R1
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x00F0             LSLS     R0,R6,#+3
   \   00000034   0x3060             ADDS     R0,R0,#+96
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??KeySelectGet_2
   1051                ucErr1=0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4681             MOV      R9,R0
   1052              }else{
   \   00000044   0x1C76             ADDS     R6,R6,#+1
   \   00000046   0xE7E7             B.N      ??KeySelectGet_0
   1053                break;
   1054              }
   1055            }
   1056            if(!ucErr1){
   \                     ??KeySelectGet_2: (+1)
   \                     ??KeySelectGet_1: (+1)
   \   00000048   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000004C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000050   0xD129             BNE.N    ??KeySelectGet_3
   1057              KeyBitDecode(ucData);
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       KeyBitDecode
   1058              ucErr=0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4680             MOV      R8,R0
   1059              for(i=0;i<32;i++){
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0006             MOVS     R6,R0
   \                     ??KeySelectGet_4: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E20             CMP      R6,#+32
   \   00000064   0xDA1F             BGE.N    ??KeySelectGet_3
   1060                if(ucData[i]<32){
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x5D80             LDRB     R0,[R0, R6]
   \   0000006C   0x2820             CMP      R0,#+32
   \   0000006E   0xDA18             BGE.N    ??KeySelectGet_5
   1061                  for(j=i+1;j<32;j++){
   \   00000070   0x1C70             ADDS     R0,R6,#+1
   \   00000072   0x0007             MOVS     R7,R0
   \                     ??KeySelectGet_6: (+1)
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x2F20             CMP      R7,#+32
   \   00000078   0xDA0C             BGE.N    ??KeySelectGet_7
   1062                    if(ucData[i]==ucData[j]){
   \   0000007A   0x4668             MOV      R0,SP
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x5D80             LDRB     R0,[R0, R6]
   \   00000080   0x4669             MOV      R1,SP
   \   00000082   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000084   0x5DC9             LDRB     R1,[R1, R7]
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD102             BNE.N    ??KeySelectGet_8
   1063                      ucErr=1;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x4680             MOV      R8,R0
   1064                      break;
   \   0000008E   0xE001             B.N      ??KeySelectGet_7
   1065                    }
   1066                  }
   \                     ??KeySelectGet_8: (+1)
   \   00000090   0x1C7F             ADDS     R7,R7,#+1
   \   00000092   0xE7EF             B.N      ??KeySelectGet_6
   1067                  if(ucErr){
   \                     ??KeySelectGet_7: (+1)
   \   00000094   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000098   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009C   0xD103             BNE.N    ??KeySelectGet_3
   1068                    break;
   1069                  }
   1070                }else{
   \                     ??KeySelectGet_9: (+1)
   \   0000009E   0x1C76             ADDS     R6,R6,#+1
   \   000000A0   0xE7DE             B.N      ??KeySelectGet_4
   1071                  ucErr=1;
   \                     ??KeySelectGet_5: (+1)
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x4680             MOV      R8,R0
   1072                  break;
   1073                }
   1074              }
   1075            }
   1076            if(ucErr1 || ucErr){
   \                     ??KeySelectGet_3: (+1)
   \   000000A6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000AA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AE   0xD104             BNE.N    ??KeySelectGet_10
   \   000000B0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000B8   0xD036             BEQ.N    ??KeySelectGet_11
   1077              if(ucType==SMALL_THICK_ZIN_TYPE || ucType==SMALL_THIN_ZIN_TYPE){
   \                     ??KeySelectGet_10: (+1)
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0x2D02             CMP      R5,#+2
   \   000000BE   0xD002             BEQ.N    ??KeySelectGet_12
   \   000000C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C2   0x2D0A             CMP      R5,#+10
   \   000000C4   0xD10B             BNE.N    ??KeySelectGet_13
   1078                Mem_Copy(ucData,&m_ucKey_GROUP_SMALL_ZIN_TYPE[ucGroup*32],32);
   \                     ??KeySelectGet_12: (+1)
   \   000000C6   0x2220             MOVS     R2,#+32
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   000000CC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D0   0xEA5F 0x114A      LSLS     R1,R10,#+5
   \   000000D4   0x4401             ADD      R1,R0,R1
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x.... 0x....      BL       Mem_Copy
   \   000000DC   0xE00D             B.N      ??KeySelectGet_14
   1079              }else{
   1080                for(i=0;i<32;i++){
   \                     ??KeySelectGet_13: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x0006             MOVS     R6,R0
   \                     ??KeySelectGet_15: (+1)
   \   000000E2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E4   0x2E20             CMP      R6,#+32
   \   000000E6   0xDA08             BGE.N    ??KeySelectGet_14
   1081                  m_ucKeyBit[i]=i;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable21_21
   \   000000EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EE   0x5586             STRB     R6,[R0, R6]
   1082                  ucData[i]=i;
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F4   0x5586             STRB     R6,[R0, R6]
   1083                }
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   \   000000F8   0xE7F3             B.N      ??KeySelectGet_15
   1084              }
   1085              KeyBitEncode(ucData);
   \                     ??KeySelectGet_14: (+1)
   \   000000FA   0x4668             MOV      R0,SP
   \   000000FC   0x.... 0x....      BL       KeyBitEncode
   1086              for(i=0;i<4;i++){
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x0006             MOVS     R6,R0
   \                     ??KeySelectGet_16: (+1)
   \   00000104   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000106   0x2E04             CMP      R6,#+4
   \   00000108   0xDA1C             BGE.N    ??KeySelectGet_17
   1087                EepromWriteVerifyBytes(KEY0_SELECT_ADDR+i*8,&ucData[i*6],6);
   \   0000010A   0x2206             MOVS     R2,#+6
   \   0000010C   0x4668             MOV      R0,SP
   \   0000010E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000110   0x2106             MOVS     R1,#+6
   \   00000112   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000116   0x4401             ADD      R1,R0,R1
   \   00000118   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011A   0x00F0             LSLS     R0,R6,#+3
   \   0000011C   0x3060             ADDS     R0,R0,#+96
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000120   0x.... 0x....      BL       EepromWriteVerifyBytes
   1088              }
   \   00000124   0x1C76             ADDS     R6,R6,#+1
   \   00000126   0xE7ED             B.N      ??KeySelectGet_16
   1089            }else{
   1090              for(i=0;i<32;i++){
   \                     ??KeySelectGet_11: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x0006             MOVS     R6,R0
   \                     ??KeySelectGet_18: (+1)
   \   0000012C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012E   0x2E20             CMP      R6,#+32
   \   00000130   0xDA08             BGE.N    ??KeySelectGet_17
   1091                m_ucKeyBit[i]=ucData[i];
   \   00000132   0x4668             MOV      R0,SP
   \   00000134   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000136   0x5D80             LDRB     R0,[R0, R6]
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable21_21
   \   0000013C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013E   0x5588             STRB     R0,[R1, R6]
   1092              }
   \   00000140   0x1C76             ADDS     R6,R6,#+1
   \   00000142   0xE7F3             B.N      ??KeySelectGet_18
   1093            }
   1094          #else
   1095            
   1096            if(ucType==LARGE_OUT_TYPE){
   1097              m_ucKeyBit[0]=4;
   1098              m_ucKeyBit[1]=5;
   1099              m_ucKeyBit[2]=25;
   1100              m_ucKeyBit[3]=20;
   1101              m_ucKeyBit[4]=6;
   1102              m_ucKeyBit[5]=7;
   1103              m_ucKeyBit[6]=16;
   1104              m_ucKeyBit[7]=8;
   1105              
   1106              m_ucKeyBit[8]=27;
   1107              m_ucKeyBit[9]=28;
   1108              m_ucKeyBit[10]=26;
   1109              m_ucKeyBit[11]=19;
   1110              m_ucKeyBit[12]=9;
   1111              m_ucKeyBit[13]=10;
   1112              m_ucKeyBit[14]=13;
   1113              m_ucKeyBit[15]=11;
   1114              
   1115              m_ucKeyBit[16]=29;
   1116              m_ucKeyBit[17]=21;
   1117              m_ucKeyBit[18]=1;
   1118              m_ucKeyBit[19]=18;
   1119              m_ucKeyBit[20]=14;
   1120              m_ucKeyBit[21]=15;
   1121              m_ucKeyBit[22]=12;
   1122              m_ucKeyBit[23]=17;
   1123              
   1124              m_ucKeyBit[24]=0;
   1125              m_ucKeyBit[25]=2;
   1126              m_ucKeyBit[26]=3;
   1127              m_ucKeyBit[27]=24;
   1128              m_ucKeyBit[28]=22;
   1129              m_ucKeyBit[28]=23;
   1130              m_ucKeyBit[30]=30;
   1131              m_ucKeyBit[31]=31;
   1132            }else{
   1133              m_ucKeyBit[0]=3;
   1134              m_ucKeyBit[1]=2;
   1135              m_ucKeyBit[2]=4;
   1136              m_ucKeyBit[3]=5;
   1137              m_ucKeyBit[4]=6;
   1138              m_ucKeyBit[5]=7;
   1139              m_ucKeyBit[6]=0;
   1140              m_ucKeyBit[7]=8;
   1141              
   1142              m_ucKeyBit[8]=9;
   1143              m_ucKeyBit[9]=10;
   1144              m_ucKeyBit[10]=11;
   1145              m_ucKeyBit[11]=12;
   1146              m_ucKeyBit[12]=13;
   1147              m_ucKeyBit[13]=14;
   1148              m_ucKeyBit[14]=15;
   1149              m_ucKeyBit[15]=16;
   1150              
   1151              m_ucKeyBit[16]=17;
   1152              m_ucKeyBit[17]=18;
   1153              m_ucKeyBit[18]=19;
   1154              m_ucKeyBit[19]=20;
   1155              m_ucKeyBit[20]=21;
   1156              m_ucKeyBit[21]=22;
   1157              m_ucKeyBit[22]=23;
   1158              m_ucKeyBit[23]=26;
   1159              
   1160              m_ucKeyBit[24]=24;
   1161              m_ucKeyBit[25]=27;
   1162              m_ucKeyBit[26]=25;
   1163              m_ucKeyBit[27]=1;
   1164              m_ucKeyBit[28]=28;
   1165              m_ucKeyBit[28]=29;
   1166              m_ucKeyBit[30]=30;
   1167              m_ucKeyBit[31]=31;
   1168            }
   1169          #endif
   1170          }
   \                     ??KeySelectGet_17: (+1)
   \   00000144   0xB008             ADD      SP,SP,#+32
   \   00000146   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1171          
   1172          
   1173          /********************************************************************************************************
   1174          ** 函数名称: KeyBitEncode
   1175          ** 功能描述:
   1176          ** 输 　 入:
   1177          **
   1178          ** 输　  出:
   1179          **
   1180          ** 全局变量:
   1181          ** 调用模块:
   1182          **
   1183          ** 作　  者: John Tonny
   1184          ** 日　  期: 2005年05月01日
   1185          **------------------------------------------------------------------------------------------------------
   1186          ** 修 改 人:
   1187          ** 日　  期:
   1188          **------------------------------------------------------------------------------------------------------
   1189          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1190          void KeyBitEncode(INT8U *pucData)
   1191          {
   \                     KeyBitEncode: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0xB090             SUB      SP,SP,#+64
   1192            INT8U i;
   1193            INT8U ucData[64];
   1194            INT8U ucStart=1;
   \   00000004   0x2101             MOVS     R1,#+1
   1195            INT8U ucMove;
   1196            INT8U ucIndex=0;
   \   00000006   0x2300             MOVS     R3,#+0
   1197            INT8U ucBits=8;
   \   00000008   0x2408             MOVS     R4,#+8
   1198          
   1199            for(i=0;i<32;i++){
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0035             MOVS     R5,R6
   \                     ??KeyBitEncode_0: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D20             CMP      R5,#+32
   \   00000012   0xDA05             BGE.N    ??KeyBitEncode_1
   1200              ucData[i]=0;
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0x466F             MOV      R7,SP
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x557E             STRB     R6,[R7, R5]
   1201            }
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0xE7F6             B.N      ??KeyBitEncode_0
   1202            for(i=0;i<32;i++){
   \                     ??KeyBitEncode_1: (+1)
   \   00000020   0x2600             MOVS     R6,#+0
   \   00000022   0x0035             MOVS     R5,R6
   \                     ??KeyBitEncode_2: (+1)
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D20             CMP      R5,#+32
   \   00000028   0xDA2C             BGE.N    ??KeyBitEncode_3
   1203              if(ucStart){
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD009             BEQ.N    ??KeyBitEncode_4
   1204                ucStart=0;
   \   00000030   0x2600             MOVS     R6,#+0
   \   00000032   0x0031             MOVS     R1,R6
   1205                ucData[ucIndex]=(*(pucData+i));
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x5D46             LDRB     R6,[R0, R5]
   \   00000038   0x466F             MOV      R7,SP
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0x54FE             STRB     R6,[R7, R3]
   1206                ucMove=ucBits-6;
   \   0000003E   0x1FA6             SUBS     R6,R4,#+6
   \   00000040   0x0032             MOVS     R2,R6
   \   00000042   0xE01D             B.N      ??KeyBitEncode_5
   1207              }else{
   1208                if(ucMove){
   \                     ??KeyBitEncode_4: (+1)
   \   00000044   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD00D             BEQ.N    ??KeyBitEncode_6
   1209                  ucData[ucIndex]=ucData[ucIndex]|((*(pucData+i))<<(ucBits-ucMove));
   \   0000004A   0x466E             MOV      R6,SP
   \   0000004C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004E   0x5CF6             LDRB     R6,[R6, R3]
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0x5D47             LDRB     R7,[R0, R5]
   \   00000054   0xEBB4 0x0C02      SUBS     R12,R4,R2
   \   00000058   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   0000005C   0x433E             ORRS     R6,R7,R6
   \   0000005E   0x466F             MOV      R7,SP
   \   00000060   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000062   0x54FE             STRB     R6,[R7, R3]
   1210                  ucIndex++;
   \   00000064   0x1C5B             ADDS     R3,R3,#+1
   1211                }
   1212                ucData[ucIndex]=((*(pucData+i))>>(ucMove));
   \                     ??KeyBitEncode_6: (+1)
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x5D46             LDRB     R6,[R0, R5]
   \   0000006A   0x4116             ASRS     R6,R6,R2
   \   0000006C   0x466F             MOV      R7,SP
   \   0000006E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000070   0x54FE             STRB     R6,[R7, R3]
   1213                ucMove=ucBits-(6-ucMove);
   \   00000072   0x1FA6             SUBS     R6,R4,#+6
   \   00000074   0x18B2             ADDS     R2,R6,R2
   1214                if(ucMove==8){
   \   00000076   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000078   0x2A08             CMP      R2,#+8
   \   0000007A   0xD101             BNE.N    ??KeyBitEncode_5
   1215                  ucStart=1;
   \   0000007C   0x2601             MOVS     R6,#+1
   \   0000007E   0x0031             MOVS     R1,R6
   1216                }
   1217              }
   1218            }
   \                     ??KeyBitEncode_5: (+1)
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
   \   00000082   0xE7CF             B.N      ??KeyBitEncode_2
   1219            for(i=0;i<32;i++){
   \                     ??KeyBitEncode_3: (+1)
   \   00000084   0x2600             MOVS     R6,#+0
   \   00000086   0x0035             MOVS     R5,R6
   \                     ??KeyBitEncode_7: (+1)
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D20             CMP      R5,#+32
   \   0000008C   0xDA06             BGE.N    ??KeyBitEncode_8
   1220              *(pucData+i)=ucData[i];
   \   0000008E   0x466E             MOV      R6,SP
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x5D76             LDRB     R6,[R6, R5]
   \   00000094   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000096   0x5546             STRB     R6,[R0, R5]
   1221            }
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   \   0000009A   0xE7F5             B.N      ??KeyBitEncode_7
   1222          }
   \                     ??KeyBitEncode_8: (+1)
   \   0000009C   0xB010             ADD      SP,SP,#+64
   \   0000009E   0xBCF0             POP      {R4-R7}
   \   000000A0   0x4770             BX       LR               ;; return
   1223          
   1224          /********************************************************************************************************
   1225          ** 函数名称: KeyBitDecode
   1226          ** 功能描述:
   1227          ** 输 　 入:
   1228          **
   1229          ** 输　  出:
   1230          **
   1231          ** 全局变量:
   1232          ** 调用模块:
   1233          **
   1234          ** 作　  者: John Tonny
   1235          ** 日　  期: 2005年05月01日
   1236          **------------------------------------------------------------------------------------------------------
   1237          ** 修 改 人:
   1238          ** 日　  期:
   1239          **------------------------------------------------------------------------------------------------------
   1240          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1241          void KeyBitDecode(INT8U *pucData)
   1242          {
   \                     KeyBitDecode: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0xB090             SUB      SP,SP,#+64
   1243            INT8U i;
   1244            INT8U ucData[64];
   1245            INT8U ucStart=1;
   \   00000004   0x2101             MOVS     R1,#+1
   1246            INT8U ucMove;
   1247            INT8U ucIndex=0;
   \   00000006   0x2300             MOVS     R3,#+0
   1248            INT8U ucBits=8;
   \   00000008   0x2408             MOVS     R4,#+8
   1249          
   1250            for(i=0;i<32;i++){
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x0035             MOVS     R5,R6
   \                     ??KeyBitDecode_0: (+1)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D20             CMP      R5,#+32
   \   00000012   0xDA05             BGE.N    ??KeyBitDecode_1
   1251              ucData[i]=0;
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0x466F             MOV      R7,SP
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x557E             STRB     R6,[R7, R5]
   1252            }
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0xE7F6             B.N      ??KeyBitDecode_0
   1253          
   1254            ucStart=1;
   \                     ??KeyBitDecode_1: (+1)
   \   00000020   0x2601             MOVS     R6,#+1
   \   00000022   0x0031             MOVS     R1,R6
   1255            ucMove=0;
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0x0032             MOVS     R2,R6
   1256            ucIndex=0;
   \   00000028   0x2600             MOVS     R6,#+0
   \   0000002A   0x0033             MOVS     R3,R6
   1257            ucBits=8;
   \   0000002C   0x2608             MOVS     R6,#+8
   \   0000002E   0x0034             MOVS     R4,R6
   1258            for(i=0;i<32;i++){
   \   00000030   0x2600             MOVS     R6,#+0
   \   00000032   0x0035             MOVS     R5,R6
   \                     ??KeyBitDecode_2: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D20             CMP      R5,#+32
   \   00000038   0xDA3E             BGE.N    ??KeyBitDecode_3
   1259              if(ucStart){
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD00C             BEQ.N    ??KeyBitDecode_4
   1260                ucStart=0;
   \   00000040   0x2600             MOVS     R6,#+0
   \   00000042   0x0031             MOVS     R1,R6
   1261                ucData[ucIndex]=(*(pucData+i))&0x3F;
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x5D46             LDRB     R6,[R0, R5]
   \   00000048   0xF016 0x063F      ANDS     R6,R6,#0x3F
   \   0000004C   0x466F             MOV      R7,SP
   \   0000004E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000050   0x54FE             STRB     R6,[R7, R3]
   1262                ucIndex++;
   \   00000052   0x1C5B             ADDS     R3,R3,#+1
   1263                ucMove=ucBits-6;
   \   00000054   0x1FA6             SUBS     R6,R4,#+6
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xE02C             B.N      ??KeyBitDecode_5
   1264              }else{
   1265                if(ucMove){
   \                     ??KeyBitDecode_4: (+1)
   \   0000005A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005C   0x2A00             CMP      R2,#+0
   \   0000005E   0xD00A             BEQ.N    ??KeyBitDecode_6
   1266                  ucData[ucIndex]=((*(pucData+i-1))>>(8-ucMove));
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0xEB00 0x0605      ADD      R6,R0,R5
   \   00000066   0xF816 0x6C01      LDRB     R6,[R6, #-1]
   \   0000006A   0xF1D2 0x0708      RSBS     R7,R2,#+8
   \   0000006E   0x413E             ASRS     R6,R6,R7
   \   00000070   0x466F             MOV      R7,SP
   \   00000072   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000074   0x54FE             STRB     R6,[R7, R3]
   1267                }
   1268                ucData[ucIndex]=(ucData[ucIndex] | ((*(pucData+i))<<ucMove))&0x3F;
   \                     ??KeyBitDecode_6: (+1)
   \   00000076   0x466E             MOV      R6,SP
   \   00000078   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000007A   0x5CF6             LDRB     R6,[R6, R3]
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x5D47             LDRB     R7,[R0, R5]
   \   00000080   0x4097             LSLS     R7,R7,R2
   \   00000082   0x433E             ORRS     R6,R7,R6
   \   00000084   0xF016 0x063F      ANDS     R6,R6,#0x3F
   \   00000088   0x466F             MOV      R7,SP
   \   0000008A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008C   0x54FE             STRB     R6,[R7, R3]
   1269                ucIndex++;
   \   0000008E   0x1C5B             ADDS     R3,R3,#+1
   1270                ucMove=ucBits-(6-ucMove);
   \   00000090   0x1FA6             SUBS     R6,R4,#+6
   \   00000092   0x18B2             ADDS     R2,R6,R2
   1271                if(ucMove>=6){
   \   00000094   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000096   0x2A06             CMP      R2,#+6
   \   00000098   0xDB0C             BLT.N    ??KeyBitDecode_5
   1272                  ucData[ucIndex]=((*(pucData+i))>>(8-ucMove))&0x3F;
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x5D46             LDRB     R6,[R0, R5]
   \   0000009E   0xF1D2 0x0708      RSBS     R7,R2,#+8
   \   000000A2   0x413E             ASRS     R6,R6,R7
   \   000000A4   0xF016 0x063F      ANDS     R6,R6,#0x3F
   \   000000A8   0x466F             MOV      R7,SP
   \   000000AA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000AC   0x54FE             STRB     R6,[R7, R3]
   1273                  ucIndex++;
   \   000000AE   0x1C5B             ADDS     R3,R3,#+1
   1274                  ucStart=1;
   \   000000B0   0x2601             MOVS     R6,#+1
   \   000000B2   0x0031             MOVS     R1,R6
   1275                }
   1276          }
   1277            }
   \                     ??KeyBitDecode_5: (+1)
   \   000000B4   0x1C6D             ADDS     R5,R5,#+1
   \   000000B6   0xE7BD             B.N      ??KeyBitDecode_2
   1278          
   1279            for(i=0;i<32;i++){
   \                     ??KeyBitDecode_3: (+1)
   \   000000B8   0x2600             MOVS     R6,#+0
   \   000000BA   0x0035             MOVS     R5,R6
   \                     ??KeyBitDecode_7: (+1)
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0x2D20             CMP      R5,#+32
   \   000000C0   0xDA06             BGE.N    ??KeyBitDecode_8
   1280              *(pucData+i)=ucData[i];
   \   000000C2   0x466E             MOV      R6,SP
   \   000000C4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C6   0x5D76             LDRB     R6,[R6, R5]
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0x5546             STRB     R6,[R0, R5]
   1281            }
   \   000000CC   0x1C6D             ADDS     R5,R5,#+1
   \   000000CE   0xE7F5             B.N      ??KeyBitDecode_7
   1282          }
   \                     ??KeyBitDecode_8: (+1)
   \   000000D0   0xB010             ADD      SP,SP,#+64
   \   000000D2   0xBCF0             POP      {R4-R7}
   \   000000D4   0x4770             BX       LR               ;; return
   1283          
   1284          /********************************************************************************************************
   1285          ** 函数名称: GroupSelectGet
   1286          ** 功能描述:
   1287          ** 输 　 入:
   1288          **
   1289          ** 输　  出:
   1290          **
   1291          ** 全局变量:
   1292          ** 调用模块:
   1293          **
   1294          ** 作　  者: John Tonny
   1295          ** 日　  期: 2005年05月01日
   1296          **------------------------------------------------------------------------------------------------------
   1297          ** 修 改 人:
   1298          ** 日　  期:
   1299          **------------------------------------------------------------------------------------------------------
   1300          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1301          INT8U GroupSelectGet(void)
   1302          {
   \                     GroupSelectGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1303            INT8U ucData;
   1304            
   1305            if(!EepromReadVerifyBytes(GROUP_SELECT_ADDR,&ucData,1)){
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x200C             MOVS     R0,#+12
   \   00000008   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD107             BNE.N    ??GroupSelectGet_0
   1306              ucData=0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1307              EepromWriteVerifyBytes(GROUP_SELECT_ADDR,&ucData,1);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x200C             MOVS     R0,#+12
   \   0000001C   0x.... 0x....      BL       EepromWriteVerifyBytes
   1308            }
   1309            return ucData;
   \                     ??GroupSelectGet_0: (+1)
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   1310          }
   1311                                  
   1312          /********************************************************************************************************
   1313          ** 函数名称: ScanParamsGet
   1314          ** 功能描述:
   1315          ** 输 　 入:
   1316          **
   1317          ** 输　  出:
   1318          **
   1319          ** 全局变量:
   1320          ** 调用模块:
   1321          **
   1322          ** 作　  者: John Tonny
   1323          ** 日　  期: 2005年05月01日
   1324          **------------------------------------------------------------------------------------------------------
   1325          ** 修 改 人:
   1326          ** 日　  期:
   1327          **------------------------------------------------------------------------------------------------------
   1328          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1329          void ScanParamsGet(void)
   1330          {
   \                     ScanParamsGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1331            INT8U ucData[2];
   1332            
   1333            if(!EepromReadVerifyBytes(SCAN_PARAMS_ADDR,ucData,2)){
   \   00000002   0x2202             MOVS     R2,#+2
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD10A             BNE.N    ??ScanParamsGet_0
   1334              ucData[0]=SCAN_OPEN_TIMES;
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1335              ucData[1]=SCAN_CLOSE_TIMES;
   \   00000016   0x2032             MOVS     R0,#+50
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1336              EepromWriteVerifyBytes(SCAN_PARAMS_ADDR,ucData,2);
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       EepromWriteVerifyBytes
   1337            }
   1338            g_ucScanOpenTime=ucData[0];
   \                     ??ScanParamsGet_0: (+1)
   \   00000026   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable21_22
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1339            g_ucScanCloseTime=ucData[1];
   \   0000002E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000032   0x....             LDR.N    R1,??DataTable21_23
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   1340          }                        
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
   1341          
   1342          /********************************************************************************************************
   1343          ** 函数名称: DMotoPosBySelected
   1344          ** 功能描述:
   1345          ** 输 　 入:
   1346          **
   1347          ** 输　  出:
   1348          **
   1349          ** 全局变量:
   1350          ** 调用模块:
   1351          **
   1352          ** 作　  者: John Tonny
   1353          ** 日　  期: 2005年05月01日
   1354          **------------------------------------------------------------------------------------------------------
   1355          ** 修 改 人:
   1356          ** 日　  期:
   1357          **------------------------------------------------------------------------------------------------------
   1358          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1359          INT8U DMotoPosBySelected(INT8U ucSelected) 
   1360          {	
   \                     DMotoPosBySelected: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1361            if(ucSelected>CARDMACHINE_DMOTO_NUMS-1){
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDB01             BLT.N    ??DMotoPosBySelected_0
   1362              return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE003             B.N      ??DMotoPosBySelected_1
   1363            }
   1364            return m_ucDMotoBit[CARDMACHINE_DMOTO_NUMS+ucSelected];
   \                     ??DMotoPosBySelected_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable21_18
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x4408             ADD      R0,R0,R1
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \                     ??DMotoPosBySelected_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
   1365          }
   1366          
   1367          /********************************************************************************************************
   1368          ** 函数名称: DMotoByPos
   1369          ** 功能描述:
   1370          ** 输 　 入:
   1371          **
   1372          ** 输　  出:
   1373          **
   1374          ** 全局变量:
   1375          ** 调用模块:
   1376          **
   1377          ** 作　  者: John Tonny
   1378          ** 日　  期: 2005年05月01日
   1379          **------------------------------------------------------------------------------------------------------
   1380          ** 修 改 人:
   1381          ** 日　  期:
   1382          **------------------------------------------------------------------------------------------------------
   1383          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1384          INT8U DMotoByPos(INT8U ucPos)
   1385          {
   \                     DMotoByPos: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1386            INT8U i;
   1387            
   1388            for(i=0;i<CARDMACHINE_DMOTO_NUMS;i++){
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0002             MOVS     R2,R0
   \                     ??DMotoByPos_0: (+1)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A04             CMP      R2,#+4
   \   0000000A   0xDA0C             BGE.N    ??DMotoByPos_1
   1389              if(m_ucDMotoBit[i+CARDMACHINE_DMOTO_NUMS]==ucPos){
   \   0000000C   0x....             LDR.N    R0,??DataTable21_18
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x4410             ADD      R0,R0,R2
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \   00000014   0x000B             MOVS     R3,R1
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0x4298             CMP      R0,R3
   \   0000001A   0xD102             BNE.N    ??DMotoByPos_2
   1390                return i;
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xE002             B.N      ??DMotoByPos_3
   1391              }
   1392            }
   \                     ??DMotoByPos_2: (+1)
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0xE7EF             B.N      ??DMotoByPos_0
   1393            return 0;	
   \                     ??DMotoByPos_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??DMotoByPos_3: (+1)
   \   00000028   0x4770             BX       LR               ;; return
   1394          }
   1395          
   1396          /********************************************************************************************************
   1397          ** 函数名称: DEV_TYPE
   1398          ** 功能描述:
   1399          ** 输 　 入:
   1400          **
   1401          ** 输　  出:
   1402          **
   1403          ** 全局变量:
   1404          ** 调用模块:
   1405          **
   1406          ** 作　  者: John Tonny
   1407          ** 日　  期: 2005年05月01日
   1408          **------------------------------------------------------------------------------------------------------
   1409          ** 修 改 人:
   1410          ** 日　  期:
   1411          **------------------------------------------------------------------------------------------------------
   1412          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1413          INT8U DEV_TYPE(void)
   1414          {
   \                     DEV_TYPE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1415          #if BOARD_OLD_EN==0
   1416            return (~(CSP_GPIO_Rd(BSP_GPIO_DEV_TYPE_PORT)>>BSP_GPIO_DEV1_TYPE_BIT)) & 0x7;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000008   0x0E00             LSRS     R0,R0,#+24
   \   0000000A   0x43C0             MVNS     R0,R0
   \   0000000C   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
   1417          #else
   1418            return ((~(CSP_GPIO_Rd(BSP_GPIO_DEV_TYPE_PORT)>>BSP_GPIO_DEV1_TYPE_BIT)) & 0x01) | ((~(CSP_GPIO_Rd(BSP_GPIO_DEV2_TYPE_PORT)>>(BSP_GPIO_DEV2_TYPE_BIT-2))) & 0x4);  
   1419          #endif
   1420          }
   1421          
   1422          /********************************************************************************************************
   1423          ** 函数名称: CARD_AUTO_MODE
   1424          ** 功能描述:
   1425          ** 输 　 入:
   1426          **
   1427          ** 输　  出:
   1428          **
   1429          ** 全局变量:
   1430          ** 调用模块:
   1431          **
   1432          ** 作　  者: John Tonny
   1433          ** 日　  期: 2005年05月01日
   1434          **------------------------------------------------------------------------------------------------------
   1435          ** 修 改 人:
   1436          ** 日　  期:
   1437          **------------------------------------------------------------------------------------------------------
   1438          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1439          INT8U CARD_AUTO_MODE(void)
   1440          {  
   \                     CARD_AUTO_MODE: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1441            CSP_GPIO_MSK ulTmp=CSP_GPIO_Rd(BSP_GPIO_AUTOCARD_PORT);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000008   0x0001             MOVS     R1,R0
   1442          #if BOARD_OLD_EN==0  
   1443            if(!CheckBit(ulTmp,BSP_GPIO_AUTOCARD_BIT)){
   \   0000000A   0x0208             LSLS     R0,R1,#+8
   \   0000000C   0xD401             BMI.N    ??CARD_AUTO_MODE_0
   1444          #else
   1445            if(CheckBit(ulTmp,BSP_GPIO_AUTOCARD_BIT)){
   1446          #endif
   1447              return TRUE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??CARD_AUTO_MODE_1
   1448            }
   1449            return FALSE;
   \                     ??CARD_AUTO_MODE_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??CARD_AUTO_MODE_1: (+1)
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
   1450          }  
   1451          
   1452          /********************************************************************************************************
   1453          ** oˉêy??3?: SMotoFreqRead
   1454          ** 1|?ü?èê?:
   1455          ** ê? ?? è?:
   1456          **
   1457          ** ê???  3?:
   1458          **
   1459          ** è???±?á?:
   1460          ** μ÷ó??￡?é:
   1461          **
   1462          ** ×÷??  ??: John Tonny
   1463          ** è???  ?ú: 2005?ê05??01è?
   1464          **------------------------------------------------------------------------------------------------------
   1465          ** DT ?? è?:
   1466          ** è???  ?ú:
   1467          **------------------------------------------------------------------------------------------------------
   1468          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1469          void SMotoFreqGet(void)
   1470          {
   \                     SMotoFreqGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1471            INT8U ucTmp;
   1472            INT8U i;
   1473            
   1474            for(i=0;i<CARDMACHINE_SMOTO_NUMS;i++){
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
   \                     ??SMotoFreqGet_0: (+1)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xDA2E             BGE.N    ??SMotoFreqGet_1
   1475              if(!EepromReadVerifyBytes(SMOTO_FREQ_ADDR+i*4,(INT8U *)&ucTmp,1)){
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x00A0             LSLS     R0,R4,#+2
   \   00000016   0x1D00             ADDS     R0,R0,#+4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10A             BNE.N    ??SMotoFreqGet_2
   1476                ucTmp=SMOTO_FREQ_DEFAULT;
   \   00000022   0x2046             MOVS     R0,#+70
   \   00000024   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1477                EepromWriteVerifyBytes(SMOTO_FREQ_ADDR+i*4,(INT8U *)&ucTmp,1);
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x00A0             LSLS     R0,R4,#+2
   \   00000030   0x1D00             ADDS     R0,R0,#+4
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       EepromWriteVerifyBytes
   1478              }
   1479              if(ucTmp<SMOTO_FREQ_500US || ucTmp>SMOTO_FREQ_2500US){
   \                     ??SMotoFreqGet_2: (+1)
   \   00000038   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003C   0x2832             CMP      R0,#+50
   \   0000003E   0xDB03             BLT.N    ??SMotoFreqGet_3
   \   00000040   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000044   0x28FB             CMP      R0,#+251
   \   00000046   0xDB0A             BLT.N    ??SMotoFreqGet_4
   1480                ucTmp=SMOTO_FREQ_DEFAULT;
   \                     ??SMotoFreqGet_3: (+1)
   \   00000048   0x2046             MOVS     R0,#+70
   \   0000004A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1481                EepromWriteVerifyBytes(SMOTO_FREQ_ADDR+i*4,&ucTmp,1);
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x00A0             LSLS     R0,R4,#+2
   \   00000056   0x1D00             ADDS     R0,R0,#+4
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       EepromWriteVerifyBytes
   1482              }	
   1483              m_ucSMotoFreq[i]=ucTmp;
   \                     ??SMotoFreqGet_4: (+1)
   \   0000005E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000062   0x....             LDR.N    R1,??DataTable21_24
   \   00000064   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000066   0x5508             STRB     R0,[R1, R4]
   1484            }
   \   00000068   0x1C64             ADDS     R4,R4,#+1
   \   0000006A   0xE7CD             B.N      ??SMotoFreqGet_0
   1485          }
   \                     ??SMotoFreqGet_1: (+1)
   \   0000006C   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1486          
   1487          /********************************************************************************************************
   1488          ** oˉêy??3?: DMotoPwmGet
   1489          ** 1|?ü?èê?:
   1490          ** ê? ?? è?:
   1491          **
   1492          ** ê???  3?:
   1493          **
   1494          ** è???±?á?:
   1495          ** μ÷ó??￡?é:
   1496          **
   1497          ** ×÷??  ??: John Tonny
   1498          ** è???  ?ú: 2005?ê05??01è?
   1499          **------------------------------------------------------------------------------------------------------
   1500          ** DT ?? è?:
   1501          ** è???  ?ú:
   1502          **------------------------------------------------------------------------------------------------------
   1503          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1504          void DMotoPwmGet(void)
   1505          {
   \                     DMotoPwmGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1506            INT16U uiPwm;
   1507            INT8U i;
   1508            
   1509            for(i=0;i<CARDMACHINE_DMOTO_NUMS;i++){
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0004             MOVS     R4,R0
   \                     ??DMotoPwmGet_0: (+1)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C04             CMP      R4,#+4
   \   0000000C   0xDA33             BGE.N    ??DMotoPwmGet_1
   1510              if(!EepromReadVerifyBytes(DMOTO_PWM_ADDR+i*4,(INT8U *)&uiPwm,2)){
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x00A0             LSLS     R0,R4,#+2
   \   00000016   0x3010             ADDS     R0,R0,#+16
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10B             BNE.N    ??DMotoPwmGet_2
   1511                uiPwm=DMOTO_FREQ_DEFAULT;
   \   00000022   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000026   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1512                EepromWriteVerifyBytes(DMOTO_PWM_ADDR+i*4,(INT8U *)&uiPwm,2);
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x00A0             LSLS     R0,R4,#+2
   \   00000032   0x3010             ADDS     R0,R0,#+16
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       EepromWriteVerifyBytes
   1513              }
   1514              if(uiPwm<DMOTO_PWM_700 ||uiPwm>DMOTO_FREQ_DEFAULT){
   \                     ??DMotoPwmGet_2: (+1)
   \   0000003A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000003E   0xF5B0 0x7F2F      CMP      R0,#+700
   \   00000042   0xDB04             BLT.N    ??DMotoPwmGet_3
   \   00000044   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000048   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000004C   0xDD0B             BLE.N    ??DMotoPwmGet_4
   1515                uiPwm=DMOTO_FREQ_DEFAULT;
   \                     ??DMotoPwmGet_3: (+1)
   \   0000004E   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000052   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   1516                EepromWriteVerifyBytes(DMOTO_PWM_ADDR+i*4,(INT8U *)&uiPwm,2);
   \   00000056   0x2202             MOVS     R2,#+2
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x00A0             LSLS     R0,R4,#+2
   \   0000005E   0x3010             ADDS     R0,R0,#+16
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       EepromWriteVerifyBytes
   1517              }
   1518              m_uiDMotoPwm[i]=uiPwm;
   \                     ??DMotoPwmGet_4: (+1)
   \   00000066   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000006A   0x....             LDR.N    R1,??DataTable21_25
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0xF821 0x0014      STRH     R0,[R1, R4, LSL #+1]
   1519            }
   \   00000072   0x1C64             ADDS     R4,R4,#+1
   \   00000074   0xE7C8             B.N      ??DMotoPwmGet_0
   1520          }
   \                     ??DMotoPwmGet_1: (+1)
   \   00000076   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1521          
   1522          /********************************************************************************************************
   1523          ** oˉêy??3?: AutoOutModeGet
   1524          ** 1|?ü?èê?:
   1525          ** ê? ?? è?:
   1526          **
   1527          ** ê???  3?:
   1528          **
   1529          ** è???±?á?:
   1530          ** μ÷ó??￡?é:
   1531          **
   1532          ** ×÷??  ??: John Tonny
   1533          ** è???  ?ú: 2005?ê05??01è?
   1534          **------------------------------------------------------------------------------------------------------
   1535          ** DT ?? è?:
   1536          ** è???  ?ú:
   1537          **------------------------------------------------------------------------------------------------------
   1538          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1539          INT8U AutoOutModeGet(void)
   1540          {
   \                     AutoOutModeGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1541            INT8U ucTmp;
   1542            
   1543            if(!EepromReadVerifyBytes(AUTOOUT_MODE_ADDR,&ucTmp,1)){
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2020             MOVS     R0,#+32
   \   00000008   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD107             BNE.N    ??AutoOutModeGet_0
   1544              ucTmp=0x01;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1545              EepromWriteVerifyBytes(AUTOOUT_MODE_ADDR,&ucTmp,1);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x2020             MOVS     R0,#+32
   \   0000001C   0x.... 0x....      BL       EepromWriteVerifyBytes
   1546            }
   1547            return ucTmp;
   \                     ??AutoOutModeGet_0: (+1)
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   1548          }
   1549          
   1550          /********************************************************************************************************
   1551          ** oˉêy??3?: BuzzEnGet
   1552          ** 1|?ü?èê?:
   1553          ** ê? ?? è?:
   1554          **
   1555          ** ê???  3?:
   1556          **
   1557          ** è???±?á?:
   1558          ** μ÷ó??￡?é:
   1559          **
   1560          ** ×÷??  ??: John Tonny
   1561          ** è???  ?ú: 2005?ê05??01è?
   1562          **------------------------------------------------------------------------------------------------------
   1563          ** DT ?? è?:
   1564          ** è???  ?ú:
   1565          **------------------------------------------------------------------------------------------------------
   1566          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1567          INT8U BuzzEnGet(void)
   1568          {
   \                     BuzzEnGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1569            INT8U ucTmp;
   1570            
   1571            if(!EepromReadVerifyBytes(BUZZ_EN_ADDR,&ucTmp,1)){
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x2024             MOVS     R0,#+36
   \   00000008   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD107             BNE.N    ??BuzzEnGet_0
   1572              ucTmp=0x01;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1573              EepromWriteVerifyBytes(BUZZ_EN_ADDR,&ucTmp,1);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x2024             MOVS     R0,#+36
   \   0000001C   0x.... 0x....      BL       EepromWriteVerifyBytes
   1574            }
   1575            return ucTmp;
   \                     ??BuzzEnGet_0: (+1)
   \   00000020   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000024   0xBD02             POP      {R1,PC}          ;; return
   1576          }
   1577          
   1578          
   1579          
   1580          /********************************************************************************************************
   1581          ** 函数名称: Box_TaskQPost
   1582          ** 功能描述:
   1583          ** 输 　 入:
   1584          **
   1585          ** 输　  出:
   1586          **
   1587          ** 全局变量:
   1588          ** 调用模块:
   1589          **
   1590          ** 作　  者: John Tonny
   1591          ** 日　  期: 2005年05月01日
   1592          **------------------------------------------------------------------------------------------------------
   1593          ** 修 改 人:
   1594          ** 日　  期:
   1595          **------------------------------------------------------------------------------------------------------
   1596          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1597          INT8U Box_TaskQPost(OS_TCB *p_tcb,INT8U *p_ucMsg,INT8U ucLen)
   1598          {
   \                     Box_TaskQPost: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1599            OS_ERR os_err;
   1600            LIB_ERR lib_err;
   1601            CPU_INT08U  *pMsg; 
   1602            
   1603            INT8U ucType=DEV_TYPE();
   \   0000000A   0x.... 0x....      BL       DEV_TYPE
   \   0000000E   0x4680             MOV      R8,R0
   1604            
   1605            pMsg= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_BoxPool,
   1606                                             (CPU_SIZE_T) ucLen,
   1607                                             (LIB_ERR  *)&lib_err);
   \   00000010   0xAA01             ADD      R2,SP,#+4
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x....             LDR.N    R0,??DataTable21_26
   \   00000018   0x.... 0x....      BL       Mem_PoolBlkGet
   \   0000001C   0x0007             MOVS     R7,R0
   1608            if(pMsg!=0){
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD012             BEQ.N    ??Box_TaskQPost_0
   1609              Mem_Copy(pMsg,p_ucMsg,ucLen);
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x.... 0x....      BL       Mem_Copy
   1610              OSTaskQPost(p_tcb, pMsg, ucLen, OS_OPT_POST_FIFO, &os_err);
   \   0000002E   0xF10D 0x0006      ADD      R0,SP,#+6
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x0032             MOVS     R2,R6
   \   0000003A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003C   0x0039             MOVS     R1,R7
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OSTaskQPost
   1611              return TRUE;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE000             B.N      ??Box_TaskQPost_1
   1612            }
   1613            return FALSE;
   \                     ??Box_TaskQPost_0: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??Box_TaskQPost_1: (+1)
   \   0000004A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1614          }
   1615          
   1616          
   1617          /********************************************************************************************************
   1618          ** 函数名称: Box_PostMsg
   1619          ** 功能描述:
   1620          ** 输 　 入:
   1621          **
   1622          ** 输　  出:
   1623          **
   1624          ** 全局变量:
   1625          ** 调用模块:
   1626          **
   1627          ** 作　  者: John Tonny
   1628          ** 日　  期: 2005年05月01日
   1629          **------------------------------------------------------------------------------------------------------
   1630          ** 修 改 人:
   1631          ** 日　  期:
   1632          **------------------------------------------------------------------------------------------------------
   1633          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1634          INT8U Box_TaskLcdQPost(OS_TCB *p_tcb,INT8U *p_ucMsg,INT8U ucLen)
   1635          {
   \                     Box_TaskLcdQPost: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1636            OS_ERR os_err;
   1637            LIB_ERR lib_err;
   1638            CPU_INT08U  *pMsg; 
   1639            
   1640            INT8U ucType=DEV_TYPE();
   \   0000000A   0x.... 0x....      BL       DEV_TYPE
   \   0000000E   0x4680             MOV      R8,R0
   1641            
   1642            if(ucType==SMALL_THICK_IN_TYPE || ucType==SMALL_THICK_OUT_TYPE || ucType==SMALL_THICK_GIN_TYPE || ucType==SMALL_THIN_IN_TYPE || ucType==SMALL_THIN_OUT_TYPE || ucType==SMALL_THIN_GIN_TYPE){
   \   00000010   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000014   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000018   0xD018             BEQ.N    ??Box_TaskLcdQPost_0
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD013             BEQ.N    ??Box_TaskLcdQPost_0
   \   00000024   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000028   0xF1B8 0x0F03      CMP      R8,#+3
   \   0000002C   0xD00E             BEQ.N    ??Box_TaskLcdQPost_0
   \   0000002E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000032   0xF1B8 0x0F09      CMP      R8,#+9
   \   00000036   0xD009             BEQ.N    ??Box_TaskLcdQPost_0
   \   00000038   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003C   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000040   0xD004             BEQ.N    ??Box_TaskLcdQPost_0
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0xF1B8 0x0F0B      CMP      R8,#+11
   \   0000004A   0xD11D             BNE.N    ??Box_TaskLcdQPost_1
   1643              pMsg= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_BoxPool,
   1644                                               (CPU_SIZE_T) ucLen,
   1645                                               (LIB_ERR  *)&lib_err);
   \                     ??Box_TaskLcdQPost_0: (+1)
   \   0000004C   0xAA01             ADD      R2,SP,#+4
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x0031             MOVS     R1,R6
   \   00000052   0x....             LDR.N    R0,??DataTable21_26
   \   00000054   0x.... 0x....      BL       Mem_PoolBlkGet
   \   00000058   0x0007             MOVS     R7,R0
   1646              if(pMsg!=0){
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD012             BEQ.N    ??Box_TaskLcdQPost_2
   1647                Mem_Copy(pMsg,p_ucMsg,ucLen);
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x0032             MOVS     R2,R6
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       Mem_Copy
   1648                OSTaskQPost(p_tcb, pMsg, ucLen, OS_OPT_POST_FIFO, &os_err);
   \   0000006A   0xF10D 0x0006      ADD      R0,SP,#+6
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x0032             MOVS     R2,R6
   \   00000076   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000078   0x0039             MOVS     R1,R7
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       OSTaskQPost
   1649                return TRUE;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0xE002             B.N      ??Box_TaskLcdQPost_3
   1650              }
   1651              return FALSE;
   \                     ??Box_TaskLcdQPost_2: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??Box_TaskLcdQPost_3
   1652            }else{
   1653              return TRUE;
   \                     ??Box_TaskLcdQPost_1: (+1)
   \   00000088   0x2001             MOVS     R0,#+1
   \                     ??Box_TaskLcdQPost_3: (+1)
   \   0000008A   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1654            }
   1655          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x400FC0C4         DC32     0x400fc0c4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40004070         DC32     0x40004070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40004008         DC32     0x40004008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x4000400C         DC32     0x4000400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x40004018         DC32     0x40004018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40004014         DC32     0x40004014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x40008004         DC32     0x40008004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x40018000         DC32     0x40018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x40008070         DC32     0x40008070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x40008008         DC32     0x40008008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x4000800C         DC32     0x4000800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x40008018         DC32     0x40008018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x40008014         DC32     0x40008014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     LPC17xx_TIMER0_IntHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     LPC17xx_TIMER1_IntHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x40090004         DC32     0x40090004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x40090070         DC32     0x40090070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x40090008         DC32     0x40090008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x4009000C         DC32     0x4009000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x40090018         DC32     0x40090018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x40090014         DC32     0x40090014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     LPC17xx_TIMER2_IntHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40094004         DC32     0x40094004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x40094070         DC32     0x40094070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x40094008         DC32     0x40094008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x4009400C         DC32     0x4009400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x40094018         DC32     0x40094018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x40094014         DC32     0x40094014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x........         DC32     LPC17xx_TIMER3_IntHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x40018004         DC32     0x40018004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x40018070         DC32     0x40018070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x40018008         DC32     0x40018008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x4001800C         DC32     0x4001800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x40018018         DC32     0x40018018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x4001801C         DC32     0x4001801c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x40018014         DC32     0x40018014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x........         DC32     LPC17xx_PWM1_IntHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \   00000000   0x........         DC32     m_ucUartBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \   00000000   0x........         DC32     m_usrBoxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \   00000000   0x........         DC32     m_ucDMotoBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_19:
   \   00000000   0x........         DC32     m_ucSMotoBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_20:
   \   00000000   0x........         DC32     m_ucKey_GROUP_SMALL_ZIN_TYPE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_21:
   \   00000000   0x........         DC32     m_ucKeyBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_22:
   \   00000000   0x........         DC32     g_ucScanOpenTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_23:
   \   00000000   0x........         DC32     g_ucScanCloseTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_24:
   \   00000000   0x........         DC32     m_ucSMotoFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_25:
   \   00000000   0x........         DC32     m_uiDMotoPwm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_26:
   \   00000000   0x........         DC32     m_BoxPool
   1656          
   1657          /*******************************************************************************************************
   1658          **                            End Of File
   1659          *******************************************************************************************************/
   1660          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AscToByte
       8   AutoOutModeGet
         8   -> EepromReadVerifyBytes
         8   -> EepromWriteVerifyBytes
      32   BoxSelectGet
        32   -> EepromReadVerifyBytes
        32   -> EepromWriteVerifyBytes
      32   Box_TaskLcdQPost
        32   -> DEV_TYPE
        32   -> Mem_Copy
        32   -> Mem_PoolBlkGet
        32   -> OSTaskQPost
      32   Box_TaskQPost
        32   -> DEV_TYPE
        32   -> Mem_Copy
        32   -> Mem_PoolBlkGet
        32   -> OSTaskQPost
       8   BuzzEnGet
         8   -> EepromReadVerifyBytes
         8   -> EepromWriteVerifyBytes
       0   ByteToAsc
      24   BytesToAscs
        24   -> ByteToAsc
       8   CARD_AUTO_MODE
         8   -> CSP_GPIO_Rd
       8   CardBoxGetSelected
         8   -> CSP_GPIO_Rd
       8   CardBoxGetSelectedA
         8   -> CSP_GPIO_Rd
      24   CardBoxPower
        24   -> CSP_GPIO_BitClr
        24   -> CSP_GPIO_BitSet
        24   -> CardBoxGetSelected
        24   -> DEV_TYPE
      16   CardBoxSetSelected
        16   -> CSP_GPIO_BitClr
        16   -> CSP_GPIO_BitSet
        16   -> CardBoxGetSelected
       8   DEV_TYPE
         8   -> CSP_GPIO_Rd
       0   DMotoByPos
       0   DMotoPosBySelected
      16   DMotoPwmGet
        16   -> EepromReadVerifyBytes
        16   -> EepromWriteVerifyBytes
      40   DMotoSelectGet
        40   -> EepromReadVerifyBytes
        40   -> EepromWriteVerifyBytes
       8   GlobalInit
         8   -> BuzzInit
         8   -> MotoInit
       8   GroupSelectGet
         8   -> EepromReadVerifyBytes
         8   -> EepromWriteVerifyBytes
      80   KeyBitDecode
      80   KeyBitEncode
      64   KeySelectGet
        64   -> DEV_TYPE
        64   -> EepromReadVerifyBytes
        64   -> EepromWriteVerifyBytes
        64   -> GroupSelectGet
        64   -> KeyBitDecode
        64   -> KeyBitEncode
        64   -> Mem_Copy
       8   LPC17xx_PWM1_IntHandler
         8   -> DMotoHook
       8   LPC17xx_TIMER0_IntHandler
         8   -> DMotoSwitchStop
       8   LPC17xx_TIMER1_IntHandler
         8   -> SMotoHook
       8   LPC17xx_TIMER2_IntHandler
         8   -> BSP_LED_Toggle
       8   LPC17xx_TIMER3_IntHandler
         8   -> MotoTime
       8   PWM1Init
         8   -> CSP_IntEn
         8   -> CSP_IntVectReg
         8   -> CSP_PM_PerClkFreqGet
       8   RevCrc16Bytes
      16   SMotoFreqGet
        16   -> EepromReadVerifyBytes
        16   -> EepromWriteVerifyBytes
      24   SMotoSelectGet
        24   -> EepromReadVerifyBytes
        24   -> EepromWriteVerifyBytes
      16   ScanInit
        16   -> CSP_GPIO_BitSet
        16   -> CSP_GPIO_Cfg
       8   ScanParamsGet
         8   -> EepromReadVerifyBytes
         8   -> EepromWriteVerifyBytes
      40   SprintF
        40   -> ByteToAsc
       8   Timer0Init
         8   -> CSP_IntEn
         8   -> CSP_IntVectReg
         8   -> CSP_PM_PerClkFreqGet
       8   Timer1Init
         8   -> CSP_IntEn
         8   -> CSP_IntVectReg
         8   -> CSP_PM_PerClkFreqGet
       8   Timer2Init
         8   -> CSP_IntEn
         8   -> CSP_IntVectReg
         8   -> CSP_PM_PerClkFreqGet
       8   Timer3Init
         8   -> CSP_IntEn
         8   -> CSP_IntVectReg
         8   -> CSP_PM_PerClkFreqGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      48  AscToByte
      38  AutoOutModeGet
     266  BoxSelectGet
     142  Box_TaskLcdQPost
      78  Box_TaskQPost
      38  BuzzEnGet
      42  ByteToAsc
      60  BytesToAscs
      22  CARD_AUTO_MODE
      50  CardBoxGetSelected
      32  CardBoxGetSelectedA
     114  CardBoxPower
     250  CardBoxSetSelected
      18  DEV_TYPE
      42  DMotoByPos
      22  DMotoPosBySelected
     120  DMotoPwmGet
     402  DMotoSelectGet
      12  GlobalInit
      38  GroupSelectGet
     214  KeyBitDecode
     162  KeyBitEncode
     330  KeySelectGet
      68  LPC17xx_PWM1_IntHandler
      26  LPC17xx_TIMER0_IntHandler
      26  LPC17xx_TIMER1_IntHandler
      28  LPC17xx_TIMER2_IntHandler
      26  LPC17xx_TIMER3_IntHandler
     110  PWM1Init
      60  RevCrc16Bytes
     110  SMotoFreqGet
     136  SMotoSelectGet
      36  ScanInit
      56  ScanParamsGet
      96  SprintF
     122  Timer0Init
     114  Timer1Init
     124  Timer2Init
     122  Timer3Init
       1  g_ucBoxCurSelected
       1  g_ucCommTime
       1  g_ucGInState
       1  g_ucGKeyTime
       1  g_ucLedErrMode
       1  g_ucLedMode
       1  g_ucScanCloseTime
       1  g_ucScanOpenTime
      12  g_usrBuzz
      40  g_usrDMoto
      24  g_usrGetKey
      24  g_usrGetKey1
       4  g_usrGlobalFlag
       4  g_usrInterruptFlags
       4  g_usrMotoFlags
      20  g_usrSMoto
       4  g_usrScan
      32  m_strVersion
       1  m_ucBoxAddr
       4  m_ucBoxBit
       1  m_ucBoxCurWorking
       1  m_ucCardBoxTxSeq
       8  m_ucDMotoBit
       1  m_ucDMotoRetrys
      32  m_ucKeyBit
      96  m_ucKey_GROUP_SMALL_ZIN_TYPE
       1  m_ucMachineAddr
       2  m_ucSMotoBit
       2  m_ucSMotoFreq
       4  m_ucUartBit
       8  m_uiDMotoPwm
       4  m_ulKeyOutput
      96  m_usrBoxInfo
       4  m_usrErrorFlags
       4  m_usrGlobalFlag

 
   349 bytes in section .bss
    96 bytes in section .data
 4 016 bytes in section .text
 
 4 016 bytes of CODE memory
   445 bytes of DATA memory

Errors: none
Warnings: none
