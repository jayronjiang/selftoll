###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:04
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Hpi.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Hpi.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\Hpi.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\Hpi.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\Hpi.c
      1          /*******************************************************************************************************
      2          *
      3          *                                 (c) Copyright 2004-2007, John Tonny
      4          *
      5          *                                           All Rights Reserved
      6          *
      7          ********************************************************************************************************
      8          *
      9          *--------------文件信息---------------------------------------------------------------------------------
     10          *文   件   名: Global.C
     11          *创   建   人: John Tonny
     12          *最后修改日期: 2009年11月01日
     13          *描        述:
     14          *
     15          *--------------历史版本信息-----------------------------------------------------------------------------
     16          * 创建人: John Tonny
     17          * 版  本: V1.0
     18          * 日　期: 2009年11月01日
     19          * 描　述: 原始版本
     20          *
     21          *-------------------------------------------------------------------------------------------------------
     22          * 修改人:
     23          * 版  本:
     24          * 日　期:
     25          * 描　述:
     26          *
     27          *--------------当前版本修订-----------------------------------------------------------------------------
     28          * 修改人:
     29          * 日　期:
     30          * 描　述:
     31          *
     32          *-------------------------------------------------------------------------------------------------------
     33          *******************************************************************************************************/
     34          
     35          #define HPI_GLOBALS
     36          #include "includes.h"

   \                                 In section .bss, align 4
   \   __absolute struct <unnamed> m_usrComm1RxData
   \                     m_usrComm1RxData:
   \   00000000                      DS8 64
     37          

   \                                 In section .data, align 4
     38          unsigned char m_ucCompileDate[]=__DATE__;
   \                     m_ucCompileDate:
   \   00000000   0x41 0x70          DC8 "Apr  6 2017"
   \              0x72 0x20    
   \              0x20 0x36    
   \              0x20 0x32    
   \              0x30 0x31    
   \              0x37 0x00    

   \                                 In section .data, align 4
     39          unsigned char m_ucCompileTime[]=__TIME__;
   \                     m_ucCompileTime:
   \   00000000   0x31 0x31          DC8 "11:01:03"
   \              0x3A 0x30    
   \              0x31 0x3A    
   \              0x30 0x33    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     40          unsigned char m_ucVersion[]="V1.00.00";
   \                     m_ucVersion:
   \   00000000   0x56 0x31          DC8 "V1.00.00"
   \              0x2E 0x30    
   \              0x30 0x2E    
   \              0x30 0x30    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     41          
     42          //应答命令:结束符03前一个字节为接收到的命令，表示正确应答命令
     43          
     44          
     45          /********************************************************************************************************
     46          ** 函数名称: Uart0LengthProcess
     47          ** 功能描述:
     48          ** 输 　 入:
     49          **
     50          ** 输　  出:
     51          **
     52          ** 全局变量:
     53          ** 调用模块:
     54          **
     55          ** 作　  者: John Tonny
     56          ** 日　  期: 2005年05月01日
     57          **------------------------------------------------------------------------------------------------------
     58          ** 修 改 人:
     59          ** 日　  期:
     60          **------------------------------------------------------------------------------------------------------
     61          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     62          INT8U Uart0LengthProcess(CardMachineRxData *pcommData,INT8U ucLen)
     63          {
   \                     Uart0LengthProcess: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     64            if(pcommData->ucLen==ucLen){
   \   00000008   0xF894 0x003F      LDRB     R0,[R4, #+63]
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD101             BNE.N    ??Uart0LengthProcess_0
     65              return TRUE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE00A             B.N      ??Uart0LengthProcess_1
     66            }
     67            Uart0Pack(INFTYPE_INCOMPLETE_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \                     ??Uart0LengthProcess_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x78A2             LDRB     R2,[R4, #+2]
   \   00000024   0x7861             LDRB     R1,[R4, #+1]
   \   00000026   0x20C3             MOVS     R0,#+195
   \   00000028   0x.... 0x....      BL       Uart0Pack
     68            return FALSE;	
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??Uart0LengthProcess_1: (+1)
   \   0000002E   0xBD3E             POP      {R1-R5,PC}       ;; return
     69          }
     70          
     71          /********************************************************************************************************
     72          ** 函数名称: SMotoWriteParams
     73          ** 功能描述:
     74          ** 输 　 入:
     75          **
     76          ** 输　  出:
     77          **
     78          ** 全局变量:
     79          ** 调用模块:
     80          **
     81          ** 作　  者: John Tonny
     82          ** 日　  期: 2005年05月01日
     83          **------------------------------------------------------------------------------------------------------
     84          ** 修 改 人:
     85          ** 日　  期:
     86          **------------------------------------------------------------------------------------------------------
     87          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     88          void SMotoWriteParams(CardMachineRxData *pcommData)
     89          {
   \                     SMotoWriteParams: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
     90            INT8U ucData[64];
     91            INT8U ucTmp;
     92            INT8U ucSelected;
     93            
     94            if(Uart0LengthProcess(pcommData,4)){
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD05D             BEQ.N    ??SMotoWriteParams_0
     95              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
     96              if(ucSelected<CARDMACHINE_SMOTO_NUMS){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDA4A             BGE.N    ??SMotoWriteParams_1
     97                pcommData->ucData[4]=0x00;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7220             STRB     R0,[R4, #+8]
     98                ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \   00000022   0x1D60             ADDS     R0,R4,#+5
   \   00000024   0x.... 0x....      BL       atoi
   \   00000028   0xF88D 0x0008      STRB     R0,[SP, #+8]
     99                if(ucTmp<SMOTO_FREQ_600US || ucTmp>SMOTO_FREQ_2500US){
   \   0000002C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000030   0x283C             CMP      R0,#+60
   \   00000032   0xDB03             BLT.N    ??SMotoWriteParams_2
   \   00000034   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000038   0x28FB             CMP      R0,#+251
   \   0000003A   0xDB0A             BLT.N    ??SMotoWriteParams_3
    100                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \                     ??SMotoWriteParams_2: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x2300             MOVS     R3,#+0
   \   00000046   0x78A2             LDRB     R2,[R4, #+2]
   \   00000048   0x7861             LDRB     R1,[R4, #+1]
   \   0000004A   0x20C5             MOVS     R0,#+197
   \   0000004C   0x.... 0x....      BL       Uart0Pack
    101                  return;
   \   00000050   0xE03D             B.N      ??SMotoWriteParams_4
    102                }
    103                if(EepromWriteVerifyBytes(SMOTO_FREQ_ADDR+ucSelected*4,&ucTmp,1)){
   \                     ??SMotoWriteParams_3: (+1)
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0xA902             ADD      R1,SP,#+8
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x00A8             LSLS     R0,R5,#+2
   \   0000005A   0x1D00             ADDS     R0,R0,#+4
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD018             BEQ.N    ??SMotoWriteParams_5
    104                  m_ucSMotoFreq[ucSelected]=ucTmp;
   \   00000066   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable10
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x5548             STRB     R0,[R1, R5]
    105                  Mem_Copy(&ucData[0],pcommData->ucData,4);
   \   00000072   0x2204             MOVS     R2,#+4
   \   00000074   0x1D21             ADDS     R1,R4,#+4
   \   00000076   0xA803             ADD      R0,SP,#+12
   \   00000078   0x.... 0x....      BL       Mem_Copy
    106                  ucData[4]=pcommData->ucCmd;
   \   0000007C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000007E   0xF88D 0x0010      STRB     R0,[SP, #+16]
    107                  Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9001             STR      R0,[SP, #+4]
   \   00000086   0x2005             MOVS     R0,#+5
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0xAB03             ADD      R3,SP,#+12
   \   0000008C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000008E   0x7861             LDRB     R1,[R4, #+1]
   \   00000090   0x78E0             LDRB     R0,[R4, #+3]
   \   00000092   0x.... 0x....      BL       Uart0Pack
   \   00000096   0xE01A             B.N      ??SMotoWriteParams_0
    108                }else{
    109                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??SMotoWriteParams_5: (+1)
   \   00000098   0x2034             MOVS     R0,#+52
   \   0000009A   0xF88D 0x000C      STRB     R0,[SP, #+12]
    110                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x9001             STR      R0,[SP, #+4]
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x9000             STR      R0,[SP, #+0]
   \   000000A6   0xAB03             ADD      R3,SP,#+12
   \   000000A8   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AA   0x7861             LDRB     R1,[R4, #+1]
   \   000000AC   0x205E             MOVS     R0,#+94
   \   000000AE   0x.... 0x....      BL       Uart0Pack
   \   000000B2   0xE00C             B.N      ??SMotoWriteParams_0
    111                }
    112              }else{
    113                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??SMotoWriteParams_1: (+1)
   \   000000B4   0x205C             MOVS     R0,#+92
   \   000000B6   0xF88D 0x000C      STRB     R0,[SP, #+12]
    114                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0xAB03             ADD      R3,SP,#+12
   \   000000C4   0x78A2             LDRB     R2,[R4, #+2]
   \   000000C6   0x7861             LDRB     R1,[R4, #+1]
   \   000000C8   0x205E             MOVS     R0,#+94
   \   000000CA   0x.... 0x....      BL       Uart0Pack
    115              }
    116            }
    117          }
   \                     ??SMotoWriteParams_0: (+1)
   \                     ??SMotoWriteParams_4: (+1)
   \   000000CE   0xB013             ADD      SP,SP,#+76
   \   000000D0   0xBD30             POP      {R4,R5,PC}       ;; return
    118          
    119          /********************************************************************************************************
    120          ** 函数名称: SMotoReadParams
    121          ** 功能描述:
    122          ** 输 　 入:
    123          **
    124          ** 输　  出:
    125          **
    126          ** 全局变量:
    127          ** 调用模块:
    128          **
    129          ** 作　  者: John Tonny
    130          ** 日　  期: 2005年05月01日
    131          **------------------------------------------------------------------------------------------------------
    132          ** 修 改 人:
    133          ** 日　  期:
    134          **------------------------------------------------------------------------------------------------------
    135          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void SMotoReadParams(CardMachineRxData *pcommData)
    137          {
   \                     SMotoReadParams: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    138            INT8U ucData[64];
    139            INT8U ucTmp;
    140            INT8U ucSelected;
    141          
    142            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD052             BEQ.N    ??SMotoReadParams_0
    143              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
    144              if(ucSelected<CARDMACHINE_SMOTO_NUMS){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDA3F             BGE.N    ??SMotoReadParams_1
    145                if(!EepromReadVerifyBytes(SMOTO_FREQ_ADDR+ucSelected*4,&ucTmp,1)){
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xA902             ADD      R1,SP,#+8
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x00A8             LSLS     R0,R5,#+2
   \   00000026   0x1D00             ADDS     R0,R0,#+4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD10A             BNE.N    ??SMotoReadParams_2
    146                  ucTmp=SMOTO_FREQ_DEFAULT;
   \   00000032   0x2046             MOVS     R0,#+70
   \   00000034   0xF88D 0x0008      STRB     R0,[SP, #+8]
    147                  EepromWriteVerifyBytes(SMOTO_FREQ_ADDR+ucSelected*4,&ucTmp,1);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xA902             ADD      R1,SP,#+8
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x00A8             LSLS     R0,R5,#+2
   \   00000040   0x1D00             ADDS     R0,R0,#+4
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       EepromWriteVerifyBytes
    148                }
    149                if(ucTmp<SMOTO_FREQ_600US || ucTmp>SMOTO_FREQ_2500US){
   \                     ??SMotoReadParams_2: (+1)
   \   00000048   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000004C   0x283C             CMP      R0,#+60
   \   0000004E   0xDB03             BLT.N    ??SMotoReadParams_3
   \   00000050   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000054   0x28FB             CMP      R0,#+251
   \   00000056   0xDB0A             BLT.N    ??SMotoReadParams_4
    150                  ucTmp=SMOTO_FREQ_DEFAULT;
   \                     ??SMotoReadParams_3: (+1)
   \   00000058   0x2046             MOVS     R0,#+70
   \   0000005A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    151                  EepromWriteVerifyBytes(SMOTO_FREQ_ADDR+ucSelected*4,&ucTmp,1);
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0xA902             ADD      R1,SP,#+8
   \   00000062   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000064   0x00A8             LSLS     R0,R5,#+2
   \   00000066   0x1D00             ADDS     R0,R0,#+4
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x.... 0x....      BL       EepromWriteVerifyBytes
    152                }
    153                ucData[0]=pcommData->ucData[0];
   \                     ??SMotoReadParams_4: (+1)
   \   0000006E   0x7920             LDRB     R0,[R4, #+4]
   \   00000070   0xF88D 0x000C      STRB     R0,[SP, #+12]
    154                SprintF(&ucData[1],3,ucTmp);
   \   00000074   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000078   0x2103             MOVS     R1,#+3
   \   0000007A   0xF10D 0x000D      ADD      R0,SP,#+13
   \   0000007E   0x.... 0x....      BL       SprintF
    155                ucData[4]=pcommData->ucCmd;
   \   00000082   0x78E0             LDRB     R0,[R4, #+3]
   \   00000084   0xF88D 0x0010      STRB     R0,[SP, #+16]
    156                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x9001             STR      R0,[SP, #+4]
   \   0000008C   0x2005             MOVS     R0,#+5
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xAB03             ADD      R3,SP,#+12
   \   00000092   0x78A2             LDRB     R2,[R4, #+2]
   \   00000094   0x7861             LDRB     R1,[R4, #+1]
   \   00000096   0x78E0             LDRB     R0,[R4, #+3]
   \   00000098   0x.... 0x....      BL       Uart0Pack
   \   0000009C   0xE00C             B.N      ??SMotoReadParams_0
    157              }else{
    158                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??SMotoReadParams_1: (+1)
   \   0000009E   0x205C             MOVS     R0,#+92
   \   000000A0   0xF88D 0x000C      STRB     R0,[SP, #+12]
    159                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0xAB03             ADD      R3,SP,#+12
   \   000000AE   0x78A2             LDRB     R2,[R4, #+2]
   \   000000B0   0x7861             LDRB     R1,[R4, #+1]
   \   000000B2   0x205E             MOVS     R0,#+94
   \   000000B4   0x.... 0x....      BL       Uart0Pack
    160              }
    161            }
    162          }
   \                     ??SMotoReadParams_0: (+1)
   \   000000B8   0xB013             ADD      SP,SP,#+76
   \   000000BA   0xBD30             POP      {R4,R5,PC}       ;; return
    163          
    164          /********************************************************************************************************
    165          ** 函数名称: DMotoWriteParams
    166          ** 功能描述:
    167          ** 输 　 入: 电机1字节+电机速度4字节
    168          **
    169          ** 输　  出:
    170          **
    171          ** 全局变量:
    172          ** 调用模块:
    173          **
    174          ** 作　  者: John Tonny
    175          ** 日　  期: 2005年05月01日
    176          **------------------------------------------------------------------------------------------------------
    177          ** 修 改 人:
    178          ** 日　  期:
    179          **------------------------------------------------------------------------------------------------------
    180          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    181          void DMotoWriteParams(CardMachineRxData *pcommData)
    182          {
   \                     DMotoWriteParams: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    183            INT8U ucData[64];
    184            INT16U uiPwm;
    185            INT8U ucSelected;
    186            
    187            if(Uart0LengthProcess(pcommData,5)){
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD060             BEQ.N    ??DMotoWriteParams_0
    188              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
    189              if(ucSelected<CARDMACHINE_DMOTO_NUMS){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xDA4D             BGE.N    ??DMotoWriteParams_1
    190                pcommData->ucData[5]=0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7260             STRB     R0,[R4, #+9]
    191                uiPwm=atoi((const char *)&pcommData->ucData[1]);
   \   00000022   0x1D60             ADDS     R0,R4,#+5
   \   00000024   0x.... 0x....      BL       atoi
   \   00000028   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    192                if(uiPwm<DMOTO_PWM_700 || uiPwm>DMOTO_FREQ_DEFAULT){
   \   0000002C   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000030   0xF5B0 0x7F2F      CMP      R0,#+700
   \   00000034   0xDB04             BLT.N    ??DMotoWriteParams_2
   \   00000036   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000003A   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000003E   0xDD0A             BLE.N    ??DMotoWriteParams_3
    193                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \                     ??DMotoWriteParams_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004C   0x7861             LDRB     R1,[R4, #+1]
   \   0000004E   0x20C5             MOVS     R0,#+197
   \   00000050   0x.... 0x....      BL       Uart0Pack
    194                  return;
   \   00000054   0xE03E             B.N      ??DMotoWriteParams_4
    195                }
    196                if(EepromWriteVerifyBytes(DMOTO_PWM_ADDR+ucSelected*4,(INT8U *)&uiPwm,2)){
   \                     ??DMotoWriteParams_3: (+1)
   \   00000056   0x2202             MOVS     R2,#+2
   \   00000058   0xA902             ADD      R1,SP,#+8
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x00A8             LSLS     R0,R5,#+2
   \   0000005E   0x3010             ADDS     R0,R0,#+16
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD019             BEQ.N    ??DMotoWriteParams_5
    197                  m_uiDMotoPwm[ucSelected]=uiPwm;
   \   0000006A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0xF821 0x0015      STRH     R0,[R1, R5, LSL #+1]
    198                  Mem_Copy(&ucData[0],pcommData->ucData,5);
   \   00000078   0x2205             MOVS     R2,#+5
   \   0000007A   0x1D21             ADDS     R1,R4,#+4
   \   0000007C   0xA803             ADD      R0,SP,#+12
   \   0000007E   0x.... 0x....      BL       Mem_Copy
    199                  ucData[5]=pcommData->ucCmd;
   \   00000082   0x78E0             LDRB     R0,[R4, #+3]
   \   00000084   0xF88D 0x0011      STRB     R0,[SP, #+17]
    200                  Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,6,0);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x9001             STR      R0,[SP, #+4]
   \   0000008C   0x2006             MOVS     R0,#+6
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xAB03             ADD      R3,SP,#+12
   \   00000092   0x78A2             LDRB     R2,[R4, #+2]
   \   00000094   0x7861             LDRB     R1,[R4, #+1]
   \   00000096   0x78E0             LDRB     R0,[R4, #+3]
   \   00000098   0x.... 0x....      BL       Uart0Pack
   \   0000009C   0xE01A             B.N      ??DMotoWriteParams_0
    201                }else{
    202                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??DMotoWriteParams_5: (+1)
   \   0000009E   0x2034             MOVS     R0,#+52
   \   000000A0   0xF88D 0x000C      STRB     R0,[SP, #+12]
    203                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0xAB03             ADD      R3,SP,#+12
   \   000000AE   0x78A2             LDRB     R2,[R4, #+2]
   \   000000B0   0x7861             LDRB     R1,[R4, #+1]
   \   000000B2   0x205E             MOVS     R0,#+94
   \   000000B4   0x.... 0x....      BL       Uart0Pack
   \   000000B8   0xE00C             B.N      ??DMotoWriteParams_0
    204                }
    205              }else{
    206                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??DMotoWriteParams_1: (+1)
   \   000000BA   0x205C             MOVS     R0,#+92
   \   000000BC   0xF88D 0x000C      STRB     R0,[SP, #+12]
    207                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x9001             STR      R0,[SP, #+4]
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x9000             STR      R0,[SP, #+0]
   \   000000C8   0xAB03             ADD      R3,SP,#+12
   \   000000CA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000CC   0x7861             LDRB     R1,[R4, #+1]
   \   000000CE   0x205E             MOVS     R0,#+94
   \   000000D0   0x.... 0x....      BL       Uart0Pack
    208              }
    209            }
    210          }
   \                     ??DMotoWriteParams_0: (+1)
   \                     ??DMotoWriteParams_4: (+1)
   \   000000D4   0xB013             ADD      SP,SP,#+76
   \   000000D6   0xBD30             POP      {R4,R5,PC}       ;; return
    211          
    212          /********************************************************************************************************
    213          ** 函数名称: DMotoReadParams
    214          ** 功能描述:
    215          ** 输 　 入:
    216          **
    217          ** 输　  出:
    218          **
    219          ** 全局变量:
    220          ** 调用模块:
    221          **
    222          ** 作　  者: John Tonny
    223          ** 日　  期: 2005年05月01日
    224          **------------------------------------------------------------------------------------------------------
    225          ** 修 改 人:
    226          ** 日　  期:
    227          **------------------------------------------------------------------------------------------------------
    228          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          void DMotoReadParams(CardMachineRxData *pcommData)
    230          {
   \                     DMotoReadParams: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    231            INT8U ucData[64];
    232            INT16U uiPwm;
    233            INT8U ucSelected;
    234            
    235            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD045             BEQ.N    ??DMotoReadParams_0
    236              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
    237              if(ucSelected<CARDMACHINE_DMOTO_NUMS){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xDA4C             BGE.N    ??DMotoReadParams_1
    238                if(!EepromReadVerifyBytes(DMOTO_PWM_ADDR+ucSelected*4,(INT8U *)&uiPwm,2)){
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0xA902             ADD      R1,SP,#+8
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x00A8             LSLS     R0,R5,#+2
   \   00000026   0x3010             ADDS     R0,R0,#+16
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD10B             BNE.N    ??DMotoReadParams_2
    239                  uiPwm=DMOTO_FREQ_DEFAULT;
   \   00000032   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000036   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    240                  EepromWriteVerifyBytes(DMOTO_PWM_ADDR+ucSelected*4,(INT8U *)&uiPwm,2);
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0xA902             ADD      R1,SP,#+8
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x00A8             LSLS     R0,R5,#+2
   \   00000042   0x3010             ADDS     R0,R0,#+16
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       EepromWriteVerifyBytes
    241                }
    242                if(uiPwm<DMOTO_PWM_700 || uiPwm>DMOTO_FREQ_DEFAULT){
   \                     ??DMotoReadParams_2: (+1)
   \   0000004A   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000004E   0xF5B0 0x7F2F      CMP      R0,#+700
   \   00000052   0xDB04             BLT.N    ??DMotoReadParams_3
   \   00000054   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000058   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000005C   0xDD0B             BLE.N    ??DMotoReadParams_4
    243                  uiPwm=DMOTO_FREQ_DEFAULT;
   \                     ??DMotoReadParams_3: (+1)
   \   0000005E   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000062   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    244                  EepromWriteVerifyBytes(DMOTO_PWM_ADDR+ucSelected*4,(INT8U *)&uiPwm,2);
   \   00000066   0x2202             MOVS     R2,#+2
   \   00000068   0xA902             ADD      R1,SP,#+8
   \   0000006A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006C   0x00A8             LSLS     R0,R5,#+2
   \   0000006E   0x3010             ADDS     R0,R0,#+16
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       EepromWriteVerifyBytes
    245                }
    246                SprintF(ucData,4,uiPwm);
   \                     ??DMotoReadParams_4: (+1)
   \   00000076   0xF8BD 0x2008      LDRH     R2,[SP, #+8]
   \   0000007A   0x2104             MOVS     R1,#+4
   \   0000007C   0xA803             ADD      R0,SP,#+12
   \   0000007E   0x.... 0x....      BL       SprintF
    247                ucData[4]=pcommData->ucCmd;
   \   00000082   0x78E0             LDRB     R0,[R4, #+3]
   \   00000084   0xF88D 0x0010      STRB     R0,[SP, #+16]
    248                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x9001             STR      R0,[SP, #+4]
   \   0000008C   0x2005             MOVS     R0,#+5
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0xAB03             ADD      R3,SP,#+12
   \   00000092   0x78A2             LDRB     R2,[R4, #+2]
   \   00000094   0x7861             LDRB     R1,[R4, #+1]
   \   00000096   0x78E0             LDRB     R0,[R4, #+3]
   \   00000098   0x.... 0x....      BL       Uart0Pack
   \   0000009C   0xE00C             B.N      ??DMotoReadParams_1
    249              }
    250            }else{
    251              ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??DMotoReadParams_0: (+1)
   \   0000009E   0x205C             MOVS     R0,#+92
   \   000000A0   0xF88D 0x000C      STRB     R0,[SP, #+12]
    252              Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0xAB03             ADD      R3,SP,#+12
   \   000000AE   0x78A2             LDRB     R2,[R4, #+2]
   \   000000B0   0x7861             LDRB     R1,[R4, #+1]
   \   000000B2   0x205E             MOVS     R0,#+94
   \   000000B4   0x.... 0x....      BL       Uart0Pack
    253            }
    254          }
   \                     ??DMotoReadParams_1: (+1)
   \   000000B8   0xB013             ADD      SP,SP,#+76
   \   000000BA   0xBD30             POP      {R4,R5,PC}       ;; return
    255          
    256          /********************************************************************************************************
    257          ** 函数名称: ParamsFlagWrite
    258          ** 功能描述:
    259          ** 输 　 入:
    260          **
    261          ** 输　  出:
    262          **
    263          ** 全局变量:
    264          ** 调用模块:
    265          **
    266          ** 作　  者: John Tonny
    267          ** 日　  期: 2005年05月01日
    268          **------------------------------------------------------------------------------------------------------
    269          ** 修 改 人:
    270          ** 日　  期:
    271          **------------------------------------------------------------------------------------------------------
    272          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          void ParamsFlagWrite(CardMachineRxData *pcommData,INT8U ucAddr)
    274          {
   \                     ParamsFlagWrite: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    275            INT8U ucData[64];
    276            INT8U ucTmp;
    277            
    278            if(Uart0LengthProcess(pcommData,1)){
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Uart0LengthProcess
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD036             BEQ.N    ??ParamsFlagWrite_0
    279              pcommData->ucData[1]=0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7160             STRB     R0,[R4, #+5]
    280              ucTmp=atoi((const char *)pcommData->ucData);
   \   00000018   0x1D20             ADDS     R0,R4,#+4
   \   0000001A   0x.... 0x....      BL       atoi
   \   0000001E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    281              if(ucTmp){
   \   00000022   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??ParamsFlagWrite_1
    282                ucTmp=0x01;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF88D 0x0008      STRB     R0,[SP, #+8]
    283              }
    284              if(EepromWriteVerifyBytes(ucAddr,&ucTmp,1)){
   \                     ??ParamsFlagWrite_1: (+1)
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xA902             ADD      R1,SP,#+8
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD013             BEQ.N    ??ParamsFlagWrite_2
    285                SprintF(ucData,1,ucTmp);
   \   00000040   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xA803             ADD      R0,SP,#+12
   \   00000048   0x.... 0x....      BL       SprintF
    286                ucData[1]=pcommData->ucCmd;
   \   0000004C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004E   0xF88D 0x000D      STRB     R0,[SP, #+13]
    287                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x9001             STR      R0,[SP, #+4]
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0xAB03             ADD      R3,SP,#+12
   \   0000005C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000005E   0x7861             LDRB     R1,[R4, #+1]
   \   00000060   0x78E0             LDRB     R0,[R4, #+3]
   \   00000062   0x.... 0x....      BL       Uart0Pack
   \   00000066   0xE00C             B.N      ??ParamsFlagWrite_0
    288              }else{
    289                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??ParamsFlagWrite_2: (+1)
   \   00000068   0x2034             MOVS     R0,#+52
   \   0000006A   0xF88D 0x000C      STRB     R0,[SP, #+12]
    290                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0xAB03             ADD      R3,SP,#+12
   \   00000078   0x78A2             LDRB     R2,[R4, #+2]
   \   0000007A   0x7861             LDRB     R1,[R4, #+1]
   \   0000007C   0x205E             MOVS     R0,#+94
   \   0000007E   0x.... 0x....      BL       Uart0Pack
    291              }
    292            }
    293          }
   \                     ??ParamsFlagWrite_0: (+1)
   \   00000082   0xB013             ADD      SP,SP,#+76
   \   00000084   0xBD30             POP      {R4,R5,PC}       ;; return
    294          
    295          /********************************************************************************************************
    296          ** 函数名称: ParamsFlagRead
    297          ** 功能描述:
    298          ** 输 　 入:
    299          **
    300          ** 输　  出:
    301          **
    302          ** 全局变量:
    303          ** 调用模块:
    304          **
    305          ** 作　  者: John Tonny
    306          ** 日　  期: 2005年05月01日
    307          **------------------------------------------------------------------------------------------------------
    308          ** 修 改 人:
    309          ** 日　  期:
    310          **------------------------------------------------------------------------------------------------------
    311          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          void ParamsFlagRead(CardMachineRxData *pcommData,INT8U ucAddr)
    313          {
   \                     ParamsFlagRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    314            INT8U ucData[64];
    315            INT8U ucTmp;
    316            
    317            if(Uart0LengthProcess(pcommData,0)){			
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Uart0LengthProcess
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD023             BEQ.N    ??ParamsFlagRead_0
    318              if(!EepromReadVerifyBytes(ucAddr,&ucTmp,1)){
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0xA902             ADD      R1,SP,#+8
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       EepromReadVerifyBytes
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD108             BNE.N    ??ParamsFlagRead_1
    319                ucTmp=0x1;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x0008      STRB     R0,[SP, #+8]
    320                EepromWriteVerifyBytes(ucAddr,&ucTmp,1);
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       EepromWriteVerifyBytes
    321              }
    322              SprintF(ucData,1,ucTmp);
   \                     ??ParamsFlagRead_1: (+1)
   \   00000036   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       SprintF
    323              ucData[1]=pcommData->ucCmd;
   \   00000042   0x78E0             LDRB     R0,[R4, #+3]
   \   00000044   0xF88D 0x000D      STRB     R0,[SP, #+13]
    324              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x9001             STR      R0,[SP, #+4]
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xAB03             ADD      R3,SP,#+12
   \   00000052   0x78A2             LDRB     R2,[R4, #+2]
   \   00000054   0x7861             LDRB     R1,[R4, #+1]
   \   00000056   0x78E0             LDRB     R0,[R4, #+3]
   \   00000058   0x.... 0x....      BL       Uart0Pack
    325            }
    326          }
   \                     ??ParamsFlagRead_0: (+1)
   \   0000005C   0xB013             ADD      SP,SP,#+76
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
    327          
    328          /********************************************************************************************************
    329          ** 函数名称: AutoOutModeWrite
    330          ** 功能描述:
    331          ** 输 　 入:
    332          **
    333          ** 输　  出:
    334          **
    335          ** 全局变量:
    336          ** 调用模块:
    337          **
    338          ** 作　  者: John Tonny
    339          ** 日　  期: 2005年05月01日
    340          **------------------------------------------------------------------------------------------------------
    341          ** 修 改 人:
    342          ** 日　  期:
    343          **------------------------------------------------------------------------------------------------------
    344          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    345          void AutoOutModeWrite(CardMachineRxData *pcommData)
    346          {
   \                     AutoOutModeWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    347            INT8U ucData[64];
    348            INT8U ucTmp;
    349            
    350            if(Uart0LengthProcess(pcommData,1)){
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD030             BEQ.N    ??AutoOutModeWrite_0
    351              ucTmp=0x01;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF88D 0x0008      STRB     R0,[SP, #+8]
    352              if(pcommData->ucData[0]==0x30){
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x2830             CMP      R0,#+48
   \   0000001C   0xD102             BNE.N    ??AutoOutModeWrite_1
    353                ucTmp=0x00;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x0008      STRB     R0,[SP, #+8]
    354              }
    355              if(EepromWriteVerifyBytes(AUTOOUT_MODE_ADDR,&ucTmp,1)){
   \                     ??AutoOutModeWrite_1: (+1)
   \   00000024   0x2201             MOVS     R2,#+1
   \   00000026   0xA902             ADD      R1,SP,#+8
   \   00000028   0x2020             MOVS     R0,#+32
   \   0000002A   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD013             BEQ.N    ??AutoOutModeWrite_2
    356                SprintF(ucData,1,ucTmp);
   \   00000032   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xA803             ADD      R0,SP,#+12
   \   0000003A   0x.... 0x....      BL       SprintF
    357                ucData[1]=pcommData->ucCmd;
   \   0000003E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000040   0xF88D 0x000D      STRB     R0,[SP, #+13]
    358                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xAB03             ADD      R3,SP,#+12
   \   0000004E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000050   0x7861             LDRB     R1,[R4, #+1]
   \   00000052   0x78E0             LDRB     R0,[R4, #+3]
   \   00000054   0x.... 0x....      BL       Uart0Pack
   \   00000058   0xE00C             B.N      ??AutoOutModeWrite_0
    359              }else{
    360                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??AutoOutModeWrite_2: (+1)
   \   0000005A   0x2034             MOVS     R0,#+52
   \   0000005C   0xF88D 0x000C      STRB     R0,[SP, #+12]
    361                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xAB03             ADD      R3,SP,#+12
   \   0000006A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000006C   0x7861             LDRB     R1,[R4, #+1]
   \   0000006E   0x205E             MOVS     R0,#+94
   \   00000070   0x.... 0x....      BL       Uart0Pack
    362              }
    363            }
    364          }
   \                     ??AutoOutModeWrite_0: (+1)
   \   00000074   0xB014             ADD      SP,SP,#+80
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    365          
    366          /********************************************************************************************************
    367          ** 函数名称: AutoOutModeRead
    368          ** 功能描述:
    369          ** 输 　 入:
    370          **
    371          ** 输　  出:
    372          **
    373          ** 全局变量:
    374          ** 调用模块:
    375          **
    376          ** 作　  者: John Tonny
    377          ** 日　  期: 2005年05月01日
    378          **------------------------------------------------------------------------------------------------------
    379          ** 修 改 人:
    380          ** 日　  期:
    381          **------------------------------------------------------------------------------------------------------
    382          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    383          void AutoOutModeRead(CardMachineRxData *pcommData)
    384          {
   \                     AutoOutModeRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    385            INT8U ucData[64];
    386            INT8U ucTmp;
    387            
    388            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD021             BEQ.N    ??AutoOutModeRead_0
    389              if(!EepromReadVerifyBytes(AUTOOUT_MODE_ADDR,&ucTmp,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE.N    ??AutoOutModeRead_1
    390                ucTmp=0x1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
    391                EepromWriteVerifyBytes(AUTOOUT_MODE_ADDR,&ucTmp,1);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0x2020             MOVS     R0,#+32
   \   0000002C   0x.... 0x....      BL       EepromWriteVerifyBytes
    392              }
    393              SprintF(ucData,1,ucTmp);
   \                     ??AutoOutModeRead_1: (+1)
   \   00000030   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xA803             ADD      R0,SP,#+12
   \   00000038   0x.... 0x....      BL       SprintF
    394              ucData[1]=pcommData->ucCmd;
   \   0000003C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003E   0xF88D 0x000D      STRB     R0,[SP, #+13]
    395              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xAB03             ADD      R3,SP,#+12
   \   0000004C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004E   0x7861             LDRB     R1,[R4, #+1]
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0x.... 0x....      BL       Uart0Pack
    396            }
    397          }
   \                     ??AutoOutModeRead_0: (+1)
   \   00000056   0xB014             ADD      SP,SP,#+80
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    398          
    399          /********************************************************************************************************
    400          ** 函数名称: BuzzEnWrite
    401          ** 功能描述:
    402          ** 输 　 入:
    403          **
    404          ** 输　  出:
    405          **
    406          ** 全局变量:
    407          ** 调用模块:
    408          **
    409          ** 作　  者: John Tonny
    410          ** 日　  期: 2005年05月01日
    411          **------------------------------------------------------------------------------------------------------
    412          ** 修 改 人:
    413          ** 日　  期:
    414          **------------------------------------------------------------------------------------------------------
    415          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    416          void BuzzEnWrite(CardMachineRxData *pcommData)
    417          {
   \                     BuzzEnWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    418            INT8U ucData[64];
    419            INT8U ucTmp[2];
    420            
    421            if(Uart0LengthProcess(pcommData,2)){
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD051             BEQ.N    ??BuzzEnWrite_0
    422              m_usrBoxInfo[BOX_FIRST].usrFlag.usrBit.bBuzzEn=1;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000016   0x7B80             LDRB     R0,[R0, #+14]
   \   00000018   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000020   0x7388             STRB     R0,[R1, #+14]
    423              ucTmp[0]=0x01;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0008      STRB     R0,[SP, #+8]
    424              if(pcommData->ucData[0]==0x30){
   \   00000028   0x7920             LDRB     R0,[R4, #+4]
   \   0000002A   0x2830             CMP      R0,#+48
   \   0000002C   0xD10A             BNE.N    ??BuzzEnWrite_1
    425                ucTmp[0]=0x00;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
    426                m_usrBoxInfo[BOX_FIRST].usrFlag.usrBit.bBuzzEn=0;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000038   0x7B80             LDRB     R0,[R0, #+14]
   \   0000003A   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000042   0x7388             STRB     R0,[R1, #+14]
    427              }
    428              ucTmp[1]=pcommData->ucData[1]&0x03;
   \                     ??BuzzEnWrite_1: (+1)
   \   00000044   0x7960             LDRB     R0,[R4, #+5]
   \   00000046   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000004A   0xF88D 0x0009      STRB     R0,[SP, #+9]
    429              m_usrBoxInfo[BOX_FIRST].ucBuzzMode=ucTmp[1];
   \   0000004E   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000056   0x72C8             STRB     R0,[R1, #+11]
    430              if(EepromWriteVerifyBytes(BUZZ_EN_ADDR,ucTmp,2)){
   \   00000058   0x2202             MOVS     R2,#+2
   \   0000005A   0xA902             ADD      R1,SP,#+8
   \   0000005C   0x2024             MOVS     R0,#+36
   \   0000005E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD01A             BEQ.N    ??BuzzEnWrite_2
    431                SprintF(ucData,1,ucTmp[0]);
   \   00000066   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xA803             ADD      R0,SP,#+12
   \   0000006E   0x.... 0x....      BL       SprintF
    432                SprintF(&ucData[1],1,ucTmp[1]);
   \   00000072   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xF10D 0x000D      ADD      R0,SP,#+13
   \   0000007C   0x.... 0x....      BL       SprintF
    433                ucData[2]=pcommData->ucCmd;
   \   00000080   0x78E0             LDRB     R0,[R4, #+3]
   \   00000082   0xF88D 0x000E      STRB     R0,[SP, #+14]
    434                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x2003             MOVS     R0,#+3
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0xAB03             ADD      R3,SP,#+12
   \   00000090   0x78A2             LDRB     R2,[R4, #+2]
   \   00000092   0x7861             LDRB     R1,[R4, #+1]
   \   00000094   0x78E0             LDRB     R0,[R4, #+3]
   \   00000096   0x.... 0x....      BL       Uart0Pack
   \   0000009A   0xE00C             B.N      ??BuzzEnWrite_0
    435              }else{
    436                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??BuzzEnWrite_2: (+1)
   \   0000009C   0x2034             MOVS     R0,#+52
   \   0000009E   0xF88D 0x000C      STRB     R0,[SP, #+12]
    437                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x9001             STR      R0,[SP, #+4]
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0xAB03             ADD      R3,SP,#+12
   \   000000AC   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AE   0x7861             LDRB     R1,[R4, #+1]
   \   000000B0   0x205E             MOVS     R0,#+94
   \   000000B2   0x.... 0x....      BL       Uart0Pack
    438              }
    439            }
    440          }
   \                     ??BuzzEnWrite_0: (+1)
   \   000000B6   0xB014             ADD      SP,SP,#+80
   \   000000B8   0xBD10             POP      {R4,PC}          ;; return
    441          
    442          /********************************************************************************************************
    443          ** 函数名称: BuzzEnRead
    444          ** 功能描述:
    445          ** 输 　 入:
    446          **
    447          ** 输　  出:
    448          **
    449          ** 全局变量:
    450          ** 调用模块:
    451          **
    452          ** 作　  者: John Tonny
    453          ** 日　  期: 2005年05月01日
    454          **------------------------------------------------------------------------------------------------------
    455          ** 修 改 人:
    456          ** 日　  期:
    457          **------------------------------------------------------------------------------------------------------
    458          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    459          void BuzzEnRead(CardMachineRxData *pcommData)
    460          {
   \                     BuzzEnRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    461            INT8U ucData[64];
    462            INT8U ucTmp[2];
    463            
    464            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD02B             BEQ.N    ??BuzzEnRead_0
    465              if(!EepromReadVerifyBytes(BUZZ_EN_ADDR,ucTmp,2)){
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2024             MOVS     R0,#+36
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??BuzzEnRead_1
    466                ucTmp[0]=0x1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
    467                ucTmp[1]=0x0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF88D 0x0009      STRB     R0,[SP, #+9]
    468                EepromWriteVerifyBytes(BUZZ_EN_ADDR,ucTmp,2);
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0xA902             ADD      R1,SP,#+8
   \   00000030   0x2024             MOVS     R0,#+36
   \   00000032   0x.... 0x....      BL       EepromWriteVerifyBytes
    469              }
    470              SprintF(ucData,1,ucTmp[0]);
   \                     ??BuzzEnRead_1: (+1)
   \   00000036   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       SprintF
    471              SprintF(&ucData[1],1,ucTmp[1]);
   \   00000042   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xF10D 0x000D      ADD      R0,SP,#+13
   \   0000004C   0x.... 0x....      BL       SprintF
    472              ucData[2]=pcommData->ucCmd;
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0xF88D 0x000E      STRB     R0,[SP, #+14]
    473              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xAB03             ADD      R3,SP,#+12
   \   00000060   0x78A2             LDRB     R2,[R4, #+2]
   \   00000062   0x7861             LDRB     R1,[R4, #+1]
   \   00000064   0x78E0             LDRB     R0,[R4, #+3]
   \   00000066   0x.... 0x....      BL       Uart0Pack
    474            }
    475          }
   \                     ??BuzzEnRead_0: (+1)
   \   0000006A   0xB014             ADD      SP,SP,#+80
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    476          
    477          /********************************************************************************************************
    478          ** 函数名称: DMotoSelectWrite
    479          ** 功能描述:
    480          ** 输 　 入:
    481          **
    482          ** 输　  出:
    483          **
    484          ** 全局变量:
    485          ** 调用模块:
    486          **
    487          ** 作　  者: John Tonny
    488          ** 日　  期: 2005年05月01日
    489          **------------------------------------------------------------------------------------------------------
    490          ** 修 改 人:
    491          ** 日　  期:
    492          **------------------------------------------------------------------------------------------------------
    493          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    494          void DMotoSelectWrite(CardMachineRxData *pcommData)
    495          {  
   \                     DMotoSelectWrite: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    496            INT8U ucData[64];
    497            INT8U i;
    498            INT8U j;
    499            INT8U ucErr=0;
   \   00000006   0x2500             MOVS     R5,#+0
    500            
    501            if(Uart0LengthProcess(pcommData,7)){
   \   00000008   0x2107             MOVS     R1,#+7
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Uart0LengthProcess
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x80B6      BEQ.W    ??DMotoSelectWrite_0
    502              for(i=0;i<7;i++){
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0007             MOVS     R7,R0
   \                     ??DMotoSelectWrite_1: (+1)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2F07             CMP      R7,#+7
   \   0000001E   0xDA1F             BGE.N    ??DMotoSelectWrite_2
    503                ucData[i]=pcommData->ucData[i]-0x30;
   \   00000020   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000022   0xEB04 0x0007      ADD      R0,R4,R7
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0x3830             SUBS     R0,R0,#+48
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0x55C8             STRB     R0,[R1, R7]
    504                if(i<4 && ucData[i]>=0x34){
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2F04             CMP      R7,#+4
   \   00000034   0xDA07             BGE.N    ??DMotoSelectWrite_3
   \   00000036   0xA802             ADD      R0,SP,#+8
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0x5DC0             LDRB     R0,[R0, R7]
   \   0000003C   0x2834             CMP      R0,#+52
   \   0000003E   0xDB02             BLT.N    ??DMotoSelectWrite_3
    505                  ucErr=1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x0005             MOVS     R5,R0
    506                  break;
   \   00000044   0xE00C             B.N      ??DMotoSelectWrite_2
    507                }
    508                if(i>=4 && ucData[i]>=0x33){
   \                     ??DMotoSelectWrite_3: (+1)
   \   00000046   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000048   0x2F04             CMP      R7,#+4
   \   0000004A   0xDB07             BLT.N    ??DMotoSelectWrite_4
   \   0000004C   0xA802             ADD      R0,SP,#+8
   \   0000004E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000050   0x5DC0             LDRB     R0,[R0, R7]
   \   00000052   0x2833             CMP      R0,#+51
   \   00000054   0xDB02             BLT.N    ??DMotoSelectWrite_4
    509                  ucErr=1;
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x0005             MOVS     R5,R0
    510                  break;
   \   0000005A   0xE001             B.N      ??DMotoSelectWrite_2
    511                }
    512              }
   \                     ??DMotoSelectWrite_4: (+1)
   \   0000005C   0x1C7F             ADDS     R7,R7,#+1
   \   0000005E   0xE7DC             B.N      ??DMotoSelectWrite_1
    513              for(i=0;i<4;i++){
   \                     ??DMotoSelectWrite_2: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0007             MOVS     R7,R0
   \                     ??DMotoSelectWrite_5: (+1)
   \   00000064   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000066   0x2F04             CMP      R7,#+4
   \   00000068   0xDA13             BGE.N    ??DMotoSelectWrite_6
    514                for(j=i+1;j<4;j++){
   \   0000006A   0x1C78             ADDS     R0,R7,#+1
   \   0000006C   0x0006             MOVS     R6,R0
   \                     ??DMotoSelectWrite_7: (+1)
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E04             CMP      R6,#+4
   \   00000072   0xDA0C             BGE.N    ??DMotoSelectWrite_8
    515                  if(ucData[i]==ucData[j]){
   \   00000074   0xA802             ADD      R0,SP,#+8
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x5DC0             LDRB     R0,[R0, R7]
   \   0000007A   0xA902             ADD      R1,SP,#+8
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0x5D89             LDRB     R1,[R1, R6]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD102             BNE.N    ??DMotoSelectWrite_9
    516                    ucErr=1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x0005             MOVS     R5,R0
    517                    break;
   \   00000088   0xE001             B.N      ??DMotoSelectWrite_8
    518                  }
    519                }
   \                     ??DMotoSelectWrite_9: (+1)
   \   0000008A   0x1C76             ADDS     R6,R6,#+1
   \   0000008C   0xE7EF             B.N      ??DMotoSelectWrite_7
    520              }
   \                     ??DMotoSelectWrite_8: (+1)
   \   0000008E   0x1C7F             ADDS     R7,R7,#+1
   \   00000090   0xE7E8             B.N      ??DMotoSelectWrite_5
    521              for(i=4;i<7;i++){
   \                     ??DMotoSelectWrite_6: (+1)
   \   00000092   0x2004             MOVS     R0,#+4
   \   00000094   0x0007             MOVS     R7,R0
   \                     ??DMotoSelectWrite_10: (+1)
   \   00000096   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000098   0x2F07             CMP      R7,#+7
   \   0000009A   0xDA13             BGE.N    ??DMotoSelectWrite_11
    522                for(j=i+1;j<7;j++){
   \   0000009C   0x1C78             ADDS     R0,R7,#+1
   \   0000009E   0x0006             MOVS     R6,R0
   \                     ??DMotoSelectWrite_12: (+1)
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0x2E07             CMP      R6,#+7
   \   000000A4   0xDA0C             BGE.N    ??DMotoSelectWrite_13
    523                  if(ucData[i]==ucData[j]){
   \   000000A6   0xA802             ADD      R0,SP,#+8
   \   000000A8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AA   0x5DC0             LDRB     R0,[R0, R7]
   \   000000AC   0xA902             ADD      R1,SP,#+8
   \   000000AE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B0   0x5D89             LDRB     R1,[R1, R6]
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD102             BNE.N    ??DMotoSelectWrite_14
    524                    ucErr=1;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x0005             MOVS     R5,R0
    525                    break;
   \   000000BA   0xE001             B.N      ??DMotoSelectWrite_13
    526                  }
    527                }
   \                     ??DMotoSelectWrite_14: (+1)
   \   000000BC   0x1C76             ADDS     R6,R6,#+1
   \   000000BE   0xE7EF             B.N      ??DMotoSelectWrite_12
    528              }
   \                     ??DMotoSelectWrite_13: (+1)
   \   000000C0   0x1C7F             ADDS     R7,R7,#+1
   \   000000C2   0xE7E8             B.N      ??DMotoSelectWrite_10
    529              
    530          
    531              if(ucErr){
   \                     ??DMotoSelectWrite_11: (+1)
   \   000000C4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xD00A             BEQ.N    ??DMotoSelectWrite_15
    532                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0x2300             MOVS     R3,#+0
   \   000000D4   0x78A2             LDRB     R2,[R4, #+2]
   \   000000D6   0x7861             LDRB     R1,[R4, #+1]
   \   000000D8   0x20C5             MOVS     R0,#+197
   \   000000DA   0x.... 0x....      BL       Uart0Pack
    533                return;
   \   000000DE   0xE050             B.N      ??DMotoSelectWrite_16
    534              }
    535              ucData[8]=ucData[0] | (ucData[1]<<4);
   \                     ??DMotoSelectWrite_15: (+1)
   \   000000E0   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000E4   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   000000E8   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000EC   0xF88D 0x0010      STRB     R0,[SP, #+16]
    536              ucData[9]=ucData[2] | (ucData[3]<<4);
   \   000000F0   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000F4   0xF89D 0x100B      LDRB     R1,[SP, #+11]
   \   000000F8   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   000000FC   0xF88D 0x0011      STRB     R0,[SP, #+17]
    537              ucData[10]=ucData[4] | (ucData[5]<<4);
   \   00000100   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000104   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \   00000108   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000010C   0xF88D 0x0012      STRB     R0,[SP, #+18]
    538              ucData[11]=ucData[6] ;
   \   00000110   0xF89D 0x000E      LDRB     R0,[SP, #+14]
   \   00000114   0xF88D 0x0013      STRB     R0,[SP, #+19]
    539              if(EepromWriteVerifyBytes(DMOTO_SELECT_ADDR,&ucData[8],4)){
   \   00000118   0x2204             MOVS     R2,#+4
   \   0000011A   0xA904             ADD      R1,SP,#+16
   \   0000011C   0x2048             MOVS     R0,#+72
   \   0000011E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD020             BEQ.N    ??DMotoSelectWrite_17
    540                for(i=0;i<7;i++){
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x0007             MOVS     R7,R0
   \                     ??DMotoSelectWrite_18: (+1)
   \   0000012A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012C   0x2F07             CMP      R7,#+7
   \   0000012E   0xDA08             BGE.N    ??DMotoSelectWrite_19
    541                  m_ucDMotoBit[i]=ucData[i];
   \   00000130   0xA802             ADD      R0,SP,#+8
   \   00000132   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000134   0x5DC0             LDRB     R0,[R0, R7]
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000013A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000013C   0x55C8             STRB     R0,[R1, R7]
    542                }
   \   0000013E   0x1C7F             ADDS     R7,R7,#+1
   \   00000140   0xE7F3             B.N      ??DMotoSelectWrite_18
    543                Mem_Copy(&ucData[0],pcommData->ucData,7);
   \                     ??DMotoSelectWrite_19: (+1)
   \   00000142   0x2207             MOVS     R2,#+7
   \   00000144   0x1D21             ADDS     R1,R4,#+4
   \   00000146   0xA802             ADD      R0,SP,#+8
   \   00000148   0x.... 0x....      BL       Mem_Copy
    544                ucData[7]=pcommData->ucCmd;
   \   0000014C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000014E   0xF88D 0x000F      STRB     R0,[SP, #+15]
    545                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,8,0);
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x9001             STR      R0,[SP, #+4]
   \   00000156   0x2008             MOVS     R0,#+8
   \   00000158   0x9000             STR      R0,[SP, #+0]
   \   0000015A   0xAB02             ADD      R3,SP,#+8
   \   0000015C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000015E   0x7861             LDRB     R1,[R4, #+1]
   \   00000160   0x78E0             LDRB     R0,[R4, #+3]
   \   00000162   0x.... 0x....      BL       Uart0Pack
   \   00000166   0xE00C             B.N      ??DMotoSelectWrite_0
    546              }else{
    547                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??DMotoSelectWrite_17: (+1)
   \   00000168   0x2034             MOVS     R0,#+52
   \   0000016A   0xF88D 0x0008      STRB     R0,[SP, #+8]
    548                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0x9001             STR      R0,[SP, #+4]
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0x9000             STR      R0,[SP, #+0]
   \   00000176   0xAB02             ADD      R3,SP,#+8
   \   00000178   0x78A2             LDRB     R2,[R4, #+2]
   \   0000017A   0x7861             LDRB     R1,[R4, #+1]
   \   0000017C   0x205E             MOVS     R0,#+94
   \   0000017E   0x.... 0x....      BL       Uart0Pack
    549              }
    550            }
    551          }
   \                     ??DMotoSelectWrite_0: (+1)
   \                     ??DMotoSelectWrite_16: (+1)
   \   00000182   0xB013             ADD      SP,SP,#+76
   \   00000184   0xBDF0             POP      {R4-R7,PC}       ;; return
    552          
    553          /********************************************************************************************************
    554          ** 函数名称: DMotoSelectRead
    555          ** 功能描述:
    556          ** 输 　 入:
    557          **
    558          ** 输　  出:
    559          **
    560          ** 全局变量:
    561          ** 调用模块:
    562          **
    563          ** 作　  者: John Tonny
    564          ** 日　  期: 2005年05月01日
    565          **------------------------------------------------------------------------------------------------------
    566          ** 修 改 人:
    567          ** 日　  期:
    568          **------------------------------------------------------------------------------------------------------
    569          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    570          void DMotoSelectRead(CardMachineRxData *pcommData)
    571          {
   \                     DMotoSelectRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    572            INT8U ucData[64];
    573            INT8U i;
    574            
    575            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01E             BEQ.N    ??DMotoSelectRead_0
    576              DMotoSelectGet(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       DMotoSelectGet
    577              for(i=0;i<7;i++){
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
   \                     ??DMotoSelectRead_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D07             CMP      R5,#+7
   \   00000020   0xDA09             BGE.N    ??DMotoSelectRead_2
    578                ucData[i]=m_ucDMotoBit[i]+0x30;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x5D40             LDRB     R0,[R0, R5]
   \   0000002A   0x3030             ADDS     R0,R0,#+48
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x5548             STRB     R0,[R1, R5]
    579              }
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F2             B.N      ??DMotoSelectRead_1
    580              ucData[7]=pcommData->ucCmd;
   \                     ??DMotoSelectRead_2: (+1)
   \   00000036   0x78E0             LDRB     R0,[R4, #+3]
   \   00000038   0xF88D 0x000F      STRB     R0,[SP, #+15]
    581              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,8,0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x2008             MOVS     R0,#+8
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xAB02             ADD      R3,SP,#+8
   \   00000046   0x78A2             LDRB     R2,[R4, #+2]
   \   00000048   0x7861             LDRB     R1,[R4, #+1]
   \   0000004A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004C   0x.... 0x....      BL       Uart0Pack
    582            }
    583          }
   \                     ??DMotoSelectRead_0: (+1)
   \   00000050   0xB013             ADD      SP,SP,#+76
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
    584          
    585          /********************************************************************************************************
    586          ** 函数名称: SMotoSelectWrite
    587          ** 功能描述:
    588          ** 输 　 入:
    589          **
    590          ** 输　  出:
    591          **
    592          ** 全局变量:
    593          ** 调用模块:
    594          **
    595          ** 作　  者: John Tonny
    596          ** 日　  期: 2005年05月01日
    597          **------------------------------------------------------------------------------------------------------
    598          ** 修 改 人:
    599          ** 日　  期:
    600          **------------------------------------------------------------------------------------------------------
    601          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    602          void SMotoSelectWrite(CardMachineRxData *pcommData)
    603          {
   \                     SMotoSelectWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
    604            INT8U ucData[64];
    605            INT8U i;
    606            INT8U ucErr=0;
   \   00000006   0x2600             MOVS     R6,#+0
    607            
    608            if(Uart0LengthProcess(pcommData,2)){
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Uart0LengthProcess
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD05D             BEQ.N    ??SMotoSelectWrite_0
    609              for(i=0;i<2;i++){
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
   \                     ??SMotoSelectWrite_1: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDA11             BGE.N    ??SMotoSelectWrite_2
    610                ucData[i]=pcommData->ucData[i]-0x30;
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000024   0x7900             LDRB     R0,[R0, #+4]
   \   00000026   0x3830             SUBS     R0,R0,#+48
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x5548             STRB     R0,[R1, R5]
    611                if(ucData[i]>=0x33){
   \   0000002E   0xA802             ADD      R0,SP,#+8
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x5D40             LDRB     R0,[R0, R5]
   \   00000034   0x2833             CMP      R0,#+51
   \   00000036   0xDB02             BLT.N    ??SMotoSelectWrite_3
    612                  ucErr=1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x0006             MOVS     R6,R0
    613                  break;
   \   0000003C   0xE001             B.N      ??SMotoSelectWrite_2
    614                }
    615              }
   \                     ??SMotoSelectWrite_3: (+1)
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \   00000040   0xE7EA             B.N      ??SMotoSelectWrite_1
    616              if(ucData[0]==ucData[1]){
   \                     ??SMotoSelectWrite_2: (+1)
   \   00000042   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000046   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD101             BNE.N    ??SMotoSelectWrite_4
    617                ucErr=1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x0006             MOVS     R6,R0
    618              }
    619              
    620              if(ucErr){
   \                     ??SMotoSelectWrite_4: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD00A             BEQ.N    ??SMotoSelectWrite_5
    621                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x2300             MOVS     R3,#+0
   \   00000062   0x78A2             LDRB     R2,[R4, #+2]
   \   00000064   0x7861             LDRB     R1,[R4, #+1]
   \   00000066   0x20C5             MOVS     R0,#+197
   \   00000068   0x.... 0x....      BL       Uart0Pack
    622                return;
   \   0000006C   0xE030             B.N      ??SMotoSelectWrite_6
    623              }
    624              if(EepromWriteVerifyBytes(SMOTO_SELECT_ADDR,ucData,2)){
   \                     ??SMotoSelectWrite_5: (+1)
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0xA902             ADD      R1,SP,#+8
   \   00000072   0x2054             MOVS     R0,#+84
   \   00000074   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD01C             BEQ.N    ??SMotoSelectWrite_7
    625                m_ucSMotoBit[0]=ucData[0];
   \   0000007C   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000084   0x7008             STRB     R0,[R1, #+0]
    626                m_ucSMotoBit[1]=ucData[1];
   \   00000086   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000008E   0x7048             STRB     R0,[R1, #+1]
    627                Mem_Copy(&ucData[0],pcommData->ucData,2);
   \   00000090   0x2202             MOVS     R2,#+2
   \   00000092   0x1D21             ADDS     R1,R4,#+4
   \   00000094   0xA802             ADD      R0,SP,#+8
   \   00000096   0x.... 0x....      BL       Mem_Copy
    628                ucData[2]=pcommData->ucCmd;
   \   0000009A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000009C   0xF88D 0x000A      STRB     R0,[SP, #+10]
    629                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0xAB02             ADD      R3,SP,#+8
   \   000000AA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AC   0x7861             LDRB     R1,[R4, #+1]
   \   000000AE   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B0   0x.... 0x....      BL       Uart0Pack
   \   000000B4   0xE00C             B.N      ??SMotoSelectWrite_0
    630              }else{
    631                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??SMotoSelectWrite_7: (+1)
   \   000000B6   0x2034             MOVS     R0,#+52
   \   000000B8   0xF88D 0x0008      STRB     R0,[SP, #+8]
    632                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x9001             STR      R0,[SP, #+4]
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0xAB02             ADD      R3,SP,#+8
   \   000000C6   0x78A2             LDRB     R2,[R4, #+2]
   \   000000C8   0x7861             LDRB     R1,[R4, #+1]
   \   000000CA   0x205E             MOVS     R0,#+94
   \   000000CC   0x.... 0x....      BL       Uart0Pack
    633              }
    634            }
    635          }
   \                     ??SMotoSelectWrite_0: (+1)
   \                     ??SMotoSelectWrite_6: (+1)
   \   000000D0   0xB012             ADD      SP,SP,#+72
   \   000000D2   0xBD70             POP      {R4-R6,PC}       ;; return
    636          
    637          /********************************************************************************************************
    638          ** 函数名称: SMotoSelectRead
    639          ** 功能描述:
    640          ** 输 　 入:
    641          **
    642          ** 输　  出:
    643          **
    644          ** 全局变量:
    645          ** 调用模块:
    646          **
    647          ** 作　  者: John Tonny
    648          ** 日　  期: 2005年05月01日
    649          **------------------------------------------------------------------------------------------------------
    650          ** 修 改 人:
    651          ** 日　  期:
    652          **------------------------------------------------------------------------------------------------------
    653          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    654          void SMotoSelectRead(CardMachineRxData *pcommData)
    655          {
   \                     SMotoSelectRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
    656            INT8U ucData[64];
    657            
    658            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01B             BEQ.N    ??SMotoSelectRead_0
    659              SMotoSelectGet(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       SMotoSelectGet
    660              ucData[0]=m_ucSMotoBit[0]+0x30;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x3030             ADDS     R0,R0,#+48
   \   00000020   0xF88D 0x0008      STRB     R0,[SP, #+8]
    661              ucData[1]=m_ucSMotoBit[1]+0x30;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000028   0x7840             LDRB     R0,[R0, #+1]
   \   0000002A   0x3030             ADDS     R0,R0,#+48
   \   0000002C   0xF88D 0x0009      STRB     R0,[SP, #+9]
    662              ucData[2]=pcommData->ucCmd;
   \   00000030   0x78E0             LDRB     R0,[R4, #+3]
   \   00000032   0xF88D 0x000A      STRB     R0,[SP, #+10]
    663              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0xAB02             ADD      R3,SP,#+8
   \   00000040   0x78A2             LDRB     R2,[R4, #+2]
   \   00000042   0x7861             LDRB     R1,[R4, #+1]
   \   00000044   0x78E0             LDRB     R0,[R4, #+3]
   \   00000046   0x.... 0x....      BL       Uart0Pack
    664            }
    665          }
   \                     ??SMotoSelectRead_0: (+1)
   \   0000004A   0xB012             ADD      SP,SP,#+72
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    666          
    667          /********************************************************************************************************
    668          ** 函数名称: BoxSelectWrite
    669          ** 功能描述:
    670          ** 输 　 入:
    671          **
    672          ** 输　  出:
    673          **
    674          ** 全局变量:
    675          ** 调用模块:
    676          **
    677          ** 作　  者: John Tonny
    678          ** 日　  期: 2005年05月01日
    679          **------------------------------------------------------------------------------------------------------
    680          ** 修 改 人:
    681          ** 日　  期:
    682          **------------------------------------------------------------------------------------------------------
    683          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    684          void BoxSelectWrite(CardMachineRxData *pcommData)
    685          {
   \                     BoxSelectWrite: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    686            INT8U ucData[64];
    687            INT8U i;
    688            INT8U j;
    689            INT8U ucErr=0;
   \   00000006   0x2700             MOVS     R7,#+0
    690            
    691            if(Uart0LengthProcess(pcommData,3)){
   \   00000008   0x2103             MOVS     R1,#+3
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Uart0LengthProcess
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x8080      BEQ.W    ??BoxSelectWrite_0
    692              for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
   \                     ??BoxSelectWrite_1: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D03             CMP      R5,#+3
   \   0000001E   0xDA11             BGE.N    ??BoxSelectWrite_2
    693                ucData[i]=pcommData->ucData[i]-0x30;
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000026   0x7900             LDRB     R0,[R0, #+4]
   \   00000028   0x3830             SUBS     R0,R0,#+48
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x5548             STRB     R0,[R1, R5]
    694                if(ucData[i]>=(0x30+CARDMACHINE_CARDBOX_NUMS)){
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x5D40             LDRB     R0,[R0, R5]
   \   00000036   0x2833             CMP      R0,#+51
   \   00000038   0xDB02             BLT.N    ??BoxSelectWrite_3
    695                  ucErr=1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0007             MOVS     R7,R0
    696                  break;
   \   0000003E   0xE001             B.N      ??BoxSelectWrite_2
    697                }
    698              }
   \                     ??BoxSelectWrite_3: (+1)
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0xE7EA             B.N      ??BoxSelectWrite_1
    699              for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \                     ??BoxSelectWrite_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
   \                     ??BoxSelectWrite_4: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D03             CMP      R5,#+3
   \   0000004C   0xDA13             BGE.N    ??BoxSelectWrite_5
    700                for(j=i+1;j<CARDMACHINE_CARDBOX_NUMS;j++){
   \   0000004E   0x1C68             ADDS     R0,R5,#+1
   \   00000050   0x0006             MOVS     R6,R0
   \                     ??BoxSelectWrite_6: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E03             CMP      R6,#+3
   \   00000056   0xDA0C             BGE.N    ??BoxSelectWrite_7
    701                  if(ucData[i]==ucData[j]){
   \   00000058   0xA802             ADD      R0,SP,#+8
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0x5D40             LDRB     R0,[R0, R5]
   \   0000005E   0xA902             ADD      R1,SP,#+8
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x5D89             LDRB     R1,[R1, R6]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD102             BNE.N    ??BoxSelectWrite_8
    702                    ucErr=1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x0007             MOVS     R7,R0
    703                    break;
   \   0000006C   0xE001             B.N      ??BoxSelectWrite_7
    704                  }
    705                }
   \                     ??BoxSelectWrite_8: (+1)
   \   0000006E   0x1C76             ADDS     R6,R6,#+1
   \   00000070   0xE7EF             B.N      ??BoxSelectWrite_6
    706              }
   \                     ??BoxSelectWrite_7: (+1)
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
   \   00000074   0xE7E8             B.N      ??BoxSelectWrite_4
    707              
    708              if(ucErr){
   \                     ??BoxSelectWrite_5: (+1)
   \   00000076   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000078   0x2F00             CMP      R7,#+0
   \   0000007A   0xD00A             BEQ.N    ??BoxSelectWrite_9
    709                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9001             STR      R0,[SP, #+4]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9000             STR      R0,[SP, #+0]
   \   00000084   0x2300             MOVS     R3,#+0
   \   00000086   0x78A2             LDRB     R2,[R4, #+2]
   \   00000088   0x7861             LDRB     R1,[R4, #+1]
   \   0000008A   0x20C5             MOVS     R0,#+197
   \   0000008C   0x.... 0x....      BL       Uart0Pack
    710                return;
   \   00000090   0xE041             B.N      ??BoxSelectWrite_10
    711              }
    712              ucData[8]=ucData[0] | (ucData[1]<<4);
   \                     ??BoxSelectWrite_9: (+1)
   \   00000092   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000096   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   0000009A   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \   0000009E   0xF88D 0x0010      STRB     R0,[SP, #+16]
    713              ucData[9]=ucData[2];
   \   000000A2   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000A6   0xF88D 0x0011      STRB     R0,[SP, #+17]
    714              if(EepromWriteVerifyBytes(BOX_SELECT_ADDR,&ucData[8],2)){
   \   000000AA   0x2202             MOVS     R2,#+2
   \   000000AC   0xA904             ADD      R1,SP,#+16
   \   000000AE   0x2058             MOVS     R0,#+88
   \   000000B0   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD021             BEQ.N    ??BoxSelectWrite_11
    715                m_ucUartBit[0]=ucData[0];
   \   000000B8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000C0   0x7008             STRB     R0,[R1, #+0]
    716                m_ucUartBit[1]=ucData[1];      
   \   000000C2   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000CA   0x7048             STRB     R0,[R1, #+1]
    717                m_ucUartBit[2]=ucData[2];
   \   000000CC   0xF89D 0x000A      LDRB     R0,[SP, #+10]
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000D4   0x7088             STRB     R0,[R1, #+2]
    718                Mem_Copy(&ucData[0],pcommData->ucData,3);
   \   000000D6   0x2203             MOVS     R2,#+3
   \   000000D8   0x1D21             ADDS     R1,R4,#+4
   \   000000DA   0xA802             ADD      R0,SP,#+8
   \   000000DC   0x.... 0x....      BL       Mem_Copy
    719                ucData[3]=pcommData->ucCmd;
   \   000000E0   0x78E0             LDRB     R0,[R4, #+3]
   \   000000E2   0xF88D 0x000B      STRB     R0,[SP, #+11]
    720                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,4,0);
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x2004             MOVS     R0,#+4
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0xAB02             ADD      R3,SP,#+8
   \   000000F0   0x78A2             LDRB     R2,[R4, #+2]
   \   000000F2   0x7861             LDRB     R1,[R4, #+1]
   \   000000F4   0x78E0             LDRB     R0,[R4, #+3]
   \   000000F6   0x.... 0x....      BL       Uart0Pack
   \   000000FA   0xE00C             B.N      ??BoxSelectWrite_0
    721              }else{
    722                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??BoxSelectWrite_11: (+1)
   \   000000FC   0x2034             MOVS     R0,#+52
   \   000000FE   0xF88D 0x0008      STRB     R0,[SP, #+8]
    723                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x9001             STR      R0,[SP, #+4]
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0xAB02             ADD      R3,SP,#+8
   \   0000010C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000010E   0x7861             LDRB     R1,[R4, #+1]
   \   00000110   0x205E             MOVS     R0,#+94
   \   00000112   0x.... 0x....      BL       Uart0Pack
    724              }
    725            }
    726          }
   \                     ??BoxSelectWrite_0: (+1)
   \                     ??BoxSelectWrite_10: (+1)
   \   00000116   0xB013             ADD      SP,SP,#+76
   \   00000118   0xBDF0             POP      {R4-R7,PC}       ;; return
    727          
    728          /********************************************************************************************************
    729          ** 函数名称: BoxSelectRead
    730          ** 功能描述:
    731          ** 输 　 入:
    732          **
    733          ** 输　  出:
    734          **
    735          ** 全局变量:
    736          ** 调用模块:
    737          **
    738          ** 作　  者: John Tonny
    739          ** 日　  期: 2005年05月01日
    740          **------------------------------------------------------------------------------------------------------
    741          ** 修 改 人:
    742          ** 日　  期:
    743          **------------------------------------------------------------------------------------------------------
    744          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    745          void BoxSelectRead(CardMachineRxData *pcommData)
    746          {
   \                     BoxSelectRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    747            INT8U ucData[64];
    748            INT8U i;
    749            
    750            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01E             BEQ.N    ??BoxSelectRead_0
    751              BoxSelectGet(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       BoxSelectGet
    752              for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
   \                     ??BoxSelectRead_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D03             CMP      R5,#+3
   \   00000020   0xDA09             BGE.N    ??BoxSelectRead_2
    753                ucData[i]=m_ucUartBit[i]+0x30;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x5D40             LDRB     R0,[R0, R5]
   \   0000002A   0x3030             ADDS     R0,R0,#+48
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x5548             STRB     R0,[R1, R5]
    754              }
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F2             B.N      ??BoxSelectRead_1
    755              ucData[3]=pcommData->ucCmd;
   \                     ??BoxSelectRead_2: (+1)
   \   00000036   0x78E0             LDRB     R0,[R4, #+3]
   \   00000038   0xF88D 0x000B      STRB     R0,[SP, #+11]
    756              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,4,0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xAB02             ADD      R3,SP,#+8
   \   00000046   0x78A2             LDRB     R2,[R4, #+2]
   \   00000048   0x7861             LDRB     R1,[R4, #+1]
   \   0000004A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004C   0x.... 0x....      BL       Uart0Pack
    757            }
    758          }
   \                     ??BoxSelectRead_0: (+1)
   \   00000050   0xB013             ADD      SP,SP,#+76
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
    759          
    760          /********************************************************************************************************
    761          ** 函数名称: KeySelectWrite
    762          ** 功能描述:
    763          ** 输 　 入:
    764          **
    765          ** 输　  出:
    766          **
    767          ** 全局变量:
    768          ** 调用模块:
    769          **
    770          ** 作　  者: John Tonny
    771          ** 日　  期: 2005年05月01日
    772          **------------------------------------------------------------------------------------------------------
    773          ** 修 改 人:
    774          ** 日　  期:
    775          **------------------------------------------------------------------------------------------------------
    776          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    777          void KeySelectWrite(CardMachineRxData *pcommData)
    778          {
   \                     KeySelectWrite: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB092             SUB      SP,SP,#+72
   \   00000006   0x0004             MOVS     R4,R0
    779            INT8U ucData[64];
    780            
    781            INT8U i;
    782            INT8U j;
    783            INT8U ucErr=0;
   \   00000008   0x2700             MOVS     R7,#+0
    784            
    785            CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
    786            
    787            if(Uart0LengthProcess(pcommData,32)){
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       Uart0LengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF000 0x809A      BEQ.W    ??KeySelectWrite_0
    788              for(i=0;i<32;i++){
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0005             MOVS     R5,R0
   \                     ??KeySelectWrite_1: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D20             CMP      R5,#+32
   \   00000024   0xDA11             BGE.N    ??KeySelectWrite_2
    789                ucData[i]=pcommData->ucData[i]-0x30;
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000002C   0x7900             LDRB     R0,[R0, #+4]
   \   0000002E   0x3830             SUBS     R0,R0,#+48
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x5548             STRB     R0,[R1, R5]
    790                if(ucData[i]>=0x31){
   \   00000036   0xA802             ADD      R0,SP,#+8
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x5D40             LDRB     R0,[R0, R5]
   \   0000003C   0x2831             CMP      R0,#+49
   \   0000003E   0xDB02             BLT.N    ??KeySelectWrite_3
    791                  ucErr=1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x0007             MOVS     R7,R0
    792                  break;
   \   00000044   0xE001             B.N      ??KeySelectWrite_2
    793                }
    794              }
   \                     ??KeySelectWrite_3: (+1)
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \   00000048   0xE7EA             B.N      ??KeySelectWrite_1
    795              for(i=0;i<32;i++){
   \                     ??KeySelectWrite_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0005             MOVS     R5,R0
   \                     ??KeySelectWrite_4: (+1)
   \   0000004E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000050   0x2D20             CMP      R5,#+32
   \   00000052   0xDA13             BGE.N    ??KeySelectWrite_5
    796                for(j=i+1;j<32;j++){
   \   00000054   0x1C68             ADDS     R0,R5,#+1
   \   00000056   0x0006             MOVS     R6,R0
   \                     ??KeySelectWrite_6: (+1)
   \   00000058   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005A   0x2E20             CMP      R6,#+32
   \   0000005C   0xDA0C             BGE.N    ??KeySelectWrite_7
    797                  if(ucData[i]==ucData[j]){
   \   0000005E   0xA802             ADD      R0,SP,#+8
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x5D40             LDRB     R0,[R0, R5]
   \   00000064   0xA902             ADD      R1,SP,#+8
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x5D89             LDRB     R1,[R1, R6]
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xD102             BNE.N    ??KeySelectWrite_8
    798                    ucErr=1;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x0007             MOVS     R7,R0
    799                    break;
   \   00000072   0xE001             B.N      ??KeySelectWrite_7
    800                  }
    801                }
   \                     ??KeySelectWrite_8: (+1)
   \   00000074   0x1C76             ADDS     R6,R6,#+1
   \   00000076   0xE7EF             B.N      ??KeySelectWrite_6
    802              }
   \                     ??KeySelectWrite_7: (+1)
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
   \   0000007A   0xE7E8             B.N      ??KeySelectWrite_4
    803          
    804              if(ucErr){
   \                     ??KeySelectWrite_5: (+1)
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0x2F00             CMP      R7,#+0
   \   00000080   0xD00A             BEQ.N    ??KeySelectWrite_9
    805                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,0,0,0);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x9001             STR      R0,[SP, #+4]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9000             STR      R0,[SP, #+0]
   \   0000008A   0x2300             MOVS     R3,#+0
   \   0000008C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000008E   0x7861             LDRB     R1,[R4, #+1]
   \   00000090   0x20C5             MOVS     R0,#+197
   \   00000092   0x.... 0x....      BL       Uart0Pack
    806                return;
   \   00000096   0xE05B             B.N      ??KeySelectWrite_10
    807              }
    808              ucErr=0;
   \                     ??KeySelectWrite_9: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x0007             MOVS     R7,R0
    809              KeyBitEncode(ucData);
   \   0000009C   0xA802             ADD      R0,SP,#+8
   \   0000009E   0x.... 0x....      BL       KeyBitEncode
    810              for(i=0;i<4;i++){
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x0005             MOVS     R5,R0
   \                     ??KeySelectWrite_11: (+1)
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D04             CMP      R5,#+4
   \   000000AA   0xDA13             BGE.N    ??KeySelectWrite_12
    811                if(!EepromWriteVerifyBytes(KEY0_SELECT_ADDR+i*8,&ucData[i*6],6)){
   \   000000AC   0x2206             MOVS     R2,#+6
   \   000000AE   0xA802             ADD      R0,SP,#+8
   \   000000B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B2   0x2106             MOVS     R1,#+6
   \   000000B4   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000B8   0x4401             ADD      R1,R0,R1
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0x00E8             LSLS     R0,R5,#+3
   \   000000BE   0x3060             ADDS     R0,R0,#+96
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD102             BNE.N    ??KeySelectWrite_13
    812                  ucErr=1;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x0007             MOVS     R7,R0
    813                  break;
   \   000000CE   0xE001             B.N      ??KeySelectWrite_12
    814                }
    815              }
   \                     ??KeySelectWrite_13: (+1)
   \   000000D0   0x1C6D             ADDS     R5,R5,#+1
   \   000000D2   0xE7E8             B.N      ??KeySelectWrite_11
    816              if(!ucErr){
   \                     ??KeySelectWrite_12: (+1)
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0x2F00             CMP      R7,#+0
   \   000000D8   0xD12D             BNE.N    ??KeySelectWrite_14
    817                KeyBitDecode(ucData);
   \   000000DA   0xA802             ADD      R0,SP,#+8
   \   000000DC   0x.... 0x....      BL       KeyBitDecode
    818                OS_ENTER_CRITICAL();
   \   000000E0   0x.... 0x....      BL       CPU_SR_Save
   \   000000E4   0x4680             MOV      R8,R0
   \   000000E6   0x.... 0x....      BL       CPU_IntDisMeasStart
    819                for(j=0;j<32;j++){
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x0006             MOVS     R6,R0
   \                     ??KeySelectWrite_15: (+1)
   \   000000EE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F0   0x2E20             CMP      R6,#+32
   \   000000F2   0xDA08             BGE.N    ??KeySelectWrite_16
    820                        m_ucKeyBit[j]=ucData[j];
   \   000000F4   0xA802             ADD      R0,SP,#+8
   \   000000F6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F8   0x5D80             LDRB     R0,[R0, R6]
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   000000FE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000100   0x5588             STRB     R0,[R1, R6]
    821                }
   \   00000102   0x1C76             ADDS     R6,R6,#+1
   \   00000104   0xE7F3             B.N      ??KeySelectWrite_15
    822                OS_EXIT_CRITICAL();
   \                     ??KeySelectWrite_16: (+1)
   \   00000106   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000010A   0x4640             MOV      R0,R8
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    823                Mem_Copy(&ucData[0],pcommData->ucData,32);
   \   00000110   0x2220             MOVS     R2,#+32
   \   00000112   0x1D21             ADDS     R1,R4,#+4
   \   00000114   0xA802             ADD      R0,SP,#+8
   \   00000116   0x.... 0x....      BL       Mem_Copy
    824                ucData[32]=pcommData->ucCmd;
   \   0000011A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000011C   0xF88D 0x0028      STRB     R0,[SP, #+40]
    825                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,33,0);
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x9001             STR      R0,[SP, #+4]
   \   00000124   0x2021             MOVS     R0,#+33
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0xAB02             ADD      R3,SP,#+8
   \   0000012A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000012C   0x7861             LDRB     R1,[R4, #+1]
   \   0000012E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000130   0x.... 0x....      BL       Uart0Pack
   \   00000134   0xE00C             B.N      ??KeySelectWrite_0
    826              }else{
    827                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??KeySelectWrite_14: (+1)
   \   00000136   0x2034             MOVS     R0,#+52
   \   00000138   0xF88D 0x0008      STRB     R0,[SP, #+8]
    828                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x9001             STR      R0,[SP, #+4]
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x9000             STR      R0,[SP, #+0]
   \   00000144   0xAB02             ADD      R3,SP,#+8
   \   00000146   0x78A2             LDRB     R2,[R4, #+2]
   \   00000148   0x7861             LDRB     R1,[R4, #+1]
   \   0000014A   0x205E             MOVS     R0,#+94
   \   0000014C   0x.... 0x....      BL       Uart0Pack
    829              }
    830            }
    831          }
   \                     ??KeySelectWrite_0: (+1)
   \                     ??KeySelectWrite_10: (+1)
   \   00000150   0xB012             ADD      SP,SP,#+72
   \   00000152   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    832          
    833          /********************************************************************************************************
    834          ** 函数名称: KeySelectRead
    835          ** 功能描述:
    836          ** 输 　 入:
    837          **
    838          ** 输　  出:
    839          **
    840          ** 全局变量:
    841          ** 调用模块:
    842          **
    843          ** 作　  者: John Tonny
    844          ** 日　  期: 2005年05月01日
    845          **------------------------------------------------------------------------------------------------------
    846          ** 修 改 人:
    847          ** 日　  期:
    848          **------------------------------------------------------------------------------------------------------
    849          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    850          void KeySelectRead(CardMachineRxData *pcommData)
    851          {
   \                     KeySelectRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
    852            INT8U ucData[64];
    853            INT8U i;
    854            
    855            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01E             BEQ.N    ??KeySelectRead_0
    856              KeySelectGet(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       KeySelectGet
    857              for(i=0;i<32;i++){
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
   \                     ??KeySelectRead_1: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D20             CMP      R5,#+32
   \   00000020   0xDA09             BGE.N    ??KeySelectRead_2
    858                ucData[i]=m_ucKeyBit[i]+0x30;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x5D40             LDRB     R0,[R0, R5]
   \   0000002A   0x3030             ADDS     R0,R0,#+48
   \   0000002C   0xA902             ADD      R1,SP,#+8
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x5548             STRB     R0,[R1, R5]
    859              }
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
   \   00000034   0xE7F2             B.N      ??KeySelectRead_1
    860              ucData[32]=pcommData->ucCmd;
   \                     ??KeySelectRead_2: (+1)
   \   00000036   0x78E0             LDRB     R0,[R4, #+3]
   \   00000038   0xF88D 0x0028      STRB     R0,[SP, #+40]
    861              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,33,0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x2021             MOVS     R0,#+33
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xAB02             ADD      R3,SP,#+8
   \   00000046   0x78A2             LDRB     R2,[R4, #+2]
   \   00000048   0x7861             LDRB     R1,[R4, #+1]
   \   0000004A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004C   0x.... 0x....      BL       Uart0Pack
    862            }
    863          }
   \                     ??KeySelectRead_0: (+1)
   \   00000050   0xB013             ADD      SP,SP,#+76
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
    864          
    865          /********************************************************************************************************
    866          ** 函数名称: UltraSoundWrite
    867          ** 功能描述:
    868          ** 输 　 入:
    869          **
    870          ** 输　  出:
    871          **
    872          ** 全局变量:
    873          ** 调用模块:
    874          **
    875          ** 作　  者: John Tonny
    876          ** 日　  期: 2005年05月01日
    877          **------------------------------------------------------------------------------------------------------
    878          ** 修 改 人:
    879          ** 日　  期:
    880          **------------------------------------------------------------------------------------------------------
    881          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    882          void UltraSoundWrite(CardMachineRxData *pcommData)
    883          {
   \                     UltraSoundWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    884            INT8U ucData[64];
    885            INT8U ucTmp[2];
    886            
    887            if(Uart0LengthProcess(pcommData,6)){
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD042             BEQ.N    ??UltraSoundWrite_0
    888              ucData[0]=pcommData->ucData[3];
   \   00000012   0x79E0             LDRB     R0,[R4, #+7]
   \   00000014   0xF88D 0x000C      STRB     R0,[SP, #+12]
    889              pcommData->ucData[3]=0x00;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x71E0             STRB     R0,[R4, #+7]
    890              ucTmp[0]=atoi((const char *)&pcommData->ucData[0]);
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   \   0000001E   0x.... 0x....      BL       atoi
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
    891              pcommData->ucData[3]=ucData[0];
   \   00000026   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000002A   0x71E0             STRB     R0,[R4, #+7]
    892              pcommData->ucData[6]=0x00;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x72A0             STRB     R0,[R4, #+10]
    893              ucTmp[1]=atoi((const char *)&pcommData->ucData[3]);
   \   00000030   0x1DE0             ADDS     R0,R4,#+7
   \   00000032   0x.... 0x....      BL       atoi
   \   00000036   0xF88D 0x0009      STRB     R0,[SP, #+9]
    894              if(EepromWriteVerifyBytes(ULTRASOUND_PARAMS_ADDR,ucTmp,2)){
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0xA902             ADD      R1,SP,#+8
   \   0000003E   0x2044             MOVS     R0,#+68
   \   00000040   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD01A             BEQ.N    ??UltraSoundWrite_1
    895                SprintF(ucData,3,ucTmp[0]);
   \   00000048   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000004C   0x2103             MOVS     R1,#+3
   \   0000004E   0xA803             ADD      R0,SP,#+12
   \   00000050   0x.... 0x....      BL       SprintF
    896                SprintF(&ucData[3],3,ucTmp[1]);
   \   00000054   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000058   0x2103             MOVS     R1,#+3
   \   0000005A   0xF10D 0x000F      ADD      R0,SP,#+15
   \   0000005E   0x.... 0x....      BL       SprintF
    897                ucData[6]=pcommData->ucCmd;
   \   00000062   0x78E0             LDRB     R0,[R4, #+3]
   \   00000064   0xF88D 0x0012      STRB     R0,[SP, #+18]
    898                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,7,0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xAB03             ADD      R3,SP,#+12
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x78E0             LDRB     R0,[R4, #+3]
   \   00000078   0x.... 0x....      BL       Uart0Pack
   \   0000007C   0xE00C             B.N      ??UltraSoundWrite_0
    899              }else{
    900                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??UltraSoundWrite_1: (+1)
   \   0000007E   0x2034             MOVS     R0,#+52
   \   00000080   0xF88D 0x000C      STRB     R0,[SP, #+12]
    901                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9001             STR      R0,[SP, #+4]
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0xAB03             ADD      R3,SP,#+12
   \   0000008E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000090   0x7861             LDRB     R1,[R4, #+1]
   \   00000092   0x205E             MOVS     R0,#+94
   \   00000094   0x.... 0x....      BL       Uart0Pack
    902              }
    903            }
    904          }
   \                     ??UltraSoundWrite_0: (+1)
   \   00000098   0xB014             ADD      SP,SP,#+80
   \   0000009A   0xBD10             POP      {R4,PC}          ;; return
    905          
    906          /********************************************************************************************************
    907          ** 函数名称: UltraSoundRead
    908          ** 功能描述:
    909          ** 输 　 入:
    910          **
    911          ** 输　  出:
    912          **
    913          ** 全局变量:
    914          ** 调用模块:
    915          **
    916          ** 作　  者: John Tonny
    917          ** 日　  期: 2005年05月01日
    918          **------------------------------------------------------------------------------------------------------
    919          ** 修 改 人:
    920          ** 日　  期:
    921          **------------------------------------------------------------------------------------------------------
    922          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    923          void UltraSoundRead(CardMachineRxData *pcommData)
    924          {
   \                     UltraSoundRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    925            INT8U ucData[64];
    926            INT8U ucTmp[2];
    927            
    928            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD02B             BEQ.N    ??UltraSoundRead_0
    929              if(!EepromReadVerifyBytes(ULTRASOUND_PARAMS_ADDR,ucTmp,2)){
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2044             MOVS     R0,#+68
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??UltraSoundRead_1
    930                ucTmp[0]=ULTRASOUND_DISTANCE_DEFAULT;
   \   00000020   0x2096             MOVS     R0,#+150
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
    931                ucTmp[1]=ULTRASOUND_TIMES_DEFAULT;
   \   00000026   0x200A             MOVS     R0,#+10
   \   00000028   0xF88D 0x0009      STRB     R0,[SP, #+9]
    932                EepromWriteVerifyBytes(ULTRASOUND_PARAMS_ADDR,ucTmp,2);
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0xA902             ADD      R1,SP,#+8
   \   00000030   0x2044             MOVS     R0,#+68
   \   00000032   0x.... 0x....      BL       EepromWriteVerifyBytes
    933              }
    934              SprintF(&ucData[0],3,ucTmp[0]);
   \                     ??UltraSoundRead_1: (+1)
   \   00000036   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       SprintF
    935              SprintF(&ucData[3],3,ucTmp[1]);
   \   00000042   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0xF10D 0x000F      ADD      R0,SP,#+15
   \   0000004C   0x.... 0x....      BL       SprintF
    936              ucData[6]=pcommData->ucCmd;
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0xF88D 0x0012      STRB     R0,[SP, #+18]
    937              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,7,0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x2007             MOVS     R0,#+7
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xAB03             ADD      R3,SP,#+12
   \   00000060   0x78A2             LDRB     R2,[R4, #+2]
   \   00000062   0x7861             LDRB     R1,[R4, #+1]
   \   00000064   0x78E0             LDRB     R0,[R4, #+3]
   \   00000066   0x.... 0x....      BL       Uart0Pack
    938            }
    939          }
   \                     ??UltraSoundRead_0: (+1)
   \   0000006A   0xB014             ADD      SP,SP,#+80
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    940          
    941          /********************************************************************************************************
    942          ** 函数名称: GroupSelectWrite
    943          ** 功能描述:
    944          ** 输 　 入:
    945          **
    946          ** 输　  出:
    947          **
    948          ** 全局变量:
    949          ** 调用模块:
    950          **
    951          ** 作　  者: John Tonny
    952          ** 日　  期: 2005年05月01日
    953          **------------------------------------------------------------------------------------------------------
    954          ** 修 改 人:
    955          ** 日　  期:
    956          **------------------------------------------------------------------------------------------------------
    957          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    958          void GroupSelectWrite(CardMachineRxData *pcommData)
    959          {
   \                     GroupSelectWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
    960            INT8U ucData[64];
    961            INT8U ucTmp;
    962            
    963            if(Uart0LengthProcess(pcommData,1)){
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD03D             BEQ.N    ??GroupSelectWrite_0
    964              ucTmp=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0xF88D 0x0008      STRB     R0,[SP, #+8]
    965              if(ucTmp<=2){
   \   0000001A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xDA28             BGE.N    ??GroupSelectWrite_1
    966                if(EepromWriteVerifyBytes(GROUP_SELECT_ADDR,&ucTmp,1)){
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xA902             ADD      R1,SP,#+8
   \   00000026   0x200C             MOVS     R0,#+12
   \   00000028   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD013             BEQ.N    ??GroupSelectWrite_2
    967                  SprintF(ucData,1,ucTmp);
   \   00000030   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xA803             ADD      R0,SP,#+12
   \   00000038   0x.... 0x....      BL       SprintF
    968                  ucData[1]=pcommData->ucCmd;
   \   0000003C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003E   0xF88D 0x000D      STRB     R0,[SP, #+13]
    969                  Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xAB03             ADD      R3,SP,#+12
   \   0000004C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004E   0x7861             LDRB     R1,[R4, #+1]
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0x.... 0x....      BL       Uart0Pack
   \   00000056   0xE01A             B.N      ??GroupSelectWrite_0
    970                }else{
    971                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??GroupSelectWrite_2: (+1)
   \   00000058   0x2034             MOVS     R0,#+52
   \   0000005A   0xF88D 0x000C      STRB     R0,[SP, #+12]
    972                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0xAB03             ADD      R3,SP,#+12
   \   00000068   0x78A2             LDRB     R2,[R4, #+2]
   \   0000006A   0x7861             LDRB     R1,[R4, #+1]
   \   0000006C   0x205E             MOVS     R0,#+94
   \   0000006E   0x.... 0x....      BL       Uart0Pack
   \   00000072   0xE00C             B.N      ??GroupSelectWrite_0
    973                }
    974              }else{
    975                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??GroupSelectWrite_1: (+1)
   \   00000074   0x205C             MOVS     R0,#+92
   \   00000076   0xF88D 0x000C      STRB     R0,[SP, #+12]
    976                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9001             STR      R0,[SP, #+4]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xAB03             ADD      R3,SP,#+12
   \   00000084   0x78A2             LDRB     R2,[R4, #+2]
   \   00000086   0x7861             LDRB     R1,[R4, #+1]
   \   00000088   0x205E             MOVS     R0,#+94
   \   0000008A   0x.... 0x....      BL       Uart0Pack
    977              }
    978            }
    979          }
   \                     ??GroupSelectWrite_0: (+1)
   \   0000008E   0xB014             ADD      SP,SP,#+80
   \   00000090   0xBD10             POP      {R4,PC}          ;; return
    980          
    981          /********************************************************************************************************
    982          ** 函数名称: GroupSelectRead
    983          ** 功能描述:
    984          ** 输 　 入:
    985          **
    986          ** 输　  出:
    987          **
    988          ** 全局变量:
    989          ** 调用模块:
    990          **
    991          ** 作　  者: John Tonny
    992          ** 日　  期: 2005年05月01日
    993          **------------------------------------------------------------------------------------------------------
    994          ** 修 改 人:
    995          ** 日　  期:
    996          **------------------------------------------------------------------------------------------------------
    997          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    998          void GroupSelectRead(CardMachineRxData *pcommData)
    999          {
   \                     GroupSelectRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1000            INT8U ucData[64];
   1001            INT8U ucTmp;
   1002            
   1003            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD021             BEQ.N    ??GroupSelectRead_0
   1004              if(!EepromReadVerifyBytes(GROUP_SELECT_ADDR,&ucTmp,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x200C             MOVS     R0,#+12
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE.N    ??GroupSelectRead_1
   1005                ucTmp=0x00;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1006                EepromWriteVerifyBytes(GROUP_SELECT_ADDR,&ucTmp,1);
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0x200C             MOVS     R0,#+12
   \   0000002C   0x.... 0x....      BL       EepromWriteVerifyBytes
   1007              }
   1008              SprintF(ucData,1,ucTmp);
   \                     ??GroupSelectRead_1: (+1)
   \   00000030   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xA803             ADD      R0,SP,#+12
   \   00000038   0x.... 0x....      BL       SprintF
   1009              ucData[1]=pcommData->ucCmd;
   \   0000003C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003E   0xF88D 0x000D      STRB     R0,[SP, #+13]
   1010              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xAB03             ADD      R3,SP,#+12
   \   0000004C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004E   0x7861             LDRB     R1,[R4, #+1]
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0x.... 0x....      BL       Uart0Pack
   1011            }
   1012          }
   \                     ??GroupSelectRead_0: (+1)
   \   00000056   0xB014             ADD      SP,SP,#+80
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
   1013          
   1014          /********************************************************************************************************
   1015          ** 函数名称: ScanParamsWrite
   1016          ** 功能描述:
   1017          ** 输 　 入:
   1018          **
   1019          ** 输　  出:
   1020          **
   1021          ** 全局变量:
   1022          ** 调用模块:
   1023          **
   1024          ** 作　  者: John Tonny
   1025          ** 日　  期: 2005年05月01日
   1026          **------------------------------------------------------------------------------------------------------
   1027          ** 修 改 人:
   1028          ** 日　  期:
   1029          **------------------------------------------------------------------------------------------------------
   1030          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1031          void ScanParamsWrite(CardMachineRxData *pcommData)
   1032          {
   \                     ScanParamsWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1033            INT8U ucData[64];
   1034            INT8U ucTmp[2];
   1035            
   1036            if(Uart0LengthProcess(pcommData,6)){
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD042             BEQ.N    ??ScanParamsWrite_0
   1037              ucData[0]=pcommData->ucData[3];
   \   00000012   0x79E0             LDRB     R0,[R4, #+7]
   \   00000014   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1038              pcommData->ucData[3]=0x00;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x71E0             STRB     R0,[R4, #+7]
   1039              ucTmp[0]=atoi((const char *)&pcommData->ucData[0]);
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   \   0000001E   0x.... 0x....      BL       atoi
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1040              pcommData->ucData[3]=ucData[0];
   \   00000026   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000002A   0x71E0             STRB     R0,[R4, #+7]
   1041              pcommData->ucData[6]=0x00;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x72A0             STRB     R0,[R4, #+10]
   1042              ucTmp[1]=atoi((const char *)&pcommData->ucData[3]);
   \   00000030   0x1DE0             ADDS     R0,R4,#+7
   \   00000032   0x.... 0x....      BL       atoi
   \   00000036   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1043              if(EepromWriteVerifyBytes(SCAN_PARAMS_ADDR,ucTmp,2)){
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0xA902             ADD      R1,SP,#+8
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD01A             BEQ.N    ??ScanParamsWrite_1
   1044                SprintF(ucData,3,ucTmp[0]);
   \   00000048   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000004C   0x2103             MOVS     R1,#+3
   \   0000004E   0xA803             ADD      R0,SP,#+12
   \   00000050   0x.... 0x....      BL       SprintF
   1045                SprintF(&ucData[3],3,ucTmp[1]);
   \   00000054   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000058   0x2103             MOVS     R1,#+3
   \   0000005A   0xF10D 0x000F      ADD      R0,SP,#+15
   \   0000005E   0x.... 0x....      BL       SprintF
   1046                ucData[6]=pcommData->ucCmd;
   \   00000062   0x78E0             LDRB     R0,[R4, #+3]
   \   00000064   0xF88D 0x0012      STRB     R0,[SP, #+18]
   1047                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,7,0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2007             MOVS     R0,#+7
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xAB03             ADD      R3,SP,#+12
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x78E0             LDRB     R0,[R4, #+3]
   \   00000078   0x.... 0x....      BL       Uart0Pack
   \   0000007C   0xE00C             B.N      ??ScanParamsWrite_0
   1048              }else{
   1049                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??ScanParamsWrite_1: (+1)
   \   0000007E   0x2034             MOVS     R0,#+52
   \   00000080   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1050                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9001             STR      R0,[SP, #+4]
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0xAB03             ADD      R3,SP,#+12
   \   0000008E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000090   0x7861             LDRB     R1,[R4, #+1]
   \   00000092   0x205E             MOVS     R0,#+94
   \   00000094   0x.... 0x....      BL       Uart0Pack
   1051              }
   1052            }
   1053          }
   \                     ??ScanParamsWrite_0: (+1)
   \   00000098   0xB014             ADD      SP,SP,#+80
   \   0000009A   0xBD10             POP      {R4,PC}          ;; return
   1054          
   1055          /********************************************************************************************************
   1056          ** 函数名称: ScanParamsRead
   1057          ** 功能描述:
   1058          ** 输 　 入:
   1059          **
   1060          ** 输　  出:
   1061          **
   1062          ** 全局变量:
   1063          ** 调用模块:
   1064          **
   1065          ** 作　  者: John Tonny
   1066          ** 日　  期: 2005年05月01日
   1067          **------------------------------------------------------------------------------------------------------
   1068          ** 修 改 人:
   1069          ** 日　  期:
   1070          **------------------------------------------------------------------------------------------------------
   1071          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1072          void ScanParamsRead(CardMachineRxData *pcommData)
   1073          {
   \                     ScanParamsRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1074            INT8U ucData[64];
   1075            INT8U ucTmp[2];
   1076            
   1077            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD02B             BEQ.N    ??ScanParamsRead_0
   1078              if(!EepromReadVerifyBytes(SCAN_PARAMS_ADDR,ucTmp,2)){
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??ScanParamsRead_1
   1079                ucTmp[0]=SCAN_OPEN_TIMES;
   \   00000020   0x2028             MOVS     R0,#+40
   \   00000022   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1080                ucTmp[1]=SCAN_CLOSE_TIMES;
   \   00000026   0x2032             MOVS     R0,#+50
   \   00000028   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1081                EepromWriteVerifyBytes(SCAN_PARAMS_ADDR,ucTmp,2);
   \   0000002C   0x2202             MOVS     R2,#+2
   \   0000002E   0xA902             ADD      R1,SP,#+8
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       EepromWriteVerifyBytes
   1082              }
   1083              SprintF(&ucData[0],3,ucTmp[0]);
   \                     ??ScanParamsRead_1: (+1)
   \   00000036   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       SprintF
   1084              SprintF(&ucData[3],3,ucTmp[1]);
   \   00000042   0xF89D 0x2009      LDRB     R2,[SP, #+9]
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0xF10D 0x000F      ADD      R0,SP,#+15
   \   0000004C   0x.... 0x....      BL       SprintF
   1085              ucData[6]=pcommData->ucCmd;
   \   00000050   0x78E0             LDRB     R0,[R4, #+3]
   \   00000052   0xF88D 0x0012      STRB     R0,[SP, #+18]
   1086              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,7,0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x2007             MOVS     R0,#+7
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xAB03             ADD      R3,SP,#+12
   \   00000060   0x78A2             LDRB     R2,[R4, #+2]
   \   00000062   0x7861             LDRB     R1,[R4, #+1]
   \   00000064   0x78E0             LDRB     R0,[R4, #+3]
   \   00000066   0x.... 0x....      BL       Uart0Pack
   1087            }
   1088          }
   \                     ??ScanParamsRead_0: (+1)
   \   0000006A   0xB014             ADD      SP,SP,#+80
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
   1089          
   1090          /********************************************************************************************************
   1091          ** 函数名称: DMotoMove
   1092          ** 功能描述: 1字节电机+1字节方向(30:正向,31反向)+3字节时间
   1093          ** 输 　 入:
   1094          **
   1095          ** 输　  出:
   1096          **
   1097          ** 全局变量:
   1098          ** 调用模块:
   1099          **
   1100          ** 作　  者: John Tonny
   1101          ** 日　  期: 2005年05月01日
   1102          **------------------------------------------------------------------------------------------------------
   1103          ** 修 改 人:
   1104          ** 日　  期:
   1105          **------------------------------------------------------------------------------------------------------
   1106          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1107          void DMotoMove(CardMachineRxData *pcommData)
   1108          {
   \                     DMotoMove: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1109            INT8U ucData[64];
   1110            INT16U uiSteps;
   1111            INT8U ucSelected;
   1112            INT16U uiTime;
   1113            
   1114            if(Uart0LengthProcess(pcommData,7)){	
   \   00000006   0x2107             MOVS     R1,#+7
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD05E             BEQ.N    ??DMotoMove_0
   1115              ucSelected=0x00;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0006             MOVS     R6,R0
   1116              if(pcommData->ucData[0]>=0x30 && pcommData->ucData[0]<=0x39){
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0x2830             CMP      R0,#+48
   \   0000001A   0xDB05             BLT.N    ??DMotoMove_1
   \   0000001C   0x7920             LDRB     R0,[R4, #+4]
   \   0000001E   0x283A             CMP      R0,#+58
   \   00000020   0xDA02             BGE.N    ??DMotoMove_1
   1117                ucSelected=pcommData->ucData[0]-0x30;
   \   00000022   0x7920             LDRB     R0,[R4, #+4]
   \   00000024   0x3830             SUBS     R0,R0,#+48
   \   00000026   0x0006             MOVS     R6,R0
   1118              }
   1119              if(ucSelected<CARDMACHINE_DMOTO_NUMS){
   \                     ??DMotoMove_1: (+1)
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E04             CMP      R6,#+4
   \   0000002C   0xDA43             BGE.N    ??DMotoMove_2
   1120                pcommData->ucData[7]=0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x72E0             STRB     R0,[R4, #+11]
   1121                uiTime=(atoi((const char *)&pcommData->ucData[2]));
   \   00000032   0x1DA0             ADDS     R0,R4,#+6
   \   00000034   0x.... 0x....      BL       atoi
   \   00000038   0x0007             MOVS     R7,R0
   1122                uiSteps=m_uiDMotoPwm[ucSelected];
   \   0000003A   0x....             LDR.N    R0,??DataTable11
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0xF830 0x0016      LDRH     R0,[R0, R6, LSL #+1]
   \   00000042   0x0005             MOVS     R5,R0
   1123                if(pcommData->ucData[1]==0x30){
   \   00000044   0x7960             LDRB     R0,[R4, #+5]
   \   00000046   0x2830             CMP      R0,#+48
   \   00000048   0xD10C             BNE.N    ??DMotoMove_3
   1124                  DMotoStart(DMOTO_FREQ_DEFAULT,uiSteps,MOTO_FORWARD_MODE,uiTime,ucSelected);
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x003B             MOVS     R3,R7
   \   00000052   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000054   0x2200             MOVS     R2,#+0
   \   00000056   0x0029             MOVS     R1,R5
   \   00000058   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005A   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000005E   0x.... 0x....      BL       DMotoStart
   \   00000062   0xE014             B.N      ??DMotoMove_4
   1125                }else if(pcommData->ucData[1]==0x31){
   \                     ??DMotoMove_3: (+1)
   \   00000064   0x7960             LDRB     R0,[R4, #+5]
   \   00000066   0x2831             CMP      R0,#+49
   \   00000068   0xD10C             BNE.N    ??DMotoMove_5
   1126                  DMotoStart(DMOTO_FREQ_DEFAULT,uiSteps,MOTO_BACKWARD_MODE,uiTime,ucSelected);
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x003B             MOVS     R3,R7
   \   00000072   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000007A   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000007E   0x.... 0x....      BL       DMotoStart
   \   00000082   0xE004             B.N      ??DMotoMove_4
   1127                }else{
   1128                  MOTO_DC_DISABLED(ucSelected,0);
   \                     ??DMotoMove_5: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x.... 0x....      BL       MOTO_DC_DISABLED
   1129                }
   1130                ucData[0]=pcommData->ucData[0];
   \                     ??DMotoMove_4: (+1)
   \   0000008E   0x7920             LDRB     R0,[R4, #+4]
   \   00000090   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1131                ucData[1]=pcommData->ucData[1];
   \   00000094   0x7960             LDRB     R0,[R4, #+5]
   \   00000096   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1132                ucData[2]=pcommData->ucCmd;
   \   0000009A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000009C   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1133                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0xAB02             ADD      R3,SP,#+8
   \   000000AA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AC   0x7861             LDRB     R1,[R4, #+1]
   \   000000AE   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B0   0x.... 0x....      BL       Uart0Pack
   \   000000B4   0xE00C             B.N      ??DMotoMove_0
   1134              }else{
   1135                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??DMotoMove_2: (+1)
   \   000000B6   0x205C             MOVS     R0,#+92
   \   000000B8   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1136                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x9001             STR      R0,[SP, #+4]
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0xAB02             ADD      R3,SP,#+8
   \   000000C6   0x78A2             LDRB     R2,[R4, #+2]
   \   000000C8   0x7861             LDRB     R1,[R4, #+1]
   \   000000CA   0x205E             MOVS     R0,#+94
   \   000000CC   0x.... 0x....      BL       Uart0Pack
   1137              }
   1138            }
   1139          }
   \                     ??DMotoMove_0: (+1)
   \   000000D0   0xB013             ADD      SP,SP,#+76
   \   000000D2   0xBDF0             POP      {R4-R7,PC}       ;; return
   1140          
   1141          /********************************************************************************************************
   1142          ** 函数名称: SMotoMove
   1143          ** 功能描述: 1字节电机+1字节方向(30:正向,31反向)+4字节脉冲数
   1144          ** 输 　 入:
   1145          **
   1146          ** 输　  出:
   1147          **
   1148          ** 全局变量:
   1149          ** 调用模块:
   1150          **
   1151          ** 作　  者: John Tonny
   1152          ** 日　  期: 2005年05月01日
   1153          **------------------------------------------------------------------------------------------------------
   1154          ** 修 改 人:
   1155          ** 日　  期:
   1156          **------------------------------------------------------------------------------------------------------
   1157          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1158          void SMotoMove(CardMachineRxData *pcommData)
   1159          {
   \                     SMotoMove: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1160            INT8U ucData[64];
   1161            INT16U uiSteps;	
   1162            INT8U ucSelected;
   1163            
   1164            if(Uart0LengthProcess(pcommData,6)){			
   \   00000006   0x2106             MOVS     R1,#+6
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD04E             BEQ.N    ??SMotoMove_0
   1165              ucSelected=0x00;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0006             MOVS     R6,R0
   1166              if(pcommData->ucData[0]>=0x30 && pcommData->ucData[0]<=0x39){
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0x2830             CMP      R0,#+48
   \   0000001A   0xDB05             BLT.N    ??SMotoMove_1
   \   0000001C   0x7920             LDRB     R0,[R4, #+4]
   \   0000001E   0x283A             CMP      R0,#+58
   \   00000020   0xDA02             BGE.N    ??SMotoMove_1
   1167                ucSelected=pcommData->ucData[0]-0x30;
   \   00000022   0x7920             LDRB     R0,[R4, #+4]
   \   00000024   0x3830             SUBS     R0,R0,#+48
   \   00000026   0x0006             MOVS     R6,R0
   1168              }
   1169              if(ucSelected<CARDMACHINE_SMOTO_NUMS){
   \                     ??SMotoMove_1: (+1)
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E02             CMP      R6,#+2
   \   0000002C   0xDA33             BGE.N    ??SMotoMove_2
   1170                pcommData->ucData[6]=0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x72A0             STRB     R0,[R4, #+10]
   1171                uiSteps=(INT16U)(atoi((const char *)&pcommData->ucData[2]));
   \   00000032   0x1DA0             ADDS     R0,R4,#+6
   \   00000034   0x.... 0x....      BL       atoi
   \   00000038   0x0005             MOVS     R5,R0
   1172                if(pcommData->ucData[1]==0x30){
   \   0000003A   0x7960             LDRB     R0,[R4, #+5]
   \   0000003C   0x2830             CMP      R0,#+48
   \   0000003E   0xD10B             BNE.N    ??SMotoMove_3
   1173                  SMotoStart(m_ucSMotoFreq[ucSelected],uiSteps,MOTO_FORWARD_MODE,ucSelected);
   \   00000040   0x0033             MOVS     R3,R6
   \   00000042   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable23
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0x5D80             LDRB     R0,[R0, R6]
   \   00000052   0x.... 0x....      BL       SMotoStart
   \   00000056   0xE00A             B.N      ??SMotoMove_4
   1174                }else{
   1175                  SMotoStart(m_ucSMotoFreq[ucSelected],uiSteps,MOTO_BACKWARD_MODE,ucSelected);
   \                     ??SMotoMove_3: (+1)
   \   00000058   0x0033             MOVS     R3,R6
   \   0000005A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x0029             MOVS     R1,R5
   \   00000060   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x5D80             LDRB     R0,[R0, R6]
   \   0000006A   0x.... 0x....      BL       SMotoStart
   1176                }
   1177                ucData[0]=pcommData->ucData[0];
   \                     ??SMotoMove_4: (+1)
   \   0000006E   0x7920             LDRB     R0,[R4, #+4]
   \   00000070   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1178                ucData[1]=pcommData->ucData[1];
   \   00000074   0x7960             LDRB     R0,[R4, #+5]
   \   00000076   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1179                ucData[2]=pcommData->ucCmd;
   \   0000007A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000007C   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1180                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,3,0);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9001             STR      R0,[SP, #+4]
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0xAB02             ADD      R3,SP,#+8
   \   0000008A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000008C   0x7861             LDRB     R1,[R4, #+1]
   \   0000008E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000090   0x.... 0x....      BL       Uart0Pack
   \   00000094   0xE00C             B.N      ??SMotoMove_0
   1181              }else{
   1182                ucData[0]=SUBTYPE_ERR_UNKNOW;
   \                     ??SMotoMove_2: (+1)
   \   00000096   0x205C             MOVS     R0,#+92
   \   00000098   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1183                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0xAB02             ADD      R3,SP,#+8
   \   000000A6   0x78A2             LDRB     R2,[R4, #+2]
   \   000000A8   0x7861             LDRB     R1,[R4, #+1]
   \   000000AA   0x205E             MOVS     R0,#+94
   \   000000AC   0x.... 0x....      BL       Uart0Pack
   1184              }
   1185            }
   1186          }
   \                     ??SMotoMove_0: (+1)
   \   000000B0   0xB012             ADD      SP,SP,#+72
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
   1187          
   1188          /********************************************************************************************************
   1189          ** 函数名称: CardToBox
   1190          ** 功能描述:
   1191          ** 输 　 入:
   1192          **
   1193          ** 输　  出:
   1194          **
   1195          ** 全局变量:
   1196          ** 调用模块:
   1197          **
   1198          ** 作　  者: John Tonny
   1199          ** 日　  期: 2005年05月01日
   1200          **------------------------------------------------------------------------------------------------------
   1201          ** 修 改 人:
   1202          ** 日　  期:
   1203          **------------------------------------------------------------------------------------------------------
   1204          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1205          void CardToBox(CardMachineRxData *pcommData)
   1206          {
   \                     CardToBox: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1207            INT8U ucData[64];
   1208            
   1209            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD037             BEQ.N    ??CardToBox_0
   1210              g_ucGInState=GIN_CARDTOANT_STATE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1211              if(pcommData->ucData[0]>=0x31){
   \   0000001A   0x7920             LDRB     R0,[R4, #+4]
   \   0000001C   0x2831             CMP      R0,#+49
   \   0000001E   0xDB10             BLT.N    ??CardToBox_1
   1212                m_usrGlobalFlag.usrBit.bGCardToBox=1;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   1213                m_usrGlobalFlag.usrBit.bGCardToOut=0;
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   \   00000040   0xE00F             B.N      ??CardToBox_2
   1214              }else{
   1215                m_usrGlobalFlag.usrBit.bGCardToBox=0;
   \                     ??CardToBox_1: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   1216                m_usrGlobalFlag.usrBit.bGCardToOut=0;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000060   0x7008             STRB     R0,[R1, #+0]
   1217              }
   1218              ucData[0]=pcommData->ucData[0];
   \                     ??CardToBox_2: (+1)
   \   00000062   0x7920             LDRB     R0,[R4, #+4]
   \   00000064   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1219              ucData[1]=pcommData->ucCmd;
   \   00000068   0x78E0             LDRB     R0,[R4, #+3]
   \   0000006A   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1220              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x9001             STR      R0,[SP, #+4]
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0xAB02             ADD      R3,SP,#+8
   \   00000078   0x78A2             LDRB     R2,[R4, #+2]
   \   0000007A   0x7861             LDRB     R1,[R4, #+1]
   \   0000007C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000007E   0x.... 0x....      BL       Uart0Pack
   1221            }
   1222          }
   \                     ??CardToBox_0: (+1)
   \   00000082   0xB012             ADD      SP,SP,#+72
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
   1223          
   1224          /********************************************************************************************************
   1225          ** 函数名称: CardToOut
   1226          ** 功能描述:
   1227          ** 输 　 入:
   1228          **
   1229          ** 输　  出:
   1230          **
   1231          ** 全局变量:
   1232          ** 调用模块:
   1233          **
   1234          ** 作　  者: John Tonny
   1235          ** 日　  期: 2005年05月01日
   1236          **------------------------------------------------------------------------------------------------------
   1237          ** 修 改 人:
   1238          ** 日　  期:
   1239          **------------------------------------------------------------------------------------------------------
   1240          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1241          void CardToOut(CardMachineRxData *pcommData)
   1242          {
   \                     CardToOut: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1243            INT8U ucData[64];
   1244          	
   1245            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD033             BEQ.N    ??CardToOut_0
   1246              if(pcommData->ucData[0]==0x31){
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x2831             CMP      R0,#+49
   \   00000016   0xD110             BNE.N    ??CardToOut_1
   1247                m_usrGlobalFlag.usrBit.bGCardToBox=0;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1248                m_usrGlobalFlag.usrBit.bGCardToOut=1;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \   00000038   0xE00F             B.N      ??CardToOut_2
   1249              }else{
   1250                m_usrGlobalFlag.usrBit.bGCardToBox=0;
   \                     ??CardToOut_1: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   1251                m_usrGlobalFlag.usrBit.bGCardToOut=0;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   1252              }
   1253              ucData[0]=pcommData->ucData[0];
   \                     ??CardToOut_2: (+1)
   \   0000005A   0x7920             LDRB     R0,[R4, #+4]
   \   0000005C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1254              ucData[1]=pcommData->ucCmd;
   \   00000060   0x78E0             LDRB     R0,[R4, #+3]
   \   00000062   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1255              Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0xAB02             ADD      R3,SP,#+8
   \   00000070   0x78A2             LDRB     R2,[R4, #+2]
   \   00000072   0x7861             LDRB     R1,[R4, #+1]
   \   00000074   0x78E0             LDRB     R0,[R4, #+3]
   \   00000076   0x.... 0x....      BL       Uart0Pack
   1256            }
   1257          }
   \                     ??CardToOut_0: (+1)
   \   0000007A   0xB012             ADD      SP,SP,#+72
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
   1258          
   1259          /********************************************************************************************************
   1260          ** 函数名称: KeyTest
   1261          ** 功能描述:
   1262          ** 输 　 入:
   1263          **
   1264          ** 输　  出:
   1265          **
   1266          ** 全局变量:
   1267          ** 调用模块:
   1268          **
   1269          ** 作　  者: John Tonny
   1270          ** 日　  期: 2005年05月01日
   1271          **------------------------------------------------------------------------------------------------------
   1272          ** 修 改 人:
   1273          ** 日　  期:
   1274          **------------------------------------------------------------------------------------------------------
   1275          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1276          void KeyTest(CardMachineRxData *pcommData)
   1277          {
   \                     KeyTest: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   1278            INT8U ucData[16]={0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38};
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable25
   \   0000000C   0x2210             MOVS     R2,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
   1279            
   1280            INT32U ulKeyOutput;
   1281            INT8U ucCmd;
   1282            
   1283            CPU_SR_ALLOC();
   \   00000012   0x2500             MOVS     R5,#+0
   1284            if(Uart0LengthProcess(pcommData,9)){		
   \   00000014   0x2109             MOVS     R1,#+9
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       Uart0LengthProcess
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD073             BEQ.N    ??KeyTest_0
   1285              if(Mem_Cmp(ucData,&pcommData->ucData[1],8)){
   \   00000020   0x2208             MOVS     R2,#+8
   \   00000022   0x1D61             ADDS     R1,R4,#+5
   \   00000024   0xA804             ADD      R0,SP,#+16
   \   00000026   0x.... 0x....      BL       Mem_Cmp
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD062             BEQ.N    ??KeyTest_1
   1286                if(pcommData->ucData[0]==0x31){
   \   0000002E   0x7920             LDRB     R0,[R4, #+4]
   \   00000030   0x2831             CMP      R0,#+49
   \   00000032   0xD12B             BNE.N    ??KeyTest_2
   1287                  m_usrGlobalFlag.usrBit.bKeyTest=1;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   1288                  OS_ENTER_CRITICAL();
   \   00000044   0x.... 0x....      BL       CPU_SR_Save
   \   00000048   0x0005             MOVS     R5,R0
   \   0000004A   0x.... 0x....      BL       CPU_IntDisMeasStart
   1289                  ulKeyOutput=g_usrGetKey.ulKeyOutput | 0x80808080;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0xF070 0x307F      ORNS     R0,R0,#+2139062143
   \   00000058   0x9003             STR      R0,[SP, #+12]
   1290                  OS_EXIT_CRITICAL();
   \   0000005A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       CPU_SR_Restore
   1291                  Uart0Pack(INFTYPE_KEY_TEST_STATUS,0,0,(INT8U *)&ulKeyOutput,4,1);
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x9001             STR      R0,[SP, #+4]
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0xAB03             ADD      R3,SP,#+12
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x206A             MOVS     R0,#+106
   \   00000074   0x.... 0x....      BL       Uart0Pack
   1292                  ucCmd=DISPLAY_KEY_TEST_MSG;
   \   00000078   0x2008             MOVS     R0,#+8
   \   0000007A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1293                  Box_TaskLcdQPost(&App_TaskLcdTCB,&ucCmd,1);
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0xA902             ADD      R1,SP,#+8
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000086   0x.... 0x....      BL       Box_TaskLcdQPost
   \   0000008A   0xE022             B.N      ??KeyTest_3
   1294                  
   1295                }else{
   1296                  m_usrGlobalFlag.usrBit.bKeyTest=0;
   \                     ??KeyTest_2: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF010 0x00EF      ANDS     R0,R0,#0xEF
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
   1297                  OS_ENTER_CRITICAL();
   \   0000009C   0x.... 0x....      BL       CPU_SR_Save
   \   000000A0   0x0005             MOVS     R5,R0
   \   000000A2   0x.... 0x....      BL       CPU_IntDisMeasStart
   1298                  g_usrGlobalFlag.usrBit.bGKey=0;
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   1299                  OS_EXIT_CRITICAL();
   \   000000B6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
   1300                  ucCmd=DISPLAY_MAIN_MSG;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1301                  Box_TaskLcdQPost(&App_TaskLcdTCB,&ucCmd,1);
   \   000000C6   0x2201             MOVS     R2,#+1
   \   000000C8   0xA902             ADD      R1,SP,#+8
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   000000CE   0x.... 0x....      BL       Box_TaskLcdQPost
   1302                }
   1303                ucData[0]=pcommData->ucData[0];
   \                     ??KeyTest_3: (+1)
   \   000000D2   0x7920             LDRB     R0,[R4, #+4]
   \   000000D4   0xF88D 0x0010      STRB     R0,[SP, #+16]
   1304                ucData[1]=pcommData->ucCmd;
   \   000000D8   0x78E0             LDRB     R0,[R4, #+3]
   \   000000DA   0xF88D 0x0011      STRB     R0,[SP, #+17]
   1305                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,2,0);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0xAB04             ADD      R3,SP,#+16
   \   000000E8   0x78A2             LDRB     R2,[R4, #+2]
   \   000000EA   0x7861             LDRB     R1,[R4, #+1]
   \   000000EC   0x78E0             LDRB     R0,[R4, #+3]
   \   000000EE   0x.... 0x....      BL       Uart0Pack
   \   000000F2   0xE009             B.N      ??KeyTest_0
   1306              }else{
   1307                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??KeyTest_1: (+1)
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x9001             STR      R0,[SP, #+4]
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x2300             MOVS     R3,#+0
   \   000000FE   0x78A2             LDRB     R2,[R4, #+2]
   \   00000100   0x7861             LDRB     R1,[R4, #+1]
   \   00000102   0x20C5             MOVS     R0,#+197
   \   00000104   0x.... 0x....      BL       Uart0Pack
   1308              }
   1309            }
   1310          }
   \                     ??KeyTest_0: (+1)
   \   00000108   0xB009             ADD      SP,SP,#+36
   \   0000010A   0xBD30             POP      {R4,R5,PC}       ;; return
   1311          
   1312          /********************************************************************************************************
   1313          ** 函数名称: CardMachineIdWrite
   1314          ** 功能描述:
   1315          ** 输 　 入:
   1316          **
   1317          ** 输　  出:
   1318          **
   1319          ** 全局变量:
   1320          ** 调用模块:
   1321          **
   1322          ** 作　  者: John Tonny
   1323          ** 日　  期: 2005年05月01日
   1324          **------------------------------------------------------------------------------------------------------
   1325          ** 修 改 人:
   1326          ** 日　  期:
   1327          **------------------------------------------------------------------------------------------------------
   1328          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1329          void CardMachineIdWrite(CardMachineRxData *pcommData)
   1330          {
   \                     CardMachineIdWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1331            INT8U ucData[64];
   1332            
   1333            if(Uart0LengthProcess(pcommData,4)){			
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD023             BEQ.N    ??CardMachineIdWrite_0
   1334              if(EepromWriteVerifyBytes(CARDMACHINE_ID_ADDR,pcommData->ucData,4)){
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0x1D21             ADDS     R1,R4,#+4
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00F             BEQ.N    ??CardMachineIdWrite_1
   1335                Mem_Copy(ucData,pcommData->ucData,4);
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0x1D21             ADDS     R1,R4,#+4
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       Mem_Copy
   1336                Uart0Pack(INFTYPE_CARD_DEV_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,4,0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0xAB02             ADD      R3,SP,#+8
   \   00000034   0x78A2             LDRB     R2,[R4, #+2]
   \   00000036   0x7861             LDRB     R1,[R4, #+1]
   \   00000038   0x2060             MOVS     R0,#+96
   \   0000003A   0x.... 0x....      BL       Uart0Pack
   \   0000003E   0xE00C             B.N      ??CardMachineIdWrite_0
   1337              }else{
   1338                ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??CardMachineIdWrite_1: (+1)
   \   00000040   0x2034             MOVS     R0,#+52
   \   00000042   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1339                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9001             STR      R0,[SP, #+4]
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0xAB02             ADD      R3,SP,#+8
   \   00000050   0x78A2             LDRB     R2,[R4, #+2]
   \   00000052   0x7861             LDRB     R1,[R4, #+1]
   \   00000054   0x205E             MOVS     R0,#+94
   \   00000056   0x.... 0x....      BL       Uart0Pack
   1340              }
   1341            }
   1342          }
   \                     ??CardMachineIdWrite_0: (+1)
   \   0000005A   0xB012             ADD      SP,SP,#+72
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   1343          
   1344          /********************************************************************************************************
   1345          ** 函数名称: CardMachineIdRead
   1346          ** 功能描述:
   1347          ** 输 　 入:
   1348          **
   1349          ** 输　  出:
   1350          **
   1351          ** 全局变量:
   1352          ** 调用模块:
   1353          **
   1354          ** 作　  者: John Tonny
   1355          ** 日　  期: 2005年05月01日
   1356          **------------------------------------------------------------------------------------------------------
   1357          ** 修 改 人:
   1358          ** 日　  期:
   1359          **------------------------------------------------------------------------------------------------------
   1360          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1361          void CardMachineIdRead(CardMachineRxData *pcommData)
   1362          {
   \                     CardMachineIdRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1363            INT8U ucData[64];
   1364            
   1365            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01E             BEQ.N    ??CardMachineIdRead_0
   1366              if(EepromReadVerifyBytes(CARDMACHINE_ID_ADDR,ucData,4)){
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00A             BEQ.N    ??CardMachineIdRead_1
   1367                Uart0Pack(INFTYPE_CARD_DEV_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,4,0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0xAB02             ADD      R3,SP,#+8
   \   0000002A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000002C   0x7861             LDRB     R1,[R4, #+1]
   \   0000002E   0x2060             MOVS     R0,#+96
   \   00000030   0x.... 0x....      BL       Uart0Pack
   \   00000034   0xE00C             B.N      ??CardMachineIdRead_0
   1368              }else{
   1369                ucData[0]=SUBTYPE_ERR_READ_INF;
   \                     ??CardMachineIdRead_1: (+1)
   \   00000036   0x2035             MOVS     R0,#+53
   \   00000038   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1370                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0xAB02             ADD      R3,SP,#+8
   \   00000046   0x78A2             LDRB     R2,[R4, #+2]
   \   00000048   0x7861             LDRB     R1,[R4, #+1]
   \   0000004A   0x205E             MOVS     R0,#+94
   \   0000004C   0x.... 0x....      BL       Uart0Pack
   1371              }
   1372            }
   1373          }
   \                     ??CardMachineIdRead_0: (+1)
   \   00000050   0xB012             ADD      SP,SP,#+72
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
   1374          
   1375          /********************************************************************************************************
   1376          ** 函数名称: CardMachineAddrWrite
   1377          ** 功能描述:
   1378          ** 输 　 入:
   1379          **
   1380          ** 输　  出:
   1381          **
   1382          ** 全局变量:
   1383          ** 调用模块:
   1384          **
   1385          ** 作　  者: John Tonny
   1386          ** 日　  期: 2005年05月01日
   1387          **------------------------------------------------------------------------------------------------------
   1388          ** 修 改 人:
   1389          ** 日　  期:
   1390          **------------------------------------------------------------------------------------------------------
   1391          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1392          void CardMachineAddrWrite(CardMachineRxData *pcommData)
   1393          {
   \                     CardMachineAddrWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1394            INT8U ucData[64];
   1395            
   1396            if(Uart0LengthProcess(pcommData,4)){			
   \   00000006   0x2104             MOVS     R1,#+4
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD031             BEQ.N    ??CardMachineAddrWrite_0
   1397              if(pcommData->ucData[0]>=0x10){
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xDB24             BLT.N    ??CardMachineAddrWrite_1
   1398                if(EepromWriteVerifyBytes(CARDMACHINE_SELFADDR_ADDR,pcommData->ucData,1)){
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x1D21             ADDS     R1,R4,#+4
   \   0000001C   0x2028             MOVS     R0,#+40
   \   0000001E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD00F             BEQ.N    ??CardMachineAddrWrite_2
   1399                  Mem_Copy(ucData,pcommData->ucData,4);
   \   00000026   0x2204             MOVS     R2,#+4
   \   00000028   0x1D21             ADDS     R1,R4,#+4
   \   0000002A   0xA802             ADD      R0,SP,#+8
   \   0000002C   0x.... 0x....      BL       Mem_Copy
   1400                  Uart0Pack(INFTYPE_CARD_DEV_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xAB02             ADD      R3,SP,#+8
   \   0000003A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000003C   0x7861             LDRB     R1,[R4, #+1]
   \   0000003E   0x2060             MOVS     R0,#+96
   \   00000040   0x.... 0x....      BL       Uart0Pack
   \   00000044   0xE017             B.N      ??CardMachineAddrWrite_0
   1401                }else{
   1402                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??CardMachineAddrWrite_2: (+1)
   \   00000046   0x2034             MOVS     R0,#+52
   \   00000048   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1403                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xAB02             ADD      R3,SP,#+8
   \   00000056   0x78A2             LDRB     R2,[R4, #+2]
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0x205E             MOVS     R0,#+94
   \   0000005C   0x.... 0x....      BL       Uart0Pack
   \   00000060   0xE009             B.N      ??CardMachineAddrWrite_0
   1404                }
   1405              }else{
   1406                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardMachineAddrWrite_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9001             STR      R0,[SP, #+4]
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000006E   0x7861             LDRB     R1,[R4, #+1]
   \   00000070   0x20C5             MOVS     R0,#+197
   \   00000072   0x.... 0x....      BL       Uart0Pack
   1407              }
   1408            }
   1409          }
   \                     ??CardMachineAddrWrite_0: (+1)
   \   00000076   0xB012             ADD      SP,SP,#+72
   \   00000078   0xBD10             POP      {R4,PC}          ;; return
   1410          
   1411          /********************************************************************************************************
   1412          ** 函数名称: CardMachineAddrRead
   1413          ** 功能描述:
   1414          ** 输 　 入:
   1415          **
   1416          ** 输　  出:
   1417          **
   1418          ** 全局变量:
   1419          ** 调用模块:
   1420          **
   1421          ** 作　  者: John Tonny
   1422          ** 日　  期: 2005年05月01日
   1423          **------------------------------------------------------------------------------------------------------
   1424          ** 修 改 人:
   1425          ** 日　  期:
   1426          **------------------------------------------------------------------------------------------------------
   1427          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1428          void CardMachineAddrRead(CardMachineRxData *pcommData)
   1429          {
   \                     CardMachineAddrRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1430            INT8U ucData[64];
   1431            
   1432            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01F             BEQ.N    ??CardMachineAddrRead_0
   1433              if(EepromReadVerifyBytes(CARDMACHINE_ID_ADDR,ucData,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2030             MOVS     R0,#+48
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD00B             BEQ.N    ??CardMachineAddrRead_1
   1434                Uart0Pack(ucData[0],pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000002C   0x7861             LDRB     R1,[R4, #+1]
   \   0000002E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000032   0x.... 0x....      BL       Uart0Pack
   \   00000036   0xE00C             B.N      ??CardMachineAddrRead_0
   1435              }else{
   1436                ucData[0]=SUBTYPE_ERR_READ_INF;
   \                     ??CardMachineAddrRead_1: (+1)
   \   00000038   0x2035             MOVS     R0,#+53
   \   0000003A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1437                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xAB02             ADD      R3,SP,#+8
   \   00000048   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004A   0x7861             LDRB     R1,[R4, #+1]
   \   0000004C   0x205E             MOVS     R0,#+94
   \   0000004E   0x.... 0x....      BL       Uart0Pack
   1438              }
   1439            }
   1440          }
   \                     ??CardMachineAddrRead_0: (+1)
   \   00000052   0xB012             ADD      SP,SP,#+72
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
   1441          
   1442          /********************************************************************************************************
   1443          ** 函数名称: CardMachineAlarmMaxWrite
   1444          ** 功能描述:
   1445          ** 输 　 入:
   1446          **
   1447          ** 输　  出:
   1448          **
   1449          ** 全局变量:
   1450          ** 调用模块:
   1451          **
   1452          ** 作　  者: John Tonny
   1453          ** 日　  期: 2005年05月01日
   1454          **------------------------------------------------------------------------------------------------------
   1455          ** 修 改 人:
   1456          ** 日　  期:
   1457          **------------------------------------------------------------------------------------------------------
   1458          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1459          void CardMachineAlarmMaxWrite(CardMachineRxData *pcommData)
   1460          {
   \                     CardMachineAlarmMaxWrite: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1461            INT8U ucData[64];
   1462            INT8U ucTmp;
   1463            INT8U i;
   1464            
   1465            if(Uart0LengthProcess(pcommData,5)){			
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD048             BEQ.N    ??CardMachineAlarmMaxWrite_0
   1466              pcommData->ucData[5]=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7260             STRB     R0,[R4, #+9]
   1467              ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \   00000016   0x1D60             ADDS     R0,R4,#+5
   \   00000018   0x.... 0x....      BL       atoi
   \   0000001C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1468              if(ucTmp<=CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDA33             BGE.N    ??CardMachineAlarmMaxWrite_1
   1469                if(EepromWriteVerifyBytes(CARDMACHINE_ALARM_MAX_ADDR,&ucTmp,1)){
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0x203C             MOVS     R0,#+60
   \   0000002E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD01E             BEQ.N    ??CardMachineAlarmMaxWrite_2
   1470                  for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \                     ??CardMachineAlarmMaxWrite_3: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D03             CMP      R5,#+3
   \   0000003E   0xDA09             BGE.N    ??CardMachineAlarmMaxWrite_4
   1471                    m_usrBoxInfo[i].ucAlarmMax=ucTmp;
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x016A             LSLS     R2,R5,#+5
   \   0000004C   0x4411             ADD      R1,R1,R2
   \   0000004E   0x7208             STRB     R0,[R1, #+8]
   1472                  }
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0xE7F2             B.N      ??CardMachineAlarmMaxWrite_3
   1473                  Mem_Copy(ucData,pcommData->ucData,5);
   \                     ??CardMachineAlarmMaxWrite_4: (+1)
   \   00000054   0x2205             MOVS     R2,#+5
   \   00000056   0x1D21             ADDS     R1,R4,#+4
   \   00000058   0xA803             ADD      R0,SP,#+12
   \   0000005A   0x.... 0x....      BL       Mem_Copy
   1474                  Uart0Pack(INFTYPE_BOX_CRITIMAX,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0x2005             MOVS     R0,#+5
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0xAB03             ADD      R3,SP,#+12
   \   00000068   0x78A2             LDRB     R2,[R4, #+2]
   \   0000006A   0x7861             LDRB     R1,[R4, #+1]
   \   0000006C   0x206B             MOVS     R0,#+107
   \   0000006E   0x.... 0x....      BL       Uart0Pack
   \   00000072   0xE017             B.N      ??CardMachineAlarmMaxWrite_0
   1475                }else{
   1476                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??CardMachineAlarmMaxWrite_2: (+1)
   \   00000074   0x2034             MOVS     R0,#+52
   \   00000076   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1477                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9001             STR      R0,[SP, #+4]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xAB03             ADD      R3,SP,#+12
   \   00000084   0x78A2             LDRB     R2,[R4, #+2]
   \   00000086   0x7861             LDRB     R1,[R4, #+1]
   \   00000088   0x205E             MOVS     R0,#+94
   \   0000008A   0x.... 0x....      BL       Uart0Pack
   \   0000008E   0xE009             B.N      ??CardMachineAlarmMaxWrite_0
   1478                }
   1479              }else{
   1480                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardMachineAlarmMaxWrite_1: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x9001             STR      R0,[SP, #+4]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x2300             MOVS     R3,#+0
   \   0000009A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000009C   0x7861             LDRB     R1,[R4, #+1]
   \   0000009E   0x20C5             MOVS     R0,#+197
   \   000000A0   0x.... 0x....      BL       Uart0Pack
   1481              }
   1482            }
   1483          }
   \                     ??CardMachineAlarmMaxWrite_0: (+1)
   \   000000A4   0xB013             ADD      SP,SP,#+76
   \   000000A6   0xBD30             POP      {R4,R5,PC}       ;; return
   1484          
   1485          /********************************************************************************************************
   1486          ** 函数名称: CardMachineAlarmMaxRead
   1487          ** 功能描述:
   1488          ** 输 　 入:
   1489          **
   1490          ** 输　  出:
   1491          **
   1492          ** 全局变量:
   1493          ** 调用模块:
   1494          **
   1495          ** 作　  者: John Tonny
   1496          ** 日　  期: 2005年05月01日
   1497          **------------------------------------------------------------------------------------------------------
   1498          ** 修 改 人:
   1499          ** 日　  期:
   1500          **------------------------------------------------------------------------------------------------------
   1501          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1502          void CardMachineAlarmMaxRead(CardMachineRxData *pcommData)
   1503          {
   \                     CardMachineAlarmMaxRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1504            INT8U ucData[64];
   1505            INT8U ucTmp;	
   1506            
   1507            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD034             BEQ.N    ??CardMachineAlarmMaxRead_0
   1508              if(EepromReadVerifyBytes(CARDMACHINE_ALARM_MAX_ADDR,&ucTmp,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x203C             MOVS     R0,#+60
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD020             BEQ.N    ??CardMachineAlarmMaxRead_1
   1509                if(ucTmp>CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDB07             BLT.N    ??CardMachineAlarmMaxRead_2
   1510                  ucTmp=CARDMACHINE_ALARM_MAX_COUNTS;
   \   00000028   0x205A             MOVS     R0,#+90
   \   0000002A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1511                  EepromWriteVerifyBytes(CARDMACHINE_ALARM_MAX_ADDR,&ucTmp,1);
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0x203C             MOVS     R0,#+60
   \   00000034   0x.... 0x....      BL       EepromWriteVerifyBytes
   1512                }
   1513                ucData[0]=pcommData->ucData[0];
   \                     ??CardMachineAlarmMaxRead_2: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1514                SprintF(&ucData[1],4,ucTmp);
   \   0000003E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000048   0x.... 0x....      BL       SprintF
   1515                Uart0Pack(INFTYPE_BOX_CRITIMAX,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2005             MOVS     R0,#+5
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xAB03             ADD      R3,SP,#+12
   \   00000056   0x78A2             LDRB     R2,[R4, #+2]
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0x206B             MOVS     R0,#+107
   \   0000005C   0x.... 0x....      BL       Uart0Pack
   \   00000060   0xE00C             B.N      ??CardMachineAlarmMaxRead_0
   1516              }else{
   1517                ucData[0]=SUBTYPE_ERR_READ_INF;
   \                     ??CardMachineAlarmMaxRead_1: (+1)
   \   00000062   0x2035             MOVS     R0,#+53
   \   00000064   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1518                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xAB03             ADD      R3,SP,#+12
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x205E             MOVS     R0,#+94
   \   00000078   0x.... 0x....      BL       Uart0Pack
   1519              }
   1520            }
   1521          }
   \                     ??CardMachineAlarmMaxRead_0: (+1)
   \   0000007C   0xB014             ADD      SP,SP,#+80
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
   1522          
   1523          /********************************************************************************************************
   1524          ** 函数名称: CardMachineAlarmMinWrite
   1525          ** 功能描述:
   1526          ** 输 　 入:
   1527          **
   1528          ** 输　  出:
   1529          **
   1530          ** 全局变量:
   1531          ** 调用模块:
   1532          **
   1533          ** 作　  者: John Tonny
   1534          ** 日　  期: 2005年05月01日
   1535          **------------------------------------------------------------------------------------------------------
   1536          ** 修 改 人:
   1537          ** 日　  期:
   1538          **------------------------------------------------------------------------------------------------------
   1539          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1540          void CardMachineAlarmMinWrite(CardMachineRxData *pcommData)
   1541          {
   \                     CardMachineAlarmMinWrite: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1542            INT8U ucData[64];
   1543            INT8U ucTmp;
   1544            INT8U i;
   1545            
   1546            if(Uart0LengthProcess(pcommData,5)){			
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD048             BEQ.N    ??CardMachineAlarmMinWrite_0
   1547              pcommData->ucData[5]=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7260             STRB     R0,[R4, #+9]
   1548              ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \   00000016   0x1D60             ADDS     R0,R4,#+5
   \   00000018   0x.... 0x....      BL       atoi
   \   0000001C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1549              if(ucTmp<=CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDA33             BGE.N    ??CardMachineAlarmMinWrite_1
   1550                if(EepromWriteVerifyBytes(CARDMACHINE_ALARM_MIN_ADDR,&ucTmp,1)){
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0x2040             MOVS     R0,#+64
   \   0000002E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD01E             BEQ.N    ??CardMachineAlarmMinWrite_2
   1551                  for(i=0;i<CARDMACHINE_CARDBOX_NUMS;i++){
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0005             MOVS     R5,R0
   \                     ??CardMachineAlarmMinWrite_3: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D03             CMP      R5,#+3
   \   0000003E   0xDA09             BGE.N    ??CardMachineAlarmMinWrite_4
   1552                    m_usrBoxInfo[i].ucAlarmMin=ucTmp;
   \   00000040   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x016A             LSLS     R2,R5,#+5
   \   0000004C   0x4411             ADD      R1,R1,R2
   \   0000004E   0x7248             STRB     R0,[R1, #+9]
   1553                  }
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0xE7F2             B.N      ??CardMachineAlarmMinWrite_3
   1554                  Mem_Copy(ucData,pcommData->ucData,5);
   \                     ??CardMachineAlarmMinWrite_4: (+1)
   \   00000054   0x2205             MOVS     R2,#+5
   \   00000056   0x1D21             ADDS     R1,R4,#+4
   \   00000058   0xA803             ADD      R0,SP,#+12
   \   0000005A   0x.... 0x....      BL       Mem_Copy
   1555                  Uart0Pack(INFTYPE_BOX_CRITIMIN,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0x2005             MOVS     R0,#+5
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0xAB03             ADD      R3,SP,#+12
   \   00000068   0x78A2             LDRB     R2,[R4, #+2]
   \   0000006A   0x7861             LDRB     R1,[R4, #+1]
   \   0000006C   0x206C             MOVS     R0,#+108
   \   0000006E   0x.... 0x....      BL       Uart0Pack
   \   00000072   0xE017             B.N      ??CardMachineAlarmMinWrite_0
   1556                }else{
   1557                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??CardMachineAlarmMinWrite_2: (+1)
   \   00000074   0x2034             MOVS     R0,#+52
   \   00000076   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1558                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9001             STR      R0,[SP, #+4]
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xAB03             ADD      R3,SP,#+12
   \   00000084   0x78A2             LDRB     R2,[R4, #+2]
   \   00000086   0x7861             LDRB     R1,[R4, #+1]
   \   00000088   0x205E             MOVS     R0,#+94
   \   0000008A   0x.... 0x....      BL       Uart0Pack
   \   0000008E   0xE009             B.N      ??CardMachineAlarmMinWrite_0
   1559                }
   1560              }else{
   1561                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardMachineAlarmMinWrite_1: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x9001             STR      R0,[SP, #+4]
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x2300             MOVS     R3,#+0
   \   0000009A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000009C   0x7861             LDRB     R1,[R4, #+1]
   \   0000009E   0x20C5             MOVS     R0,#+197
   \   000000A0   0x.... 0x....      BL       Uart0Pack
   1562              }
   1563            }
   1564          }
   \                     ??CardMachineAlarmMinWrite_0: (+1)
   \   000000A4   0xB013             ADD      SP,SP,#+76
   \   000000A6   0xBD30             POP      {R4,R5,PC}       ;; return
   1565          
   1566          /********************************************************************************************************
   1567          ** 函数名称: CardMachineAlarmMinRead
   1568          ** 功能描述:
   1569          ** 输 　 入:
   1570          **
   1571          ** 输　  出:
   1572          **
   1573          ** 全局变量:
   1574          ** 调用模块:
   1575          **
   1576          ** 作　  者: John Tonny
   1577          ** 日　  期: 2005年05月01日
   1578          **------------------------------------------------------------------------------------------------------
   1579          ** 修 改 人:
   1580          ** 日　  期:
   1581          **------------------------------------------------------------------------------------------------------
   1582          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1583          void CardMachineAlarmMinRead(CardMachineRxData *pcommData)
   1584          {
   \                     CardMachineAlarmMinRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1585            INT8U ucData[64];
   1586            INT8U ucTmp;	
   1587            
   1588            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD034             BEQ.N    ??CardMachineAlarmMinRead_0
   1589              if(EepromReadVerifyBytes(CARDMACHINE_ALARM_MIN_ADDR,&ucTmp,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD020             BEQ.N    ??CardMachineAlarmMinRead_1
   1590                if(ucTmp>CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDB07             BLT.N    ??CardMachineAlarmMinRead_2
   1591                  ucTmp=CARDMACHINE_ALARM_MIN_COUNTS;
   \   00000028   0x200A             MOVS     R0,#+10
   \   0000002A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1592                  EepromWriteVerifyBytes(CARDMACHINE_ALARM_MIN_ADDR,&ucTmp,1);
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x.... 0x....      BL       EepromWriteVerifyBytes
   1593                }
   1594                ucData[0]=pcommData->ucData[0];
   \                     ??CardMachineAlarmMinRead_2: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1595                SprintF(&ucData[1],4,ucTmp);
   \   0000003E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000048   0x.... 0x....      BL       SprintF
   1596                Uart0Pack(INFTYPE_BOX_CRITIMIN,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2005             MOVS     R0,#+5
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xAB03             ADD      R3,SP,#+12
   \   00000056   0x78A2             LDRB     R2,[R4, #+2]
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0x206C             MOVS     R0,#+108
   \   0000005C   0x.... 0x....      BL       Uart0Pack
   \   00000060   0xE00C             B.N      ??CardMachineAlarmMinRead_0
   1597              }else{
   1598                ucData[0]=SUBTYPE_ERR_READ_INF;
   \                     ??CardMachineAlarmMinRead_1: (+1)
   \   00000062   0x2035             MOVS     R0,#+53
   \   00000064   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1599                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xAB03             ADD      R3,SP,#+12
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x205E             MOVS     R0,#+94
   \   00000078   0x.... 0x....      BL       Uart0Pack
   1600              }
   1601            }
   1602          }
   \                     ??CardMachineAlarmMinRead_0: (+1)
   \   0000007C   0xB014             ADD      SP,SP,#+80
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
   1603          
   1604          /********************************************************************************************************
   1605          ** 函数名称: CardMachineMaxCountWrite
   1606          ** 功能描述:
   1607          ** 输 　 入:
   1608          **
   1609          ** 输　  出:
   1610          **
   1611          ** 全局变量:
   1612          ** 调用模块:
   1613          **
   1614          ** 作　  者: John Tonny
   1615          ** 日　  期: 2005年05月01日
   1616          **------------------------------------------------------------------------------------------------------
   1617          ** 修 改 人:
   1618          ** 日　  期:
   1619          **------------------------------------------------------------------------------------------------------
   1620          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1621          void CardMachineMaxCountWrite(CardMachineRxData *pcommData)
   1622          {
   \                     CardMachineMaxCountWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1623            INT8U ucData[64];
   1624            INT8U ucTmp;
   1625            
   1626            if(Uart0LengthProcess(pcommData,5)){			
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD039             BEQ.N    ??CardMachineMaxCountWrite_0
   1627              pcommData->ucData[5]=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7260             STRB     R0,[R4, #+9]
   1628              ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \   00000016   0x1D60             ADDS     R0,R4,#+5
   \   00000018   0x.... 0x....      BL       atoi
   \   0000001C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1629              if(ucTmp<=CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDA24             BGE.N    ??CardMachineMaxCountWrite_1
   1630                if(EepromWriteVerifyBytes(CARDMACHINE_MAXCOUNT_ADDR,&ucTmp,1)){
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0xA902             ADD      R1,SP,#+8
   \   0000002C   0x2038             MOVS     R0,#+56
   \   0000002E   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00F             BEQ.N    ??CardMachineMaxCountWrite_2
   1631                  Mem_Copy(ucData,pcommData->ucData,5);
   \   00000036   0x2205             MOVS     R2,#+5
   \   00000038   0x1D21             ADDS     R1,R4,#+4
   \   0000003A   0xA803             ADD      R0,SP,#+12
   \   0000003C   0x.... 0x....      BL       Mem_Copy
   1632                  Uart0Pack(INFTYPE_CARD_DEV_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9001             STR      R0,[SP, #+4]
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0xAB03             ADD      R3,SP,#+12
   \   0000004A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000004C   0x7861             LDRB     R1,[R4, #+1]
   \   0000004E   0x2060             MOVS     R0,#+96
   \   00000050   0x.... 0x....      BL       Uart0Pack
   \   00000054   0xE017             B.N      ??CardMachineMaxCountWrite_0
   1633                }else{
   1634                  ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \                     ??CardMachineMaxCountWrite_2: (+1)
   \   00000056   0x2034             MOVS     R0,#+52
   \   00000058   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1635                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9001             STR      R0,[SP, #+4]
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0xAB03             ADD      R3,SP,#+12
   \   00000066   0x78A2             LDRB     R2,[R4, #+2]
   \   00000068   0x7861             LDRB     R1,[R4, #+1]
   \   0000006A   0x205E             MOVS     R0,#+94
   \   0000006C   0x.... 0x....      BL       Uart0Pack
   \   00000070   0xE009             B.N      ??CardMachineMaxCountWrite_0
   1636                }
   1637              }else{
   1638                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardMachineMaxCountWrite_1: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9001             STR      R0,[SP, #+4]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9000             STR      R0,[SP, #+0]
   \   0000007A   0x2300             MOVS     R3,#+0
   \   0000007C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000007E   0x7861             LDRB     R1,[R4, #+1]
   \   00000080   0x20C5             MOVS     R0,#+197
   \   00000082   0x.... 0x....      BL       Uart0Pack
   1639              }
   1640            }
   1641          }
   \                     ??CardMachineMaxCountWrite_0: (+1)
   \   00000086   0xB014             ADD      SP,SP,#+80
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
   1642          
   1643          /********************************************************************************************************
   1644          ** 函数名称: CardMachineMaxCountRead
   1645          ** 功能描述:
   1646          ** 输 　 入:
   1647          **
   1648          ** 输　  出:
   1649          **
   1650          ** 全局变量:
   1651          ** 调用模块:
   1652          **
   1653          ** 作　  者: John Tonny
   1654          ** 日　  期: 2005年05月01日
   1655          **------------------------------------------------------------------------------------------------------
   1656          ** 修 改 人:
   1657          ** 日　  期:
   1658          **------------------------------------------------------------------------------------------------------
   1659          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1660          void CardMachineMaxCountRead(CardMachineRxData *pcommData)
   1661          {
   \                     CardMachineMaxCountRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   1662            INT8U ucData[64];
   1663            INT8U ucTmp;	
   1664            
   1665            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD035             BEQ.N    ??CardMachineMaxCountRead_0
   1666              if(EepromReadVerifyBytes(CARDMACHINE_MAXCOUNT_ADDR,&ucTmp,1)){
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x2038             MOVS     R0,#+56
   \   00000018   0x.... 0x....      BL       EepromReadVerifyBytes
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD021             BEQ.N    ??CardMachineMaxCountRead_1
   1667                if(ucTmp>CARDMACHINE_MAX_COUNTS){
   \   00000020   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000024   0x2865             CMP      R0,#+101
   \   00000026   0xDB07             BLT.N    ??CardMachineMaxCountRead_2
   1668                  ucTmp=CARDMACHINE_MAX_COUNTS;
   \   00000028   0x2064             MOVS     R0,#+100
   \   0000002A   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1669                  EepromWriteVerifyBytes(CARDMACHINE_MAXCOUNT_ADDR,&ucTmp,1);
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA902             ADD      R1,SP,#+8
   \   00000032   0x2038             MOVS     R0,#+56
   \   00000034   0x.... 0x....      BL       EepromWriteVerifyBytes
   1670                }
   1671                ucData[0]=pcommData->ucData[0];
   \                     ??CardMachineMaxCountRead_2: (+1)
   \   00000038   0x7920             LDRB     R0,[R4, #+4]
   \   0000003A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1672                SprintF(&ucData[1],4,ucTmp);
   \   0000003E   0xF89D 0x2008      LDRB     R2,[SP, #+8]
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000048   0x.... 0x....      BL       SprintF
   1673                Uart0Pack(ucData[0],pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2005             MOVS     R0,#+5
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xAB03             ADD      R3,SP,#+12
   \   00000056   0x78A2             LDRB     R2,[R4, #+2]
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000005E   0x.... 0x....      BL       Uart0Pack
   \   00000062   0xE00C             B.N      ??CardMachineMaxCountRead_0
   1674              }else{
   1675                ucData[0]=SUBTYPE_ERR_READ_INF;
   \                     ??CardMachineMaxCountRead_1: (+1)
   \   00000064   0x2035             MOVS     R0,#+53
   \   00000066   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1676                Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9001             STR      R0,[SP, #+4]
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0xAB03             ADD      R3,SP,#+12
   \   00000074   0x78A2             LDRB     R2,[R4, #+2]
   \   00000076   0x7861             LDRB     R1,[R4, #+1]
   \   00000078   0x205E             MOVS     R0,#+94
   \   0000007A   0x.... 0x....      BL       Uart0Pack
   1677              }
   1678            }
   1679          }
   \                     ??CardMachineMaxCountRead_0: (+1)
   \   0000007E   0xB014             ADD      SP,SP,#+80
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   1680          
   1681          /********************************************************************************************************
   1682          ** 函数名称: CardMachineStateRead
   1683          ** 功能描述:
   1684          ** 输 　 入:
   1685          **
   1686          ** 输　  出:
   1687          **
   1688          ** 全局变量:
   1689          ** 调用模块:
   1690          **
   1691          ** 作　  者: John Tonny
   1692          ** 日　  期: 2005年05月01日
   1693          **------------------------------------------------------------------------------------------------------
   1694          ** 修 改 人:
   1695          ** 日　  期:
   1696          **------------------------------------------------------------------------------------------------------
   1697          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1698          void CardMachineStateRead(CardMachineRxData *pcommData)
   1699          {
   \                     CardMachineStateRead: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1700            INT32U ulTmp;
   1701            
   1702            CPU_SR_ALLOC();
   \   00000004   0x2500             MOVS     R5,#+0
   1703            if(Uart0LengthProcess(pcommData,0)){		
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD018             BEQ.N    ??CardMachineStateRead_0
   1704              OS_ENTER_CRITICAL();
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   \   00000016   0x0005             MOVS     R5,R0
   \   00000018   0x.... 0x....      BL       CPU_IntDisMeasStart
   1705              ulTmp=~g_usrGetKey.ulKeyOutput;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000020   0x6940             LDR      R0,[R0, #+20]
   \   00000022   0x43C0             MVNS     R0,R0
   \   00000024   0x9002             STR      R0,[SP, #+8]
   1706              OS_EXIT_CRITICAL();
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
   1707              Uart0Pack(INFTYPE_DEVICE_STATUS,pcommData->ucAddr,pcommData->ucSeq,(INT8U *)&ulTmp,4,0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0xAB02             ADD      R3,SP,#+8
   \   0000003A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000003C   0x7861             LDRB     R1,[R4, #+1]
   \   0000003E   0x2067             MOVS     R0,#+103
   \   00000040   0x.... 0x....      BL       Uart0Pack
   1708            }
   1709          }
   \                     ??CardMachineStateRead_0: (+1)
   \   00000044   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1710          
   1711          /********************************************************************************************************
   1712          ** 函数名称: CardMachineTypeRead
   1713          ** 功能描述:
   1714          ** 输 　 入:
   1715          **
   1716          ** 输　  出:
   1717          **
   1718          ** 全局变量:
   1719          ** 调用模块:
   1720          **
   1721          ** 作　  者: John Tonny
   1722          ** 日　  期: 2005年05月01日
   1723          **------------------------------------------------------------------------------------------------------
   1724          ** 修 改 人:
   1725          ** 日　  期:
   1726          **------------------------------------------------------------------------------------------------------
   1727          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1728          void CardMachineTypeRead(CardMachineRxData *pcommData)
   1729          {
   \                     CardMachineTypeRead: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1730            INT8U ucData[64];
   1731            
   1732            if(Uart0LengthProcess(pcommData,0)){			
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD058             BEQ.N    ??CardMachineTypeRead_0
   1733              if(DEV_TYPE()==SMALL_THICK_OUT_TYPE){
   \   00000012   0x.... 0x....      BL       DEV_TYPE
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD10D             BNE.N    ??CardMachineTypeRead_1
   1734                //小发卡机
   1735                ucData[0]=SMALL_THICK_OUT_DEVICE_TYPE;
   \   0000001A   0x2080             MOVS     R0,#+128
   \   0000001C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1736                Uart0Pack(INFTYPE_DEVICE_TYPE,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0xAB02             ADD      R3,SP,#+8
   \   0000002A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000002C   0x7861             LDRB     R1,[R4, #+1]
   \   0000002E   0x2066             MOVS     R0,#+102
   \   00000030   0x.... 0x....      BL       Uart0Pack
   \   00000034   0xE046             B.N      ??CardMachineTypeRead_0
   1737              }else if(DEV_TYPE()==SMALL_THICK_IN_TYPE){
   \                     ??CardMachineTypeRead_1: (+1)
   \   00000036   0x.... 0x....      BL       DEV_TYPE
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD10D             BNE.N    ??CardMachineTypeRead_2
   1738                //小收卡机
   1739                ucData[0]=SMALL_THICK_IN_DEVICE_TYPE;
   \   0000003E   0x2082             MOVS     R0,#+130
   \   00000040   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1740                Uart0Pack(INFTYPE_DEVICE_TYPE,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xAB02             ADD      R3,SP,#+8
   \   0000004E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000050   0x7861             LDRB     R1,[R4, #+1]
   \   00000052   0x2066             MOVS     R0,#+102
   \   00000054   0x.... 0x....      BL       Uart0Pack
   \   00000058   0xE034             B.N      ??CardMachineTypeRead_0
   1741              }else if(DEV_TYPE()==LARGE_THICK_OUT_TYPE){
   \                     ??CardMachineTypeRead_2: (+1)
   \   0000005A   0x.... 0x....      BL       DEV_TYPE
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD10D             BNE.N    ??CardMachineTypeRead_3
   1742                ucData[0]=LARGE_THICK_OUT_DEVICE_TYPE;
   \   00000062   0x2084             MOVS     R0,#+132
   \   00000064   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1743                Uart0Pack(INFTYPE_DEVICE_TYPE,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xAB02             ADD      R3,SP,#+8
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x2066             MOVS     R0,#+102
   \   00000078   0x.... 0x....      BL       Uart0Pack
   \   0000007C   0xE022             B.N      ??CardMachineTypeRead_0
   1744              }else if(DEV_TYPE()==SMALL_THICK_GIN_TYPE){
   \                     ??CardMachineTypeRead_3: (+1)
   \   0000007E   0x.... 0x....      BL       DEV_TYPE
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD10D             BNE.N    ??CardMachineTypeRead_4
   1745                ucData[0]=SMALL_THICK_GIN_DEVICE_TYPE;
   \   00000086   0x2085             MOVS     R0,#+133
   \   00000088   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1746                Uart0Pack(INFTYPE_DEVICE_TYPE,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0xAB02             ADD      R3,SP,#+8
   \   00000096   0x78A2             LDRB     R2,[R4, #+2]
   \   00000098   0x7861             LDRB     R1,[R4, #+1]
   \   0000009A   0x2066             MOVS     R0,#+102
   \   0000009C   0x.... 0x....      BL       Uart0Pack
   \   000000A0   0xE010             B.N      ??CardMachineTypeRead_0
   1747              }else if(DEV_TYPE()==SMALL_THICK_ZIN_TYPE){
   \                     ??CardMachineTypeRead_4: (+1)
   \   000000A2   0x.... 0x....      BL       DEV_TYPE
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD10C             BNE.N    ??CardMachineTypeRead_0
   1748                ucData[0]=SMALL_THICK_IN_DEVICE_TYPE;
   \   000000AA   0x2082             MOVS     R0,#+130
   \   000000AC   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1749                Uart0Pack(INFTYPE_DEVICE_TYPE,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x9001             STR      R0,[SP, #+4]
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x9000             STR      R0,[SP, #+0]
   \   000000B8   0xAB02             ADD      R3,SP,#+8
   \   000000BA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000BC   0x7861             LDRB     R1,[R4, #+1]
   \   000000BE   0x2066             MOVS     R0,#+102
   \   000000C0   0x.... 0x....      BL       Uart0Pack
   1750              }else{
   1751              }
   1752            }
   1753          }
   \                     ??CardMachineTypeRead_0: (+1)
   \   000000C4   0xB012             ADD      SP,SP,#+72
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
   1754          
   1755          /********************************************************************************************************
   1756          ** 函数名称: CardMachineVersionRead
   1757          ** 功能描述:
   1758          ** 输 　 入:
   1759          **
   1760          ** 输　  出:
   1761          **
   1762          ** 全局变量:
   1763          ** 调用模块:
   1764          **
   1765          ** 作　  者: John Tonny
   1766          ** 日　  期: 2005年05月01日
   1767          **------------------------------------------------------------------------------------------------------
   1768          ** 修 改 人:
   1769          ** 日　  期:
   1770          **------------------------------------------------------------------------------------------------------
   1771          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1772          void CardMachineVersionRead(CardMachineRxData *pcommData)
   1773          {
   \                     CardMachineVersionRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1774            INT8U ucData[64];
   1775            INT8U ucLen;
   1776            
   1777            if(Uart0LengthProcess(pcommData,1)){	
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00E             BEQ.N    ??CardMachineVersionRead_0
   1778              ucLen=GetVersion(ucData);
   \   00000012   0xA802             ADD      R0,SP,#+8
   \   00000014   0x.... 0x....      BL       GetVersion
   \   00000018   0x0005             MOVS     R5,R0
   1779              Uart0Pack(INFTYPE_DEVICE_VER,pcommData->ucAddr,pcommData->ucSeq,ucData,ucLen,0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xAB02             ADD      R3,SP,#+8
   \   00000026   0x78A2             LDRB     R2,[R4, #+2]
   \   00000028   0x7861             LDRB     R1,[R4, #+1]
   \   0000002A   0x206F             MOVS     R0,#+111
   \   0000002C   0x.... 0x....      BL       Uart0Pack
   1780            }
   1781          }
   \                     ??CardMachineVersionRead_0: (+1)
   \   00000030   0xB013             ADD      SP,SP,#+76
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
   1782          
   1783          /********************************************************************************************************
   1784          ** 函数名称: CardMachineDataRead
   1785          ** 功能描述:
   1786          ** 输 　 入:
   1787          **
   1788          ** 输　  出:
   1789          **
   1790          ** 全局变量:
   1791          ** 调用模块:
   1792          **
   1793          ** 作　  者: John Tonny
   1794          ** 日　  期: 2005年05月01日
   1795          **------------------------------------------------------------------------------------------------------
   1796          ** 修 改 人:
   1797          ** 日　  期:
   1798          **------------------------------------------------------------------------------------------------------
   1799          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1800          void CardMachineDataRead(CardMachineRxData *pcommData)
   1801          {
   \                     CardMachineDataRead: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1802            INT8U ucData[64];
   1803            INT8S usLen;
   1804            INT8S usAddr;
   1805            INT8S usAddr1;
   1806            
   1807            if(Uart0LengthProcess(pcommData,3)){	
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD051             BEQ.N    ??CardMachineDataRead_0
   1808              usAddr=AscToByte(pcommData->ucData[0]);
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x.... 0x....      BL       AscToByte
   \   00000018   0x0007             MOVS     R7,R0
   1809              usAddr1=AscToByte(pcommData->ucData[1]);
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x.... 0x....      BL       AscToByte
   \   00000020   0x0006             MOVS     R6,R0
   1810              usLen=AscToByte(pcommData->ucData[2]);
   \   00000022   0x79A0             LDRB     R0,[R4, #+6]
   \   00000024   0x.... 0x....      BL       AscToByte
   \   00000028   0x0005             MOVS     R5,R0
   1811              if(usAddr<0 || usAddr1<0 || usLen<0){
   \   0000002A   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD405             BMI.N    ??CardMachineDataRead_1
   \   00000030   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD402             BMI.N    ??CardMachineDataRead_1
   \   00000036   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD500             BPL.N    ??CardMachineDataRead_2
   1812                return;
   \                     ??CardMachineDataRead_1: (+1)
   \   0000003C   0xE03B             B.N      ??CardMachineDataRead_3
   1813              }
   1814              usAddr=(usAddr<<4)+usAddr1;
   \                     ??CardMachineDataRead_2: (+1)
   \   0000003E   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000040   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000042   0xEB16 0x1707      ADDS     R7,R6,R7, LSL #+4
   1815              usAddr=(usAddr/8)*8;
   \   00000046   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000048   0x2008             MOVS     R0,#+8
   \   0000004A   0xFB97 0xF0F0      SDIV     R0,R7,R0
   \   0000004E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000050   0x00C7             LSLS     R7,R0,#+3
   1816              if(usAddr+usLen<256 && usLen<=8){
   \   00000052   0xB27F             SXTB     R7,R7            ;; SignExt  R7,R7,#+24,#+24
   \   00000054   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000056   0x19E8             ADDS     R0,R5,R7
   \   00000058   0x28FF             CMP      R0,#+255
   \   0000005A   0xDC2C             BGT.N    ??CardMachineDataRead_0
   \   0000005C   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   0000005E   0x2D09             CMP      R5,#+9
   \   00000060   0xDA29             BGE.N    ??CardMachineDataRead_0
   1817                ucData[0]=pcommData->ucData[0];
   \   00000062   0x7920             LDRB     R0,[R4, #+4]
   \   00000064   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1818                ucData[1]=pcommData->ucData[1];
   \   00000068   0x7960             LDRB     R0,[R4, #+5]
   \   0000006A   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1819                ucData[2]=pcommData->ucData[2];
   \   0000006E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000070   0xF88D 0x000A      STRB     R0,[SP, #+10]
   1820                EepromReadBytes((INT8U)usAddr,&ucData[32],(INT8U)usLen);
   \   00000074   0x002A             MOVS     R2,R5
   \   00000076   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000078   0xA90A             ADD      R1,SP,#+40
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x.... 0x....      BL       EepromReadBytes
   1821                BytesToAscs(&ucData[32],(INT8U)usLen,&ucData[3]);
   \   00000082   0xF10D 0x020B      ADD      R2,SP,#+11
   \   00000086   0x0029             MOVS     R1,R5
   \   00000088   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008A   0xA80A             ADD      R0,SP,#+40
   \   0000008C   0x.... 0x....      BL       BytesToAscs
   1822                ucData[3+usLen*2]=pcommData->ucCmd;
   \   00000090   0x78E0             LDRB     R0,[R4, #+3]
   \   00000092   0xA902             ADD      R1,SP,#+8
   \   00000094   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   00000096   0xEB01 0x0145      ADD      R1,R1,R5, LSL #+1
   \   0000009A   0x70C8             STRB     R0,[R1, #+3]
   1823                Uart0Pack(pcommData->ucCmd,pcommData->ucAddr,pcommData->ucSeq,ucData,4+usLen*2,0);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0xB26D             SXTB     R5,R5            ;; SignExt  R5,R5,#+24,#+24
   \   000000A2   0x0068             LSLS     R0,R5,#+1
   \   000000A4   0x1D00             ADDS     R0,R0,#+4
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0xAB02             ADD      R3,SP,#+8
   \   000000AC   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AE   0x7861             LDRB     R1,[R4, #+1]
   \   000000B0   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B2   0x.... 0x....      BL       Uart0Pack
   1824              }
   1825            }
   1826          }
   \                     ??CardMachineDataRead_0: (+1)
   \                     ??CardMachineDataRead_3: (+1)
   \   000000B6   0xB013             ADD      SP,SP,#+76
   \   000000B8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1827          
   1828          /********************************************************************************************************
   1829          ** 函数名称: CardMachineDataWrite
   1830          ** 功能描述:
   1831          ** 输 　 入:
   1832          **
   1833          ** 输　  出:
   1834          **
   1835          ** 全局变量:
   1836          ** 调用模块:
   1837          **
   1838          ** 作　  者: John Tonny
   1839          ** 日　  期: 2005年05月01日
   1840          **------------------------------------------------------------------------------------------------------
   1841          ** 修 改 人:
   1842          ** 日　  期:
   1843          **------------------------------------------------------------------------------------------------------
   1844          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1845          void CardMachineDataWrite(CardMachineRxData *pcommData)
   1846          {
   \                     CardMachineDataWrite: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1847            if(Uart0LengthProcess(pcommData,0)){	
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       Uart0LengthProcess
   1848                    
   1849            }
   1850          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
   1851          
   1852          /********************************************************************************************************
   1853          ** 函数名称: CardBoxVersionRead
   1854          ** 功能描述:
   1855          ** 输 　 入:
   1856          **
   1857          ** 输　  出:
   1858          **
   1859          ** 全局变量:
   1860          ** 调用模块:
   1861          **
   1862          ** 作　  者: John Tonny
   1863          ** 日　  期: 2005年05月01日
   1864          **------------------------------------------------------------------------------------------------------
   1865          ** 修 改 人:
   1866          ** 日　  期:
   1867          **------------------------------------------------------------------------------------------------------
   1868          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1869          void CardBoxVersionRead(CardMachineRxData *pcommData)
   1870          {
   \                     CardBoxVersionRead: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   1871            INT8U ucData[64];
   1872            INT8U ucSelected;
   1873            
   1874            if(Uart0LengthProcess(pcommData,1)){	
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01C             BEQ.N    ??CardBoxVersionRead_0
   1875              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
   1876              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D03             CMP      R5,#+3
   \   0000001C   0xDA0C             BGE.N    ??CardBoxVersionRead_1
   1877              #if BOARD_OLD_EN==0
   1878                ucData[0]=pcommData->ucSeq;
   \   0000001E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000020   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1879                UartPack(CARDMACHINE_READ_VERSION_CMD,UART_RESPONSE_MODE,1,ucData,ucSelected);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0xAB02             ADD      R3,SP,#+8
   \   0000002C   0x2201             MOVS     R2,#+1
   \   0000002E   0x2140             MOVS     R1,#+64
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x.... 0x....      BL       UartPack
   \   00000036   0xE009             B.N      ??CardBoxVersionRead_0
   1880              #else
   1881                ucData[0]=BOX_UART_SEND_MSG;
   1882                ucData[1]=CARDMACHINE_READ_VERSION_CMD;
   1883                ucData[2]=UART_RESPONSE_MODE;
   1884                ucData[3]=ucSelected;
   1885                
   1886                ucData[4]=pcommData->ucSeq;
   1887                BoxPostMsg(ucData,5);
   1888              #endif          
   1889              }else{
   1890                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxVersionRead_1: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x78A2             LDRB     R2,[R4, #+2]
   \   00000044   0x7861             LDRB     R1,[R4, #+1]
   \   00000046   0x20C5             MOVS     R0,#+197
   \   00000048   0x.... 0x....      BL       Uart0Pack
   1891              }
   1892            }
   1893          }
   \                     ??CardBoxVersionRead_0: (+1)
   \   0000004C   0xB013             ADD      SP,SP,#+76
   \   0000004E   0xBD30             POP      {R4,R5,PC}       ;; return
   1894          
   1895          /********************************************************************************************************
   1896          ** 函数名称: CardBoxIdWrite
   1897          ** 功能描述:
   1898          ** 输 　 入:
   1899          **
   1900          ** 输　  出:
   1901          **
   1902          ** 全局变量:
   1903          ** 调用模块:
   1904          **
   1905          ** 作　  者: John Tonny
   1906          ** 日　  期: 2005年05月01日
   1907          **------------------------------------------------------------------------------------------------------
   1908          ** 修 改 人:
   1909          ** 日　  期:
   1910          **------------------------------------------------------------------------------------------------------
   1911          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1912          void CardBoxIdWrite(CardMachineRxData *pcommData)
   1913          {
   \                     CardBoxIdWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1914            INT8U ucSelected;	
   1915            INT8U ucData[64];
   1916            INT32U *pulTmp;
   1917            
   1918            if(Uart0LengthProcess(pcommData,9)){		
   \   00000006   0x2109             MOVS     R1,#+9
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD034             BEQ.N    ??CardBoxIdWrite_0
   1919              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
   1920              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D03             CMP      R5,#+3
   \   0000001C   0xDA24             BGE.N    ??CardBoxIdWrite_1
   1921              #if BOARD_OLD_EN==0
   1922                pulTmp=(INT32U *)&ucData[0];
   \   0000001E   0xA802             ADD      R0,SP,#+8
   \   00000020   0x0006             MOVS     R6,R0
   1923                pcommData->ucData[9]=0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7360             STRB     R0,[R4, #+13]
   1924                *pulTmp=atoi((const char *)&pcommData->ucData[1]);
   \   00000026   0x1D60             ADDS     R0,R4,#+5
   \   00000028   0x.... 0x....      BL       atoi
   \   0000002C   0x6030             STR      R0,[R6, #+0]
   1925                if(*pulTmp>99999999){
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable34_1  ;; 0x5f5e100
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD30A             BCC.N    ??CardBoxIdWrite_2
   1926                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x78A2             LDRB     R2,[R4, #+2]
   \   00000044   0x7861             LDRB     R1,[R4, #+1]
   \   00000046   0x20C5             MOVS     R0,#+197
   \   00000048   0x.... 0x....      BL       Uart0Pack
   \   0000004C   0xE016             B.N      ??CardBoxIdWrite_0
   1927                }else{
   1928                  ucData[4]=pcommData->ucSeq;
   \                     ??CardBoxIdWrite_2: (+1)
   \   0000004E   0x78A0             LDRB     R0,[R4, #+2]
   \   00000050   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1929                  UartPack(CARDMACHINE_WRITE_MACHINE_ID_CMD,UART_RESPONSE_MODE,5,ucData,ucSelected);
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x9000             STR      R0,[SP, #+0]
   \   0000005A   0xAB02             ADD      R3,SP,#+8
   \   0000005C   0x2205             MOVS     R2,#+5
   \   0000005E   0x2140             MOVS     R1,#+64
   \   00000060   0x2005             MOVS     R0,#+5
   \   00000062   0x.... 0x....      BL       UartPack
   \   00000066   0xE009             B.N      ??CardBoxIdWrite_0
   1930                }
   1931              #else
   1932                pulTmp=(INT32U *)&ucData[4];
   1933                pcommData->ucData[9]=0;
   1934                *pulTmp=atoi((const char *)&pcommData->ucData[1]);
   1935                if(*pulTmp>99999999){
   1936                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   1937                }else{
   1938                  ucData[0]=BOX_UART_SEND_MSG;
   1939                  ucData[1]=CARDMACHINE_WRITE_MACHINE_ID_CMD;
   1940                  ucData[2]=UART_RESPONSE_MODE;
   1941                  ucData[3]=ucSelected;
   1942                  
   1943                  ucData[8]=pcommData->ucSeq;
   1944                  BoxPostMsg(ucData,9);
   1945                }
   1946              #endif
   1947              }else{
   1948                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxIdWrite_1: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9001             STR      R0,[SP, #+4]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x2300             MOVS     R3,#+0
   \   00000072   0x78A2             LDRB     R2,[R4, #+2]
   \   00000074   0x7861             LDRB     R1,[R4, #+1]
   \   00000076   0x20C5             MOVS     R0,#+197
   \   00000078   0x.... 0x....      BL       Uart0Pack
   1949              }
   1950            }
   1951          }
   \                     ??CardBoxIdWrite_0: (+1)
   \   0000007C   0xB012             ADD      SP,SP,#+72
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
   1952          
   1953          /********************************************************************************************************
   1954          ** 函数名称: CardBoxIdRead
   1955          ** 功能描述:
   1956          ** 输 　 入:
   1957          **
   1958          ** 输　  出:
   1959          **
   1960          ** 全局变量:
   1961          ** 调用模块:
   1962          **
   1963          ** 作　  者: John Tonny
   1964          ** 日　  期: 2005年05月01日
   1965          **------------------------------------------------------------------------------------------------------
   1966          ** 修 改 人:
   1967          ** 日　  期:
   1968          
   1969          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1970          void CardBoxIdRead(CardMachineRxData *pcommData)
   1971          {
   \                     CardBoxIdRead: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   1972            INT8U ucData[64];
   1973            INT8U ucSelected;	
   1974            INT8U ucType=DEV_TYPE();
   \   00000006   0x.... 0x....      BL       DEV_TYPE
   \   0000000A   0x0006             MOVS     R6,R0
   1975            
   1976            if(Uart0LengthProcess(pcommData,1)){			
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Uart0LengthProcess
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD075             BEQ.N    ??CardBoxIdRead_0
   1977              ucSelected=pcommData->ucData[0]-0x30;
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x3830             SUBS     R0,R0,#+48
   \   0000001C   0x0005             MOVS     R5,R0
   1978              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D03             CMP      R5,#+3
   \   00000022   0xDA65             BGE.N    ??CardBoxIdRead_1
   1979                if(ucType==SMALL_THICK_ZIN_TYPE || ucType==SMALL_THIN_ZIN_TYPE){
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E02             CMP      R6,#+2
   \   00000028   0xD002             BEQ.N    ??CardBoxIdRead_2
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E0A             CMP      R6,#+10
   \   0000002E   0xD12A             BNE.N    ??CardBoxIdRead_3
   1980                  ucData[0]=pcommData->ucData[0];
   \                     ??CardBoxIdRead_2: (+1)
   \   00000030   0x7920             LDRB     R0,[R4, #+4]
   \   00000032   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1981                  if(m_usrBoxInfo[ucSelected].ulMachineId>99999999){
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x0169             LSLS     R1,R5,#+5
   \   0000003E   0x4408             ADD      R0,R0,R1
   \   00000040   0x6840             LDR      R0,[R0, #+4]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable34_1  ;; 0x5f5e100
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD307             BCC.N    ??CardBoxIdRead_4
   1982                    m_usrBoxInfo[ucSelected].ulMachineId=99999999;
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x5f5e0ff
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x016A             LSLS     R2,R5,#+5
   \   00000056   0x4411             ADD      R1,R1,R2
   \   00000058   0x6048             STR      R0,[R1, #+4]
   1983                  }
   1984                  SprintF(&ucData[1],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \                     ??CardBoxIdRead_4: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0x0169             LSLS     R1,R5,#+5
   \   00000062   0x4408             ADD      R0,R0,R1
   \   00000064   0x6842             LDR      R2,[R0, #+4]
   \   00000066   0x2108             MOVS     R1,#+8
   \   00000068   0xF10D 0x0009      ADD      R0,SP,#+9
   \   0000006C   0x.... 0x....      BL       SprintF
   1985                  Uart0Pack(INFYPTE_CARD_BOX_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,9,0);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9001             STR      R0,[SP, #+4]
   \   00000074   0x2009             MOVS     R0,#+9
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xAB02             ADD      R3,SP,#+8
   \   0000007A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000007C   0x7861             LDRB     R1,[R4, #+1]
   \   0000007E   0x2061             MOVS     R0,#+97
   \   00000080   0x.... 0x....      BL       Uart0Pack
   \   00000084   0xE03E             B.N      ??CardBoxIdRead_0
   1986                }else{
   1987                  if(m_usrBoxInfo[ucSelected].usrFlag.usrBit.bBoxLoad && m_usrBoxInfo[ucSelected].usrFlag.usrBit.bConnected){
   \                     ??CardBoxIdRead_3: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x0169             LSLS     R1,R5,#+5
   \   0000008E   0x4408             ADD      R0,R0,R1
   \   00000090   0x7B80             LDRB     R0,[R0, #+14]
   \   00000092   0xF010 0x0005      ANDS     R0,R0,#0x5
   \   00000096   0x2805             CMP      R0,#+5
   \   00000098   0xD134             BNE.N    ??CardBoxIdRead_0
   1988                    ucData[0]=pcommData->ucData[0];
   \   0000009A   0x7920             LDRB     R0,[R4, #+4]
   \   0000009C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1989                    if(m_usrBoxInfo[ucSelected].ulMachineId>99999999){
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x0169             LSLS     R1,R5,#+5
   \   000000A8   0x4408             ADD      R0,R0,R1
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable34_1  ;; 0x5f5e100
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD307             BCC.N    ??CardBoxIdRead_5
   1990                      m_usrBoxInfo[ucSelected].ulMachineId=99999999;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x5f5e0ff
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0x016A             LSLS     R2,R5,#+5
   \   000000C0   0x4411             ADD      R1,R1,R2
   \   000000C2   0x6048             STR      R0,[R1, #+4]
   1991                    }
   1992                    SprintF(&ucData[1],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \                     ??CardBoxIdRead_5: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0x0169             LSLS     R1,R5,#+5
   \   000000CC   0x4408             ADD      R0,R0,R1
   \   000000CE   0x6842             LDR      R2,[R0, #+4]
   \   000000D0   0x2108             MOVS     R1,#+8
   \   000000D2   0xF10D 0x0009      ADD      R0,SP,#+9
   \   000000D6   0x.... 0x....      BL       SprintF
   1993                    Uart0Pack(INFYPTE_CARD_BOX_SERIAL,pcommData->ucAddr,pcommData->ucSeq,ucData,9,0);
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x9001             STR      R0,[SP, #+4]
   \   000000DE   0x2009             MOVS     R0,#+9
   \   000000E0   0x9000             STR      R0,[SP, #+0]
   \   000000E2   0xAB02             ADD      R3,SP,#+8
   \   000000E4   0x78A2             LDRB     R2,[R4, #+2]
   \   000000E6   0x7861             LDRB     R1,[R4, #+1]
   \   000000E8   0x2061             MOVS     R0,#+97
   \   000000EA   0x.... 0x....      BL       Uart0Pack
   \   000000EE   0xE009             B.N      ??CardBoxIdRead_0
   1994                  }
   1995                }
   1996              }else{
   1997                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxIdRead_1: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x9001             STR      R0,[SP, #+4]
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x9000             STR      R0,[SP, #+0]
   \   000000F8   0x2300             MOVS     R3,#+0
   \   000000FA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000FC   0x7861             LDRB     R1,[R4, #+1]
   \   000000FE   0x20C5             MOVS     R0,#+197
   \   00000100   0x.... 0x....      BL       Uart0Pack
   1998              }
   1999            }
   2000          }
   \                     ??CardBoxIdRead_0: (+1)
   \   00000104   0xB012             ADD      SP,SP,#+72
   \   00000106   0xBD70             POP      {R4-R6,PC}       ;; return
   2001          
   2002          /********************************************************************************************************
   2003          ** 函数名称: CardBoxCountWrite
   2004          ** 功能描述:
   2005          ** 输 　 入:
   2006          **
   2007          ** 输　  出:
   2008          **
   2009          ** 全局变量:
   2010          ** 调用模块:
   2011          **
   2012          ** 作　  者: John Tonny
   2013          ** 日　  期: 2005年05月01日
   2014          **------------------------------------------------------------------------------------------------------
   2015          ** 修 改 人:
   2016          ** 日　  期:
   2017          **------------------------------------------------------------------------------------------------------
   2018          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2019          void CardBoxCountWrite(CardMachineRxData *pcommData)
   2020          {
   \                     CardBoxCountWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   2021            INT8U ucData[64];
   2022            INT8U ucTmp;
   2023            INT8U ucSelected;
   2024            
   2025            if(Uart0LengthProcess(pcommData,5)){			
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD04B             BEQ.N    ??CardBoxCountWrite_0
   2026              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0006             MOVS     R6,R0
   2027              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E03             CMP      R6,#+3
   \   0000001C   0xDA3B             BGE.N    ??CardBoxCountWrite_1
   2028                pcommData->ucData[5]=0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7260             STRB     R0,[R4, #+9]
   2029                ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \   00000022   0x1D60             ADDS     R0,R4,#+5
   \   00000024   0x.... 0x....      BL       atoi
   \   00000028   0x0005             MOVS     R5,R0
   2030                if(ucTmp>CARDMACHINE_MAX_COUNTS){
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D65             CMP      R5,#+101
   \   0000002E   0xDB0A             BLT.N    ??CardBoxCountWrite_2
   2031                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x9001             STR      R0,[SP, #+4]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9000             STR      R0,[SP, #+0]
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x78A2             LDRB     R2,[R4, #+2]
   \   0000003C   0x7861             LDRB     R1,[R4, #+1]
   \   0000003E   0x20C5             MOVS     R0,#+197
   \   00000040   0x.... 0x....      BL       Uart0Pack
   \   00000044   0xE031             B.N      ??CardBoxCountWrite_0
   2032                }else{
   2033                  if(m_usrBoxInfo[ucSelected].usrCountResponse.ucEnabled){
   \                     ??CardBoxCountWrite_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x0171             LSLS     R1,R6,#+5
   \   0000004E   0x4408             ADD      R0,R0,R1
   \   00000050   0x7C00             LDRB     R0,[R0, #+16]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00D             BEQ.N    ??CardBoxCountWrite_3
   2034                    ucData[0]=SUBTYPE_ERR_DEVICE_BUSY;
   \   00000056   0x203B             MOVS     R0,#+59
   \   00000058   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2035                    Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9001             STR      R0,[SP, #+4]
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0xAB02             ADD      R3,SP,#+8
   \   00000066   0x78A2             LDRB     R2,[R4, #+2]
   \   00000068   0x7861             LDRB     R1,[R4, #+1]
   \   0000006A   0x205E             MOVS     R0,#+94
   \   0000006C   0x.... 0x....      BL       Uart0Pack
   \   00000070   0xE01B             B.N      ??CardBoxCountWrite_0
   2036                  }else{
   2037                  #if BOARD_OLD_EN==0          
   2038                    ucData[0]=ucTmp;
   \                     ??CardBoxCountWrite_3: (+1)
   \   00000072   0xF88D 0x5008      STRB     R5,[SP, #+8]
   2039                    ucData[1]=0x00;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF88D 0x0009      STRB     R0,[SP, #+9]
   2040                    ucData[2]=pcommData->ucSeq;
   \   0000007C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007E   0xF88D 0x000A      STRB     R0,[SP, #+10]
   2041                    UartPack(UART_COUNT_SET_WRITE,UART_RESPONSE_MODE,3,ucData,ucSelected);
   \   00000082   0x0030             MOVS     R0,R6
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x9000             STR      R0,[SP, #+0]
   \   00000088   0xAB02             ADD      R3,SP,#+8
   \   0000008A   0x2203             MOVS     R2,#+3
   \   0000008C   0x2140             MOVS     R1,#+64
   \   0000008E   0x20EA             MOVS     R0,#+234
   \   00000090   0x.... 0x....      BL       UartPack
   \   00000094   0xE009             B.N      ??CardBoxCountWrite_0
   2042                  #else
   2043                    ucData[0]=BOX_UART_SEND_MSG;
   2044                    ucData[1]=UART_COUNT_SET_WRITE;
   2045                    ucData[2]=UART_RESPONSE_MODE;
   2046                    ucData[3]=ucSelected;
   2047                    
   2048                    ucData[4]=ucTmp;
   2049                    ucData[5]=0x00;
   2050                    ucData[6]=pcommData->ucSeq;
   2051                    BoxPostMsg(ucData,7);
   2052                  #endif          
   2053                  }
   2054                }
   2055              }else{
   2056                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxCountWrite_1: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x2300             MOVS     R3,#+0
   \   000000A0   0x78A2             LDRB     R2,[R4, #+2]
   \   000000A2   0x7861             LDRB     R1,[R4, #+1]
   \   000000A4   0x20C5             MOVS     R0,#+197
   \   000000A6   0x.... 0x....      BL       Uart0Pack
   2057              }
   2058            }
   2059          }
   \                     ??CardBoxCountWrite_0: (+1)
   \   000000AA   0xB012             ADD      SP,SP,#+72
   \   000000AC   0xBD70             POP      {R4-R6,PC}       ;; return
   2060          
   2061          /********************************************************************************************************
   2062          ** 函数名称: CardBoxCountRead
   2063          ** 功能描述:
   2064          ** 输 　 入:
   2065          **
   2066          ** 输　  出:
   2067          **
   2068          ** 全局变量:
   2069          ** 调用模块:
   2070          **
   2071          ** 作　  者: John Tonny
   2072          ** 日　  期: 2005年05月01日
   2073          **------------------------------------------------------------------------------------------------------
   2074          ** 修 改 人:
   2075          ** 日　  期:
   2076          **------------------------------------------------------------------------------------------------------
   2077          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2078          void CardBoxCountRead(CardMachineRxData *pcommData)
   2079          {
   \                     CardBoxCountRead: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   2080            INT8U ucData[64];
   2081            INT8U ucSelected;	
   2082            INT8U ucType=DEV_TYPE();
   \   00000006   0x.... 0x....      BL       DEV_TYPE
   \   0000000A   0x0006             MOVS     R6,R0
   2083            
   2084            if(Uart0LengthProcess(pcommData,1)){			
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Uart0LengthProcess
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD05A             BEQ.N    ??CardBoxCountRead_0
   2085              ucSelected=pcommData->ucData[0]-0x30;
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x3830             SUBS     R0,R0,#+48
   \   0000001C   0x0005             MOVS     R5,R0
   2086              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D03             CMP      R5,#+3
   \   00000022   0xDA4A             BGE.N    ??CardBoxCountRead_1
   2087                if(ucType==SMALL_THICK_ZIN_TYPE || ucType==SMALL_THIN_ZIN_TYPE){
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E02             CMP      R6,#+2
   \   00000028   0xD002             BEQ.N    ??CardBoxCountRead_2
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E0A             CMP      R6,#+10
   \   0000002E   0xD117             BNE.N    ??CardBoxCountRead_3
   2088                  ucData[0]=pcommData->ucData[0];
   \                     ??CardBoxCountRead_2: (+1)
   \   00000030   0x7920             LDRB     R0,[R4, #+4]
   \   00000032   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2089                  SprintF(&ucData[1],4,m_usrBoxInfo[ucSelected].ucCounts);
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x0169             LSLS     R1,R5,#+5
   \   0000003E   0x5C42             LDRB     R2,[R0, R1]
   \   00000040   0x2104             MOVS     R1,#+4
   \   00000042   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000046   0x.... 0x....      BL       SprintF
   2090                  Uart0Pack(INFTYPE_CARD_COUNT,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x2005             MOVS     R0,#+5
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0xAB02             ADD      R3,SP,#+8
   \   00000054   0x78A2             LDRB     R2,[R4, #+2]
   \   00000056   0x7861             LDRB     R1,[R4, #+1]
   \   00000058   0x2062             MOVS     R0,#+98
   \   0000005A   0x.... 0x....      BL       Uart0Pack
   \   0000005E   0xE036             B.N      ??CardBoxCountRead_0
   2091                }else{
   2092                  if(m_usrBoxInfo[ucSelected].usrFlag.usrBit.bBoxLoad && m_usrBoxInfo[ucSelected].usrFlag.usrBit.bConnected){
   \                     ??CardBoxCountRead_3: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x0169             LSLS     R1,R5,#+5
   \   00000068   0x4408             ADD      R0,R0,R1
   \   0000006A   0x7B80             LDRB     R0,[R0, #+14]
   \   0000006C   0xF010 0x0005      ANDS     R0,R0,#0x5
   \   00000070   0x2805             CMP      R0,#+5
   \   00000072   0xD12C             BNE.N    ??CardBoxCountRead_0
   2093                    ucData[0]=pcommData->ucData[0];
   \   00000074   0x7920             LDRB     R0,[R4, #+4]
   \   00000076   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2094                    SprintF(&ucData[1],4,m_usrBoxInfo[ucSelected].ucCounts);
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x0169             LSLS     R1,R5,#+5
   \   00000082   0x5C42             LDRB     R2,[R0, R1]
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0xF10D 0x0009      ADD      R0,SP,#+9
   \   0000008A   0x.... 0x....      BL       SprintF
   2095                  #if COUNT_ID_EN==0          
   2096                    Uart0Pack(INFTYPE_CARD_COUNT,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   2097                  #else
   2098                    SprintF(&ucData[5],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000092   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0x0169             LSLS     R1,R5,#+5
   \   00000096   0x4408             ADD      R0,R0,R1
   \   00000098   0x6842             LDR      R2,[R0, #+4]
   \   0000009A   0x2108             MOVS     R1,#+8
   \   0000009C   0xF10D 0x000D      ADD      R0,SP,#+13
   \   000000A0   0x.... 0x....      BL       SprintF
   2099                    Uart0Pack(INFTYPE_CARD_COUNT,pcommData->ucAddr,pcommData->ucSeq,ucData,13,0);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9001             STR      R0,[SP, #+4]
   \   000000A8   0x200D             MOVS     R0,#+13
   \   000000AA   0x9000             STR      R0,[SP, #+0]
   \   000000AC   0xAB02             ADD      R3,SP,#+8
   \   000000AE   0x78A2             LDRB     R2,[R4, #+2]
   \   000000B0   0x7861             LDRB     R1,[R4, #+1]
   \   000000B2   0x2062             MOVS     R0,#+98
   \   000000B4   0x.... 0x....      BL       Uart0Pack
   \   000000B8   0xE009             B.N      ??CardBoxCountRead_0
   2100                  #endif          
   2101                  }
   2102                }
   2103              }else{
   2104                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxCountRead_1: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x9001             STR      R0,[SP, #+4]
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0x2300             MOVS     R3,#+0
   \   000000C4   0x78A2             LDRB     R2,[R4, #+2]
   \   000000C6   0x7861             LDRB     R1,[R4, #+1]
   \   000000C8   0x20C5             MOVS     R0,#+197
   \   000000CA   0x.... 0x....      BL       Uart0Pack
   2105              }
   2106            }
   2107          }
   \                     ??CardBoxCountRead_0: (+1)
   \   000000CE   0xB012             ADD      SP,SP,#+72
   \   000000D0   0xBD70             POP      {R4-R6,PC}       ;; return
   2108          
   2109          /********************************************************************************************************
   2110          ** 函数名称: CardBoxCountWrite
   2111          ** 功能描述:
   2112          ** 输 　 入:
   2113          **
   2114          ** 输　  出:
   2115          **
   2116          ** 全局变量:
   2117          ** 调用模块:
   2118          **
   2119          ** 作　  者: John Tonny
   2120          ** 日　  期: 2005年05月01日
   2121          **------------------------------------------------------------------------------------------------------
   2122          ** 修 改 人:
   2123          ** 日　  期:
   2124          **------------------------------------------------------------------------------------------------------
   2125          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2126          void CardBoxMaxCountWrite(CardMachineRxData *pcommData)
   2127          {
   \                     CardBoxMaxCountWrite: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB094             SUB      SP,SP,#+80
   \   00000004   0x0004             MOVS     R4,R0
   2128            INT8U ucData[64];
   2129            INT8U ucTmp;
   2130            INT8U i;
   2131            INT8U ucSelected;
   2132            
   2133            if(Uart0LengthProcess(pcommData,5)){			
   \   00000006   0x2105             MOVS     R1,#+5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD073             BEQ.N    ??CardBoxMaxCountWrite_0
   2134              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0006             MOVS     R6,R0
   2135              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x2E03             CMP      R6,#+3
   \   0000001C   0xDA63             BGE.N    ??CardBoxMaxCountWrite_1
   2136                pcommData->ucData[5]=0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7260             STRB     R0,[R4, #+9]
   2137                for(i=0;i<4;i++){
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0005             MOVS     R5,R0
   \                     ??CardBoxMaxCountWrite_2: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D04             CMP      R5,#+4
   \   0000002A   0xDA0E             BGE.N    ??CardBoxMaxCountWrite_3
   2138                  if(AscToByte(pcommData->ucData[i])<0){
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0xEB04 0x0005      ADD      R0,R4,R5
   \   00000032   0x7900             LDRB     R0,[R0, #+4]
   \   00000034   0x.... 0x....      BL       AscToByte
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD504             BPL.N    ??CardBoxMaxCountWrite_4
   2139                    pcommData->ucData[i]=0x30;
   \   0000003C   0x2030             MOVS     R0,#+48
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0xEB04 0x0105      ADD      R1,R4,R5
   \   00000044   0x7108             STRB     R0,[R1, #+4]
   2140                  }
   2141                }
   \                     ??CardBoxMaxCountWrite_4: (+1)
   \   00000046   0x1C6D             ADDS     R5,R5,#+1
   \   00000048   0xE7ED             B.N      ??CardBoxMaxCountWrite_2
   2142                ucTmp=(INT8U)(atoi((const char *)&pcommData->ucData[1]));
   \                     ??CardBoxMaxCountWrite_3: (+1)
   \   0000004A   0x1D60             ADDS     R0,R4,#+5
   \   0000004C   0x.... 0x....      BL       atoi
   \   00000050   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2143                if(ucTmp>CARDMACHINE_MAX_COUNTS){
   \   00000054   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000058   0x2865             CMP      R0,#+101
   \   0000005A   0xDB0A             BLT.N    ??CardBoxMaxCountWrite_5
   2144                  Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x9001             STR      R0,[SP, #+4]
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x78A2             LDRB     R2,[R4, #+2]
   \   00000068   0x7861             LDRB     R1,[R4, #+1]
   \   0000006A   0x20C5             MOVS     R0,#+197
   \   0000006C   0x.... 0x....      BL       Uart0Pack
   \   00000070   0xE043             B.N      ??CardBoxMaxCountWrite_0
   2145                }else{
   2146                  if(!EepromWriteVerifyBytes(CARDMACHINE_MAXCOUNT_ADDR,&ucTmp,1)){
   \                     ??CardBoxMaxCountWrite_5: (+1)
   \   00000072   0x2201             MOVS     R2,#+1
   \   00000074   0xA902             ADD      R1,SP,#+8
   \   00000076   0x2038             MOVS     R0,#+56
   \   00000078   0x.... 0x....      BL       EepromWriteVerifyBytes
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD10C             BNE.N    ??CardBoxMaxCountWrite_6
   2147                    ucData[0]=SUBTYPE_ERR_WRITE_INF;
   \   00000080   0x2034             MOVS     R0,#+52
   \   00000082   0xF88D 0x000C      STRB     R0,[SP, #+12]
   2148                    Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9001             STR      R0,[SP, #+4]
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0xAB03             ADD      R3,SP,#+12
   \   00000090   0x78A2             LDRB     R2,[R4, #+2]
   \   00000092   0x7861             LDRB     R1,[R4, #+1]
   \   00000094   0x205E             MOVS     R0,#+94
   \   00000096   0x.... 0x....      BL       Uart0Pack
   2149                  }
   2150                  Uart0Pack(INFTYPE_CARD_COUNT_MAX,pcommData->ucAddr,pcommData->ucSeq,&pcommData->ucData[0],5,0);
   \                     ??CardBoxMaxCountWrite_6: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x9001             STR      R0,[SP, #+4]
   \   0000009E   0x2005             MOVS     R0,#+5
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0x1D23             ADDS     R3,R4,#+4
   \   000000A4   0x78A2             LDRB     R2,[R4, #+2]
   \   000000A6   0x7861             LDRB     R1,[R4, #+1]
   \   000000A8   0x2068             MOVS     R0,#+104
   \   000000AA   0x.... 0x....      BL       Uart0Pack
   2151                  
   2152                  m_usrBoxInfo[ucSelected].ucMaxCounts=ucTmp;
   \   000000AE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   000000B6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000B8   0x0172             LSLS     R2,R6,#+5
   \   000000BA   0x4411             ADD      R1,R1,R2
   \   000000BC   0x7048             STRB     R0,[R1, #+1]
   2153                #if BOARD_OLD_EN==0        
   2154                  ucData[0]=ucTmp;
   \   000000BE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C2   0xF88D 0x000C      STRB     R0,[SP, #+12]
   2155                  ucData[1]=0x00;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF88D 0x000D      STRB     R0,[SP, #+13]
   2156                  ucData[2]=pcommData->ucSeq;
   \   000000CC   0x78A0             LDRB     R0,[R4, #+2]
   \   000000CE   0xF88D 0x000E      STRB     R0,[SP, #+14]
   2157                  UartPack(CARDMACHINE_WRITE_COUNT_MAX_CMD,UART_RESPONSE_MODE,3,ucData,ucSelected);
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0xAB03             ADD      R3,SP,#+12
   \   000000DA   0x2203             MOVS     R2,#+3
   \   000000DC   0x2140             MOVS     R1,#+64
   \   000000DE   0x201A             MOVS     R0,#+26
   \   000000E0   0x.... 0x....      BL       UartPack
   \   000000E4   0xE009             B.N      ??CardBoxMaxCountWrite_0
   2158                #else
   2159                  ucData[0]=BOX_UART_SEND_MSG;
   2160                  ucData[1]=CARDMACHINE_WRITE_COUNT_MAX_CMD;
   2161                  ucData[2]=UART_RESPONSE_MODE;
   2162                  ucData[3]=ucSelected;
   2163                  
   2164                  ucData[4]=ucTmp;
   2165                  ucData[5]=0x00;
   2166                  ucData[6]=pcommData->ucSeq;
   2167                  BoxPostMsg(ucData,7);
   2168                #endif          
   2169                }
   2170              }else{
   2171                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxMaxCountWrite_1: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x9000             STR      R0,[SP, #+0]
   \   000000EE   0x2300             MOVS     R3,#+0
   \   000000F0   0x78A2             LDRB     R2,[R4, #+2]
   \   000000F2   0x7861             LDRB     R1,[R4, #+1]
   \   000000F4   0x20C5             MOVS     R0,#+197
   \   000000F6   0x.... 0x....      BL       Uart0Pack
   2172              }
   2173            }
   2174          }
   \                     ??CardBoxMaxCountWrite_0: (+1)
   \   000000FA   0xB014             ADD      SP,SP,#+80
   \   000000FC   0xBD70             POP      {R4-R6,PC}       ;; return
   2175          
   2176          /********************************************************************************************************
   2177          ** 函数名称: CardBoxMaxCountRead
   2178          ** 功能描述:
   2179          ** 输 　 入:
   2180          **
   2181          ** 输　  出:
   2182          **
   2183          ** 全局变量:
   2184          ** 调用模块:
   2185          **
   2186          ** 作　  者: John Tonny
   2187          ** 日　  期: 2005年05月01日
   2188          **------------------------------------------------------------------------------------------------------
   2189          ** 修 改 人:
   2190          ** 日　  期:
   2191          **------------------------------------------------------------------------------------------------------
   2192          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2193          void CardBoxMaxCountRead(CardMachineRxData *pcommData)
   2194          {
   \                     CardBoxMaxCountRead: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
   \   00000004   0x0004             MOVS     R4,R0
   2195            INT8U ucData[64];
   2196            INT8U ucSelected;	
   2197            INT8U ucType=DEV_TYPE();
   \   00000006   0x.... 0x....      BL       DEV_TYPE
   \   0000000A   0x0006             MOVS     R6,R0
   2198            
   2199            if(Uart0LengthProcess(pcommData,1)){			
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Uart0LengthProcess
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD043             BEQ.N    ??CardBoxMaxCountRead_0
   2200              ucSelected=pcommData->ucData[0]-0x30;
   \   00000018   0x7920             LDRB     R0,[R4, #+4]
   \   0000001A   0x3830             SUBS     R0,R0,#+48
   \   0000001C   0x0005             MOVS     R5,R0
   2201              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D03             CMP      R5,#+3
   \   00000022   0xDA33             BGE.N    ??CardBoxMaxCountRead_1
   2202                if(ucType==SMALL_THICK_ZIN_TYPE || ucType==SMALL_THIN_ZIN_TYPE){
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E02             CMP      R6,#+2
   \   00000028   0xD002             BEQ.N    ??CardBoxMaxCountRead_2
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E0A             CMP      R6,#+10
   \   0000002E   0xD114             BNE.N    ??CardBoxMaxCountRead_3
   2203                  ucData[0]=pcommData->ucData[0];
   \                     ??CardBoxMaxCountRead_2: (+1)
   \   00000030   0x7920             LDRB     R0,[R4, #+4]
   \   00000032   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2204                  SprintF(&ucData[1],4,500);
   \   00000036   0xF44F 0x72FA      MOV      R2,#+500
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000040   0x.... 0x....      BL       SprintF
   2205                  Uart0Pack(INFTYPE_CARD_COUNT_MAX,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0x2005             MOVS     R0,#+5
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xAB02             ADD      R3,SP,#+8
   \   0000004E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000050   0x7861             LDRB     R1,[R4, #+1]
   \   00000052   0x2068             MOVS     R0,#+104
   \   00000054   0x.... 0x....      BL       Uart0Pack
   \   00000058   0xE022             B.N      ??CardBoxMaxCountRead_0
   2206                }else{
   2207                  ucData[0]=pcommData->ucData[0];
   \                     ??CardBoxMaxCountRead_3: (+1)
   \   0000005A   0x7920             LDRB     R0,[R4, #+4]
   \   0000005C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2208                  SprintF(&ucData[1],4,m_usrBoxInfo[ucSelected].ucMaxCounts);
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x0169             LSLS     R1,R5,#+5
   \   00000068   0x4408             ADD      R0,R0,R1
   \   0000006A   0x7842             LDRB     R2,[R0, #+1]
   \   0000006C   0x2104             MOVS     R1,#+4
   \   0000006E   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000072   0x.... 0x....      BL       SprintF
   2209                  Uart0Pack(INFTYPE_CARD_COUNT_MAX,pcommData->ucAddr,pcommData->ucSeq,ucData,5,0);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9001             STR      R0,[SP, #+4]
   \   0000007A   0x2005             MOVS     R0,#+5
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0xAB02             ADD      R3,SP,#+8
   \   00000080   0x78A2             LDRB     R2,[R4, #+2]
   \   00000082   0x7861             LDRB     R1,[R4, #+1]
   \   00000084   0x2068             MOVS     R0,#+104
   \   00000086   0x.... 0x....      BL       Uart0Pack
   \   0000008A   0xE009             B.N      ??CardBoxMaxCountRead_0
   2210                }
   2211              }else{
   2212                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxMaxCountRead_1: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x9001             STR      R0,[SP, #+4]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x2300             MOVS     R3,#+0
   \   00000096   0x78A2             LDRB     R2,[R4, #+2]
   \   00000098   0x7861             LDRB     R1,[R4, #+1]
   \   0000009A   0x20C5             MOVS     R0,#+197
   \   0000009C   0x.... 0x....      BL       Uart0Pack
   2213              }
   2214            }
   2215          }
   \                     ??CardBoxMaxCountRead_0: (+1)
   \   000000A0   0xB012             ADD      SP,SP,#+72
   \   000000A2   0xBD70             POP      {R4-R6,PC}       ;; return
   2216          
   2217          /********************************************************************************************************
   2218          ** 函数名称: CardBoxRecordInit
   2219          ** 功能描述:
   2220          ** 输 　 入:
   2221          **
   2222          ** 输　  出:
   2223          **
   2224          ** 全局变量:
   2225          ** 调用模块:
   2226          **
   2227          ** 作　  者: John Tonny
   2228          ** 日　  期: 2005年05月01日
   2229          **------------------------------------------------------------------------------------------------------
   2230          ** 修 改 人:
   2231          ** 日　  期:
   2232          **------------------------------------------------------------------------------------------------------
   2233          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2234          void CardBoxRecordInit(CardMachineRxData *pcommData)
   2235          {
   \                     CardBoxRecordInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   2236            INT8U ucData[64];
   2237            INT8U ucSelected;	
   2238            
   2239            if(Uart0LengthProcess(pcommData,1)){			
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD032             BEQ.N    ??CardBoxRecordInit_0
   2240              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
   2241              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D03             CMP      R5,#+3
   \   0000001C   0xDA22             BGE.N    ??CardBoxRecordInit_1
   2242                if(m_usrBoxInfo[ucSelected].usrCountResponse.ucEnabled){
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0169             LSLS     R1,R5,#+5
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0x7C00             LDRB     R0,[R0, #+16]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??CardBoxRecordInit_2
   2243                  ucData[0]=SUBTYPE_ERR_DEVICE_BUSY;
   \   0000002E   0x203B             MOVS     R0,#+59
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2244                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAB02             ADD      R3,SP,#+8
   \   0000003E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000040   0x7861             LDRB     R1,[R4, #+1]
   \   00000042   0x205E             MOVS     R0,#+94
   \   00000044   0x.... 0x....      BL       Uart0Pack
   \   00000048   0xE016             B.N      ??CardBoxRecordInit_0
   2245                }else{
   2246                #if BOARD_OLD_EN==0        
   2247                  ucData[0]=pcommData->ucSeq;
   \                     ??CardBoxRecordInit_2: (+1)
   \   0000004A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000004C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2248                  UartPack(CARDMACHINE_RECORD_INIT_CMD,UART_RESPONSE_MODE,1,ucData,ucSelected);
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x9000             STR      R0,[SP, #+0]
   \   00000056   0xAB02             ADD      R3,SP,#+8
   \   00000058   0x2201             MOVS     R2,#+1
   \   0000005A   0x2140             MOVS     R1,#+64
   \   0000005C   0x2029             MOVS     R0,#+41
   \   0000005E   0x.... 0x....      BL       UartPack
   \   00000062   0xE009             B.N      ??CardBoxRecordInit_0
   2249                #else
   2250                  ucData[0]=BOX_UART_SEND_MSG;
   2251                  ucData[1]=CARDMACHINE_RECORD_INIT_CMD;
   2252                  ucData[2]=UART_RESPONSE_MODE;
   2253                  ucData[3]=ucSelected;
   2254                  
   2255                  ucData[4]=pcommData->ucSeq;
   2256                  BoxPostMsg(ucData,5);
   2257                #endif
   2258                }
   2259              }else{
   2260                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxRecordInit_1: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9001             STR      R0,[SP, #+4]
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x2300             MOVS     R3,#+0
   \   0000006E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000070   0x7861             LDRB     R1,[R4, #+1]
   \   00000072   0x20C5             MOVS     R0,#+197
   \   00000074   0x.... 0x....      BL       Uart0Pack
   2261              }
   2262            }
   2263          }
   \                     ??CardBoxRecordInit_0: (+1)
   \   00000078   0xB013             ADD      SP,SP,#+76
   \   0000007A   0xBD30             POP      {R4,R5,PC}       ;; return
   2264          
   2265          /********************************************************************************************************
   2266          ** 函数名称: CardBoxCountAddSub
   2267          ** 功能描述:
   2268          ** 输 　 入:
   2269          **
   2270          ** 输　  出:
   2271          **
   2272          ** 全局变量:
   2273          ** 调用模块:
   2274          **
   2275          ** 作　  者: John Tonny
   2276          ** 日　  期: 2005年05月01日
   2277          **------------------------------------------------------------------------------------------------------
   2278          ** 修 改 人:
   2279          ** 日　  期:
   2280          **------------------------------------------------------------------------------------------------------
   2281          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2282          void CardBoxCountAddSub(CardMachineRxData *pcommData)
   2283          {
   \                     CardBoxCountAddSub: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB093             SUB      SP,SP,#+76
   \   00000004   0x0004             MOVS     R4,R0
   2284            INT8U ucData[64];
   2285            INT8U ucSelected;
   2286            
   2287            if(Uart0LengthProcess(pcommData,2)){
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD050             BEQ.N    ??CardBoxCountAddSub_0
   2288              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
   2289              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D03             CMP      R5,#+3
   \   0000001C   0xDA40             BGE.N    ??CardBoxCountAddSub_1
   2290                if(m_usrBoxInfo[ucSelected].usrCountResponse.ucEnabled){
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0169             LSLS     R1,R5,#+5
   \   00000026   0x4408             ADD      R0,R0,R1
   \   00000028   0x7C00             LDRB     R0,[R0, #+16]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??CardBoxCountAddSub_2
   2291                  ucData[0]=SUBTYPE_ERR_DEVICE_BUSY;
   \   0000002E   0x203B             MOVS     R0,#+59
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2292                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucData,1,0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAB02             ADD      R3,SP,#+8
   \   0000003E   0x78A2             LDRB     R2,[R4, #+2]
   \   00000040   0x7861             LDRB     R1,[R4, #+1]
   \   00000042   0x205E             MOVS     R0,#+94
   \   00000044   0x.... 0x....      BL       Uart0Pack
   \   00000048   0xE034             B.N      ??CardBoxCountAddSub_0
   2293                }else{
   2294                  if(pcommData->ucData[1]==0x30){
   \                     ??CardBoxCountAddSub_2: (+1)
   \   0000004A   0x7960             LDRB     R0,[R4, #+5]
   \   0000004C   0x2830             CMP      R0,#+48
   \   0000004E   0xD10C             BNE.N    ??CardBoxCountAddSub_3
   2295                  #if BOARD_OLD_EN==0        
   2296                    ucData[0]=pcommData->ucSeq;
   \   00000050   0x78A0             LDRB     R0,[R4, #+2]
   \   00000052   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2297                    UartPack(UART_COUNT_ADD_CMD,UART_RESPONSE_MODE,1,ucData,ucSelected);
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0xAB02             ADD      R3,SP,#+8
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x2140             MOVS     R1,#+64
   \   00000062   0x20E7             MOVS     R0,#+231
   \   00000064   0x.... 0x....      BL       UartPack
   \   00000068   0xE024             B.N      ??CardBoxCountAddSub_0
   2298                  #else
   2299                    ucData[0]=BOX_UART_SEND_MSG;
   2300                    ucData[1]=UART_COUNT_ADD_CMD;
   2301                    ucData[2]=UART_RESPONSE_MODE;
   2302                    ucData[3]=ucSelected;
   2303                    
   2304                    ucData[4]=pcommData->ucSeq;
   2305                    BoxPostMsg(ucData,5);
   2306                  #endif
   2307                  }else if(pcommData->ucData[1]==0x31){
   \                     ??CardBoxCountAddSub_3: (+1)
   \   0000006A   0x7960             LDRB     R0,[R4, #+5]
   \   0000006C   0x2831             CMP      R0,#+49
   \   0000006E   0xD10C             BNE.N    ??CardBoxCountAddSub_4
   2308                  #if BOARD_OLD_EN==0        
   2309                    ucData[0]=pcommData->ucSeq;
   \   00000070   0x78A0             LDRB     R0,[R4, #+2]
   \   00000072   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2310                    UartPack(UART_COUNT_SUB_CMD,UART_RESPONSE_MODE,1,ucData,ucSelected);
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0xAB02             ADD      R3,SP,#+8
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0x2140             MOVS     R1,#+64
   \   00000082   0x20E8             MOVS     R0,#+232
   \   00000084   0x.... 0x....      BL       UartPack
   \   00000088   0xE014             B.N      ??CardBoxCountAddSub_0
   2311                  #else
   2312                    ucData[0]=BOX_UART_SEND_MSG;
   2313                    ucData[1]=UART_COUNT_SUB_CMD;
   2314                    ucData[2]=UART_RESPONSE_MODE;
   2315                    ucData[3]=ucSelected;
   2316                    
   2317                    ucData[4]=pcommData->ucSeq;
   2318                    BoxPostMsg(ucData,5);
   2319                  #endif
   2320                  }else{
   2321                    Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxCountAddSub_4: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0x2300             MOVS     R3,#+0
   \   00000094   0x78A2             LDRB     R2,[R4, #+2]
   \   00000096   0x7861             LDRB     R1,[R4, #+1]
   \   00000098   0x20C5             MOVS     R0,#+197
   \   0000009A   0x.... 0x....      BL       Uart0Pack
   \   0000009E   0xE009             B.N      ??CardBoxCountAddSub_0
   2322                  }
   2323                }
   2324              }else{
   2325                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxCountAddSub_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x9001             STR      R0,[SP, #+4]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x2300             MOVS     R3,#+0
   \   000000AA   0x78A2             LDRB     R2,[R4, #+2]
   \   000000AC   0x7861             LDRB     R1,[R4, #+1]
   \   000000AE   0x20C5             MOVS     R0,#+197
   \   000000B0   0x.... 0x....      BL       Uart0Pack
   2326              }
   2327            }
   2328          }
   \                     ??CardBoxCountAddSub_0: (+1)
   \   000000B4   0xB013             ADD      SP,SP,#+76
   \   000000B6   0xBD30             POP      {R4,R5,PC}       ;; return
   2329          
   2330          /********************************************************************************************************
   2331          ** 函数名称: CardBoxMotoMove
   2332          ** 功能描述:
   2333          ** 输 　 入:
   2334          **
   2335          ** 输　  出:
   2336          **
   2337          ** 全局变量:
   2338          ** 调用模块:
   2339          **
   2340          ** 作　  者: John Tonny
   2341          ** 日　  期: 2005年05月01日
   2342          **------------------------------------------------------------------------------------------------------
   2343          ** 修 改 人:
   2344          ** 日　  期:
   2345          **------------------------------------------------------------------------------------------------------
   2346          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2347          void CardBoxMotoMove(CardMachineRxData *pcommData)
   2348          {
   \                     CardBoxMotoMove: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   2349            INT8U ucData[32];
   2350            INT8U ucSelected;
   2351            
   2352            if(Uart0LengthProcess(pcommData,2)){			
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       Uart0LengthProcess
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD026             BEQ.N    ??CardBoxMotoMove_0
   2353              ucSelected=pcommData->ucData[0]-0x30;
   \   00000012   0x7920             LDRB     R0,[R4, #+4]
   \   00000014   0x3830             SUBS     R0,R0,#+48
   \   00000016   0x0005             MOVS     R5,R0
   2354              if(ucSelected<=CARDMACHINE_CARDBOX_NUMS-1){
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D03             CMP      R5,#+3
   \   0000001C   0xDA16             BGE.N    ??CardBoxMotoMove_1
   2355              #if BOARD_OLD_EN==0      
   2356                ucData[0]=0xA2;
   \   0000001E   0x20A2             MOVS     R0,#+162
   \   00000020   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2357                ucData[1]=0x06;
   \   00000024   0x2006             MOVS     R0,#+6
   \   00000026   0xF88D 0x0009      STRB     R0,[SP, #+9]
   2358                ucData[2]=pcommData->ucData[1]-0x30;
   \   0000002A   0x7960             LDRB     R0,[R4, #+5]
   \   0000002C   0x3830             SUBS     R0,R0,#+48
   \   0000002E   0xF88D 0x000A      STRB     R0,[SP, #+10]
   2359                ucData[3]=pcommData->ucSeq;
   \   00000032   0x78A0             LDRB     R0,[R4, #+2]
   \   00000034   0xF88D 0x000B      STRB     R0,[SP, #+11]
   2360                
   2361                UartPack(CARDMACHINE_CLOSE_DOOR_CMD,UART_RESPONSE_MODE,4,ucData,ucSelected);
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0xAB02             ADD      R3,SP,#+8
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0x2140             MOVS     R1,#+64
   \   00000044   0x2011             MOVS     R0,#+17
   \   00000046   0x.... 0x....      BL       UartPack
   \   0000004A   0xE009             B.N      ??CardBoxMotoMove_0
   2362              #else
   2363                ucData[0]=BOX_UART_SEND_MSG;
   2364                ucData[1]=UART_COUNT_SUB_CMD;
   2365                ucData[2]=UART_RESPONSE_MODE;
   2366                ucData[3]=ucSelected;
   2367                
   2368                ucData[4]=0xA2;
   2369                ucData[5]=0x06;
   2370                ucData[6]=pcommData->ucData[1]-0x30;
   2371                ucData[7]=pcommData->ucSeq;
   2372                BoxPostMsg(ucData,8);
   2373              #endif
   2374              }else{
   2375                Uart0Pack(INFTYPE_FORMAT_ERR,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \                     ??CardBoxMotoMove_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x78A2             LDRB     R2,[R4, #+2]
   \   00000058   0x7861             LDRB     R1,[R4, #+1]
   \   0000005A   0x20C5             MOVS     R0,#+197
   \   0000005C   0x.... 0x....      BL       Uart0Pack
   2376              }
   2377            }
   2378          }
   \                     ??CardBoxMotoMove_0: (+1)
   \   00000060   0xB00B             ADD      SP,SP,#+44
   \   00000062   0xBD30             POP      {R4,R5,PC}       ;; return
   2379          
   2380          /********************************************************************************************************
   2381          ** 函数名称: UartLengthProcess
   2382          ** 功能描述:
   2383          ** 输 　 入:
   2384          **
   2385          ** 输　  出:
   2386          **
   2387          ** 全局变量:
   2388          ** 调用模块:
   2389          **
   2390          ** 作　  者: John Tonny
   2391          ** 日　  期: 2005年05月01日
   2392          **------------------------------------------------------------------------------------------------------
   2393          ** 修 改 人:
   2394          ** 日　  期:
   2395          **------------------------------------------------------------------------------------------------------
   2396          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2397          INT8U UartLengthProcess(CommRxData *pcommData,INT8U ucLen)
   2398          {
   \                     UartLengthProcess: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   2399            if(pcommData->ucLen==UART_BASIC_RSP_LEN+ucLen){
   \   00000002   0x7850             LDRB     R0,[R2, #+1]
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x1DCB             ADDS     R3,R1,#+7
   \   00000008   0x4298             CMP      R0,R3
   \   0000000A   0xD101             BNE.N    ??UartLengthProcess_0
   2400              return TRUE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??UartLengthProcess_1
   2401            }	
   2402            return FALSE;		
   \                     ??UartLengthProcess_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??UartLengthProcess_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
   2403          }
   2404          
   2405          /********************************************************************************************************
   2406          ** 函数名称: CardBoxRecordInitResponse
   2407          ** 功能描述:
   2408          ** 输 　 入:
   2409          **
   2410          ** 输　  出:
   2411          **
   2412          ** 全局变量:
   2413          ** 调用模块:
   2414          **
   2415          ** 作　  者: John Tonny
   2416          ** 日　  期: 2005年05月01日
   2417          **------------------------------------------------------------------------------------------------------
   2418          ** 修 改 人:
   2419          ** 日　  期:
   2420          **------------------------------------------------------------------------------------------------------
   2421          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2422          void CardBoxRecordInitResponse(CommRxData *pcommData,INT8U ucSelected)
   2423          {
   \                     CardBoxRecordInitResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2424            INT8U ucData[32];
   2425            
   2426            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA30             BGE.N    ??CardBoxRecordInitResponse_0
   2427              return;
   2428            }
   2429            
   2430            if(UartLengthProcess(pcommData,0)){
   \                     ??CardBoxRecordInitResponse_1: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UartLengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD02A             BEQ.N    ??CardBoxRecordInitResponse_2
   2431              if(!pcommData->ucStatus){
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD127             BNE.N    ??CardBoxRecordInitResponse_2
   2432                m_usrBoxInfo[ucSelected].ucCounts=0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable28
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x016A             LSLS     R2,R5,#+5
   \   00000028   0x5488             STRB     R0,[R1, R2]
   2433                ucData[0]=ucSelected+0x30;
   \   0000002A   0xF115 0x0030      ADDS     R0,R5,#+48
   \   0000002E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2434                SprintF(&ucData[1],4,m_usrBoxInfo[ucSelected].ucCounts);
   \   00000032   0x....             LDR.N    R0,??DataTable28
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x0169             LSLS     R1,R5,#+5
   \   00000038   0x5C42             LDRB     R2,[R0, R1]
   \   0000003A   0x2104             MOVS     R1,#+4
   \   0000003C   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000040   0x.... 0x....      BL       SprintF
   2435              #if COUNT_ID_EN==0          
   2436                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,pcommData->ucData[0],ucData,5,0);
   2437              #else
   2438                SprintF(&ucData[5],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \   00000044   0x....             LDR.N    R0,??DataTable28
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x0169             LSLS     R1,R5,#+5
   \   0000004A   0x4408             ADD      R0,R0,R1
   \   0000004C   0x6842             LDR      R2,[R0, #+4]
   \   0000004E   0x2108             MOVS     R1,#+8
   \   00000050   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000054   0x.... 0x....      BL       SprintF
   2439                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,pcommData->ucData[0],ucData,13,0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   \   0000005C   0x200D             MOVS     R0,#+13
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0xAB02             ADD      R3,SP,#+8
   \   00000062   0x79A2             LDRB     R2,[R4, #+6]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   00000068   0x7801             LDRB     R1,[R0, #+0]
   \   0000006A   0x2062             MOVS     R0,#+98
   \   0000006C   0x.... 0x....      BL       Uart0Pack
   2440              #endif          
   2441              }
   2442            }
   2443          }
   \                     ??CardBoxRecordInitResponse_2: (+1)
   \                     ??CardBoxRecordInitResponse_0: (+1)
   \   00000070   0xB00B             ADD      SP,SP,#+44
   \   00000072   0xBD30             POP      {R4,R5,PC}       ;; return
   2444          
   2445          /********************************************************************************************************
   2446          ** 函数名称: CardBoxMachineIdResponse
   2447          ** 功能描述:
   2448          ** 输 　 入:
   2449          **
   2450          ** 输　  出:
   2451          **
   2452          ** 全局变量:
   2453          ** 调用模块:
   2454          **
   2455          ** 作　  者: John Tonny
   2456          ** 日　  期: 2005年05月01日
   2457          **------------------------------------------------------------------------------------------------------
   2458          ** 修 改 人:
   2459          ** 日　  期:
   2460          **------------------------------------------------------------------------------------------------------
   2461          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2462          void CardBoxMachineIdResponse(CommRxData *pcommData,INT8U ucSelected)
   2463          {
   \                     CardBoxMachineIdResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2464            INT8U ucData[32];
   2465          	
   2466            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA29             BGE.N    ??CardBoxMachineIdResponse_0
   2467              return;
   2468            }
   2469            
   2470            if(UartLengthProcess(pcommData,4)){
   \                     ??CardBoxMachineIdResponse_1: (+1)
   \   0000000E   0x2104             MOVS     R1,#+4
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UartLengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD023             BEQ.N    ??CardBoxMachineIdResponse_2
   2471              if(!pcommData->ucStatus){
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD120             BNE.N    ??CardBoxMachineIdResponse_2
   2472                m_usrBoxInfo[ucSelected].ulMachineId=*((int32u *)&pcommData->ucData[0]);
   \   00000020   0xF8D4 0x0006      LDR      R0,[R4, #+6]
   \   00000024   0x....             LDR.N    R1,??DataTable28
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x016A             LSLS     R2,R5,#+5
   \   0000002A   0x4411             ADD      R1,R1,R2
   \   0000002C   0x6048             STR      R0,[R1, #+4]
   2473                ucData[0]=ucSelected+0x30;
   \   0000002E   0xF115 0x0030      ADDS     R0,R5,#+48
   \   00000032   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2474                SprintF(&ucData[1],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \   00000036   0x....             LDR.N    R0,??DataTable28
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x0169             LSLS     R1,R5,#+5
   \   0000003C   0x4408             ADD      R0,R0,R1
   \   0000003E   0x6842             LDR      R2,[R0, #+4]
   \   00000040   0x2108             MOVS     R1,#+8
   \   00000042   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000046   0x.... 0x....      BL       SprintF
   2475                Uart0Pack(INFYPTE_CARD_BOX_SERIAL,m_ucMachineAddr,pcommData->ucData[4],ucData,9,0);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x2009             MOVS     R0,#+9
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0xAB02             ADD      R3,SP,#+8
   \   00000054   0x7AA2             LDRB     R2,[R4, #+10]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable34_4
   \   0000005A   0x7801             LDRB     R1,[R0, #+0]
   \   0000005C   0x2061             MOVS     R0,#+97
   \   0000005E   0x.... 0x....      BL       Uart0Pack
   2476              }
   2477            }
   2478          }
   \                     ??CardBoxMachineIdResponse_2: (+1)
   \                     ??CardBoxMachineIdResponse_0: (+1)
   \   00000062   0xB00B             ADD      SP,SP,#+44
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
   2479          
   2480          /********************************************************************************************************
   2481          ** 函数名称: CardBoxBasicInfoResponse
   2482          ** 功能描述:
   2483          ** 输 　 入:
   2484          **
   2485          ** 输　  出:
   2486          **
   2487          ** 全局变量:
   2488          ** 调用模块:
   2489          **
   2490          ** 作　  者: John Tonny
   2491          ** 日　  期: 2005年05月01日
   2492          **------------------------------------------------------------------------------------------------------
   2493          ** 修 改 人:
   2494          ** 日　  期:
   2495          **------------------------------------------------------------------------------------------------------
   2496          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2497          void CardBoxBasicInfoResponse(CommRxData *pcommData,INT8U ucSelected)
   2498          {
   \                     CardBoxBasicInfoResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2499            INT8U ucBit;	
   2500            INT8U ucData[64];
   2501            INT8U ucType=DEV_TYPE();
   \   00000008   0x.... 0x....      BL       DEV_TYPE
   \   0000000C   0x0007             MOVS     R7,R0
   2502            
   2503            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D03             CMP      R5,#+3
   \   00000012   0xF280 0x80C1      BGE.W    ??CardBoxBasicInfoResponse_0
   2504              return;
   2505            }
   2506            
   2507            if(UartLengthProcess(pcommData,9)){
   \                     ??CardBoxBasicInfoResponse_1: (+1)
   \   00000016   0x2109             MOVS     R1,#+9
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       UartLengthProcess
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xF000 0x80BA      BEQ.W    ??CardBoxBasicInfoResponse_2
   2508              CardBoxConnectReset(ucSelected);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       CardBoxConnectReset
   2509              if(!pcommData->ucStatus){
   \   0000002C   0x7960             LDRB     R0,[R4, #+5]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x80B2      BNE.W    ??CardBoxBasicInfoResponse_2
   2510                ucBit=m_ucKeyBit[BOXLOAD1_BIT+ucSelected*8];
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable34_5
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0xEB00 0x00C5      ADD      R0,R0,R5, LSL #+3
   \   0000003E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000040   0x0006             MOVS     R6,R0
   2511                if(!CheckBit(g_usrGetKey.ulKeyOutput,ucBit)){
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable34
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0x40F0             LSRS     R0,R0,R6
   \   0000004A   0x07C0             LSLS     R0,R0,#+31
   \   0000004C   0xF140 0x80A4      BPL.W    ??CardBoxBasicInfoResponse_0
   2512                  return;
   2513                }
   2514                                                                
   2515                if(m_usrBoxInfo[ucSelected].ucCounts!=pcommData->ucData[4]){
   \                     ??CardBoxBasicInfoResponse_3: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable34_2
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x0169             LSLS     R1,R5,#+5
   \   00000058   0x5C40             LDRB     R0,[R0, R1]
   \   0000005A   0x7AA1             LDRB     R1,[R4, #+10]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD008             BEQ.N    ??CardBoxBasicInfoResponse_4
   2516                  ucData[0]=DISPLAY_MAIN_MSG;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF88D 0x0000      STRB     R0,[SP, #+0]
   2517                  Box_TaskLcdQPost(&App_TaskLcdTCB,ucData,1);
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable34_6
   \   0000006E   0x.... 0x....      BL       Box_TaskLcdQPost
   2518                }
   2519                
   2520                m_usrBoxInfo[ucSelected].ulMachineId=*((int32u *)&pcommData->ucData[0]);
   \                     ??CardBoxBasicInfoResponse_4: (+1)
   \   00000072   0xF8D4 0x0006      LDR      R0,[R4, #+6]
   \   00000076   0x....             LDR.N    R1,??DataTable34_2
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x016A             LSLS     R2,R5,#+5
   \   0000007C   0x4411             ADD      R1,R1,R2
   \   0000007E   0x6048             STR      R0,[R1, #+4]
   2521                m_usrBoxInfo[ucSelected].ucCounts=pcommData->ucData[4];
   \   00000080   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000082   0x....             LDR.N    R1,??DataTable34_2
   \   00000084   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000086   0x016A             LSLS     R2,R5,#+5
   \   00000088   0x5488             STRB     R0,[R1, R2]
   2522                m_usrBoxInfo[ucSelected].ucBoxMaxCounts=pcommData->ucData[6];
   \   0000008A   0x7B20             LDRB     R0,[R4, #+12]
   \   0000008C   0x....             LDR.N    R1,??DataTable34_2
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x016A             LSLS     R2,R5,#+5
   \   00000092   0x4411             ADD      R1,R1,R2
   \   00000094   0x7288             STRB     R0,[R1, #+10]
   2523                
   2524                if(m_usrBoxInfo[ucSelected].usrCountResponse.ucEnabled && m_usrBoxInfo[ucSelected].ucCounts==m_usrBoxInfo[ucSelected].usrCountResponse.ucNewCount){
   \   00000096   0x....             LDR.N    R0,??DataTable34_2
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0x0169             LSLS     R1,R5,#+5
   \   0000009C   0x4408             ADD      R0,R0,R1
   \   0000009E   0x7C00             LDRB     R0,[R0, #+16]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD00E             BEQ.N    ??CardBoxBasicInfoResponse_5
   \   000000A4   0x....             LDR.N    R0,??DataTable34_2
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x0169             LSLS     R1,R5,#+5
   \   000000AA   0x5C40             LDRB     R0,[R0, R1]
   \   000000AC   0x....             LDR.N    R1,??DataTable34_2
   \   000000AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B0   0x016A             LSLS     R2,R5,#+5
   \   000000B2   0x4411             ADD      R1,R1,R2
   \   000000B4   0x7E49             LDRB     R1,[R1, #+25]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD103             BNE.N    ??CardBoxBasicInfoResponse_5
   2525                  CardBoxCountReset(ucSelected);
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x.... 0x....      BL       CardBoxCountReset
   2526                }
   2527                
   2528                if(ucType==SMALL_THICK_IN_TYPE || ucType==SMALL_THICK_GIN_TYPE){
   \                     ??CardBoxBasicInfoResponse_5: (+1)
   \   000000C2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000C4   0x2F01             CMP      R7,#+1
   \   000000C6   0xD002             BEQ.N    ??CardBoxBasicInfoResponse_6
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x2F03             CMP      R7,#+3
   \   000000CC   0xD12C             BNE.N    ??CardBoxBasicInfoResponse_7
   2529                  //收卡
   2530                  if((pcommData->ucData[8]&0x03)==0x02){
   \                     ??CardBoxBasicInfoResponse_6: (+1)
   \   000000CE   0x7BA0             LDRB     R0,[R4, #+14]
   \   000000D0   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000D4   0x2802             CMP      R0,#+2
   \   000000D6   0xD11A             BNE.N    ??CardBoxBasicInfoResponse_8
   2531                    m_usrBoxInfo[ucSelected].usrFlag.usrBit.bCardPos=1;												//到位
   \   000000D8   0x....             LDR.N    R0,??DataTable34_2
   \   000000DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DC   0x0169             LSLS     R1,R5,#+5
   \   000000DE   0x4408             ADD      R0,R0,R1
   \   000000E0   0x7B80             LDRB     R0,[R0, #+14]
   \   000000E2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000E6   0x....             LDR.N    R1,??DataTable34_2
   \   000000E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EA   0x016A             LSLS     R2,R5,#+5
   \   000000EC   0x4411             ADD      R1,R1,R2
   \   000000EE   0x7388             STRB     R0,[R1, #+14]
   2532                    if(!m_usrBoxInfo[ucSelected].usrFlag.usrBit.bSelftest){
   \   000000F0   0x....             LDR.N    R0,??DataTable34_2
   \   000000F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F4   0x0169             LSLS     R1,R5,#+5
   \   000000F6   0x4408             ADD      R0,R0,R1
   \   000000F8   0x7B80             LDRB     R0,[R0, #+14]
   \   000000FA   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD145             BNE.N    ??CardBoxBasicInfoResponse_9
   2533                      CardBoxPosReset(ucSelected);
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0x.... 0x....      BL       CardBoxPosReset
   \   0000010C   0xE040             B.N      ??CardBoxBasicInfoResponse_9
   2534                    }
   2535                  }else{
   2536                    m_usrBoxInfo[ucSelected].usrFlag.usrBit.bCardPos=0;
   \                     ??CardBoxBasicInfoResponse_8: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable34_2
   \   00000110   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000112   0x0169             LSLS     R1,R5,#+5
   \   00000114   0x4408             ADD      R0,R0,R1
   \   00000116   0x7B80             LDRB     R0,[R0, #+14]
   \   00000118   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   0000011C   0x....             LDR.N    R1,??DataTable34_2
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0x016A             LSLS     R2,R5,#+5
   \   00000122   0x4411             ADD      R1,R1,R2
   \   00000124   0x7388             STRB     R0,[R1, #+14]
   \   00000126   0xE033             B.N      ??CardBoxBasicInfoResponse_9
   2537                  }
   2538                }else if(ucType==SMALL_THICK_OUT_TYPE || ucType==LARGE_THICK_OUT_TYPE){
   \                     ??CardBoxBasicInfoResponse_7: (+1)
   \   00000128   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012A   0x2F00             CMP      R7,#+0
   \   0000012C   0xD002             BEQ.N    ??CardBoxBasicInfoResponse_10
   \   0000012E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000130   0x2F04             CMP      R7,#+4
   \   00000132   0xD12D             BNE.N    ??CardBoxBasicInfoResponse_9
   2539                  //发卡
   2540                  if((pcommData->ucData[8]&0x03)==0x01){
   \                     ??CardBoxBasicInfoResponse_10: (+1)
   \   00000134   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000136   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD11C             BNE.N    ??CardBoxBasicInfoResponse_11
   2541                    m_usrBoxInfo[ucSelected].usrFlag.usrBit.bCardPos=1;												//到位
   \   0000013E   0x....             LDR.N    R0,??DataTable34_2
   \   00000140   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000142   0x0169             LSLS     R1,R5,#+5
   \   00000144   0x4408             ADD      R0,R0,R1
   \   00000146   0x7B80             LDRB     R0,[R0, #+14]
   \   00000148   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000014C   0x....             LDR.N    R1,??DataTable34_2
   \   0000014E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000150   0x016A             LSLS     R2,R5,#+5
   \   00000152   0x4411             ADD      R1,R1,R2
   \   00000154   0x7388             STRB     R0,[R1, #+14]
   2542                    m_usrBoxInfo[ucSelected].usrFlag.usrBit.bSelftest=0;
   \   00000156   0x....             LDR.N    R0,??DataTable34_2
   \   00000158   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000015A   0x0169             LSLS     R1,R5,#+5
   \   0000015C   0x4408             ADD      R0,R0,R1
   \   0000015E   0x7B80             LDRB     R0,[R0, #+14]
   \   00000160   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000164   0x....             LDR.N    R1,??DataTable34_2
   \   00000166   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000168   0x016A             LSLS     R2,R5,#+5
   \   0000016A   0x4411             ADD      R1,R1,R2
   \   0000016C   0x7388             STRB     R0,[R1, #+14]
   2543                    CardBoxPosReset(ucSelected);
   \   0000016E   0x0028             MOVS     R0,R5
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x.... 0x....      BL       CardBoxPosReset
   \   00000176   0xE00B             B.N      ??CardBoxBasicInfoResponse_9
   2544                  }else{
   2545                    m_usrBoxInfo[ucSelected].usrFlag.usrBit.bCardPos=0;
   \                     ??CardBoxBasicInfoResponse_11: (+1)
   \   00000178   0x....             LDR.N    R0,??DataTable34_2
   \   0000017A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000017C   0x0169             LSLS     R1,R5,#+5
   \   0000017E   0x4408             ADD      R0,R0,R1
   \   00000180   0x7B80             LDRB     R0,[R0, #+14]
   \   00000182   0xF010 0x00DF      ANDS     R0,R0,#0xDF
   \   00000186   0x....             LDR.N    R1,??DataTable34_2
   \   00000188   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018A   0x016A             LSLS     R2,R5,#+5
   \   0000018C   0x4411             ADD      R1,R1,R2
   \   0000018E   0x7388             STRB     R0,[R1, #+14]
   2546                  }
   2547                }
   2548                BoxConnected(ucSelected);
   \                     ??CardBoxBasicInfoResponse_9: (+1)
   \   00000190   0x0028             MOVS     R0,R5
   \   00000192   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000194   0x.... 0x....      BL       BoxConnected
   2549              }
   2550            }
   2551          }
   \                     ??CardBoxBasicInfoResponse_2: (+1)
   \                     ??CardBoxBasicInfoResponse_0: (+1)
   \   00000198   0xB011             ADD      SP,SP,#+68
   \   0000019A   0xBDF0             POP      {R4-R7,PC}       ;; return
   2552          
   2553          /********************************************************************************************************
   2554          ** 函数名称: CardBoxCountAddSubResponse
   2555          ** 功能描述:
   2556          ** 输 　 入:
   2557          **
   2558          ** 输　  出:
   2559          **
   2560          ** 全局变量:
   2561          ** 调用模块:
   2562          **
   2563          ** 作　  者: John Tonny
   2564          ** 日　  期: 2005年05月01日
   2565          **------------------------------------------------------------------------------------------------------
   2566          ** 修 改 人:
   2567          ** 日　  期:
   2568          **------------------------------------------------------------------------------------------------------
   2569          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2570          void CardBoxCountAddSubResponse(CommRxData *pcommData,INT8U ucSelected)
   2571          {
   \                     CardBoxCountAddSubResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2572            INT8U ucData[32];
   2573          	
   2574            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA3E             BGE.N    ??CardBoxCountAddSubResponse_0
   2575              return;
   2576            }
   2577            
   2578            if(UartLengthProcess(pcommData,2)){
   \                     ??CardBoxCountAddSubResponse_1: (+1)
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UartLengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD038             BEQ.N    ??CardBoxCountAddSubResponse_2
   2579              if(!pcommData->ucStatus){
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD135             BNE.N    ??CardBoxCountAddSubResponse_2
   2580                if(m_usrBoxInfo[ucSelected].ucCounts!=pcommData->ucData[0]){
   \   00000020   0x....             LDR.N    R0,??DataTable34_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0169             LSLS     R1,R5,#+5
   \   00000026   0x5C40             LDRB     R0,[R0, R1]
   \   00000028   0x79A1             LDRB     R1,[R4, #+6]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD007             BEQ.N    ??CardBoxCountAddSubResponse_3
   2581                  ucData[0]=DISPLAY_MAIN_MSG;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2582                  Box_TaskLcdQPost(&App_TaskLcdTCB,ucData,1);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0xA902             ADD      R1,SP,#+8
   \   00000038   0x....             LDR.N    R0,??DataTable34_6
   \   0000003A   0x.... 0x....      BL       Box_TaskLcdQPost
   2583                }
   2584                
   2585                m_usrBoxInfo[ucSelected].ucCounts=pcommData->ucData[0];
   \                     ??CardBoxCountAddSubResponse_3: (+1)
   \   0000003E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000040   0x....             LDR.N    R1,??DataTable34_2
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x016A             LSLS     R2,R5,#+5
   \   00000046   0x5488             STRB     R0,[R1, R2]
   2586                ucData[0]=ucSelected+0x30;
   \   00000048   0xF115 0x0030      ADDS     R0,R5,#+48
   \   0000004C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2587                SprintF(&ucData[1],4,m_usrBoxInfo[ucSelected].ucCounts);
   \   00000050   0x....             LDR.N    R0,??DataTable34_2
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0x0169             LSLS     R1,R5,#+5
   \   00000056   0x5C42             LDRB     R2,[R0, R1]
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0xF10D 0x0009      ADD      R0,SP,#+9
   \   0000005E   0x.... 0x....      BL       SprintF
   2588              #if COUNT_ID_EN==0          
   2589                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,0,ucData,5,1);
   2590              #else
   2591                SprintF(&ucData[5],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \   00000062   0x....             LDR.N    R0,??DataTable34_2
   \   00000064   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000066   0x0169             LSLS     R1,R5,#+5
   \   00000068   0x4408             ADD      R0,R0,R1
   \   0000006A   0x6842             LDR      R2,[R0, #+4]
   \   0000006C   0x2108             MOVS     R1,#+8
   \   0000006E   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000072   0x.... 0x....      BL       SprintF
   2592                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,0,ucData,13,1);
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x9001             STR      R0,[SP, #+4]
   \   0000007A   0x200D             MOVS     R0,#+13
   \   0000007C   0x9000             STR      R0,[SP, #+0]
   \   0000007E   0xAB02             ADD      R3,SP,#+8
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x....             LDR.N    R0,??DataTable34_4
   \   00000084   0x7801             LDRB     R1,[R0, #+0]
   \   00000086   0x2062             MOVS     R0,#+98
   \   00000088   0x.... 0x....      BL       Uart0Pack
   2593              #endif          
   2594              }
   2595            }
   2596          }
   \                     ??CardBoxCountAddSubResponse_2: (+1)
   \                     ??CardBoxCountAddSubResponse_0: (+1)
   \   0000008C   0xB00B             ADD      SP,SP,#+44
   \   0000008E   0xBD30             POP      {R4,R5,PC}       ;; return
   2597          
   2598          /********************************************************************************************************
   2599          ** 函数名称: CardBoxCountResponse
   2600          ** 功能描述:
   2601          ** 输 　 入:
   2602          **
   2603          ** 输　  出:
   2604          **
   2605          ** 全局变量:
   2606          ** 调用模块:
   2607          **
   2608          ** 作　  者: John Tonny
   2609          ** 日　  期: 2005年05月01日
   2610          **------------------------------------------------------------------------------------------------------
   2611          ** 修 改 人:
   2612          ** 日　  期:
   2613          **------------------------------------------------------------------------------------------------------
   2614          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2615          void CardBoxCountResponse(CommRxData *pcommData,INT8U ucSelected)
   2616          {
   \                     CardBoxCountResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2617            INT8U ucData[32];
   2618                
   2619            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA51             BGE.N    ??CardBoxCountResponse_0
   2620              return;
   2621            }
   2622            
   2623            if(UartLengthProcess(pcommData,2)){
   \                     ??CardBoxCountResponse_1: (+1)
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UartLengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD04B             BEQ.N    ??CardBoxCountResponse_2
   2624              if(!pcommData->ucStatus){
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD148             BNE.N    ??CardBoxCountResponse_2
   2625                if(m_usrBoxInfo[ucSelected].ucCounts!=pcommData->ucData[0]){
   \   00000020   0x....             LDR.N    R0,??DataTable34_2
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0169             LSLS     R1,R5,#+5
   \   00000026   0x5C40             LDRB     R0,[R0, R1]
   \   00000028   0x79A1             LDRB     R1,[R4, #+6]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD007             BEQ.N    ??CardBoxCountResponse_3
   2626                  ucData[0]=DISPLAY_MAIN_MSG;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2627                  Box_TaskLcdQPost(&App_TaskLcdTCB,ucData,1);
   \   00000034   0x2201             MOVS     R2,#+1
   \   00000036   0xA902             ADD      R1,SP,#+8
   \   00000038   0x....             LDR.N    R0,??DataTable34_6
   \   0000003A   0x.... 0x....      BL       Box_TaskLcdQPost
   2628                }
   2629                m_usrBoxInfo[ucSelected].ucCounts=pcommData->ucData[0];
   \                     ??CardBoxCountResponse_3: (+1)
   \   0000003E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000040   0x....             LDR.N    R1,??DataTable34_2
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x016A             LSLS     R2,R5,#+5
   \   00000046   0x5488             STRB     R0,[R1, R2]
   2630                
   2631                if(m_usrBoxInfo[ucSelected].usrCountResponse.ucEnabled && m_usrBoxInfo[ucSelected].ucCounts==m_usrBoxInfo[ucSelected].usrCountResponse.ucNewCount){
   \   00000048   0x....             LDR.N    R0,??DataTable34_2
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x0169             LSLS     R1,R5,#+5
   \   0000004E   0x4408             ADD      R0,R0,R1
   \   00000050   0x7C00             LDRB     R0,[R0, #+16]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00E             BEQ.N    ??CardBoxCountResponse_4
   \   00000056   0x....             LDR.N    R0,??DataTable34_2
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x0169             LSLS     R1,R5,#+5
   \   0000005C   0x5C40             LDRB     R0,[R0, R1]
   \   0000005E   0x....             LDR.N    R1,??DataTable34_2
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x016A             LSLS     R2,R5,#+5
   \   00000064   0x4411             ADD      R1,R1,R2
   \   00000066   0x7E49             LDRB     R1,[R1, #+25]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD103             BNE.N    ??CardBoxCountResponse_4
   2632                  CardBoxCountReset(ucSelected);
   \   0000006C   0x0028             MOVS     R0,R5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       CardBoxCountReset
   2633                }
   2634                
   2635                ucData[0]=ucSelected+0x30;
   \                     ??CardBoxCountResponse_4: (+1)
   \   00000074   0xF115 0x0030      ADDS     R0,R5,#+48
   \   00000078   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2636                SprintF(&ucData[1],4,pcommData->ucData[0]);
   \   0000007C   0x79A2             LDRB     R2,[R4, #+6]
   \   0000007E   0x2104             MOVS     R1,#+4
   \   00000080   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000084   0x.... 0x....      BL       SprintF
   2637              #if COUNT_ID_EN==0          
   2638                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,pcommData->ucData[2],ucData,5,0);
   2639              #else
   2640                SprintF(&ucData[5],8,m_usrBoxInfo[ucSelected].ulMachineId);
   \   00000088   0x....             LDR.N    R0,??DataTable34_2
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x0169             LSLS     R1,R5,#+5
   \   0000008E   0x4408             ADD      R0,R0,R1
   \   00000090   0x6842             LDR      R2,[R0, #+4]
   \   00000092   0x2108             MOVS     R1,#+8
   \   00000094   0xF10D 0x000D      ADD      R0,SP,#+13
   \   00000098   0x.... 0x....      BL       SprintF
   2641                Uart0Pack(INFTYPE_CARD_COUNT,m_ucMachineAddr,pcommData->ucData[2],ucData,13,0);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0x200D             MOVS     R0,#+13
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0xAB02             ADD      R3,SP,#+8
   \   000000A6   0x7A22             LDRB     R2,[R4, #+8]
   \   000000A8   0x....             LDR.N    R0,??DataTable34_4
   \   000000AA   0x7801             LDRB     R1,[R0, #+0]
   \   000000AC   0x2062             MOVS     R0,#+98
   \   000000AE   0x.... 0x....      BL       Uart0Pack
   2642              #endif          
   2643              }
   2644            }
   2645          }
   \                     ??CardBoxCountResponse_2: (+1)
   \                     ??CardBoxCountResponse_0: (+1)
   \   000000B2   0xB00B             ADD      SP,SP,#+44
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
   2646          
   2647          /********************************************************************************************************
   2648          ** 函数名称: CardBoxMaxCountResponse
   2649          ** 功能描述:
   2650          ** 输 　 入:
   2651          **
   2652          ** 输　  出:
   2653          **
   2654          ** 全局变量:
   2655          ** 调用模块:
   2656          **
   2657          ** 作　  者: John Tonny
   2658          ** 日　  期: 2005年05月01日
   2659          **------------------------------------------------------------------------------------------------------
   2660          ** 修 改 人:
   2661          ** 日　  期:
   2662          **------------------------------------------------------------------------------------------------------
   2663          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2664          void CardBoxMaxCountResponse(CommRxData *pcommData,INT8U ucSelected)
   2665          {
   \                     CardBoxMaxCountResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2666            INT8U ucData[32];
   2667            
   2668            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA1D             BGE.N    ??CardBoxMaxCountResponse_0
   2669              return;
   2670            }
   2671            
   2672            if(UartLengthProcess(pcommData,2)){
   \                     ??CardBoxMaxCountResponse_1: (+1)
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       UartLengthProcess
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD017             BEQ.N    ??CardBoxMaxCountResponse_2
   2673              if(!pcommData->ucStatus){
   \   0000001A   0x7960             LDRB     R0,[R4, #+5]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD114             BNE.N    ??CardBoxMaxCountResponse_2
   2674                ucData[0]=ucSelected+0x30;
   \   00000020   0xF115 0x0030      ADDS     R0,R5,#+48
   \   00000024   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2675                SprintF(&ucData[1],4,pcommData->ucData[0]);
   \   00000028   0x79A2             LDRB     R2,[R4, #+6]
   \   0000002A   0x2104             MOVS     R1,#+4
   \   0000002C   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000030   0x.... 0x....      BL       SprintF
   2676                Uart0Pack(INFTYPE_CARD_COUNT_MAX,m_ucMachineAddr,pcommData->ucData[2+1],ucData,5,0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9001             STR      R0,[SP, #+4]
   \   00000038   0x2005             MOVS     R0,#+5
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAB02             ADD      R3,SP,#+8
   \   0000003E   0x7A62             LDRB     R2,[R4, #+9]
   \   00000040   0x....             LDR.N    R0,??DataTable34_4
   \   00000042   0x7801             LDRB     R1,[R0, #+0]
   \   00000044   0x2068             MOVS     R0,#+104
   \   00000046   0x.... 0x....      BL       Uart0Pack
   2677              }
   2678            }
   2679          }
   \                     ??CardBoxMaxCountResponse_2: (+1)
   \                     ??CardBoxMaxCountResponse_0: (+1)
   \   0000004A   0xB00B             ADD      SP,SP,#+44
   \   0000004C   0xBD30             POP      {R4,R5,PC}       ;; return
   2680          
   2681          /********************************************************************************************************
   2682          ** 函数名称: CardBoxVersioinResponse
   2683          ** 功能描述:
   2684          ** 输 　 入:
   2685          **
   2686          ** 输　  出:
   2687          **
   2688          ** 全局变量:
   2689          ** 调用模块:
   2690          **
   2691          ** 作　  者: John Tonny
   2692          ** 日　  期: 2005年05月01日
   2693          **------------------------------------------------------------------------------------------------------
   2694          ** 修 改 人:
   2695          ** 日　  期:
   2696          **------------------------------------------------------------------------------------------------------
   2697          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2698          void CardBoxVersionResponse(CommRxData *pcommData,INT8U ucSelected)
   2699          {
   \                     CardBoxVersionResponse: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   2700            INT8U ucData[32];
   2701          
   2702            if(ucSelected>=CARDMACHINE_CARDBOX_NUMS){
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D03             CMP      R5,#+3
   \   0000000C   0xDA1B             BGE.N    ??CardBoxVersionResponse_0
   2703              return;
   2704            }
   2705            
   2706            if(!pcommData->ucStatus){
   \                     ??CardBoxVersionResponse_1: (+1)
   \   0000000E   0x7960             LDRB     R0,[R4, #+5]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD118             BNE.N    ??CardBoxVersionResponse_2
   2707              ucData[0]=ucSelected+0x30;
   \   00000014   0xF115 0x0030      ADDS     R0,R5,#+48
   \   00000018   0xF88D 0x0008      STRB     R0,[SP, #+8]
   2708              Mem_Copy(&ucData[1],pcommData->ucData,pcommData->ucLen-6);
   \   0000001C   0x7860             LDRB     R0,[R4, #+1]
   \   0000001E   0x1F82             SUBS     R2,R0,#+6
   \   00000020   0x1DA1             ADDS     R1,R4,#+6
   \   00000022   0xF10D 0x0009      ADD      R0,SP,#+9
   \   00000026   0x.... 0x....      BL       Mem_Copy
   2709              Uart0Pack(0x9A,m_ucMachineAddr,pcommData->ucData[pcommData->ucLen-3-3],ucData,pcommData->ucLen-6+1,0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x7860             LDRB     R0,[R4, #+1]
   \   00000030   0x1F40             SUBS     R0,R0,#+5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x9000             STR      R0,[SP, #+0]
   \   00000036   0xAB02             ADD      R3,SP,#+8
   \   00000038   0x7860             LDRB     R0,[R4, #+1]
   \   0000003A   0x5C22             LDRB     R2,[R4, R0]
   \   0000003C   0x....             LDR.N    R0,??DataTable34_4
   \   0000003E   0x7801             LDRB     R1,[R0, #+0]
   \   00000040   0x209A             MOVS     R0,#+154
   \   00000042   0x.... 0x....      BL       Uart0Pack
   2710            }
   2711          }
   \                     ??CardBoxVersionResponse_2: (+1)
   \                     ??CardBoxVersionResponse_0: (+1)
   \   00000046   0xB00B             ADD      SP,SP,#+44
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
   2712          
   2713          /********************************************************************************************************
   2714          ** 函数名称: GetVersion
   2715          ** 功能描述:
   2716          ** 输 　 入:
   2717          **
   2718          ** 输　  出:
   2719          **
   2720          ** 全局变量:
   2721          ** 调用模块:
   2722          **
   2723          ** 作　  者: John Tonny
   2724          ** 日　  期: 2005年05月01日
   2725          **------------------------------------------------------------------------------------------------------
   2726          ** 修 改 人:
   2727          ** 日　  期:
   2728          **------------------------------------------------------------------------------------------------------
   2729          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2730          INT8U GetVersion(INT8U *pucData)
   2731          {
   \                     GetVersion: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2732            INT8U ucTmp;
   2733            INT8U ucLen;
   2734            
   2735            ucLen=sizeof(m_ucVersion)-1;
   \   00000004   0x2008             MOVS     R0,#+8
   \   00000006   0x0006             MOVS     R6,R0
   2736            Mem_Copy(&pucData[0],m_ucVersion,ucLen);
   \   00000008   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x....             LDR.N    R1,??DataTable34_7
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       Mem_Copy
   2737            ucTmp=ucLen;
   \   00000014   0x0035             MOVS     R5,R6
   2738            pucData[ucTmp++]=0x20;
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x5560             STRB     R0,[R4, R5]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   2739            ucLen=sizeof(m_ucCompileDate)-1;
   \   0000001E   0x200B             MOVS     R0,#+11
   \   00000020   0x0006             MOVS     R6,R0
   2740            Mem_Copy(&pucData[ucTmp],m_ucCompileDate,ucLen);
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x....             LDR.N    R1,??DataTable34_8
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000002E   0x.... 0x....      BL       Mem_Copy
   2741            ucTmp+=ucLen;
   \   00000032   0x1975             ADDS     R5,R6,R5
   2742            pucData[ucTmp++]=0x20;
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x5560             STRB     R0,[R4, R5]
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   2743            ucLen=sizeof(m_ucCompileTime)-1;
   \   0000003C   0x2008             MOVS     R0,#+8
   \   0000003E   0x0006             MOVS     R6,R0
   2744            Mem_Copy(&pucData[ucTmp],m_ucCompileTime,ucLen);
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x0032             MOVS     R2,R6
   \   00000044   0x....             LDR.N    R1,??DataTable34_9
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0xEB04 0x0005      ADD      R0,R4,R5
   \   0000004C   0x.... 0x....      BL       Mem_Copy
   2745            ucTmp+=ucLen;	
   \   00000050   0x1975             ADDS     R5,R6,R5
   2746            return ucTmp;
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   2747          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     m_ucSMotoFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     m_uiDMotoPwm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     m_usrBoxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     m_ucDMotoBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     m_ucSMotoBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     m_ucUartBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     m_ucKeyBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     m_ucSMotoFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     g_ucGInState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     m_usrGlobalFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     g_usrGetKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     App_TaskLcdTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     g_usrGlobalFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     m_usrBoxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     g_usrGetKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     m_usrBoxInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x05F5E0FF         DC32     0x5f5e0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_4:
   \   00000000   0x........         DC32     m_ucMachineAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_5:
   \   00000000   0x........         DC32     m_ucKeyBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_6:
   \   00000000   0x........         DC32     App_TaskLcdTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_7:
   \   00000000   0x........         DC32     m_ucVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_8:
   \   00000000   0x........         DC32     m_ucCompileDate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_9:
   \   00000000   0x........         DC32     m_ucCompileTime

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x31 0x32          DC8 49, 50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x33 0x34    
   \              0x35 0x36    
   \              0x37 0x38    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   2748          
   2749          
   2750          
   2751          
   2752          /*******************************************************************************************************
   2753          **                            End Of File
   2754          *******************************************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      88   AutoOutModeRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   AutoOutModeWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   BoxSelectRead
        88   -> BoxSelectGet
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      96   BoxSelectWrite
        96   -> EepromWriteVerifyBytes
        96   -> Mem_Copy
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
      88   BuzzEnRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   BuzzEnWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   CardBoxBasicInfoResponse
        88   -> BoxConnected
        88   -> Box_TaskLcdQPost
        88   -> CardBoxConnectReset
        88   -> CardBoxCountReset
        88   -> CardBoxPosReset
        88   -> DEV_TYPE
        88   -> UartLengthProcess
      88   CardBoxCountAddSub
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> UartPack
      56   CardBoxCountAddSubResponse
        56   -> Box_TaskLcdQPost
        56   -> SprintF
        56   -> Uart0Pack
        56   -> UartLengthProcess
      88   CardBoxCountRead
        88   -> DEV_TYPE
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      56   CardBoxCountResponse
        56   -> Box_TaskLcdQPost
        56   -> CardBoxCountReset
        56   -> SprintF
        56   -> Uart0Pack
        56   -> UartLengthProcess
      88   CardBoxCountWrite
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> UartPack
        88   -> atoi
      88   CardBoxIdRead
        88   -> DEV_TYPE
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   CardBoxIdWrite
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> UartPack
        88   -> atoi
      56   CardBoxMachineIdResponse
        56   -> SprintF
        56   -> Uart0Pack
        56   -> UartLengthProcess
      88   CardBoxMaxCountRead
        88   -> DEV_TYPE
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      56   CardBoxMaxCountResponse
        56   -> SprintF
        56   -> Uart0Pack
        56   -> UartLengthProcess
      96   CardBoxMaxCountWrite
        96   -> AscToByte
        96   -> EepromWriteVerifyBytes
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
        96   -> UartPack
        96   -> atoi
      56   CardBoxMotoMove
        56   -> Uart0LengthProcess
        56   -> Uart0Pack
        56   -> UartPack
      88   CardBoxRecordInit
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> UartPack
      56   CardBoxRecordInitResponse
        56   -> SprintF
        56   -> Uart0Pack
        56   -> UartLengthProcess
      88   CardBoxVersionRead
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> UartPack
      56   CardBoxVersionResponse
        56   -> Mem_Copy
        56   -> Uart0Pack
      80   CardMachineAddrRead
        80   -> EepromReadVerifyBytes
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      80   CardMachineAddrWrite
        80   -> EepromWriteVerifyBytes
        80   -> Mem_Copy
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      88   CardMachineAlarmMaxRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   CardMachineAlarmMaxWrite
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      88   CardMachineAlarmMinRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   CardMachineAlarmMinWrite
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      96   CardMachineDataRead
        96   -> AscToByte
        96   -> BytesToAscs
        96   -> EepromReadBytes
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
       8   CardMachineDataWrite
         8   -> Uart0LengthProcess
      80   CardMachineIdRead
        80   -> EepromReadVerifyBytes
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      80   CardMachineIdWrite
        80   -> EepromWriteVerifyBytes
        80   -> Mem_Copy
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      88   CardMachineMaxCountRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   CardMachineMaxCountWrite
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      24   CardMachineStateRead
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> Uart0LengthProcess
        24   -> Uart0Pack
      80   CardMachineTypeRead
        80   -> DEV_TYPE
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      88   CardMachineVersionRead
        88   -> GetVersion
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      80   CardToBox
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      80   CardToOut
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      96   DMotoMove
        96   -> DMotoStart
        96   -> MOTO_DC_DISABLED
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
        96   -> atoi
      88   DMotoReadParams
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   DMotoSelectRead
        88   -> DMotoSelectGet
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      96   DMotoSelectWrite
        96   -> EepromWriteVerifyBytes
        96   -> Mem_Copy
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
      88   DMotoWriteParams
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      16   GetVersion
        16   -> Mem_Copy
      88   GroupSelectRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   GroupSelectWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   KeySelectRead
        88   -> KeySelectGet
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      96   KeySelectWrite
        96   -> CPU_IntDisMeasStart
        96   -> CPU_IntDisMeasStop
        96   -> CPU_SR_Restore
        96   -> CPU_SR_Save
        96   -> EepromWriteVerifyBytes
        96   -> KeyBitDecode
        96   -> KeyBitEncode
        96   -> Mem_Copy
        96   -> Uart0LengthProcess
        96   -> Uart0Pack
      48   KeyTest
        48   -> Box_TaskLcdQPost
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_Cmp
        48   -> Uart0LengthProcess
        48   -> Uart0Pack
        48   -> __aeabi_memcpy4
      88   ParamsFlagRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   ParamsFlagWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      88   SMotoMove
        88   -> SMotoStart
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      88   SMotoReadParams
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      80   SMotoSelectRead
        80   -> SMotoSelectGet
        80   -> Uart0LengthProcess
        80   -> Uart0Pack
      88   SMotoSelectWrite
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   SMotoWriteParams
        88   -> EepromWriteVerifyBytes
        88   -> Mem_Copy
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      88   ScanParamsRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   ScanParamsWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi
      24   Uart0LengthProcess
        24   -> Uart0Pack
       0   UartLengthProcess
      88   UltraSoundRead
        88   -> EepromReadVerifyBytes
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
      88   UltraSoundWrite
        88   -> EepromWriteVerifyBytes
        88   -> SprintF
        88   -> Uart0LengthProcess
        88   -> Uart0Pack
        88   -> atoi


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable28
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable34_8
       4  ??DataTable34_9
      16  ?_0
      90  AutoOutModeRead
     120  AutoOutModeWrite
      84  BoxSelectRead
     282  BoxSelectWrite
     110  BuzzEnRead
     186  BuzzEnWrite
     412  CardBoxBasicInfoResponse
     184  CardBoxCountAddSub
     144  CardBoxCountAddSubResponse
     210  CardBoxCountRead
     182  CardBoxCountResponse
     174  CardBoxCountWrite
     264  CardBoxIdRead
     128  CardBoxIdWrite
     102  CardBoxMachineIdResponse
     164  CardBoxMaxCountRead
      78  CardBoxMaxCountResponse
     254  CardBoxMaxCountWrite
     100  CardBoxMotoMove
     124  CardBoxRecordInit
     116  CardBoxRecordInitResponse
      80  CardBoxVersionRead
      74  CardBoxVersionResponse
      86  CardMachineAddrRead
     122  CardMachineAddrWrite
     128  CardMachineAlarmMaxRead
     168  CardMachineAlarmMaxWrite
     128  CardMachineAlarmMinRead
     168  CardMachineAlarmMinWrite
     186  CardMachineDataRead
      14  CardMachineDataWrite
      84  CardMachineIdRead
      94  CardMachineIdWrite
     130  CardMachineMaxCountRead
     138  CardMachineMaxCountWrite
      70  CardMachineStateRead
     200  CardMachineTypeRead
      52  CardMachineVersionRead
     134  CardToBox
     126  CardToOut
     212  DMotoMove
     188  DMotoReadParams
      84  DMotoSelectRead
     390  DMotoSelectWrite
     216  DMotoWriteParams
      88  GetVersion
      90  GroupSelectRead
     146  GroupSelectWrite
      84  KeySelectRead
     342  KeySelectWrite
     268  KeyTest
      96  ParamsFlagRead
     134  ParamsFlagWrite
     180  SMotoMove
     188  SMotoReadParams
      78  SMotoSelectRead
     212  SMotoSelectWrite
     210  SMotoWriteParams
     110  ScanParamsRead
     156  ScanParamsWrite
      48  Uart0LengthProcess
      20  UartLengthProcess
     110  UltraSoundRead
     156  UltraSoundWrite
      12  m_ucCompileDate
      12  m_ucCompileTime
      12  m_ucVersion
      64  m_usrComm1RxData

 
    64 bytes in section .bss
    36 bytes in section .data
    16 bytes in section .rodata
 9 596 bytes in section .text
 
 9 596 bytes of CODE  memory
    16 bytes of CONST memory
   100 bytes of DATA  memory

Errors: none
Warnings: none
