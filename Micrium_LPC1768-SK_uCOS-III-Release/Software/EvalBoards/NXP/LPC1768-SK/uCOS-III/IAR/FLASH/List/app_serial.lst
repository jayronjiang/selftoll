###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:01
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\app_serial.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\app_serial.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\app_serial.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\app_serial.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\app_serial.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              EXAMPLE CODE
      4          *
      5          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                           uC/Serial
     18          *                                        Application Code
     19          *
     20          * Filename      : app_serial.c
     21          * Version       : V1.00
     22          * Programmer(s) : FT
     23          *********************************************************************************************************
     24          */
     25          
     26          /*
     27          *********************************************************************************************************
     28          *                                             INCLUDE FILES
     29          *********************************************************************************************************
     30          */
     31          
     32          
     33          #define  APP_SERIAL_MODULE
     34          #include <app_serial.h>

   \                                 In section .bss, align 4
   \   __absolute MEM_POOL m_UartBufPool
   \                     m_UartBufPool:
   \   00000000                      DS8 72

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskUart0ReceiveTCB
   \                     App_TaskUart0ReceiveTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskUart0ReceiveStk[128]
   \                     App_TaskUart0ReceiveStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskUart1ReceiveTCB
   \                     App_TaskUart1ReceiveTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskUart1ReceiveStk[128]
   \                     App_TaskUart1ReceiveStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskUart2ReceiveTCB
   \                     App_TaskUart2ReceiveTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskUart2ReceiveStk[128]
   \                     App_TaskUart2ReceiveStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskUart3ReceiveTCB
   \                     App_TaskUart3ReceiveTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskUart3ReceiveStk[128]
   \                     App_TaskUart3ReceiveStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskUartProcessTCB
   \                     App_TaskUartProcessTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskUartProcessStk[128]
   \                     App_TaskUartProcessStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskBoxTCB
   \                     App_TaskBoxTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskBoxStk[128]
   \                     App_TaskBoxStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskLcdTCB
   \                     App_TaskLcdTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskLcdStk[128]
   \                     App_TaskLcdStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskBuzzTCB
   \                     App_TaskBuzzTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskBuzzStk[128]
   \                     App_TaskBuzzStk:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
   \   __absolute OS_TCB App_TaskActionTCB
   \                     App_TaskActionTCB:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute CPU_ADDR App_TaskActionStk[128]
   \                     App_TaskActionStk:
   \   00000000                      DS8 512
     35          #include <Global.h>
     36          #include <Hpi.h>
     37          #include <key.h>
     38          #include <Moto.h>
     39          #include <I2c.h>
     40          #include <I2C24C02.H>
     41          #include <bsp_os.h>
     42          #include <csp.h>
     43          
     44          
     45          //#if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)
     46          #include <stdio.h>
     47          //#endif
     48          
     49          #define OpenScan()           		  CSP_GPIO_BitClr(BSP_GPIO_SCAN_PORT,BSP_GPIO_SCAN_OUT);
     50          #define CloseScan()           		  CSP_GPIO_BitSet(BSP_GPIO_SCAN_PORT,BSP_GPIO_SCAN_OUT);
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                                 ENABLE
     55          *********************************************************************************************************
     56          */
     57          
     58          #if (APP_CFG_SERIAL_EN == DEF_ENABLED)
     59          
     60          #define UART0_MODE      0
     61          
     62          #define ULTRASOUND_EN   1
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                       LOCAL GLOBAL VARIABLES
     67          *********************************************************************************************************
     68          */
     69          
     70          #if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)
     71          static  SERIAL_IF_NBR    App_SerTraceIF_Nbr;
     72          #endif
     73          

   \                                 In section .bss, align 4
     74          static SERIAL_IF_NBR     Uart_SerTraceIF_Nbr[4];
   \                     Uart_SerTraceIF_Nbr:
   \   00000000                      DS8 4
     75          
     76          extern BSP_OS_SEM                *g_pActionSem;
     77          

   \                                 In section .data, align 4
     78          static INT8U m_ucBoxToUart[3]={2,1,3};
   \                     m_ucBoxToUart:
   \   00000000   0x02 0x01          DC8 2, 1, 3, 0
   \              0x03 0x00    

   \                                 In section .data, align 4
     79          static INT8U m_ucUartToBox[3]={1,0,2};
   \                     m_ucUartToBox:
   \   00000000   0x01 0x00          DC8 1, 0, 2, 0
   \              0x02 0x00    
     80          
     81          /*
     82          *********************************************************************************************************
     83          *                                          FUNCTION PROTOTYPES
     84          *********************************************************************************************************
     85          */
     86          
     87          
     88          /*
     89          *********************************************************************************************************
     90          *                                    LOCAL CONFIGURATION ERRORS
     91          *********************************************************************************************************
     92          */
     93          
     94          
     95          /*
     96          *********************************************************************************************************
     97          *                                         App_SerialInit()
     98          *
     99          * Description : Initialize Serial module
    100          *
    101          * Argument(s) : none.
    102          *
    103          * Caller(s)   : Application
    104          *
    105          * Return(s)   : none.
    106          *
    107          * Note(s)     : none.
    108          *********************************************************************************************************
    109          */
    110          

   \                                 In section .text, align 2, keep-with-next
    111          CPU_BOOLEAN  App_SerialInit (void)
    112          {
   \                     App_SerialInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    113              SERIAL_ERR     err;
    114          #if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)  
    115              SERIAL_IF_CFG  uart_cfg;
    116          #endif
    117          
    118              CPU_SIZE_T      octets_reqd;
    119              LIB_ERR         lib_err;
    120              
    121              INT8U ucType=DEV_TYPE();
   \   00000004   0x.... 0x....      BL       DEV_TYPE
   \   00000008   0x0004             MOVS     R4,R0
    122              
    123              CPU_SR_ALLOC();
   \   0000000A   0x2500             MOVS     R5,#+0
    124              
    125              CPU_CRITICAL_ENTER();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   \   00000010   0x0005             MOVS     R5,R0
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStart
    126              Mem_PoolCreate((MEM_POOL   *)&m_UartBufPool,
    127                             (void       *) 0,
    128                             (CPU_SIZE_T  ) 0,
    129                             (CPU_SIZE_T  ) 20,
    130                             (CPU_SIZE_T  ) 64,
    131                             (CPU_SIZE_T  ) 1,
    132                             (CPU_SIZE_T *)&octets_reqd,
    133                             (LIB_ERR    *)&lib_err);
   \   00000016   0xF10D 0x0012      ADD      R0,SP,#+18
   \   0000001A   0x9003             STR      R0,[SP, #+12]
   \   0000001C   0xA805             ADD      R0,SP,#+20
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2040             MOVS     R0,#+64
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x2314             MOVS     R3,#+20
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000032   0x.... 0x....      BL       Mem_PoolCreate
    134              
    135              if (lib_err != LIB_MEM_ERR_NONE) {
   \   00000036   0xF9BD 0x0012      LDRSH    R0,[SP, #+18]
   \   0000003A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD006             BEQ.N    ??App_SerialInit_0
    136                  CPU_CRITICAL_EXIT();
   \   00000042   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000046   0x0028             MOVS     R0,R5
   \   00000048   0x.... 0x....      BL       CPU_SR_Restore
    137                  return (DEF_FAIL);    
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE04D             B.N      ??App_SerialInit_1
    138              }
    139              CPU_CRITICAL_EXIT();
   \                     ??App_SerialInit_0: (+1)
   \   00000050   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
    140                  
    141              Serial_Init();                                              /* Initial Serial module                                */
   \   0000005A   0x.... 0x....      BL       Serial_Init
    142          
    143              Serial_DevDrvAdd(                  "UART0",                 /* Add serial interface/device.                         */
    144                               (SERIAL_DEV_CFG *)&SerialDev_LPCxxxx_UART0,
    145                                                  128u,
    146                                                  128u,
    147                                                 &err);
   \   0000005E   0xA804             ADD      R0,SP,#+16
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0x2380             MOVS     R3,#+128
   \   00000064   0x2280             MOVS     R2,#+128
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000006E   0x.... 0x....      BL       Serial_DevDrvAdd
    148              
    149              if (err != SERIAL_ERR_NONE) {
   \   00000072   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD001             BEQ.N    ??App_SerialInit_2
    150                  return (DEF_FAIL);    
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE036             B.N      ??App_SerialInit_1
    151              }
    152              
    153              if(ucType!=SMALL_THICK_ZIN_TYPE && ucType!=SMALL_THIN_ZIN_TYPE){
   \                     ??App_SerialInit_2: (+1)
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x2C02             CMP      R4,#+2
   \   00000082   0xD012             BEQ.N    ??App_SerialInit_3
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2C0A             CMP      R4,#+10
   \   00000088   0xD00F             BEQ.N    ??App_SerialInit_3
    154                Serial_DevDrvAdd(                  "UART1",                 /* Add serial interface/device.                         */
    155                                 (SERIAL_DEV_CFG *)&SerialDev_LPCxxxx_UART1_Alt,
    156                                                    128u,
    157                                                    128u,
    158                                                   &err);
   \   0000008A   0xA804             ADD      R0,SP,#+16
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x2380             MOVS     R3,#+128
   \   00000090   0x2280             MOVS     R2,#+128
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable10_3
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable10_4
   \   0000009A   0x.... 0x....      BL       Serial_DevDrvAdd
    159                
    160                if (err != SERIAL_ERR_NONE) {
   \   0000009E   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD001             BEQ.N    ??App_SerialInit_3
    161                    return (DEF_FAIL);    
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE020             B.N      ??App_SerialInit_1
    162                }
    163              }
    164               
    165              Serial_DevDrvAdd(                  "UART2",                 /* Add serial interface/device.                         */
    166                               (SERIAL_DEV_CFG *)&SerialDev_LPCxxxx_UART2,
    167                                                  128u,
    168                                                  128u,
    169                                                 &err);
   \                     ??App_SerialInit_3: (+1)
   \   000000AA   0xA804             ADD      R0,SP,#+16
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x2380             MOVS     R3,#+128
   \   000000B0   0x2280             MOVS     R2,#+128
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable10_5
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable10_6
   \   000000BA   0x.... 0x....      BL       Serial_DevDrvAdd
    170              
    171              if (err != SERIAL_ERR_NONE) {
   \   000000BE   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD001             BEQ.N    ??App_SerialInit_4
    172                  return (DEF_FAIL);    
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xE010             B.N      ??App_SerialInit_1
    173              }
    174          
    175              Serial_DevDrvAdd(                  "UART3",                 /* Add serial interface/device.                         */
    176                               (SERIAL_DEV_CFG *)&SerialDev_LPCxxxx_UART3_Alt1,
    177                                                  128u,
    178                                                  128u,
    179                                                 &err);
   \                     ??App_SerialInit_4: (+1)
   \   000000CA   0xA804             ADD      R0,SP,#+16
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   \   000000CE   0x2380             MOVS     R3,#+128
   \   000000D0   0x2280             MOVS     R2,#+128
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable10_7
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable10_8
   \   000000DA   0x.... 0x....      BL       Serial_DevDrvAdd
    180              
    181              if (err != SERIAL_ERR_NONE) {
   \   000000DE   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD001             BEQ.N    ??App_SerialInit_5
    182                  return (DEF_FAIL);    
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE000             B.N      ??App_SerialInit_1
    183              }
    184              
    185          #if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)    
    186              uart_cfg.Baudrate = SERIAL_BAUDRATE_115200;
    187              uart_cfg.DataBits = SERIAL_DATABITS_8;
    188              uart_cfg.StopBits = SERIAL_STOPBITS_1;
    189              uart_cfg.Parity   = SERIAL_PARITY_NONE;
    190              uart_cfg.FlowCtrl = SERIAL_FLOW_CTRL_NONE;
    191          
    192              App_SerTraceIF_Nbr = Serial_Open((CPU_CHAR      *)APP_SERIAL_CFG_TRACE_PORT_NAME,
    193                                               (SERIAL_IF_CFG *)&uart_cfg,
    194                                               (SERIAL_ERR    *)&err);
    195              if (err != SERIAL_ERR_NONE) {
    196                  return (DEF_FAIL);
    197              }
    198              
    199              Serial_SetLineDrv((SERIAL_IF_NBR        ) App_SerTraceIF_Nbr,
    200                                (SERIAL_LINE_DRV_API *)&SerialLine_TTY ,
    201                                (SERIAL_ERR          *)&err);  
    202              if (err != SERIAL_ERR_NONE) {
    203                  return (DEF_FAIL);
    204              }
    205          #endif    
    206          
    207              return (DEF_OK);    
   \                     ??App_SerialInit_5: (+1)
   \   000000EA   0x2001             MOVS     R0,#+1
   \                     ??App_SerialInit_1: (+1)
   \   000000EC   0xB007             ADD      SP,SP,#+28
   \   000000EE   0xBD30             POP      {R4,R5,PC}       ;; return
    208          }
    209          
    210          /**********************************************************************************************************
    211          *                                           Uart_Receive()
    212          *
    213          * Description : Read a string from the serial terminal. 
    214          *
    215          * Argument(s) : p_str       Pointer to string.
    216          *
    217          *               len         String length.
    218          *
    219          * Return(s)   : The number of octets written.
    220          *
    221          * Caller(s)   : Application.
    222          *
    223          * Note(s)     : none.
    224          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    225          void Uart_Receive(void *p_arg)
    226          {
   \                     Uart_Receive: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    227            CPU_INT08U ucMode=*((CPU_INT08U *)p_arg);
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
    228              
    229            if(ucMode==0){
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD104             BNE.N    ??Uart_Receive_0
    230              Uart0Receive(ucMode);
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       Uart0Receive
   \   00000014   0xE009             B.N      ??Uart_Receive_1
    231            }else if(ucMode>=1 && ucMode<=3){
   \                     ??Uart_Receive_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD006             BEQ.N    ??Uart_Receive_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDA03             BGE.N    ??Uart_Receive_1
    232              UartReceive(ucMode);
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x.... 0x....      BL       UartReceive
    233            }      
    234          }
   \                     ??Uart_Receive_1: (+1)
   \   0000002A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    235          
    236          /**********************************************************************************************************
    237          *                                           Uart0Receive()
    238          *
    239          * Description : Read a string from the serial terminal. 
    240          *
    241          * Argument(s) : p_str       Pointer to string.
    242          *
    243          *               len         String length.
    244          *
    245          * Return(s)   : The number of octets written.
    246          *
    247          * Caller(s)   : Application.
    248          *
    249          * Note(s)     : none.
    250          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void  Uart0Receive  (CPU_INT08U ucMode)
    252          {
   \                     Uart0Receive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
    253            SERIAL_ERR     err;
    254            SERIAL_IF_CFG  uart_cfg;
    255            
    256            uart_cfg.Baudrate = SERIAL_BAUDRATE_9600;
   \   00000006   0xF44F 0x5016      MOV      R0,#+9600
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    257            uart_cfg.DataBits = SERIAL_DATABITS_8;
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    258            uart_cfg.StopBits = SERIAL_STOPBITS_1;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0005      STRB     R0,[SP, #+5]
    259            uart_cfg.Parity   = SERIAL_PARITY_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    260            uart_cfg.FlowCtrl = SERIAL_FLOW_CTRL_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF88D 0x0007      STRB     R0,[SP, #+7]
    261            Uart_SerTraceIF_Nbr[0] = Serial_Open((CPU_CHAR      *)"UART0",
    262                                             (SERIAL_IF_CFG *)&uart_cfg,
    263                                             (SERIAL_ERR    *)&err);
   \   00000024   0xAA02             ADD      R2,SP,#+8
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000002C   0x.... 0x....      BL       Serial_Open
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable10_9
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    264            if (err != SERIAL_ERR_NONE) {
   \   00000036   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD103             BNE.N    ??Uart0Receive_0
    265              return ;
    266            }
    267                
    268          #if UART0_MODE==0
    269            Uart0UnPack(ucMode);
   \                     ??Uart0Receive_1: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       Uart0UnPack
    270          #else
    271            UartUnPack(ucMode);
    272          #endif    
    273          }
   \                     ??Uart0Receive_0: (+1)
   \   00000046   0xBD1F             POP      {R0-R4,PC}       ;; return
    274          
    275          /**********************************************************************************************************
    276          *                                           UartReceive()
    277          *
    278          * Description : Read a string from the serial terminal. 
    279          *
    280          * Argument(s) : p_str       Pointer to string.
    281          *
    282          *               len         String length.
    283          *
    284          * Return(s)   : The number of octets written.
    285          *
    286          * Caller(s)   : Application.
    287          *
    288          * Note(s)     : none.
    289          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    290          void  UartReceive  (CPU_INT08U ucMode)
    291          { 
   \                     UartReceive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x0004             MOVS     R4,R0
    292            SERIAL_ERR     err;
    293            SERIAL_IF_CFG  uart_cfg;
    294            
    295            CPU_CHAR       ucName[3][8]={"UART1","UART2","UART3"};
   \   00000006   0xA803             ADD      R0,SP,#+12
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable10_10
   \   0000000C   0x2218             MOVS     R2,#+24
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy4
    296            
    297            m_ucMachineAddr=0x40;
   \   00000012   0x2040             MOVS     R0,#+64
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable10_11
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    298          
    299            uart_cfg.Baudrate = SERIAL_BAUDRATE_9600;
   \   0000001A   0xF44F 0x5016      MOV      R0,#+9600
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    300            uart_cfg.DataBits = SERIAL_DATABITS_8;
   \   00000020   0x2008             MOVS     R0,#+8
   \   00000022   0xF88D 0x0004      STRB     R0,[SP, #+4]
    301            uart_cfg.StopBits = SERIAL_STOPBITS_1;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF88D 0x0005      STRB     R0,[SP, #+5]
    302            uart_cfg.Parity   = SERIAL_PARITY_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    303            uart_cfg.FlowCtrl = SERIAL_FLOW_CTRL_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0007      STRB     R0,[SP, #+7]
    304            if(ucMode==0 && ucMode>3){
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD102             BNE.N    ??UartReceive_0
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C04             CMP      R4,#+4
   \   00000042   0xDA27             BGE.N    ??UartReceive_1
    305              return;
    306            }
    307            Uart_SerTraceIF_Nbr[ucMode] = Serial_Open((CPU_CHAR      *)&ucName[ucMode-1],
    308                                           (SERIAL_IF_CFG *)&uart_cfg,
    309                                           (SERIAL_ERR    *)&err);
   \                     ??UartReceive_0: (+1)
   \   00000044   0xAA02             ADD      R2,SP,#+8
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0xA803             ADD      R0,SP,#+12
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0xEB00 0x00C4      ADD      R0,R0,R4, LSL #+3
   \   00000050   0x3808             SUBS     R0,R0,#+8
   \   00000052   0x.... 0x....      BL       Serial_Open
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable10_9
   \   0000005A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005C   0x5508             STRB     R0,[R1, R4]
    310            if (err != SERIAL_ERR_NONE) {
   \   0000005E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD116             BNE.N    ??UartReceive_1
    311              return ;
    312            }
    313          
    314            if(ucMode==1){
   \                     ??UartReceive_2: (+1)
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C01             CMP      R4,#+1
   \   0000006A   0xD104             BNE.N    ??UartReceive_3
    315              Uart1UnPack(ucMode);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       Uart1UnPack
   \   00000074   0xE00E             B.N      ??UartReceive_4
    316            }else if(ucMode==2){
   \                     ??UartReceive_3: (+1)
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0x2C02             CMP      R4,#+2
   \   0000007A   0xD104             BNE.N    ??UartReceive_5
    317              Uart1UnPack(ucMode);
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x.... 0x....      BL       Uart1UnPack
   \   00000084   0xE006             B.N      ??UartReceive_4
    318            }else if(ucMode==3){
   \                     ??UartReceive_5: (+1)
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2C03             CMP      R4,#+3
   \   0000008A   0xD103             BNE.N    ??UartReceive_4
    319          #if BOARD_OLD_EN==0     
    320          
    321          #if ULTRASOUND_EN==0
    322              Uart1UnPack(ucMode);
    323          #else
    324              Uart3UnPack(ucMode);
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x.... 0x....      BL       Uart3UnPack
    325          #endif
    326          
    327          #else
    328              Uart1UnPack(ucMode);    
    329          #endif
    330            }
    331          }
   \                     ??UartReceive_4: (+1)
   \                     ??UartReceive_1: (+1)
   \   00000094   0xB00A             ADD      SP,SP,#+40
   \   00000096   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x55 0x41          DC8 "UART1"
   \              0x52 0x54    
   \              0x31 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
   \   00000008   0x55 0x41          DC8 "UART2"
   \              0x52 0x54    
   \              0x32 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
   \   00000010   0x55 0x41          DC8 "UART3"
   \              0x52 0x54    
   \              0x33 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    332                  
    333          /**********************************************************************************************************
    334          *                                           Uart_Process()
    335          *
    336          * Description : Read a string from the serial terminal. 
    337          *
    338          * Argument(s) : p_str       Pointer to string.
    339          *
    340          *               len         String length.
    341          *
    342          * Return(s)   : The number of octets written.
    343          *
    344          * Caller(s)   : Application.
    345          *
    346          * Note(s)     : none.
    347          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    348          void  Uart_Process  (void)
    349          {
   \                     Uart_Process: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    350            LIB_ERR       lib_err;
    351            OS_ERR        os_err;
    352            CPU_TS        ts;
    353            CPU_CHAR      *pMsg; 
    354            OS_MSG_SIZE   msgSize;
    355            
    356            pMsg = (CPU_CHAR *)OSTaskQPend(0, OS_OPT_PEND_BLOCKING, &msgSize, &ts, &os_err);
   \   00000002   0xF10D 0x0006      ADD      R0,SP,#+6
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0xAB03             ADD      R3,SP,#+12
   \   0000000A   0xAA01             ADD      R2,SP,#+4
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       OSTaskQPend
   \   00000014   0x0004             MOVS     R4,R0
    357            if(pMsg!= 0){
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD016             BEQ.N    ??Uart_Process_0
    358              if(*(pMsg+1)==UART0_SOF){
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD105             BNE.N    ??Uart_Process_1
    359                Uart0Process(pMsg,msgSize);
   \   00000020   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       Uart0Process
   \   0000002A   0xE007             B.N      ??Uart_Process_2
    360              }else if(*(pMsg+1)==UART_SOF){
   \                     ??Uart_Process_1: (+1)
   \   0000002C   0x7860             LDRB     R0,[R4, #+1]
   \   0000002E   0x28FE             CMP      R0,#+254
   \   00000030   0xD104             BNE.N    ??Uart_Process_2
    361                UartProcess(pMsg,msgSize);
   \   00000032   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UartProcess
    362              }
    363              Mem_PoolBlkFree(&m_UartBufPool, pMsg, &lib_err);
   \                     ??Uart_Process_2: (+1)
   \   0000003C   0xAA02             ADD      R2,SP,#+8
   \   0000003E   0x0021             MOVS     R1,R4
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000044   0x.... 0x....      BL       Mem_PoolBlkFree
    364              if (lib_err != LIB_MEM_ERR_NONE)  {
    365                //error
    366              }        
    367            }
    368          }
   \                     ??Uart_Process_0: (+1)
   \   00000048   0xBD1F             POP      {R0-R4,PC}       ;; return
    369          
    370          /*
    371          *********************************************************************************************************
    372          *                                           App_SerPrintf()
    373          *
    374          * Description : Output  'printf()' statements 
    375          *
    376          * Argument(s) : p_fmt       Pointer to format string.
    377          *
    378          * Return(s)   : The number of octets written.
    379          *
    380          * Caller(s)   : Application.
    381          *
    382          * Note(s)     : none.
    383          *********************************************************************************************************
    384          */
    385          
    386          #if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)  
    387          void  App_SerPrintf (CPU_CHAR  *p_fmt, 
    388                               ...)
    389          {
    390              CPU_CHAR    str[80u + 1u];
    391              CPU_SIZE_T  len;
    392              SERIAL_ERR  err;
    393              va_list     vArgs;
    394          
    395          
    396              va_start(vArgs, p_fmt);
    397              
    398              vsprintf((char       *)str, 
    399                       (char const *)p_fmt, 
    400                                     vArgs);
    401              
    402              va_end(vArgs);
    403          
    404              len = Str_Len(str);
    405          
    406              Serial_Wr((SERIAL_IF_NBR   )App_SerTraceIF_Nbr,
    407                        (void           *)&str[0],
    408                        (CPU_SIZE_T      )len,
    409                        (CPU_INT32U      )0,
    410                        (SERIAL_ERR     *)&err);
    411          
    412          }
    413          #endif
    414          
    415          
    416          /*
    417          *********************************************************************************************************
    418          *                                           App_SerPrintf()
    419          *
    420          * Description : Read a string from the serial terminal. 
    421          *
    422          * Argument(s) : p_str       Pointer to string.
    423          *
    424          *               len         String length.
    425          *
    426          * Return(s)   : The number of octets written.
    427          *
    428          * Caller(s)   : Application.
    429          *
    430          * Note(s)     : none.
    431          *********************************************************************************************************
    432          */
    433          
    434          #if (APP_SERIAL_CFG_TRACE_EN == DEF_ENABLED)  
    435          void  App_SerStrRd  (CPU_CHAR   *p_str,
    436                               CPU_SIZE_T  len)
    437          {
    438              SERIAL_ERR  err;
    439          
    440              Serial_Rd((SERIAL_IF_NBR   )App_SerTraceIF_Nbr,
    441                        (void           *)p_str,
    442                        (CPU_SIZE_T      )len,
    443                        (CPU_INT32U      )0,
    444                        (SERIAL_ERR     *)&err);
    445          }
    446          #endif
    447          
    448          
    449          /*
    450          *********************************************************************************************************
    451          *                                           Uart_SerStrRd()
    452          *
    453          * Description : Read a string from the serial terminal. 
    454          *
    455          * Argument(s) : p_str       Pointer to string.
    456          *
    457          *               len         String length.
    458          *
    459          * Return(s)   : The number of octets written.
    460          *
    461          * Caller(s)   : Application.
    462          *
    463          * Note(s)     : none.
    464          *********************************************************************************************************
    465          */
    466          

   \                                 In section .text, align 2, keep-with-next
    467          void  Uart_SerStrRd  (SERIAL_IF_NBR  if_nbr,
    468                                CPU_CHAR   *p_str,
    469                               CPU_SIZE_T  len,
    470                               CPU_INT32U      timeout_ms,
    471                               SERIAL_ERR *perr)
    472          {
   \                     Uart_SerStrRd: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    473              /*Serial_RdAsync((SERIAL_IF_NBR   )App_SerTraceIF_Nbr,
    474                        (void           *)p_str,
    475                        (CPU_SIZE_T      )len,
    476                        (SERIAL_CALLBACK_FNCT *)0,
    477                        (CPU_INT32U      )0,
    478                        (SERIAL_ERR     *)perr);*/
    479          
    480              
    481              
    482              Serial_Rd((SERIAL_IF_NBR   )if_nbr,
    483                        (void           *)p_str,
    484                        (CPU_SIZE_T      )len,
    485                        (CPU_INT32U      )timeout_ms,
    486                        (SERIAL_ERR     *)perr);
   \   00000012   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000016   0x003B             MOVS     R3,R7
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       Serial_Rd
    487              
    488              
    489              /*Serial_WaitFor((SERIAL_IF_NBR   )App_SerTraceIF_Nbr,
    490                        (void           *)p_str,
    491                        (CPU_SIZE_T      )len,
    492                        (CPU_INT32U      )10,
    493                        (SERIAL_ERR     *)perr);*/
    494          }
   \   00000024   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    495          
    496          
    497          /*
    498          *********************************************************************************************************
    499          *                                           Uart_SerStrWr()
    500          *
    501          * Description : Read a string from the serial terminal. 
    502          *
    503          * Argument(s) : p_str       Pointer to string.
    504          *
    505          *               len         String length.
    506          *
    507          * Return(s)   : The number of octets written.
    508          *
    509          * Caller(s)   : Application.
    510          *
    511          * Note(s)     : none.
    512          *********************************************************************************************************
    513          */
    514          

   \                                 In section .text, align 2, keep-with-next
    515          void  Uart_SerStrWr  (SERIAL_IF_NBR  if_nbr,
    516                                CPU_CHAR   *p_str,
    517                               CPU_SIZE_T  len,
    518                               SERIAL_ERR *perr)
    519          {
   \                     Uart_SerStrWr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    520            
    521              Serial_WrAsync((SERIAL_IF_NBR   )if_nbr,
    522                        (void           *)p_str,
    523                        (CPU_SIZE_T      )len,
    524                        (SERIAL_CALLBACK_FNCT *)0,
    525                        (CPU_INT32U      )0,
    526                        (SERIAL_ERR     *)perr);    
   \   0000000C   0x9701             STR      R7,[SP, #+4]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x.... 0x....      BL       Serial_WrAsync
    527          }
   \   00000020   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    528          
    529          /**********************************************************************************************************
    530          *                                           Uart0Pack()
    531          *
    532          * Description : Read a string from the serial terminal. 
    533          *
    534          * Argument(s) : p_str       Pointer to string.
    535          *
    536          *               len         String length.
    537          *
    538          * Return(s)   : The number of octets written.
    539          *
    540          * Caller(s)   : Application.
    541          *
    542          * Note(s)     : none.
    543          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    544          void  Uart0Pack  (CPU_INT08U ucCmd,
    545                               CPU_INT08U ucAddr,
    546                               CPU_INT08U ucSeq,
    547                               CPU_INT08U *pucData,
    548                               CPU_INT08U ucLen,
    549                               CPU_INT08U ucMode)
    550          {
   \                     Uart0Pack: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C0E             LDR      R4,[SP, #+56]
   \   0000000E   0x9D0F             LDR      R5,[SP, #+60]
    551              LIB_ERR lib_err;
    552              SERIAL_ERR err;
    553          
    554              static CPU_INT08U ucTxSeq=0x0F;		//0x10~0x7F
    555              CPU_INT08U *pucTx;
    556              CPU_INT08U ucBcc=0;
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
    557              CPU_INT08U i;
    558              
    559              pucTx= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_UartBufPool,
    560                                               (CPU_SIZE_T)64,
    561                                               (LIB_ERR  *)&lib_err);
   \   00000014   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000018   0x2140             MOVS     R1,#+64
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000001E   0x.... 0x....      BL       Mem_PoolBlkGet
   \   00000022   0x4681             MOV      R9,R0
    562              if(!pucTx){
   \   00000024   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000028   0xD067             BEQ.N    ??Uart0Pack_0
    563                return;
    564              }
    565            
    566              pucTx[0]=UART0_SOF;
   \                     ??Uart0Pack_1: (+1)
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xF889 0x0000      STRB     R0,[R9, #+0]
    567              if(ucMode){
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD01A             BEQ.N    ??Uart0Pack_2
    568                pucTx[1]=m_ucMachineAddr;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable10_11
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xF889 0x0001      STRB     R0,[R9, #+1]
    569                if(ucTxSeq==0x80){
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x2880             CMP      R0,#+128
   \   00000048   0xD103             BNE.N    ??Uart0Pack_3
    570                  ucTxSeq=0x0F;
   \   0000004A   0x200F             MOVS     R0,#+15
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    571                }
    572                ucTxSeq++;
   \                     ??Uart0Pack_3: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
    573                pucTx[2]=ucTxSeq;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xF889 0x0002      STRB     R0,[R9, #+2]
   \   0000006A   0xE003             B.N      ??Uart0Pack_4
    574              }else{
    575                pucTx[1]=ucAddr;
   \                     ??Uart0Pack_2: (+1)
   \   0000006C   0xF889 0x6001      STRB     R6,[R9, #+1]
    576                pucTx[2]=ucSeq;
   \   00000070   0xF889 0x7002      STRB     R7,[R9, #+2]
    577              }
    578              pucTx[3]=ucCmd;
   \                     ??Uart0Pack_4: (+1)
   \   00000074   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000078   0xF889 0x0003      STRB     R0,[R9, #+3]
    579              ucBcc^=pucTx[1];
   \   0000007C   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \   00000080   0xEA90 0x0A0A      EORS     R10,R0,R10
    580              ucBcc^=pucTx[2];
   \   00000084   0xF899 0x0002      LDRB     R0,[R9, #+2]
   \   00000088   0xEA90 0x0A0A      EORS     R10,R0,R10
    581              ucBcc^=pucTx[3];
   \   0000008C   0xF899 0x0003      LDRB     R0,[R9, #+3]
   \   00000090   0xEA90 0x0A0A      EORS     R10,R0,R10
    582              for(i=0;i<ucLen;i++){
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x4683             MOV      R11,R0
   \                     ??Uart0Pack_5: (+1)
   \   00000098   0x4658             MOV      R0,R11
   \   0000009A   0x0021             MOVS     R1,R4
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD212             BCS.N    ??Uart0Pack_6
    583                  pucTx[4+i]=*(pucData+i);
   \   000000A4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A8   0xF818 0x000B      LDRB     R0,[R8, R11]
   \   000000AC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B0   0xEB09 0x010B      ADD      R1,R9,R11
   \   000000B4   0x7108             STRB     R0,[R1, #+4]
    584                  ucBcc^=pucTx[4+i];
   \   000000B6   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BA   0xEB09 0x000B      ADD      R0,R9,R11
   \   000000BE   0x7900             LDRB     R0,[R0, #+4]
   \   000000C0   0xEA90 0x0A0A      EORS     R10,R0,R10
    585              }
   \   000000C4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   000000C8   0xE7E6             B.N      ??Uart0Pack_5
    586              pucTx[4+ucLen]=UART0_EOF;
   \                     ??Uart0Pack_6: (+1)
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0xEB09 0x0104      ADD      R1,R9,R4
   \   000000D2   0x7108             STRB     R0,[R1, #+4]
    587              pucTx[5+ucLen]=ucBcc;
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0xEB09 0x0004      ADD      R0,R9,R4
   \   000000DA   0xF880 0xA005      STRB     R10,[R0, #+5]
    588              Serial_WrAsync((SERIAL_IF_NBR   )Uart_SerTraceIF_Nbr[0],
    589                        (void           *)pucTx,
    590                        (CPU_SIZE_T      )ucLen+6,
    591                        (SERIAL_CALLBACK_FNCT *)UartTxFinish,
    592                        (CPU_INT32U      )0,
    593                        (SERIAL_ERR     *)&err);        
   \   000000DE   0xA802             ADD      R0,SP,#+8
   \   000000E0   0x9001             STR      R0,[SP, #+4]
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0x.... 0x....      ADR.W    R3,UartTxFinish
   \   000000EA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EC   0x1DA2             ADDS     R2,R4,#+6
   \   000000EE   0x4649             MOV      R1,R9
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x.... 0x....      BL       Serial_WrAsync
    594              
    595          }
   \                     ??Uart0Pack_0: (+1)
   \   000000FA   0xB005             ADD      SP,SP,#+20
   \   000000FC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return

   \                                 In section .data, align 1
   \                     `Uart0Pack::ucTxSeq`:
   \   00000000   0x0F               DC8 15
    596                    
    597          /********************************************************************************************************
    598          ** oˉêy??3?: UartPack
    599          ** 1|?ü?èê?:
    600          ** ê? ?? è?:
    601          **
    602          ** ê???  3?:
    603          **
    604          ** è???±?á?:
    605          ** μ÷ó??￡?é:
    606          **
    607          ** ×÷??  ??: John Tonny
    608          ** è???  ?ú: 2005?ê05??01è?
    609          **------------------------------------------------------------------------------------------------------
    610          ** DT ?? è?:
    611          ** è???  ?ú:
    612          **------------------------------------------------------------------------------------------------------
    613          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    614          void UartPack(INT8U ucCmd,INT8U ucResponse,INT8U ucLen,INT8U *pucData,INT8U ucSelected)
    615          {
   \                     UartPack: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C0C             LDR      R4,[SP, #+48]
    616            LIB_ERR lib_err;
    617            OS_ERR os_err;
    618            CommTxData *pcommTxData=NULL;
   \   0000000E   0xF05F 0x0900      MOVS     R9,#+0
    619            INT16U intCrc16;
    620            INT8U ucSelectedA;
    621            
    622            pcommTxData= (CommTxData *)Mem_PoolBlkGet((MEM_POOL *)&m_UartBufPool,
    623                                             (CPU_SIZE_T)sizeof(CommTxData),
    624                                             (LIB_ERR  *)&lib_err);
   \   00000012   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000016   0x2140             MOVS     R1,#+64
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000001C   0x.... 0x....      BL       Mem_PoolBlkGet
   \   00000020   0x4681             MOV      R9,R0
    625            if(!pcommTxData){
   \   00000022   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000026   0xD044             BEQ.N    ??UartPack_0
    626              return;
    627            }
    628            
    629            if(m_ucUartBit[ucSelected]>=CARDMACHINE_CARDBOX_NUMS){
   \                     ??UartPack_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x5D00             LDRB     R0,[R0, R4]
   \   00000030   0x2803             CMP      R0,#+3
   \   00000032   0xDA3E             BGE.N    ??UartPack_0
    630              return;
    631            }
    632            
    633            pcommTxData->ucHead=UART_SOF;
   \                     ??UartPack_2: (+1)
   \   00000034   0x20FE             MOVS     R0,#+254
   \   00000036   0xF889 0x0000      STRB     R0,[R9, #+0]
    634            pcommTxData->ucLen=ucLen+5;
   \   0000003A   0x1D78             ADDS     R0,R7,#+5
   \   0000003C   0xF889 0x0001      STRB     R0,[R9, #+1]
    635            pcommTxData->uiCluster=0x0301 | ucResponse;
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0xF240 0x3001      MOVW     R0,#+769
   \   00000046   0x4330             ORRS     R0,R0,R6
   \   00000048   0xF8A9 0x0002      STRH     R0,[R9, #+2]
    636            pcommTxData->ucCmd=ucCmd;
   \   0000004C   0xF889 0x5004      STRB     R5,[R9, #+4]
    637            Mem_Copy(pcommTxData->ucData,pucData,ucLen);
   \   00000050   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000052   0x003A             MOVS     R2,R7
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0xF119 0x0005      ADDS     R0,R9,#+5
   \   0000005A   0x.... 0x....      BL       Mem_Copy
    638            
    639            intCrc16=RevCrc16Bytes(&pcommTxData->ucLen,ucLen+4,0xA001);
   \   0000005E   0xF24A 0x0201      MOVW     R2,#+40961
   \   00000062   0x1D39             ADDS     R1,R7,#+4
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0xF119 0x0001      ADDS     R0,R9,#+1
   \   0000006A   0x.... 0x....      BL       RevCrc16Bytes
   \   0000006E   0x4683             MOV      R11,R0
    640            pcommTxData->ucData[ucLen]=(INT8U)(intCrc16&0xFF);
   \   00000070   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000072   0xEB09 0x0007      ADD      R0,R9,R7
   \   00000076   0xF880 0xB005      STRB     R11,[R0, #+5]
    641            pcommTxData->ucData[ucLen+1]=(INT8U)(intCrc16>>8);
   \   0000007A   0x4658             MOV      R0,R11
   \   0000007C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007E   0x0A00             LSRS     R0,R0,#+8
   \   00000080   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000082   0xEB09 0x0107      ADD      R1,R9,R7
   \   00000086   0x7188             STRB     R0,[R1, #+6]
    642            
    643          #if BOARD_OLD_EN==0  
    644            ucSelectedA=m_ucBoxToUart[m_ucUartBit[ucSelected]];
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x5D09             LDRB     R1,[R1, R4]
   \   00000094   0x5C40             LDRB     R0,[R0, R1]
   \   00000096   0x4682             MOV      R10,R0
    645          #else
    646            ucSelectedA=3;
    647          #endif  
    648            Serial_WrAsync((SERIAL_IF_NBR   )ucSelectedA,
    649                      (void           *)&pcommTxData->ucHead,
    650                      (CPU_SIZE_T      )ucLen+7,
    651                      (SERIAL_CALLBACK_FNCT *)UartTxFinish,
    652                      (CPU_INT32U)0,
    653                      (SERIAL_ERR     *)&os_err);        
   \   00000098   0xA802             ADD      R0,SP,#+8
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x.... 0x....      ADR.W    R3,UartTxFinish
   \   000000A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A6   0x1DFA             ADDS     R2,R7,#+7
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x.... 0x....      BL       Serial_WrAsync
    654          
    655          }
   \                     ??UartPack_0: (+1)
   \   000000B2   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    656          
    657          /********************************************************************************************************
    658          ** oˉêy??3?: UartTxFinish
    659          ** 1|?ü?èê?:
    660          ** ê? ?? è?:
    661          **
    662          ** ê???  3?:
    663          **
    664          ** è???±?á?:
    665          ** μ÷ó??￡?é:
    666          **
    667          ** ×÷??  ??: John Tonny
    668          ** è???  ?ú: 2005?ê05??01è?
    669          **------------------------------------------------------------------------------------------------------
    670          ** DT ?? è?:
    671          ** è???  ?ú:
    672          **------------------------------------------------------------------------------------------------------
    673          *******************************************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    674          void UartTxFinish(SERIAL_IF_NBR if_nbr,void *p_arg,void *p_buf,CPU_SIZE_T wr_len,SERIAL_ERR err)
    675          {
   \                     UartTxFinish: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    676          //                           err == SERIAL_ERR_UNDERFLOW ? SERIAL_ERR_NONE : err);
    677            LIB_ERR lib_err;
    678            
    679            Mem_PoolBlkFree(&m_UartBufPool, p_buf, &lib_err);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x0031             MOVS     R1,R6
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000012   0x.... 0x....      BL       Mem_PoolBlkFree
    680            if (lib_err != LIB_MEM_ERR_NONE)  {
    681              //error
    682            }
    683          }
   \   00000016   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    684          
    685          /********************************************************************************************************
    686          ** oˉêy??3?: Uart0UnPack
    687          ** 1|?ü?èê?:
    688          ** ê? ?? è?:
    689          **
    690          ** ê???  3?:
    691          **
    692          ** è???±?á?:
    693          ** μ÷ó??￡?é:
    694          **
    695          ** ×÷??  ??: John Tonny
    696          ** è???  ?ú: 2005?ê05??01è?
    697          **------------------------------------------------------------------------------------------------------
    698          ** DT ?? è?:
    699          ** è???  ?ú:
    700          **------------------------------------------------------------------------------------------------------
    701          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    702          void Uart0UnPack(CPU_INT08U ucMode)
    703          {
   \                     Uart0UnPack: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
    704            LIB_ERR        lib_err;
    705            OS_ERR         os_err;
    706            SERIAL_ERR     err;
    707            
    708            CPU_INT08U     ucStart;
    709            CPU_INT08U     ucStop;
    710            CPU_INT08U     ucCounts;    
    711            CPU_INT08U     ucErr;
    712            CPU_CHAR       scBcc;
    713            CPU_CHAR       scData;
    714            
    715            CPU_INT08U     *pucRx=NULL;
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
    716            CPU_INT08U     *pucBuf;
    717            
    718            m_ucMachineAddr=0x40;
   \   0000000C   0x2040             MOVS     R0,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable10_11
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    719                
    720            Uart0Pack(INFTYPE_POWER_ON,0,0,NULL,0,1);				//上电
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x2055             MOVS     R0,#+85
   \   00000024   0x.... 0x....      BL       Uart0Pack
    721            Uart0Pack(INFTYPE_BELTCLEAR,0,0,NULL,0,1);				//清除故障
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x9001             STR      R0,[SP, #+4]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9000             STR      R0,[SP, #+0]
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x207F             MOVS     R0,#+127
   \   00000038   0x.... 0x....      BL       Uart0Pack
    722            
    723            ucStart=0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x0005             MOVS     R5,R0
    724            ucCounts=0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
    725            while (DEF_TRUE) {                
    726              Uart_SerStrRd(Uart_SerTraceIF_Nbr[0],&scData,1,0,&err);
   \                     ??Uart0UnPack_0: (+1)
   \   00000044   0xA803             ADD      R0,SP,#+12
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0xA902             ADD      R1,SP,#+8
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       Uart_SerStrRd
    727              if(err==SERIAL_ERR_NONE){
   \   00000058   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xF040 0x80B5      BNE.W    ??Uart0UnPack_1
    728                  if(ucCounts>=64){
   \   00000062   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   0x2F40             CMP      R7,#+64
   \   00000066   0xDB1D             BLT.N    ??Uart0UnPack_2
    729                    ucErr=0xC1;
   \   00000068   0x20C1             MOVS     R0,#+193
   \   0000006A   0x4680             MOV      R8,R0
    730                    Uart0Pack(ucErr,0,0,0,0,1);
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x9001             STR      R0,[SP, #+4]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x2300             MOVS     R3,#+0
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x.... 0x....      BL       Uart0Pack
    731                    if(pucRx!=0){
   \   00000082   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000086   0xD008             BEQ.N    ??Uart0UnPack_3
    732                      Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   00000088   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000008C   0x4651             MOV      R1,R10
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000092   0x.... 0x....      BL       Mem_PoolBlkFree
    733                      if (lib_err != LIB_MEM_ERR_NONE)  {
    734                        //error
    735                      }
    736                      pucRx=0;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x4682             MOV      R10,R0
    737                    }
    738                    ucStart=0;
   \                     ??Uart0UnPack_3: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x0005             MOVS     R5,R0
    739                    ucCounts=0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x0007             MOVS     R7,R0
   \   000000A2   0xE7CF             B.N      ??Uart0UnPack_0
    740                  }else{
    741                    if(scData==UART0_SOF && ucStart==0){
   \                     ??Uart0UnPack_2: (+1)
   \   000000A4   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000A8   0x2802             CMP      R0,#+2
   \   000000AA   0xD126             BNE.N    ??Uart0UnPack_4
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D00             CMP      R5,#+0
   \   000000B0   0xD123             BNE.N    ??Uart0UnPack_4
    742                      pucRx= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_UartBufPool,
    743                                                       (CPU_SIZE_T) 64,
    744                                                       (LIB_ERR  *)&lib_err);
   \   000000B2   0xF10D 0x020A      ADD      R2,SP,#+10
   \   000000B6   0x2140             MOVS     R1,#+64
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000000BC   0x.... 0x....      BL       Mem_PoolBlkGet
   \   000000C0   0x4682             MOV      R10,R0
    745                      if(pucRx!=0){
   \   000000C2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000C6   0xD0BD             BEQ.N    ??Uart0UnPack_0
    746                        ucCounts=0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x0007             MOVS     R7,R0
    747                        pucBuf=pucRx;
   \   000000CC   0x46D3             MOV      R11,R10
    748                        *pucBuf=0x00;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xF88B 0x0000      STRB     R0,[R11, #+0]
    749                        pucBuf++;
   \   000000D4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    750                        ucCounts++;
   \   000000D8   0x1C7F             ADDS     R7,R7,#+1
    751                        ucStart=1;
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x0005             MOVS     R5,R0
    752                        ucStop=0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x0006             MOVS     R6,R0
    753                        scBcc=0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x4681             MOV      R9,R0
    754                        ucErr=0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x4680             MOV      R8,R0
    755                        *pucBuf=scData;
   \   000000EA   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000EE   0xF88B 0x0000      STRB     R0,[R11, #+0]
    756                        pucBuf++;
   \   000000F2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    757                        ucCounts++;
   \   000000F6   0x1C7F             ADDS     R7,R7,#+1
   \   000000F8   0xE7A4             B.N      ??Uart0UnPack_0
    758                      }
    759                    }else if(ucStart==1){
   \                     ??Uart0UnPack_4: (+1)
   \   000000FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FC   0x2D01             CMP      R5,#+1
   \   000000FE   0xD154             BNE.N    ??Uart0UnPack_5
    760                      *pucBuf=scData;
   \   00000100   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000104   0xF88B 0x0000      STRB     R0,[R11, #+0]
    761                      pucBuf++;
   \   00000108   0xF11B 0x0B01      ADDS     R11,R11,#+1
    762                      ucCounts++;
   \   0000010C   0x1C7F             ADDS     R7,R7,#+1
    763                      if(scData==UART0_EOF && ucStop==0){
   \   0000010E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000112   0x2803             CMP      R0,#+3
   \   00000114   0xD105             BNE.N    ??Uart0UnPack_6
   \   00000116   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000118   0x2E00             CMP      R6,#+0
   \   0000011A   0xD102             BNE.N    ??Uart0UnPack_6
    764                        ucStop=1;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x0006             MOVS     R6,R0
   \   00000120   0xE790             B.N      ??Uart0UnPack_0
    765                      }else if(ucStart==1 && ucStop==1){
   \                     ??Uart0UnPack_6: (+1)
   \   00000122   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000124   0x2D01             CMP      R5,#+1
   \   00000126   0xD13B             BNE.N    ??Uart0UnPack_7
   \   00000128   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000012A   0x2E01             CMP      R6,#+1
   \   0000012C   0xD138             BNE.N    ??Uart0UnPack_7
    766                        if(scBcc!=scData){
   \   0000012E   0x4648             MOV      R0,R9
   \   00000130   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000134   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000136   0x4288             CMP      R0,R1
   \   00000138   0xD019             BEQ.N    ??Uart0UnPack_8
    767                          ucErr=0xC4;
   \   0000013A   0x20C4             MOVS     R0,#+196
   \   0000013C   0x4680             MOV      R8,R0
    768                          Uart0Pack(ucErr,0,0,0,0,1);
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x9001             STR      R0,[SP, #+4]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x9000             STR      R0,[SP, #+0]
   \   00000146   0x2300             MOVS     R3,#+0
   \   00000148   0x2200             MOVS     R2,#+0
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x4640             MOV      R0,R8
   \   0000014E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000150   0x.... 0x....      BL       Uart0Pack
    769                          if(pucRx!=0){
   \   00000154   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000158   0xD01D             BEQ.N    ??Uart0UnPack_9
    770                            Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   0000015A   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000015E   0x4651             MOV      R1,R10
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000164   0x.... 0x....      BL       Mem_PoolBlkFree
    771                            if (lib_err != LIB_MEM_ERR_NONE)  {
    772                              //error
    773                            }
    774                            pucRx=NULL;
   \   00000168   0x2000             MOVS     R0,#+0
   \   0000016A   0x4682             MOV      R10,R0
   \   0000016C   0xE013             B.N      ??Uart0UnPack_9
    775                          }
    776                        }else{
    777                          OSTaskQPost(&App_TaskUartProcessTCB, pucRx, ucCounts, OS_OPT_POST_FIFO, &os_err);
   \                     ??Uart0UnPack_8: (+1)
   \   0000016E   0xF10D 0x000E      ADD      R0,SP,#+14
   \   00000172   0x9000             STR      R0,[SP, #+0]
   \   00000174   0x2300             MOVS     R3,#+0
   \   00000176   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000178   0x003A             MOVS     R2,R7
   \   0000017A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000017C   0x4651             MOV      R1,R10
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000182   0x.... 0x....      BL       OSTaskQPost
    778                          if(os_err!=OS_ERR_NONE){
   \   00000186   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD001             BEQ.N    ??Uart0UnPack_10
    779                            //error
    780                            ucStart=1;
   \   0000018E   0x2001             MOVS     R0,#+1
   \   00000190   0x0005             MOVS     R5,R0
    781                          }
    782                          pucRx=NULL;
   \                     ??Uart0UnPack_10: (+1)
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0x4682             MOV      R10,R0
    783                        }
    784                        ucStart=0;
   \                     ??Uart0UnPack_9: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x0005             MOVS     R5,R0
    785                        ucCounts=0;
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0x0007             MOVS     R7,R0
   \   0000019E   0xE751             B.N      ??Uart0UnPack_0
    786                      }else{
    787                        scBcc^=scData;
   \                     ??Uart0UnPack_7: (+1)
   \   000001A0   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001A4   0xEA90 0x0909      EORS     R9,R0,R9
   \   000001A8   0xE74C             B.N      ??Uart0UnPack_0
    788                      }
    789                    }else{
    790                      //error
    791                      //ucErr=0xC3;
    792                      //Uart0Pack(ucErr,0,0,0,0,1);
    793                      if(pucRx!=0){
   \                     ??Uart0UnPack_5: (+1)
   \   000001AA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001AE   0xD008             BEQ.N    ??Uart0UnPack_11
    794                        Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   000001B0   0xF10D 0x020A      ADD      R2,SP,#+10
   \   000001B4   0x4651             MOV      R1,R10
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000001BA   0x.... 0x....      BL       Mem_PoolBlkFree
    795                        if (lib_err != LIB_MEM_ERR_NONE)  {
    796                          //error
    797                        }
    798                        pucRx=NULL;
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x4682             MOV      R10,R0
    799                      }
    800                      ucStart=0;
   \                     ??Uart0UnPack_11: (+1)
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0x0005             MOVS     R5,R0
    801                      ucCounts=0;
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0x0007             MOVS     R7,R0
   \   000001CA   0xE73B             B.N      ??Uart0UnPack_0
    802                    }
    803                  }
    804             }else{
    805                if(pucRx!=0){
   \                     ??Uart0UnPack_1: (+1)
   \   000001CC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001D0   0xD008             BEQ.N    ??Uart0UnPack_12
    806                  Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   000001D2   0xF10D 0x020A      ADD      R2,SP,#+10
   \   000001D6   0x4651             MOV      R1,R10
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable10
   \   000001DC   0x.... 0x....      BL       Mem_PoolBlkFree
    807                  if (lib_err != LIB_MEM_ERR_NONE)  {
    808                    //error
    809                  }
    810                  pucRx=NULL;
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x4682             MOV      R10,R0
    811                }
    812                ucStart=0;
   \                     ??Uart0UnPack_12: (+1)
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x0005             MOVS     R5,R0
    813                ucCounts=0;
   \   000001E8   0x2000             MOVS     R0,#+0
   \   000001EA   0x0007             MOVS     R7,R0
   \   000001EC   0xE72A             B.N      ??Uart0UnPack_0
    814              }
    815            }    
    816          }
    817          
    818          /********************************************************************************************************
    819          ** oˉêy??3?: UartUnPack
    820          ** 1|?ü?èê?:
    821          ** ê? ?? è?:
    822          **
    823          ** ê???  3?:
    824          **
    825          ** è???±?á?:
    826          ** μ÷ó??￡?é:
    827          **
    828          ** ×÷??  ??: John Tonny
    829          ** è???  ?ú: 2005?ê05??01è?
    830          **------------------------------------------------------------------------------------------------------
    831          ** DT ?? è?:
    832          ** è???  ?ú:
    833          **------------------------------------------------------------------------------------------------------
    834          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    835          void UartUnPack(CPU_INT08U ucMode)
    836          {
   \                     UartUnPack: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
    837            LIB_ERR        lib_err;
    838            OS_ERR         os_err;
    839            SERIAL_ERR     err;
    840            
    841            CPU_INT08U     ucState=0;
   \   00000008   0x2500             MOVS     R5,#+0
    842            CPU_INT08U      ucLen;
    843            CPU_INT08U     ucCounts;    
    844            CPU_INT08U     ucErr;
    845            CPU_INT16U     uiCrc16;
    846            CPU_CHAR       scData;
    847            
    848            CPU_INT08U     *pucRx=NULL;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    849            CPU_INT08U     *pucBuf;
    850            
    851            ucState=0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
    852            ucCounts=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
    853            while (DEF_TRUE) {                
    854              Uart_SerStrRd(Uart_SerTraceIF_Nbr[0],&scData,1,0,&err);
   \                     ??UartUnPack_0: (+1)
   \   00000016   0xA803             ADD      R0,SP,#+12
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xA902             ADD      R1,SP,#+8
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable10_9
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       Uart_SerStrRd
    855              if(err==SERIAL_ERR_NONE){
   \   0000002A   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x8098      BNE.W    ??UartUnPack_1
    856                if(ucCounts>=64){
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x2F40             CMP      R7,#+64
   \   00000038   0xDB1B             BLT.N    ??UartUnPack_2
    857                  ucErr=0xC1;
   \   0000003A   0x20C1             MOVS     R0,#+193
   \   0000003C   0x4680             MOV      R8,R0
    858                  Uart0Pack(ucErr,0,0,0,0,1);
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       Uart0Pack
    859                  if(pucRx!=0){
   \   00000054   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000058   0xD008             BEQ.N    ??UartUnPack_3
    860                    Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   0000005A   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000064   0x.... 0x....      BL       Mem_PoolBlkFree
    861                    if (lib_err != LIB_MEM_ERR_NONE)  {
    862                      //error
    863                    }
    864                    pucRx=0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4682             MOV      R10,R0
    865                  }
    866                  ucState=0;
   \                     ??UartUnPack_3: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0005             MOVS     R5,R0
   \   00000070   0xE7D1             B.N      ??UartUnPack_0
    867                }else{
    868                  if(scData==UART_SOF && ucState==0){
   \                     ??UartUnPack_2: (+1)
   \   00000072   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000076   0x28FE             CMP      R0,#+254
   \   00000078   0xD121             BNE.N    ??UartUnPack_4
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD11E             BNE.N    ??UartUnPack_4
    869                    pucRx= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_UartBufPool,
    870                                                     (CPU_SIZE_T) 64,
    871                                                     (LIB_ERR  *)&lib_err);
   \   00000080   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000084   0x2140             MOVS     R1,#+64
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable10
   \   0000008A   0x.... 0x....      BL       Mem_PoolBlkGet
   \   0000008E   0x4682             MOV      R10,R0
    872                    if(pucRx!=0){
   \   00000090   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000094   0xD0BF             BEQ.N    ??UartUnPack_0
    873                      pucBuf=pucRx;
   \   00000096   0x46D3             MOV      R11,R10
    874                      ucState=1;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x0005             MOVS     R5,R0
    875                      ucCounts=0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x0007             MOVS     R7,R0
    876                      ucErr=0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x4680             MOV      R8,R0
    877                      *pucBuf=ucMode;
   \   000000A4   0xF88B 0x4000      STRB     R4,[R11, #+0]
    878                      pucBuf++;
   \   000000A8   0xF11B 0x0B01      ADDS     R11,R11,#+1
    879                      ucCounts++;
   \   000000AC   0x1C7F             ADDS     R7,R7,#+1
    880                      *pucBuf=scData;
   \   000000AE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000B2   0xF88B 0x0000      STRB     R0,[R11, #+0]
    881                      pucBuf++;
   \   000000B6   0xF11B 0x0B01      ADDS     R11,R11,#+1
    882                      ucCounts++;
   \   000000BA   0x1C7F             ADDS     R7,R7,#+1
   \   000000BC   0xE7AB             B.N      ??UartUnPack_0
    883                    }
    884                  }else if(ucState==1){
   \                     ??UartUnPack_4: (+1)
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D01             CMP      R5,#+1
   \   000000C2   0xD10C             BNE.N    ??UartUnPack_5
    885                    *pucBuf=scData;
   \   000000C4   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C8   0xF88B 0x0000      STRB     R0,[R11, #+0]
    886                    ucLen=scData;
   \   000000CC   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D0   0x0006             MOVS     R6,R0
    887                    pucBuf++;
   \   000000D2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    888                    ucCounts++;
   \   000000D6   0x1C7F             ADDS     R7,R7,#+1
    889                    ucState=2;
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0x0005             MOVS     R5,R0
   \   000000DC   0xE79B             B.N      ??UartUnPack_0
    890                  }else{
    891                    *pucBuf=scData;
   \                     ??UartUnPack_5: (+1)
   \   000000DE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000E2   0xF88B 0x0000      STRB     R0,[R11, #+0]
    892                    pucBuf++;
   \   000000E6   0xF11B 0x0B01      ADDS     R11,R11,#+1
    893                    ucCounts++;
   \   000000EA   0x1C7F             ADDS     R7,R7,#+1
    894                    if(ucCounts==ucLen+3){
   \   000000EC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F0   0x1CF0             ADDS     R0,R6,#+3
   \   000000F2   0x4287             CMP      R7,R0
   \   000000F4   0xD18F             BNE.N    ??UartUnPack_0
    895                      uiCrc16=RevCrc16Bytes(pucRx+2,ucLen+1,0xA001);
   \   000000F6   0xF24A 0x0201      MOVW     R2,#+40961
   \   000000FA   0x1C71             ADDS     R1,R6,#+1
   \   000000FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000FE   0xF11A 0x0002      ADDS     R0,R10,#+2
   \   00000102   0x.... 0x....      BL       RevCrc16Bytes
   \   00000106   0x4681             MOV      R9,R0
    896                      if(!uiCrc16){
   \   00000108   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000010C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000110   0xD112             BNE.N    ??UartUnPack_6
    897                        OSTaskQPost(&App_TaskUartProcessTCB, pucRx, ucCounts, OS_OPT_POST_FIFO, &os_err);
   \   00000112   0xF10D 0x000E      ADD      R0,SP,#+14
   \   00000116   0x9000             STR      R0,[SP, #+0]
   \   00000118   0x2300             MOVS     R3,#+0
   \   0000011A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011C   0x003A             MOVS     R2,R7
   \   0000011E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000120   0x4651             MOV      R1,R10
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000126   0x.... 0x....      BL       OSTaskQPost
    898                        if(os_err!=OS_ERR_NONE){
   \   0000012A   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD013             BEQ.N    ??UartUnPack_7
    899                          //error
    900                          ucState=1;
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0x0005             MOVS     R5,R0
   \   00000136   0xE010             B.N      ??UartUnPack_7
    901                        }
    902                      }else{
    903                        Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \                     ??UartUnPack_6: (+1)
   \   00000138   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000013C   0x4651             MOV      R1,R10
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000142   0x.... 0x....      BL       Mem_PoolBlkFree
    904                        if (lib_err != LIB_MEM_ERR_NONE){
   \   00000146   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   0000014A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000014E   0x4288             CMP      R0,R1
   \   00000150   0xD001             BEQ.N    ??UartUnPack_8
    905                          //error
    906                          ucState=1;
   \   00000152   0x2001             MOVS     R0,#+1
   \   00000154   0x0005             MOVS     R5,R0
    907                        }
    908                        pucRx=NULL;
   \                     ??UartUnPack_8: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x4682             MOV      R10,R0
    909                      }
    910                      ucState=0;
   \                     ??UartUnPack_7: (+1)
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0x0005             MOVS     R5,R0
    911                      ucCounts=0;
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x0007             MOVS     R7,R0
   \   00000162   0xE758             B.N      ??UartUnPack_0
    912                    }
    913                  }
    914                }
    915             }else{
    916                if(pucRx!=0){
   \                     ??UartUnPack_1: (+1)
   \   00000164   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000168   0xD007             BEQ.N    ??UartUnPack_9
    917                  Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   0000016A   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000016E   0x4651             MOV      R1,R10
   \   00000170   0x....             LDR.N    R0,??DataTable10
   \   00000172   0x.... 0x....      BL       Mem_PoolBlkFree
    918                  if (lib_err != LIB_MEM_ERR_NONE)  {
    919                    //error
    920                  }
    921                  pucRx=NULL;
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0x4682             MOV      R10,R0
    922                }
    923                ucState=0;
   \                     ??UartUnPack_9: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x0005             MOVS     R5,R0
    924                ucCounts=0;
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x0007             MOVS     R7,R0
   \   00000182   0xE748             B.N      ??UartUnPack_0
    925              }
    926            }    
    927          }
    928          
    929          /********************************************************************************************************
    930          ** oˉêy??3?: Uart1UnPack
    931          ** 1|?ü?èê?:
    932          ** ê? ?? è?:
    933          **
    934          ** ê???  3?:
    935          **
    936          ** è???±?á?:
    937          ** μ÷ó??￡?é:
    938          **
    939          ** ×÷??  ??: John Tonny
    940          ** è???  ?ú: 2005?ê05??01è?
    941          **------------------------------------------------------------------------------------------------------
    942          ** DT ?? è?:
    943          ** è???  ?ú:
    944          **------------------------------------------------------------------------------------------------------
    945          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    946          void Uart1UnPack(CPU_INT08U ucMode)
    947          { 
   \                     Uart1UnPack: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
    948            LIB_ERR        lib_err;
    949            OS_ERR         os_err;
    950            SERIAL_ERR     err;
    951            
    952            CPU_INT08U     ucState=0;
   \   00000008   0x2500             MOVS     R5,#+0
    953            CPU_INT08U     ucLen;
    954            CPU_INT08U     ucCounts;    
    955            CPU_INT08U     ucErr;
    956            CPU_INT16U     uiCrc16;
    957            CPU_CHAR       scData;
    958            
    959            CPU_INT08U     *pucRx=NULL;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    960            CPU_INT08U     *pucBuf;
    961            
    962          #if BOARD_OLD_EN==1
    963            CPU_INT08U     ucSelected;
    964          #endif
    965            
    966            ucState=0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0005             MOVS     R5,R0
    967            ucCounts=0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
    968            while (DEF_TRUE) {                
    969              Uart_SerStrRd(Uart_SerTraceIF_Nbr[ucMode],&scData,1,0,&err);
   \                     ??Uart1UnPack_0: (+1)
   \   00000016   0xA803             ADD      R0,SP,#+12
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xA902             ADD      R1,SP,#+8
   \   00000020   0x....             LDR.N    R0,??DataTable10_9
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x5D00             LDRB     R0,[R0, R4]
   \   00000026   0x.... 0x....      BL       Uart_SerStrRd
    970              if(err==SERIAL_ERR_NONE){
   \   0000002A   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF040 0x8095      BNE.W    ??Uart1UnPack_1
    971                if(ucCounts>=64){
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x2F40             CMP      R7,#+64
   \   00000038   0xDB1A             BLT.N    ??Uart1UnPack_2
    972                  ucErr=0xC1;
   \   0000003A   0x20C1             MOVS     R0,#+193
   \   0000003C   0x4680             MOV      R8,R0
    973                  Uart0Pack(ucErr,0,0,0,0,1);
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       Uart0Pack
    974                  if(pucRx!=0){
   \   00000054   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000058   0xD007             BEQ.N    ??Uart1UnPack_3
    975                    Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   0000005A   0xF10D 0x020A      ADD      R2,SP,#+10
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x....             LDR.N    R0,??DataTable10
   \   00000062   0x.... 0x....      BL       Mem_PoolBlkFree
    976                    if (lib_err != LIB_MEM_ERR_NONE)  {
    977                      //error
    978                    }
    979                    pucRx=0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4682             MOV      R10,R0
    980                  }
    981                  ucState=0;
   \                     ??Uart1UnPack_3: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0005             MOVS     R5,R0
   \   0000006E   0xE7D2             B.N      ??Uart1UnPack_0
    982                }else{
    983                  if(scData==UART_SOF && ucState==0){
   \                     ??Uart1UnPack_2: (+1)
   \   00000070   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000074   0x28FE             CMP      R0,#+254
   \   00000076   0xD120             BNE.N    ??Uart1UnPack_4
   \   00000078   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD11D             BNE.N    ??Uart1UnPack_4
    984                    pucRx= (CPU_INT08U *)Mem_PoolBlkGet((MEM_POOL *)&m_UartBufPool,
    985                                                     (CPU_SIZE_T) 64,
    986                                                     (LIB_ERR  *)&lib_err);
   \   0000007E   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000082   0x2140             MOVS     R1,#+64
   \   00000084   0x....             LDR.N    R0,??DataTable10
   \   00000086   0x.... 0x....      BL       Mem_PoolBlkGet
   \   0000008A   0x4682             MOV      R10,R0
    987                    if(pucRx!=0){
   \   0000008C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000090   0xD0C1             BEQ.N    ??Uart1UnPack_0
    988                      pucBuf=pucRx;
   \   00000092   0x46D3             MOV      R11,R10
    989                      ucState=1;
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x0005             MOVS     R5,R0
    990                      ucCounts=0;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x0007             MOVS     R7,R0
    991                      ucErr=0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x4680             MOV      R8,R0
    992                    #if BOARD_OLD_EN==0
    993                      *pucBuf=ucMode;
   \   000000A0   0xF88B 0x4000      STRB     R4,[R11, #+0]
    994                    #else
    995                      ucSelected=CardBoxGetSelectedA()+1;
    996                      *pucBuf=ucSelected;
    997                    #endif
    998                      pucBuf++;
   \   000000A4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    999                      ucCounts++;
   \   000000A8   0x1C7F             ADDS     R7,R7,#+1
   1000                      *pucBuf=scData;
   \   000000AA   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000AE   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1001                      pucBuf++;
   \   000000B2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1002                      ucCounts++;
   \   000000B6   0x1C7F             ADDS     R7,R7,#+1
   \   000000B8   0xE7AD             B.N      ??Uart1UnPack_0
   1003                    }
   1004                  }else if(ucState==1){
   \                     ??Uart1UnPack_4: (+1)
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0x2D01             CMP      R5,#+1
   \   000000BE   0xD10C             BNE.N    ??Uart1UnPack_5
   1005                  #if BOARD_OLD_EN==1
   1006                    if(ucSelected!=(CardBoxGetSelectedA()+1)){
   1007                      Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   1008                      if (lib_err != LIB_MEM_ERR_NONE)  {
   1009                        //error
   1010                      }
   1011                      pucRx=NULL;
   1012                      ucState=0;
   1013                      ucCounts=0;
   1014                      continue;
   1015                    }
   1016                  #endif
   1017                    *pucBuf=scData;
   \   000000C0   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C4   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1018                    ucLen=scData;
   \   000000C8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000CC   0x0006             MOVS     R6,R0
   1019                    pucBuf++;
   \   000000CE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1020                    ucCounts++;
   \   000000D2   0x1C7F             ADDS     R7,R7,#+1
   1021                    ucState=2;
   \   000000D4   0x2002             MOVS     R0,#+2
   \   000000D6   0x0005             MOVS     R5,R0
   \   000000D8   0xE79D             B.N      ??Uart1UnPack_0
   1022                  }else{
   1023                  #if BOARD_OLD_EN==1
   1024                    if(ucSelected!=(CardBoxGetSelectedA()+1)){
   1025                      Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   1026                      if (lib_err != LIB_MEM_ERR_NONE)  {
   1027                        //error
   1028                      }
   1029                      pucRx=NULL;
   1030                      ucState=0;
   1031                      ucCounts=0;
   1032                      continue;
   1033                    }
   1034                  #endif
   1035                    *pucBuf=scData;
   \                     ??Uart1UnPack_5: (+1)
   \   000000DA   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000DE   0xF88B 0x0000      STRB     R0,[R11, #+0]
   1036                    pucBuf++;
   \   000000E2   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1037                    ucCounts++;
   \   000000E6   0x1C7F             ADDS     R7,R7,#+1
   1038                    if(ucCounts==ucLen+3){
   \   000000E8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000EA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EC   0x1CF0             ADDS     R0,R6,#+3
   \   000000EE   0x4287             CMP      R7,R0
   \   000000F0   0xD191             BNE.N    ??Uart1UnPack_0
   1039                      uiCrc16=RevCrc16Bytes(pucRx+2,ucLen+1,0xA001);
   \   000000F2   0xF24A 0x0201      MOVW     R2,#+40961
   \   000000F6   0x1C71             ADDS     R1,R6,#+1
   \   000000F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000FA   0xF11A 0x0002      ADDS     R0,R10,#+2
   \   000000FE   0x.... 0x....      BL       RevCrc16Bytes
   \   00000102   0x4681             MOV      R9,R0
   1040                      if(!uiCrc16){
   \   00000104   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000108   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000010C   0xD112             BNE.N    ??Uart1UnPack_6
   1041                        OSTaskQPost(&App_TaskUartProcessTCB, pucRx, ucCounts, OS_OPT_POST_FIFO, &os_err);
   \   0000010E   0xF10D 0x000E      ADD      R0,SP,#+14
   \   00000112   0x9000             STR      R0,[SP, #+0]
   \   00000114   0x2300             MOVS     R3,#+0
   \   00000116   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000118   0x003A             MOVS     R2,R7
   \   0000011A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000011C   0x4651             MOV      R1,R10
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000122   0x.... 0x....      BL       OSTaskQPost
   1042                        if(os_err!=OS_ERR_NONE){
   \   00000126   0xF8BD 0x000E      LDRH     R0,[SP, #+14]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD012             BEQ.N    ??Uart1UnPack_7
   1043                          //error
   1044                          ucState=1;
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x0005             MOVS     R5,R0
   \   00000132   0xE00F             B.N      ??Uart1UnPack_7
   1045                        }
   1046                      }else{
   1047                        Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \                     ??Uart1UnPack_6: (+1)
   \   00000134   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000138   0x4651             MOV      R1,R10
   \   0000013A   0x....             LDR.N    R0,??DataTable10
   \   0000013C   0x.... 0x....      BL       Mem_PoolBlkFree
   1048                        if (lib_err != LIB_MEM_ERR_NONE){
   \   00000140   0xF9BD 0x000A      LDRSH    R0,[SP, #+10]
   \   00000144   0xF242 0x7110      MOVW     R1,#+10000
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xD001             BEQ.N    ??Uart1UnPack_8
   1049                          //error
   1050                          ucState=1;
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x0005             MOVS     R5,R0
   1051                        }
   1052                        pucRx=NULL;
   \                     ??Uart1UnPack_8: (+1)
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0x4682             MOV      R10,R0
   1053                      }
   1054                      ucState=0;
   \                     ??Uart1UnPack_7: (+1)
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x0005             MOVS     R5,R0
   1055                      ucCounts=0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x0007             MOVS     R7,R0
   \   0000015C   0xE75B             B.N      ??Uart1UnPack_0
   1056                    }
   1057                  }
   1058                }
   1059             }else{
   1060                if(pucRx!=0){
   \                     ??Uart1UnPack_1: (+1)
   \   0000015E   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000162   0xD007             BEQ.N    ??Uart1UnPack_9
   1061                  Mem_PoolBlkFree(&m_UartBufPool, pucRx, &lib_err);
   \   00000164   0xF10D 0x020A      ADD      R2,SP,#+10
   \   00000168   0x4651             MOV      R1,R10
   \   0000016A   0x....             LDR.N    R0,??DataTable10
   \   0000016C   0x.... 0x....      BL       Mem_PoolBlkFree
   1062                  if (lib_err != LIB_MEM_ERR_NONE)  {
   1063                    //error
   1064                  }
   1065                  pucRx=NULL;
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x4682             MOV      R10,R0
   1066                }
   1067                ucState=0;
   \                     ??Uart1UnPack_9: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x0005             MOVS     R5,R0
   1068                ucCounts=0;
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0x0007             MOVS     R7,R0
   \   0000017C   0xE74B             B.N      ??Uart1UnPack_0
   1069              }
   1070            }    
   1071          }
   1072          
   1073          
   1074          /********************************************************************************************************
   1075          ** oˉêy??3?: Uart3UnPack
   1076          ** 1|?ü?èê?:
   1077          ** ê? ?? è?:
   1078          **
   1079          ** ê???  3?:
   1080          **
   1081          ** è???±?á?:
   1082          ** μ÷ó??￡?é:
   1083          **
   1084          ** ×÷??  ??: John Tonny
   1085          ** è???  ?ú: 2005?ê05??01è?
   1086          **------------------------------------------------------------------------------------------------------
   1087          ** DT ?? è?:
   1088          ** è???  ?ú:
   1089          **------------------------------------------------------------------------------------------------------
   1090          *******************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1091          void Uart3UnPack(CPU_INT08U ucMode)
   1092          {
   \                     Uart3UnPack: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   1093            SERIAL_ERR     err;
   1094            
   1095            CPU_INT08U     ucStart;
   1096            CPU_INT08U     ucCounts;    
   1097            CPU_CHAR       scData;
   1098            
   1099            CPU_INT08U     ucRx[10];
   1100            CPU_INT08U     *pucBuf;
   1101            
   1102            CPU_INT08U     ucTimes;
   1103            CPU_INT08U     ucNoTimes;
   1104            CPU_INT08U     ucMaxTimes;
   1105            CPU_INT08U     ucMaxDistance;
   1106            CPU_INT08U     ucHaved;
   1107            
   1108            CPU_INT08U     ucRecvLen;
   1109          #if ULTRASOUND_LEN_7_EN==1
   1110            ucRecvLen=7;
   \   00000006   0x2007             MOVS     R0,#+7
   \   00000008   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1111          #else
   1112            ucRecvLen=8;
   1113          #endif
   1114           
   1115            if(!EepromReadVerifyBytes(ULTRASOUND_PARAMS_ADDR,ucRx,2)){
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0xA903             ADD      R1,SP,#+12
   \   00000010   0x2044             MOVS     R0,#+68
   \   00000012   0x.... 0x....      BL       EepromReadVerifyBytes
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD104             BNE.N    ??Uart3UnPack_0
   1116              ucMaxTimes=ULTRASOUND_TIMES_DEFAULT;
   \   0000001A   0x200A             MOVS     R0,#+10
   \   0000001C   0x4681             MOV      R9,R0
   1117              ucMaxDistance=ULTRASOUND_DISTANCE_DEFAULT;
   \   0000001E   0x2096             MOVS     R0,#+150
   \   00000020   0x4682             MOV      R10,R0
   \   00000022   0xE005             B.N      ??Uart3UnPack_1
   1118            }else{
   1119              ucMaxDistance=ucRx[0];
   \                     ??Uart3UnPack_0: (+1)
   \   00000024   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000028   0x4682             MOV      R10,R0
   1120              ucMaxTimes=ucRx[1];
   \   0000002A   0xF89D 0x000D      LDRB     R0,[SP, #+13]
   \   0000002E   0x4681             MOV      R9,R0
   1121            }
   1122              
   1123            m_ucMachineAddr=0x40;
   \                     ??Uart3UnPack_1: (+1)
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x....             LDR.N    R1,??DataTable10_11
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   1124                
   1125            ucHaved=0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x4683             MOV      R11,R0
   1126            ucTimes=0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0007             MOVS     R7,R0
   1127            ucNoTimes=0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x4680             MOV      R8,R0
   1128            ucStart=0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0004             MOVS     R4,R0
   1129            ucCounts=0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0005             MOVS     R5,R0
   1130            while (DEF_TRUE) {                
   1131              Uart_SerStrRd(Uart_SerTraceIF_Nbr[3],&scData,1,0,&err);
   \                     ??Uart3UnPack_2: (+1)
   \   0000004A   0xF10D 0x000A      ADD      R0,SP,#+10
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0xA902             ADD      R1,SP,#+8
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   0000005A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000005C   0x.... 0x....      BL       Uart_SerStrRd
   1132              if(err==SERIAL_ERR_NONE){
   \   00000060   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xF040 0x80AA      BNE.W    ??Uart3UnPack_3
   1133              #if ULTRASOUND_NEW_EN==0
   1134                if(ucCounts>ucRecvLen){
   1135                  ucStart=0;
   1136                  ucCounts=0;
   1137                }else{
   1138                  if(scData==UART3_SOF && ucStart==0){
   1139                    ucCounts=0;
   1140                    ucStart=1;
   1141                    pucBuf=ucRx;
   1142                    *pucBuf=scData;
   1143                    pucBuf++;
   1144                    ucCounts++;
   1145                  }else if(ucStart==1){
   1146                    *pucBuf=scData;
   1147                    pucBuf++;
   1148                    ucCounts++;
   1149                  #if ULTRASOUND_LEN_7_EN==0
   1150                    if(ucCounts==8 && scData==UART3_EOF){
   1151                  #else            
   1152                    if(ucCounts==7){
   1153                  #endif
   1154                      if(ucRx[3]<=ucMaxDistance && ucRx[4]<=ucMaxDistance){
   1155                        ucNoTimes=0;
   1156                        if(ucTimes<ucMaxTimes){                
   1157                          ucTimes++;
   1158                          if(ucTimes>=ucMaxTimes && ucHaved==0){
   1159                            ucHaved=1;
   1160                            UltraSoundSend(1);
   1161                            Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   1162                          }
   1163                        }else{
   1164                          Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   1165                        }
   1166                      }else{
   1167                        if(ucNoTimes<ucMaxTimes){                
   1168                          ucNoTimes++;
   1169                          if(ucNoTimes>=ucMaxTimes){
   1170                            ucHaved=0;
   1171                            UltraSoundSend(0);
   1172                            Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   1173                          }
   1174                        }
   1175                        ucTimes=0;
   1176                      }
   1177                      ucStart=0;
   1178                    }
   1179                  }else{
   1180                    ucStart=0;
   1181                  }
   1182                }
   1183            #else
   1184                if(ucCounts>ucRecvLen){
   \   0000006A   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD204             BCS.N    ??Uart3UnPack_4
   1185                  ucStart=0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x0004             MOVS     R4,R0
   1186                  ucCounts=0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x0005             MOVS     R5,R0
   \   0000007E   0xE7E4             B.N      ??Uart3UnPack_2
   1187                }else{
   1188                  if(scData==UART3_SOF && ucStart==0){
   \                     ??Uart3UnPack_4: (+1)
   \   00000080   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000084   0x28CB             CMP      R0,#+203
   \   00000086   0xD10E             BNE.N    ??Uart3UnPack_5
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD10B             BNE.N    ??Uart3UnPack_5
   1189                    ucCounts=0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x0005             MOVS     R5,R0
   1190                    ucStart=1;
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x0004             MOVS     R4,R0
   1191                    pucBuf=ucRx;
   \   00000096   0xA803             ADD      R0,SP,#+12
   \   00000098   0x0006             MOVS     R6,R0
   1192                    *pucBuf=scData;
   \   0000009A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000009E   0x7030             STRB     R0,[R6, #+0]
   1193                    pucBuf++;
   \   000000A0   0x1C76             ADDS     R6,R6,#+1
   1194                    ucCounts++;
   \   000000A2   0x1C6D             ADDS     R5,R5,#+1
   \   000000A4   0xE7D1             B.N      ??Uart3UnPack_2
   1195                  }else if(scData==UART3_CMD && ucStart==1){
   \                     ??Uart3UnPack_5: (+1)
   \   000000A6   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000AA   0x2855             CMP      R0,#+85
   \   000000AC   0xD10A             BNE.N    ??Uart3UnPack_6
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x2C01             CMP      R4,#+1
   \   000000B2   0xD107             BNE.N    ??Uart3UnPack_6
   1196                    *pucBuf=scData;
   \   000000B4   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000B8   0x7030             STRB     R0,[R6, #+0]
   1197                    pucBuf++;
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   1198                    ucCounts++;
   \   000000BC   0x1C6D             ADDS     R5,R5,#+1
   1199                    ucStart=2;
   \   000000BE   0x2002             MOVS     R0,#+2
   \   000000C0   0x0004             MOVS     R4,R0
   \   000000C2   0xE7C2             B.N      ??Uart3UnPack_2
   1200                  }else if(scData==UART3_LEN && ucStart==2){
   \                     ??Uart3UnPack_6: (+1)
   \   000000C4   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C8   0x2804             CMP      R0,#+4
   \   000000CA   0xD10A             BNE.N    ??Uart3UnPack_7
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2C02             CMP      R4,#+2
   \   000000D0   0xD107             BNE.N    ??Uart3UnPack_7
   1201                    *pucBuf=scData;
   \   000000D2   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000D6   0x7030             STRB     R0,[R6, #+0]
   1202                    pucBuf++;
   \   000000D8   0x1C76             ADDS     R6,R6,#+1
   1203                    ucCounts++;
   \   000000DA   0x1C6D             ADDS     R5,R5,#+1
   1204                    ucStart=3;
   \   000000DC   0x2003             MOVS     R0,#+3
   \   000000DE   0x0004             MOVS     R4,R0
   \   000000E0   0xE7B3             B.N      ??Uart3UnPack_2
   1205                  }else if(ucStart==3){
   \                     ??Uart3UnPack_7: (+1)
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x2C03             CMP      R4,#+3
   \   000000E6   0xD167             BNE.N    ??Uart3UnPack_8
   1206                    *pucBuf=scData;
   \   000000E8   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000EC   0x7030             STRB     R0,[R6, #+0]
   1207                    pucBuf++;
   \   000000EE   0x1C76             ADDS     R6,R6,#+1
   1208                    ucCounts++;
   \   000000F0   0x1C6D             ADDS     R5,R5,#+1
   1209                  #if ULTRASOUND_LEN_7_EN==0
   1210                    if(ucCounts==8 && scData==UART3_EOF){
   1211                  #else            
   1212                    if(ucCounts==7){
   \   000000F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F4   0x2D07             CMP      R5,#+7
   \   000000F6   0xD1A8             BNE.N    ??Uart3UnPack_2
   1213                  #endif
   1214                      if(ucRx[3]<=ucMaxDistance && ucRx[4]<=ucMaxDistance){
   \   000000F8   0x4650             MOV      R0,R10
   \   000000FA   0xF89D 0x100F      LDRB     R1,[SP, #+15]
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD336             BCC.N    ??Uart3UnPack_9
   \   00000104   0x4650             MOV      R0,R10
   \   00000106   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x4288             CMP      R0,R1
   \   0000010E   0xD330             BCC.N    ??Uart3UnPack_9
   1215                        ucNoTimes=0;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x4680             MOV      R8,R0
   1216                        if(ucTimes<ucMaxTimes){                
   \   00000114   0x0038             MOVS     R0,R7
   \   00000116   0x4649             MOV      R1,R9
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD21C             BCS.N    ??Uart3UnPack_10
   1217                          ucTimes++;
   \   00000120   0x1C7F             ADDS     R7,R7,#+1
   1218                          if(ucTimes>=ucMaxTimes && ucHaved==0){
   \   00000122   0x0038             MOVS     R0,R7
   \   00000124   0x4649             MOV      R1,R9
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012A   0x4288             CMP      R0,R1
   \   0000012C   0xD341             BCC.N    ??Uart3UnPack_11
   \   0000012E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000132   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000136   0xD13C             BNE.N    ??Uart3UnPack_11
   1219                            ucHaved=1;
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0x4683             MOV      R11,R0
   1220                            UltraSoundSend(1);
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0x.... 0x....      BL       UltraSoundSend
   1221                            Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0x9001             STR      R0,[SP, #+4]
   \   00000146   0x2004             MOVS     R0,#+4
   \   00000148   0x9000             STR      R0,[SP, #+0]
   \   0000014A   0xF10D 0x030F      ADD      R3,SP,#+15
   \   0000014E   0x2200             MOVS     R2,#+0
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x206E             MOVS     R0,#+110
   \   00000154   0x.... 0x....      BL       Uart0Pack
   \   00000158   0xE02B             B.N      ??Uart3UnPack_11
   1222                          }
   1223                        }else{
   1224                          Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   \                     ??Uart3UnPack_10: (+1)
   \   0000015A   0x2001             MOVS     R0,#+1
   \   0000015C   0x9001             STR      R0,[SP, #+4]
   \   0000015E   0x2004             MOVS     R0,#+4
   \   00000160   0x9000             STR      R0,[SP, #+0]
   \   00000162   0xF10D 0x030F      ADD      R3,SP,#+15
   \   00000166   0x2200             MOVS     R2,#+0
   \   00000168   0x2100             MOVS     R1,#+0
   \   0000016A   0x206E             MOVS     R0,#+110
   \   0000016C   0x.... 0x....      BL       Uart0Pack
   \   00000170   0xE01F             B.N      ??Uart3UnPack_11
   1225                        }
   1226                      }else{
   1227                        if(ucNoTimes<ucMaxTimes){                
   \                     ??Uart3UnPack_9: (+1)
   \   00000172   0x4640             MOV      R0,R8
   \   00000174   0x4649             MOV      R1,R9
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000178   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000017A   0x4288             CMP      R0,R1
   \   0000017C   0xD217             BCS.N    ??Uart3UnPack_12
   1228                          ucNoTimes++;
   \   0000017E   0xF118 0x0801      ADDS     R8,R8,#+1
   1229                          if(ucNoTimes>=ucMaxTimes){
   \   00000182   0x4640             MOV      R0,R8
   \   00000184   0x4649             MOV      R1,R9
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD30F             BCC.N    ??Uart3UnPack_12
   1230                            ucHaved=0;
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x4683             MOV      R11,R0
   1231                            UltraSoundSend(0);
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0x.... 0x....      BL       UltraSoundSend
   1232                            Uart0Pack(INFTYPE_ULTRASOUND_STATUS,0,0,&ucRx[3],4,1);
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0x9001             STR      R0,[SP, #+4]
   \   0000019C   0x2004             MOVS     R0,#+4
   \   0000019E   0x9000             STR      R0,[SP, #+0]
   \   000001A0   0xF10D 0x030F      ADD      R3,SP,#+15
   \   000001A4   0x2200             MOVS     R2,#+0
   \   000001A6   0x2100             MOVS     R1,#+0
   \   000001A8   0x206E             MOVS     R0,#+110
   \   000001AA   0x.... 0x....      BL       Uart0Pack
   1233                          }
   1234                        }
   1235                        ucTimes=0;
   \                     ??Uart3UnPack_12: (+1)
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x0007             MOVS     R7,R0
   1236                      }
   1237                      ucStart=0;
   \                     ??Uart3UnPack_11: (+1)
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x0004             MOVS     R4,R0
   \   000001B6   0xE748             B.N      ??Uart3UnPack_2
   1238                    }
   1239                  }else{
   1240                    ucStart=0;
   \                     ??Uart3UnPack_8: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x0004             MOVS     R4,R0
   \   000001BC   0xE745             B.N      ??Uart3UnPack_2
   1241                  }
   1242                }          
   1243            #endif        
   1244             }else{
   1245                ucStart=0;
   \                     ??Uart3UnPack_3: (+1)
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x0004             MOVS     R4,R0
   \   000001C2   0xE742             B.N      ??Uart3UnPack_2
   1246              }
   1247            }    
   1248          }
   1249          
   1250          /**********************************************************************************************************
   1251          *                                           Uart0Process()
   1252          *
   1253          * Description : Read a string from the serial terminal. 
   1254          *
   1255          * Argument(s) : p_str       Pointer to string.
   1256          *
   1257          *               len         String length.
   1258          *
   1259          * Return(s)   : The number of octets written.
   1260          *
   1261          * Caller(s)   : Application.
   1262          *
   1263          * Note(s)     : none.
   1264          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1265          void Uart0Process(CPU_CHAR *pMsg,OS_MSG_SIZE msgSize)
   1266          {
   \                     Uart0Process: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1267            INT8U ucBuf[8];
   1268            CPU_SR_ALLOC();
   \   00000008   0x2600             MOVS     R6,#+0
   1269            
   1270            CardMachineRxData *pcommData=(CardMachineRxData *)&pMsg[1];
   \   0000000A   0x1C67             ADDS     R7,R4,#+1
   1271            
   1272            pcommData->ucLen=msgSize-7;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x1FC0             SUBS     R0,R0,#+7
   \   00000010   0xF887 0x003F      STRB     R0,[R7, #+63]
   1273            m_ucMachineAddr=pcommData->ucAddr;
   \   00000014   0x7878             LDRB     R0,[R7, #+1]
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   1274            switch(pcommData->ucCmd){
   \   0000001C   0x78F8             LDRB     R0,[R7, #+3]
   \   0000001E   0x2810             CMP      R0,#+16
   \   00000020   0xF000 0x8123      BEQ.W    ??Uart0Process_0
   \   00000024   0x2811             CMP      R0,#+17
   \   00000026   0xF000 0x8120      BEQ.W    ??Uart0Process_0
   \   0000002A   0x2813             CMP      R0,#+19
   \   0000002C   0xF000 0x811D      BEQ.W    ??Uart0Process_0
   \   00000030   0x2815             CMP      R0,#+21
   \   00000032   0xF000 0x8136      BEQ.W    ??Uart0Process_1
   \   00000036   0x2820             CMP      R0,#+32
   \   00000038   0xF000 0x8117      BEQ.W    ??Uart0Process_0
   \   0000003C   0x2821             CMP      R0,#+33
   \   0000003E   0xF000 0x8114      BEQ.W    ??Uart0Process_0
   \   00000042   0x2822             CMP      R0,#+34
   \   00000044   0xF000 0x8111      BEQ.W    ??Uart0Process_0
   \   00000048   0x2823             CMP      R0,#+35
   \   0000004A   0xF000 0x810E      BEQ.W    ??Uart0Process_0
   \   0000004E   0x2830             CMP      R0,#+48
   \   00000050   0xF000 0x814C      BEQ.W    ??Uart0Process_2
   \   00000054   0x2831             CMP      R0,#+49
   \   00000056   0xF000 0x8151      BEQ.W    ??Uart0Process_3
   \   0000005A   0x2832             CMP      R0,#+50
   \   0000005C   0xF000 0x8156      BEQ.W    ??Uart0Process_4
   \   00000060   0x2834             CMP      R0,#+52
   \   00000062   0xF000 0x8157      BEQ.W    ??Uart0Process_5
   \   00000066   0x2835             CMP      R0,#+53
   \   00000068   0xF000 0x8158      BEQ.W    ??Uart0Process_6
   \   0000006C   0x2836             CMP      R0,#+54
   \   0000006E   0xF000 0x8159      BEQ.W    ??Uart0Process_7
   \   00000072   0x2838             CMP      R0,#+56
   \   00000074   0xF000 0x80F9      BEQ.W    ??Uart0Process_0
   \   00000078   0x2839             CMP      R0,#+57
   \   0000007A   0xF000 0x80F6      BEQ.W    ??Uart0Process_0
   \   0000007E   0x283A             CMP      R0,#+58
   \   00000080   0xF000 0x8154      BEQ.W    ??Uart0Process_8
   \   00000084   0x283B             CMP      R0,#+59
   \   00000086   0xF000 0x8160      BEQ.W    ??Uart0Process_9
   \   0000008A   0x283C             CMP      R0,#+60
   \   0000008C   0xF000 0x816C      BEQ.W    ??Uart0Process_10
   \   00000090   0x283D             CMP      R0,#+61
   \   00000092   0xF000 0x8198      BEQ.W    ??Uart0Process_11
   \   00000096   0x2841             CMP      R0,#+65
   \   00000098   0xF000 0x812C      BEQ.W    ??Uart0Process_12
   \   0000009C   0x2842             CMP      R0,#+66
   \   0000009E   0xF000 0x8131      BEQ.W    ??Uart0Process_13
   \   000000A2   0x2843             CMP      R0,#+67
   \   000000A4   0xF000 0x81AE      BEQ.W    ??Uart0Process_14
   \   000000A8   0x2845             CMP      R0,#+69
   \   000000AA   0xF000 0x81AC      BEQ.W    ??Uart0Process_15
   \   000000AE   0x2846             CMP      R0,#+70
   \   000000B0   0xF000 0x81AD      BEQ.W    ??Uart0Process_16
   \   000000B4   0x2848             CMP      R0,#+72
   \   000000B6   0xF000 0x81AE      BEQ.W    ??Uart0Process_17
   \   000000BA   0x2849             CMP      R0,#+73
   \   000000BC   0xF000 0x81AF      BEQ.W    ??Uart0Process_18
   \   000000C0   0x2850             CMP      R0,#+80
   \   000000C2   0xF000 0x81B0      BEQ.W    ??Uart0Process_19
   \   000000C6   0x2851             CMP      R0,#+81
   \   000000C8   0xF000 0x81B1      BEQ.W    ??Uart0Process_20
   \   000000CC   0x2852             CMP      R0,#+82
   \   000000CE   0xF000 0x81B2      BEQ.W    ??Uart0Process_21
   \   000000D2   0x286B             CMP      R0,#+107
   \   000000D4   0xF000 0x81B3      BEQ.W    ??Uart0Process_22
   \   000000D8   0x286C             CMP      R0,#+108
   \   000000DA   0xF000 0x81B4      BEQ.W    ??Uart0Process_23
   \   000000DE   0x286D             CMP      R0,#+109
   \   000000E0   0xF000 0x81B5      BEQ.W    ??Uart0Process_24
   \   000000E4   0x286F             CMP      R0,#+111
   \   000000E6   0xF000 0x81B3      BEQ.W    ??Uart0Process_25
   \   000000EA   0x2880             CMP      R0,#+128
   \   000000EC   0xF000 0x81B4      BEQ.W    ??Uart0Process_26
   \   000000F0   0x2881             CMP      R0,#+129
   \   000000F2   0xF000 0x81B1      BEQ.W    ??Uart0Process_26
   \   000000F6   0x2882             CMP      R0,#+130
   \   000000F8   0xF000 0x81AE      BEQ.W    ??Uart0Process_26
   \   000000FC   0x2883             CMP      R0,#+131
   \   000000FE   0xF000 0x81AB      BEQ.W    ??Uart0Process_26
   \   00000102   0x2890             CMP      R0,#+144
   \   00000104   0xF000 0x81AC      BEQ.W    ??Uart0Process_27
   \   00000108   0x2891             CMP      R0,#+145
   \   0000010A   0xF000 0x81A9      BEQ.W    ??Uart0Process_27
   \   0000010E   0x2892             CMP      R0,#+146
   \   00000110   0xF000 0x81A6      BEQ.W    ??Uart0Process_27
   \   00000114   0x2893             CMP      R0,#+147
   \   00000116   0xF000 0x81A3      BEQ.W    ??Uart0Process_27
   \   0000011A   0x289A             CMP      R0,#+154
   \   0000011C   0xF000 0x81A4      BEQ.W    ??Uart0Process_28
   \   00000120   0x28A0             CMP      R0,#+160
   \   00000122   0xF000 0x81A5      BEQ.W    ??Uart0Process_29
   \   00000126   0x28A1             CMP      R0,#+161
   \   00000128   0xF000 0x81A6      BEQ.W    ??Uart0Process_30
   \   0000012C   0x28A2             CMP      R0,#+162
   \   0000012E   0xF000 0x81A7      BEQ.W    ??Uart0Process_31
   \   00000132   0x28A3             CMP      R0,#+163
   \   00000134   0xF000 0x81A5      BEQ.W    ??Uart0Process_32
   \   00000138   0x28A4             CMP      R0,#+164
   \   0000013A   0xF000 0x81A2      BEQ.W    ??Uart0Process_32
   \   0000013E   0x28A5             CMP      R0,#+165
   \   00000140   0xF000 0x81A0      BEQ.W    ??Uart0Process_33
   \   00000144   0x28A6             CMP      R0,#+166
   \   00000146   0xF000 0x819E      BEQ.W    ??Uart0Process_34
   \   0000014A   0x28A7             CMP      R0,#+167
   \   0000014C   0xF000 0x819F      BEQ.W    ??Uart0Process_35
   \   00000150   0x28AA             CMP      R0,#+170
   \   00000152   0xF000 0x81A0      BEQ.W    ??Uart0Process_36
   \   00000156   0x28AB             CMP      R0,#+171
   \   00000158   0xF000 0x81A5      BEQ.W    ??Uart0Process_37
   \   0000015C   0x28AC             CMP      R0,#+172
   \   0000015E   0xF000 0x81AA      BEQ.W    ??Uart0Process_38
   \   00000162   0x28C0             CMP      R0,#+192
   \   00000164   0xD02A             BEQ.N    ??Uart0Process_39
   \   00000166   0x28C1             CMP      R0,#+193
   \   00000168   0xD02C             BEQ.N    ??Uart0Process_40
   \   0000016A   0x28C2             CMP      R0,#+194
   \   0000016C   0xD02E             BEQ.N    ??Uart0Process_41
   \   0000016E   0x28C3             CMP      R0,#+195
   \   00000170   0xD030             BEQ.N    ??Uart0Process_42
   \   00000172   0x28C4             CMP      R0,#+196
   \   00000174   0xD031             BEQ.N    ??Uart0Process_43
   \   00000176   0x28C5             CMP      R0,#+197
   \   00000178   0xD033             BEQ.N    ??Uart0Process_44
   \   0000017A   0x28C6             CMP      R0,#+198
   \   0000017C   0xD035             BEQ.N    ??Uart0Process_45
   \   0000017E   0x28C7             CMP      R0,#+199
   \   00000180   0xD037             BEQ.N    ??Uart0Process_46
   \   00000182   0x28C8             CMP      R0,#+200
   \   00000184   0xD039             BEQ.N    ??Uart0Process_47
   \   00000186   0x28C9             CMP      R0,#+201
   \   00000188   0xD03B             BEQ.N    ??Uart0Process_48
   \   0000018A   0x28CA             CMP      R0,#+202
   \   0000018C   0xD03D             BEQ.N    ??Uart0Process_49
   \   0000018E   0x28CB             CMP      R0,#+203
   \   00000190   0xD03F             BEQ.N    ??Uart0Process_50
   \   00000192   0x28CC             CMP      R0,#+204
   \   00000194   0xD041             BEQ.N    ??Uart0Process_51
   \   00000196   0x28CD             CMP      R0,#+205
   \   00000198   0xD043             BEQ.N    ??Uart0Process_52
   \   0000019A   0x28CE             CMP      R0,#+206
   \   0000019C   0xD045             BEQ.N    ??Uart0Process_53
   \   0000019E   0x28CF             CMP      R0,#+207
   \   000001A0   0xD047             BEQ.N    ??Uart0Process_54
   \   000001A2   0x28D0             CMP      R0,#+208
   \   000001A4   0xD049             BEQ.N    ??Uart0Process_55
   \   000001A6   0x28D1             CMP      R0,#+209
   \   000001A8   0xD04B             BEQ.N    ??Uart0Process_56
   \   000001AA   0x28D2             CMP      R0,#+210
   \   000001AC   0xD04D             BEQ.N    ??Uart0Process_57
   \   000001AE   0x28D3             CMP      R0,#+211
   \   000001B0   0xD04F             BEQ.N    ??Uart0Process_58
   \   000001B2   0x28D4             CMP      R0,#+212
   \   000001B4   0xD051             BEQ.N    ??Uart0Process_59
   \   000001B6   0x28D5             CMP      R0,#+213
   \   000001B8   0xD053             BEQ.N    ??Uart0Process_60
   \   000001BA   0xE17F             B.N      ??Uart0Process_61
   1275              case SMOTO_WRITE_PARAMS_CMD:
   1276                SMotoWriteParams(pcommData);
   \                     ??Uart0Process_39: (+1)
   \   000001BC   0x0038             MOVS     R0,R7
   \   000001BE   0x.... 0x....      BL       SMotoWriteParams
   1277                break;
   \   000001C2   0xE17B             B.N      ??Uart0Process_61
   1278              case SMOTO_READ_PARAMS_CMD:
   1279                SMotoReadParams(pcommData);
   \                     ??Uart0Process_40: (+1)
   \   000001C4   0x0038             MOVS     R0,R7
   \   000001C6   0x.... 0x....      BL       SMotoReadParams
   1280                break;
   \   000001CA   0xE177             B.N      ??Uart0Process_61
   1281          
   1282              case DMOTO_WRITE_PARAMS_CMD:
   1283                DMotoWriteParams(pcommData);
   \                     ??Uart0Process_41: (+1)
   \   000001CC   0x0038             MOVS     R0,R7
   \   000001CE   0x.... 0x....      BL       DMotoWriteParams
   1284                break;
   \   000001D2   0xE173             B.N      ??Uart0Process_61
   1285              case DMOTO_READ_PARAMS_CMD:
   1286                DMotoReadParams(pcommData);
   \                     ??Uart0Process_42: (+1)
   \   000001D4   0x0038             MOVS     R0,R7
   \   000001D6   0x.... 0x....      BL       DMotoReadParams
   1287          
   1288              case AUTOOUT_MODE_WRITE_CMD:
   1289                //ParamsFlagWrite(pcommData,AUTOOUT_MODE_ADDR);
   1290                AutoOutModeWrite(pcommData);
   \                     ??Uart0Process_43: (+1)
   \   000001DA   0x0038             MOVS     R0,R7
   \   000001DC   0x.... 0x....      BL       AutoOutModeWrite
   1291                break;
   \   000001E0   0xE16C             B.N      ??Uart0Process_61
   1292              case AUTOOUT_MODE_READ_CMD:
   1293                //ParamsFlagRead(pcommData,AUTOOUT_MODE_ADDR);
   1294                AutoOutModeRead(pcommData);
   \                     ??Uart0Process_44: (+1)
   \   000001E2   0x0038             MOVS     R0,R7
   \   000001E4   0x.... 0x....      BL       AutoOutModeRead
   1295                break;
   \   000001E8   0xE168             B.N      ??Uart0Process_61
   1296          
   1297              case BUZZ_EN_WRITE_CMD:
   1298                //ParamsFlagWrite(pcommData,BUZZ_EN_ADDR);
   1299                BuzzEnWrite(pcommData);
   \                     ??Uart0Process_45: (+1)
   \   000001EA   0x0038             MOVS     R0,R7
   \   000001EC   0x.... 0x....      BL       BuzzEnWrite
   1300                break;
   \   000001F0   0xE164             B.N      ??Uart0Process_61
   1301              case BUZZ_EN_READ_CMD:
   1302                //ParamsFlagRead(pcommData,BUZZ_EN_ADDR);
   1303                BuzzEnRead(pcommData);
   \                     ??Uart0Process_46: (+1)
   \   000001F2   0x0038             MOVS     R0,R7
   \   000001F4   0x.... 0x....      BL       BuzzEnRead
   1304                break;
   \   000001F8   0xE160             B.N      ??Uart0Process_61
   1305          
   1306              case DMOTO_SELECT_WRITE_CMD:
   1307                DMotoSelectWrite(pcommData);
   \                     ??Uart0Process_47: (+1)
   \   000001FA   0x0038             MOVS     R0,R7
   \   000001FC   0x.... 0x....      BL       DMotoSelectWrite
   1308                break;
   \   00000200   0xE15C             B.N      ??Uart0Process_61
   1309              case DMOTO_SELECT_READ_CMD:
   1310                DMotoSelectRead(pcommData);
   \                     ??Uart0Process_48: (+1)
   \   00000202   0x0038             MOVS     R0,R7
   \   00000204   0x.... 0x....      BL       DMotoSelectRead
   1311                break;
   \   00000208   0xE158             B.N      ??Uart0Process_61
   1312          
   1313              case SMOTO_SELECT_WRITE_CMD:
   1314                SMotoSelectWrite(pcommData);
   \                     ??Uart0Process_49: (+1)
   \   0000020A   0x0038             MOVS     R0,R7
   \   0000020C   0x.... 0x....      BL       SMotoSelectWrite
   1315                break;
   \   00000210   0xE154             B.N      ??Uart0Process_61
   1316              case SMOTO_SELECT_READ_CMD:
   1317                SMotoSelectRead(pcommData);
   \                     ??Uart0Process_50: (+1)
   \   00000212   0x0038             MOVS     R0,R7
   \   00000214   0x.... 0x....      BL       SMotoSelectRead
   1318                break;
   \   00000218   0xE150             B.N      ??Uart0Process_61
   1319          
   1320              case BOX_SELECT_WRITE_CMD:
   1321                BoxSelectWrite(pcommData);
   \                     ??Uart0Process_51: (+1)
   \   0000021A   0x0038             MOVS     R0,R7
   \   0000021C   0x.... 0x....      BL       BoxSelectWrite
   1322                break;
   \   00000220   0xE14C             B.N      ??Uart0Process_61
   1323              case BOX_SELECT_READ_CMD:
   1324                BoxSelectRead(pcommData);
   \                     ??Uart0Process_52: (+1)
   \   00000222   0x0038             MOVS     R0,R7
   \   00000224   0x.... 0x....      BL       BoxSelectRead
   1325                break;
   \   00000228   0xE148             B.N      ??Uart0Process_61
   1326          
   1327              case KEY_SELECT_WRITE_CMD:
   1328                KeySelectWrite(pcommData);
   \                     ??Uart0Process_53: (+1)
   \   0000022A   0x0038             MOVS     R0,R7
   \   0000022C   0x.... 0x....      BL       KeySelectWrite
   1329                break;
   \   00000230   0xE144             B.N      ??Uart0Process_61
   1330              case KEY_SELECT_READ_CMD:
   1331                KeySelectRead(pcommData);
   \                     ??Uart0Process_54: (+1)
   \   00000232   0x0038             MOVS     R0,R7
   \   00000234   0x.... 0x....      BL       KeySelectRead
   1332                break;
   \   00000238   0xE140             B.N      ??Uart0Process_61
   1333          
   1334              case ULTRASOUND_WRITE_CMD:
   1335                UltraSoundWrite(pcommData);
   \                     ??Uart0Process_55: (+1)
   \   0000023A   0x0038             MOVS     R0,R7
   \   0000023C   0x.... 0x....      BL       UltraSoundWrite
   1336                break;
   \   00000240   0xE13C             B.N      ??Uart0Process_61
   1337              case ULTRASOUND_READ_CMD:
   1338                UltraSoundRead(pcommData);
   \                     ??Uart0Process_56: (+1)
   \   00000242   0x0038             MOVS     R0,R7
   \   00000244   0x.... 0x....      BL       UltraSoundRead
   1339                break;
   \   00000248   0xE138             B.N      ??Uart0Process_61
   1340          
   1341              case GROUP_SELECT_WRITE_CMD:
   1342                GroupSelectWrite(pcommData);
   \                     ??Uart0Process_57: (+1)
   \   0000024A   0x0038             MOVS     R0,R7
   \   0000024C   0x.... 0x....      BL       GroupSelectWrite
   1343                break;
   \   00000250   0xE134             B.N      ??Uart0Process_61
   1344              case GROUP_SELECT_READ_CMD:
   1345                GroupSelectRead(pcommData);
   \                     ??Uart0Process_58: (+1)
   \   00000252   0x0038             MOVS     R0,R7
   \   00000254   0x.... 0x....      BL       GroupSelectRead
   1346                break;
   \   00000258   0xE130             B.N      ??Uart0Process_61
   1347          
   1348              case SCAN_PARAMS_WRITE_CMD:
   1349                ScanParamsWrite(pcommData);
   \                     ??Uart0Process_59: (+1)
   \   0000025A   0x0038             MOVS     R0,R7
   \   0000025C   0x.... 0x....      BL       ScanParamsWrite
   1350                break;
   \   00000260   0xE12C             B.N      ??Uart0Process_61
   1351              case SCAN_PARAMS_READ_CMD:
   1352                ScanParamsRead(pcommData);
   \                     ??Uart0Process_60: (+1)
   \   00000262   0x0038             MOVS     R0,R7
   \   00000264   0x.... 0x....      BL       ScanParamsRead
   1353                break;
   \   00000268   0xE128             B.N      ??Uart0Process_61
   1354          
   1355                
   1356              case 0x10: 					//?¨?ú3??¨￡????¨′ó?¨?D×°3?μ??á?¨ìì???????￡
   1357              case 0x13:
   1358              case 0x11: 					//?¨?úí??¨￡????¨′ó?¨?ú?úμ??á?¨????・￠3?è￥?￡
   1359              case 0x20: 					//?¨?úê??¨￡????¨′ó?¨?ú×°è?μ??á?¨ìì???????￡//D?ê??¨?úê1ó?
   1360              case 0x21: 					//?¨?ú???¨￡????¨′ó?¨?ú?úμ??á?¨????×°???¨?D?￡//ê??¨?úê1ó?
   1361              case 0x22: 					//?¨?úí??¨￡????¨í?3?￡?D?ê??¨?ú?¨???áD′?TD§ê±???¨í?3?
   1362              case 0x23:					//?μ?¨??ê?		
   1363              case 0x38:                                  //掉卡开门3
   1364              case 0x39:                                  //打印机门
   1365                if(BSP_OS_SemWait(g_pActionSem,20)==DEF_FAIL){
   \                     ??Uart0Process_0: (+1)
   \   0000026A   0x2114             MOVS     R1,#+20
   \   0000026C   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000270   0x6800             LDR      R0,[R0, #+0]
   \   00000272   0x.... 0x....      BL       BSP_OS_SemWait
   \   00000276   0x2800             CMP      R0,#+0
   \   00000278   0xD10D             BNE.N    ??Uart0Process_62
   1366                  ucBuf[0]=SUBTYPE_ERR_DEVICE_BUSY;
   \   0000027A   0x203B             MOVS     R0,#+59
   \   0000027C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1367                  Uart0Pack(INFTYPE_DEVICE_ERR,pcommData->ucAddr,pcommData->ucSeq,ucBuf,1,0);
   \   00000280   0x2000             MOVS     R0,#+0
   \   00000282   0x9001             STR      R0,[SP, #+4]
   \   00000284   0x2001             MOVS     R0,#+1
   \   00000286   0x9000             STR      R0,[SP, #+0]
   \   00000288   0xAB02             ADD      R3,SP,#+8
   \   0000028A   0x78BA             LDRB     R2,[R7, #+2]
   \   0000028C   0x7879             LDRB     R1,[R7, #+1]
   \   0000028E   0x205E             MOVS     R0,#+94
   \   00000290   0x.... 0x....      BL       Uart0Pack
   \   00000294   0xE004             B.N      ??Uart0Process_63
   1368                }else{
   1369                  Box_TaskQPost(&App_TaskActionTCB,&pcommData->ucHead,sizeof(CardMachineRxData));  
   \                     ??Uart0Process_62: (+1)
   \   00000296   0x2240             MOVS     R2,#+64
   \   00000298   0x0039             MOVS     R1,R7
   \   0000029A   0x....             LDR.N    R0,??DataTable13_5
   \   0000029C   0x.... 0x....      BL       Box_TaskQPost
   1370                }
   1371                break;
   \                     ??Uart0Process_63: (+1)
   \   000002A0   0xE10C             B.N      ??Uart0Process_61
   1372                
   1373              case 0x15:					//?D??1¤??
   1374                if(pcommData->ucData[0]==0x30){
   \                     ??Uart0Process_1: (+1)
   \   000002A2   0x7938             LDRB     R0,[R7, #+4]
   \   000002A4   0x2830             CMP      R0,#+48
   \   000002A6   0xD110             BNE.N    ??Uart0Process_64
   1375                  OS_ENTER_CRITICAL();
   \   000002A8   0x.... 0x....      BL       CPU_SR_Save
   \   000002AC   0x0006             MOVS     R6,R0
   \   000002AE   0x.... 0x....      BL       CPU_IntDisMeasStart
   1376                  g_usrGlobalFlag.usrBit.bLedOutMode=3;		
   \   000002B2   0x....             LDR.N    R0,??DataTable13_6
   \   000002B4   0x7800             LDRB     R0,[R0, #+0]
   \   000002B6   0xF050 0x0060      ORRS     R0,R0,#0x60
   \   000002BA   0x....             LDR.N    R1,??DataTable13_6
   \   000002BC   0x7008             STRB     R0,[R1, #+0]
   1377                  OS_EXIT_CRITICAL();
   \   000002BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002C2   0x0030             MOVS     R0,R6
   \   000002C4   0x.... 0x....      BL       CPU_SR_Restore
   \   000002C8   0xE00F             B.N      ??Uart0Process_65
   1378                }else{
   1379                  OS_ENTER_CRITICAL();
   \                     ??Uart0Process_64: (+1)
   \   000002CA   0x.... 0x....      BL       CPU_SR_Save
   \   000002CE   0x0006             MOVS     R6,R0
   \   000002D0   0x.... 0x....      BL       CPU_IntDisMeasStart
   1380                  g_usrGlobalFlag.usrBit.bLedOutMode=0;		
   \   000002D4   0x....             LDR.N    R0,??DataTable13_6
   \   000002D6   0x7800             LDRB     R0,[R0, #+0]
   \   000002D8   0xF010 0x009F      ANDS     R0,R0,#0x9F
   \   000002DC   0x....             LDR.N    R1,??DataTable13_6
   \   000002DE   0x7008             STRB     R0,[R1, #+0]
   1381                  OS_EXIT_CRITICAL();
   \   000002E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002E4   0x0030             MOVS     R0,R6
   \   000002E6   0x.... 0x....      BL       CPU_SR_Restore
   1382                }
   1383                break;
   \                     ??Uart0Process_65: (+1)
   \   000002EA   0xE0E7             B.N      ??Uart0Process_61
   1384                
   1385              case 0x30:					//?á?¨?ú?μáDo? I2C
   1386                CardMachineIdRead(pcommData);
   \                     ??Uart0Process_2: (+1)
   \   000002EC   0x0038             MOVS     R0,R7
   \   000002EE   0x.... 0x....      BL       CardMachineIdRead
   1387                break;
   \   000002F2   0xE0E3             B.N      ??Uart0Process_61
   1388              case 0x41:					//éè???¨?ú?μáDo? I2C
   1389                CardMachineIdWrite(pcommData);
   \                     ??Uart0Process_12: (+1)
   \   000002F4   0x0038             MOVS     R0,R7
   \   000002F6   0x.... 0x....      BL       CardMachineIdWrite
   1390                break;
   \   000002FA   0xE0DF             B.N      ??Uart0Process_61
   1391          
   1392              case 0x31:					//?á?¨?D?μáDo? UART3
   1393                CardBoxIdRead(pcommData);
   \                     ??Uart0Process_3: (+1)
   \   000002FC   0x0038             MOVS     R0,R7
   \   000002FE   0x.... 0x....      BL       CardBoxIdRead
   1394                break;
   \   00000302   0xE0DB             B.N      ??Uart0Process_61
   1395              case 0x42:					//éè???¨?D?μáDo? UART3
   1396                CardBoxIdWrite(pcommData);
   \                     ??Uart0Process_13: (+1)
   \   00000304   0x0038             MOVS     R0,R7
   \   00000306   0x.... 0x....      BL       CardBoxIdWrite
   1397                break;
   \   0000030A   0xE0D7             B.N      ??Uart0Process_61
   1398          
   1399              case 0x32:					//?áè??¨?D?¨êy I2C ?òUART3
   1400                CardBoxCountRead(pcommData);
   \                     ??Uart0Process_4: (+1)
   \   0000030C   0x0038             MOVS     R0,R7
   \   0000030E   0x.... 0x....      BL       CardBoxCountRead
   1401                break;		
   \   00000312   0xE0D3             B.N      ??Uart0Process_61
   1402              case 0x34: 					//éè???¨?Dμ±?°′?′￠?¨êy UART3
   1403                CardBoxCountWrite(pcommData);
   \                     ??Uart0Process_5: (+1)
   \   00000314   0x0038             MOVS     R0,R7
   \   00000316   0x.... 0x....      BL       CardBoxCountWrite
   1404                break;
   \   0000031A   0xE0CF             B.N      ??Uart0Process_61
   1405          
   1406              case 0x35:					//?áè??¨?úμ??・
   1407                CardMachineAddrRead(pcommData);
   \                     ??Uart0Process_6: (+1)
   \   0000031C   0x0038             MOVS     R0,R7
   \   0000031E   0x.... 0x....      BL       CardMachineAddrRead
   1408                break;
   \   00000322   0xE0CB             B.N      ??Uart0Process_61
   1409              case 0x36:					//éè???¨?úμ??・
   1410                CardMachineAddrWrite(pcommData);
   \                     ??Uart0Process_7: (+1)
   \   00000324   0x0038             MOVS     R0,R7
   \   00000326   0x.... 0x....      BL       CardMachineAddrWrite
   1411                break;
   \   0000032A   0xE0C7             B.N      ??Uart0Process_61
   1412                
   1413              case 0x3A:			//内部天线	
   1414                CardBoxSetSelected(BOX_FIRST,BOX_POWER_OFF_MODE);
   \                     ??Uart0Process_8: (+1)
   \   0000032C   0x2100             MOVS     R1,#+0
   \   0000032E   0x2000             MOVS     R0,#+0
   \   00000330   0x.... 0x....      BL       CardBoxSetSelected
   1415                Uart0Pack(INFTYPE_CMD_FINISHED,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   00000334   0x2000             MOVS     R0,#+0
   \   00000336   0x9001             STR      R0,[SP, #+4]
   \   00000338   0x2000             MOVS     R0,#+0
   \   0000033A   0x9000             STR      R0,[SP, #+0]
   \   0000033C   0x2300             MOVS     R3,#+0
   \   0000033E   0x78BA             LDRB     R2,[R7, #+2]
   \   00000340   0x7879             LDRB     R1,[R7, #+1]
   \   00000342   0x205F             MOVS     R0,#+95
   \   00000344   0x.... 0x....      BL       Uart0Pack
   1416                break;
   \   00000348   0xE0B8             B.N      ??Uart0Process_61
   1417                
   1418              case 0x3B:			// 外部天线
   1419                CardBoxSetSelected(BOX_FIRST,BOX_POWER_ON_MODE);
   \                     ??Uart0Process_9: (+1)
   \   0000034A   0x2101             MOVS     R1,#+1
   \   0000034C   0x2000             MOVS     R0,#+0
   \   0000034E   0x.... 0x....      BL       CardBoxSetSelected
   1420                Uart0Pack(INFTYPE_CMD_FINISHED,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   00000352   0x2000             MOVS     R0,#+0
   \   00000354   0x9001             STR      R0,[SP, #+4]
   \   00000356   0x2000             MOVS     R0,#+0
   \   00000358   0x9000             STR      R0,[SP, #+0]
   \   0000035A   0x2300             MOVS     R3,#+0
   \   0000035C   0x78BA             LDRB     R2,[R7, #+2]
   \   0000035E   0x7879             LDRB     R1,[R7, #+1]
   \   00000360   0x205F             MOVS     R0,#+95
   \   00000362   0x.... 0x....      BL       Uart0Pack
   1421                break;
   \   00000366   0xE0A9             B.N      ??Uart0Process_61
   1422          
   1423              case 0x3C:			//开扫描枪
   1424                CloseScan();
   \                     ??Uart0Process_10: (+1)
   \   00000368   0x2101             MOVS     R1,#+1
   \   0000036A   0x2002             MOVS     R0,#+2
   \   0000036C   0x.... 0x....      BL       CSP_GPIO_BitSet
   1425                OS_ENTER_CRITICAL();
   \   00000370   0x.... 0x....      BL       CPU_SR_Save
   \   00000374   0x0006             MOVS     R6,R0
   \   00000376   0x.... 0x....      BL       CPU_IntDisMeasStart
   1426                g_usrScan.bEnabled=1;
   \   0000037A   0x....             LDR.N    R0,??DataTable13_7
   \   0000037C   0x8800             LDRH     R0,[R0, #+0]
   \   0000037E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000382   0x....             LDR.N    R1,??DataTable13_7
   \   00000384   0x8008             STRH     R0,[R1, #+0]
   1427                g_usrScan.bMode=SCAN_CLOSE_MODE;
   \   00000386   0x....             LDR.N    R0,??DataTable13_7
   \   00000388   0x8800             LDRH     R0,[R0, #+0]
   \   0000038A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000038E   0x4008             ANDS     R0,R1,R0
   \   00000390   0x....             LDR.N    R1,??DataTable13_7
   \   00000392   0x8008             STRH     R0,[R1, #+0]
   1428                g_usrScan.b14Times=g_ucScanCloseTime;
   \   00000394   0x....             LDR.N    R0,??DataTable13_7
   \   00000396   0x8800             LDRH     R0,[R0, #+0]
   \   00000398   0xF410 0x4040      ANDS     R0,R0,#0xC000
   \   0000039C   0x....             LDR.N    R1,??DataTable13_8
   \   0000039E   0x7809             LDRB     R1,[R1, #+0]
   \   000003A0   0x4308             ORRS     R0,R1,R0
   \   000003A2   0x....             LDR.N    R1,??DataTable13_7
   \   000003A4   0x8008             STRH     R0,[R1, #+0]
   1429                OS_EXIT_CRITICAL();
   \   000003A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003AA   0x0030             MOVS     R0,R6
   \   000003AC   0x.... 0x....      BL       CPU_SR_Restore
   1430                
   1431                Uart0Pack(INFTYPE_CMD_FINISHED,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   000003B0   0x2000             MOVS     R0,#+0
   \   000003B2   0x9001             STR      R0,[SP, #+4]
   \   000003B4   0x2000             MOVS     R0,#+0
   \   000003B6   0x9000             STR      R0,[SP, #+0]
   \   000003B8   0x2300             MOVS     R3,#+0
   \   000003BA   0x78BA             LDRB     R2,[R7, #+2]
   \   000003BC   0x7879             LDRB     R1,[R7, #+1]
   \   000003BE   0x205F             MOVS     R0,#+95
   \   000003C0   0x.... 0x....      BL       Uart0Pack
   1432                break;
   \   000003C4   0xE07A             B.N      ??Uart0Process_61
   1433              
   1434              case 0x3D:			// 关扫描枪
   1435                CloseScan();
   \                     ??Uart0Process_11: (+1)
   \   000003C6   0x2101             MOVS     R1,#+1
   \   000003C8   0x2002             MOVS     R0,#+2
   \   000003CA   0x.... 0x....      BL       CSP_GPIO_BitSet
   1436                OS_ENTER_CRITICAL();
   \   000003CE   0x.... 0x....      BL       CPU_SR_Save
   \   000003D2   0x0006             MOVS     R6,R0
   \   000003D4   0x.... 0x....      BL       CPU_IntDisMeasStart
   1437                g_usrScan.bEnabled=0;
   \   000003D8   0x....             LDR.N    R0,??DataTable13_7
   \   000003DA   0x8800             LDRH     R0,[R0, #+0]
   \   000003DC   0x0440             LSLS     R0,R0,#+17       ;; ZeroExtS R0,R0,#+17,#+17
   \   000003DE   0x0C40             LSRS     R0,R0,#+17
   \   000003E0   0x....             LDR.N    R1,??DataTable13_7
   \   000003E2   0x8008             STRH     R0,[R1, #+0]
   1438                OS_EXIT_CRITICAL();
   \   000003E4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000003E8   0x0030             MOVS     R0,R6
   \   000003EA   0x.... 0x....      BL       CPU_SR_Restore
   1439                Uart0Pack(INFTYPE_CMD_FINISHED,pcommData->ucAddr,pcommData->ucSeq,NULL,0,0);
   \   000003EE   0x2000             MOVS     R0,#+0
   \   000003F0   0x9001             STR      R0,[SP, #+4]
   \   000003F2   0x2000             MOVS     R0,#+0
   \   000003F4   0x9000             STR      R0,[SP, #+0]
   \   000003F6   0x2300             MOVS     R3,#+0
   \   000003F8   0x78BA             LDRB     R2,[R7, #+2]
   \   000003FA   0x7879             LDRB     R1,[R7, #+1]
   \   000003FC   0x205F             MOVS     R0,#+95
   \   000003FE   0x.... 0x....      BL       Uart0Pack
   1440                break;
   \   00000402   0xE05B             B.N      ??Uart0Process_61
   1441          
   1442              case 0x43:				//éè???¨?úμ±?°ê1ó?±¨?ˉò? I2C í¨??D-òé?T′???			
   1443                break;
   \                     ??Uart0Process_14: (+1)
   \   00000404   0xE05A             B.N      ??Uart0Process_61
   1444              case 0x45:				//éè???¨?ú?ì?úμ?áù???¨êy I2C
   1445                CardMachineAlarmMaxWrite(pcommData);
   \                     ??Uart0Process_15: (+1)
   \   00000406   0x0038             MOVS     R0,R7
   \   00000408   0x.... 0x....      BL       CardMachineAlarmMaxWrite
   1446                break;
   \   0000040C   0xE056             B.N      ??Uart0Process_61
   1447              case 0x46:				//éè???¨?ú?ì??μ?áù???¨êy I2C
   1448                CardMachineAlarmMinWrite(pcommData);
   \                     ??Uart0Process_16: (+1)
   \   0000040E   0x0038             MOVS     R0,R7
   \   00000410   0x.... 0x....      BL       CardMachineAlarmMinWrite
   1449                break;
   \   00000414   0xE052             B.N      ??Uart0Process_61
   1450          
   1451              case 0x48:					//?á?¨?D×?′ó?¨êy
   1452                CardBoxMaxCountRead(pcommData);
   \                     ??Uart0Process_17: (+1)
   \   00000416   0x0038             MOVS     R0,R7
   \   00000418   0x.... 0x....      BL       CardBoxMaxCountRead
   1453                break;
   \   0000041C   0xE04E             B.N      ??Uart0Process_61
   1454              case 0x49:					//éè?¨?D×?′ó?¨êy I2C
   1455                CardBoxMaxCountWrite(pcommData);
   \                     ??Uart0Process_18: (+1)
   \   0000041E   0x0038             MOVS     R0,R7
   \   00000420   0x.... 0x....      BL       CardBoxMaxCountWrite
   1456                break;
   \   00000424   0xE04A             B.N      ??Uart0Process_61
   1457          
   1458              case 0x50:					//?áè??¨?ú×′ì?D??￠ GPIO		
   1459                CardMachineStateRead(pcommData);
   \                     ??Uart0Process_19: (+1)
   \   00000426   0x0038             MOVS     R0,R7
   \   00000428   0x.... 0x....      BL       CardMachineStateRead
   1460                break;
   \   0000042C   0xE046             B.N      ??Uart0Process_61
   1461              case 0x51:					//?áè??¨?úààDí
   1462                CardMachineTypeRead(pcommData);
   \                     ??Uart0Process_20: (+1)
   \   0000042E   0x0038             MOVS     R0,R7
   \   00000430   0x.... 0x....      BL       CardMachineTypeRead
   1463                break;
   \   00000434   0xE042             B.N      ??Uart0Process_61
   1464              case 0x52:				//??3y?¨?DD??￠
   1465                CardBoxRecordInit(pcommData);
   \                     ??Uart0Process_21: (+1)
   \   00000436   0x0038             MOVS     R0,R7
   \   00000438   0x.... 0x....      BL       CardBoxRecordInit
   1466                break;
   \   0000043C   0xE03E             B.N      ??Uart0Process_61
   1467                
   1468              case 0x6B:					//?á?¨?ú?ì?úáù???¨êyI2C
   1469                CardMachineAlarmMaxRead(pcommData);
   \                     ??Uart0Process_22: (+1)
   \   0000043E   0x0038             MOVS     R0,R7
   \   00000440   0x.... 0x....      BL       CardMachineAlarmMaxRead
   1470                break;
   \   00000444   0xE03A             B.N      ??Uart0Process_61
   1471              case 0x6C:					//?á?¨?ú?ì??áù???¨êyI2C
   1472                CardMachineAlarmMinRead(pcommData);
   \                     ??Uart0Process_23: (+1)
   \   00000446   0x0038             MOVS     R0,R7
   \   00000448   0x.... 0x....      BL       CardMachineAlarmMinRead
   1473                break;
   \   0000044C   0xE036             B.N      ??Uart0Process_61
   1474              case 0x6D:					//3?ê??ˉ?¨?ú????
   1475                break;
   \                     ??Uart0Process_24: (+1)
   \   0000044E   0xE035             B.N      ??Uart0Process_61
   1476              case 0x6F:					//?á?¨?ú1ì?t°?±?D??￠/??DT/μ÷ê? I2C
   1477                CardMachineVersionRead(pcommData);
   \                     ??Uart0Process_25: (+1)
   \   00000450   0x0038             MOVS     R0,R7
   \   00000452   0x.... 0x....      BL       CardMachineVersionRead
   1478                break;		
   \   00000456   0xE031             B.N      ??Uart0Process_61
   1479              case 0x80:			//?á?¨?úêy?Y?éID
   1480              case 0x81:
   1481              case 0x82:
   1482              case 0x83:
   1483                CardMachineDataRead(pcommData);
   \                     ??Uart0Process_26: (+1)
   \   00000458   0x0038             MOVS     R0,R7
   \   0000045A   0x.... 0x....      BL       CardMachineDataRead
   1484              break;
   \   0000045E   0xE02D             B.N      ??Uart0Process_61
   1485              case 0x90:			//D′?¨?úêy?Y?éID
   1486              case 0x91:
   1487              case 0x92:
   1488              case 0x93:           
   1489                CardMachineDataWrite(pcommData);
   \                     ??Uart0Process_27: (+1)
   \   00000460   0x0038             MOVS     R0,R7
   \   00000462   0x.... 0x....      BL       CardMachineDataWrite
   1490              break;
   \   00000466   0xE029             B.N      ??Uart0Process_61
   1491              case 0x9A:	//?á?¨?D°?±?D??￠
   1492                CardBoxVersionRead(pcommData);
   \                     ??Uart0Process_28: (+1)
   \   00000468   0x0038             MOVS     R0,R7
   \   0000046A   0x.... 0x....      BL       CardBoxVersionRead
   1493                break;
   \   0000046E   0xE025             B.N      ??Uart0Process_61
   1494          
   1495                //A0??μ÷ê?ê1ó??üá?×?	
   1496              case 0xA0://μ÷ê?ê±ê1ó?￡?éy?μ??ì¨
   1497                CardBoxMotoMove(pcommData);
   \                     ??Uart0Process_29: (+1)
   \   00000470   0x0038             MOVS     R0,R7
   \   00000472   0x.... 0x....      BL       CardBoxMotoMove
   1498                break;
   \   00000476   0xE021             B.N      ??Uart0Process_61
   1499          
   1500              case 0xA1:  //μ÷ê?ê±ê1ó?￡??ó???¨êy
   1501                CardBoxCountAddSub(pcommData);;
   \                     ??Uart0Process_30: (+1)
   \   00000478   0x0038             MOVS     R0,R7
   \   0000047A   0x.... 0x....      BL       CardBoxCountAddSub
   1502                break;
   \   0000047E   0xE01D             B.N      ??Uart0Process_61
   1503          
   1504              case 0xA2:		//μ??ú2aê?
   1505                break;
   \                     ??Uart0Process_31: (+1)
   \   00000480   0xE01C             B.N      ??Uart0Process_61
   1506          
   1507              case 0xA3:		//??????ê??¨éè?¨￡¨μ÷ê?ê±ê1ó?￡??¨??μ?′??¨?úê±￡?×??ˉ??ê??á??ê?oD￡?
   1508              case 0xA4:		//μ??ú?-?・2aê?￡?ê?μ?′???á???oó￡???è??-?・2aê?
   1509                break;
   \                     ??Uart0Process_32: (+1)
   \   00000482   0xE01B             B.N      ??Uart0Process_61
   1510              case 0xA5: //?±á÷μ??ú?-?・2aê?
   1511                break;
   \                     ??Uart0Process_33: (+1)
   \   00000484   0xE01A             B.N      ??Uart0Process_61
   1512          
   1513              case 0xA6:
   1514                DMotoMove(pcommData);
   \                     ??Uart0Process_34: (+1)
   \   00000486   0x0038             MOVS     R0,R7
   \   00000488   0x.... 0x....      BL       DMotoMove
   1515                break;
   \   0000048C   0xE016             B.N      ??Uart0Process_61
   1516              case 0xA7:
   1517                SMotoMove(pcommData);
   \                     ??Uart0Process_35: (+1)
   \   0000048E   0x0038             MOVS     R0,R7
   \   00000490   0x.... 0x....      BL       SMotoMove
   1518                break;
   \   00000494   0xE012             B.N      ??Uart0Process_61
   1519              case 0xAA:
   1520                if(DEV_TYPE()==SMALL_THICK_GIN_TYPE){
   \                     ??Uart0Process_36: (+1)
   \   00000496   0x.... 0x....      BL       DEV_TYPE
   \   0000049A   0x2803             CMP      R0,#+3
   \   0000049C   0xD102             BNE.N    ??Uart0Process_66
   1521                  CardToBox(pcommData);
   \   0000049E   0x0038             MOVS     R0,R7
   \   000004A0   0x.... 0x....      BL       CardToBox
   1522                }
   1523                break;
   \                     ??Uart0Process_66: (+1)
   \   000004A4   0xE00A             B.N      ??Uart0Process_61
   1524              case 0xAB:
   1525                if(DEV_TYPE()==SMALL_THICK_GIN_TYPE){
   \                     ??Uart0Process_37: (+1)
   \   000004A6   0x.... 0x....      BL       DEV_TYPE
   \   000004AA   0x2803             CMP      R0,#+3
   \   000004AC   0xD102             BNE.N    ??Uart0Process_67
   1526                  CardToOut(pcommData);
   \   000004AE   0x0038             MOVS     R0,R7
   \   000004B0   0x.... 0x....      BL       CardToOut
   1527                }
   1528                break;		
   \                     ??Uart0Process_67: (+1)
   \   000004B4   0xE002             B.N      ??Uart0Process_61
   1529              case 0xAC:		//debug
   1530                KeyTest(pcommData);
   \                     ??Uart0Process_38: (+1)
   \   000004B6   0x0038             MOVS     R0,R7
   \   000004B8   0x.... 0x....      BL       KeyTest
   1531                break;		
   1532            }
   1533          }
   \                     ??Uart0Process_61: (+1)
   \   000004BC   0xB005             ADD      SP,SP,#+20
   \   000004BE   0xBDF0             POP      {R4-R7,PC}       ;; return
   1534          
   1535          
   1536          /**********************************************************************************************************
   1537          *                                           UartProcess()
   1538          *
   1539          * Description : Read a string from the serial terminal. 
   1540          *
   1541          * Argument(s) : p_str       Pointer to string.
   1542          *
   1543          *               len         String length.
   1544          *
   1545          * Return(s)   : The number of octets written.
   1546          *
   1547          * Caller(s)   : Application.
   1548          *
   1549          * Note(s)     : none.
   1550          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1551          void UartProcess(CPU_CHAR *pMsg,OS_MSG_SIZE msgSize)
   1552          {
   \                     UartProcess: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1553            CommRxData *pcommData=(CommRxData *)&pMsg[1];
   \   00000006   0x1C66             ADDS     R6,R4,#+1
   1554            CPU_INT08U ucSelected;
   1555          #if BOARD_OLD_EN==0  
   1556            ucSelected=m_ucUartToBox[(*pMsg)-1];
   \   00000008   0x....             LDR.N    R0,??DataTable13_9
   \   0000000A   0x7821             LDRB     R1,[R4, #+0]
   \   0000000C   0x4408             ADD      R0,R0,R1
   \   0000000E   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \   00000012   0x0007             MOVS     R7,R0
   1557          #else
   1558            ucSelected=(*pMsg)-1;  
   1559          #endif  
   1560            
   1561            if((pcommData->uiCluster & 0x0381)==0x0381 && !pcommData->ucStatus){
   \   00000014   0x8870             LDRH     R0,[R6, #+2]
   \   00000016   0xF240 0x3181      MOVW     R1,#+897
   \   0000001A   0x4008             ANDS     R0,R1,R0
   \   0000001C   0xF240 0x3181      MOVW     R1,#+897
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD140             BNE.N    ??UartProcess_0
   \   00000024   0x7970             LDRB     R0,[R6, #+5]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD13D             BNE.N    ??UartProcess_0
   1562              switch(pcommData->ucCmd){
   \   0000002A   0x7930             LDRB     R0,[R6, #+4]
   \   0000002C   0x1EC0             SUBS     R0,R0,#+3
   \   0000002E   0xD035             BEQ.N    ??UartProcess_1
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD914             BLS.N    ??UartProcess_2
   \   00000036   0x1F80             SUBS     R0,R0,#+6
   \   00000038   0xD018             BEQ.N    ??UartProcess_3
   \   0000003A   0x380F             SUBS     R0,R0,#+15
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD927             BLS.N    ??UartProcess_4
   \   00000040   0x3810             SUBS     R0,R0,#+16
   \   00000042   0xD007             BEQ.N    ??UartProcess_5
   \   00000044   0x38BA             SUBS     R0,R0,#+186
   \   00000046   0xD01D             BEQ.N    ??UartProcess_6
   \   00000048   0x1F00             SUBS     R0,R0,#+4
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD914             BLS.N    ??UartProcess_7
   \   0000004E   0x1EC0             SUBS     R0,R0,#+3
   \   00000050   0xD018             BEQ.N    ??UartProcess_6
   \   00000052   0xE028             B.N      ??UartProcess_8
   1563                case CARDMACHINE_RECORD_INIT_CMD:
   1564                  CardBoxRecordInitResponse(pcommData,ucSelected);
   \                     ??UartProcess_5: (+1)
   \   00000054   0x0039             MOVS     R1,R7
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x0030             MOVS     R0,R6
   \   0000005A   0x.... 0x....      BL       CardBoxRecordInitResponse
   1565                  return;
   \   0000005E   0xE022             B.N      ??UartProcess_9
   1566                        
   1567                case CARDMACHINE_READ_MACHINE_ID_CMD:
   1568                case CARDMACHINE_WRITE_MACHINE_ID_CMD:
   1569                  CardBoxMachineIdResponse(pcommData,ucSelected);
   \                     ??UartProcess_2: (+1)
   \   00000060   0x0039             MOVS     R1,R7
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       CardBoxMachineIdResponse
   1570                  return;
   \   0000006A   0xE01C             B.N      ??UartProcess_9
   1571                
   1572                case CARDMACHINE_READ_BASIC_INFO_CMD:
   1573                  CardBoxBasicInfoResponse(pcommData,ucSelected);
   \                     ??UartProcess_3: (+1)
   \   0000006C   0x0039             MOVS     R1,R7
   \   0000006E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000070   0x0030             MOVS     R0,R6
   \   00000072   0x.... 0x....      BL       CardBoxBasicInfoResponse
   1574                  return;
   \   00000076   0xE016             B.N      ??UartProcess_9
   1575                        
   1576                case UART_COUNT_ADD_CMD:
   1577                case UART_COUNT_SUB_CMD:
   1578                  CardBoxCountAddSubResponse(pcommData,ucSelected);
   \                     ??UartProcess_7: (+1)
   \   00000078   0x0039             MOVS     R1,R7
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0x.... 0x....      BL       CardBoxCountAddSubResponse
   1579                  return;
   \   00000082   0xE010             B.N      ??UartProcess_9
   1580                
   1581                case UART_COUNT_SET_WRITE:
   1582                case UART_COUNT_READ_CMD:
   1583                  CardBoxCountResponse(pcommData,ucSelected);
   \                     ??UartProcess_6: (+1)
   \   00000084   0x0039             MOVS     R1,R7
   \   00000086   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000088   0x0030             MOVS     R0,R6
   \   0000008A   0x.... 0x....      BL       CardBoxCountResponse
   1584                  return;
   \   0000008E   0xE00A             B.N      ??UartProcess_9
   1585                
   1586                        
   1587                case CARDMACHINE_READ_COUNT_MAX_CMD:
   1588                case CARDMACHINE_WRITE_COUNT_MAX_CMD:
   1589                  CardBoxMaxCountResponse(pcommData,ucSelected);
   \                     ??UartProcess_4: (+1)
   \   00000090   0x0039             MOVS     R1,R7
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x.... 0x....      BL       CardBoxMaxCountResponse
   1590                  return;
   \   0000009A   0xE004             B.N      ??UartProcess_9
   1591                                                                
   1592                case CARDMACHINE_READ_VERSION_CMD:
   1593                  CardBoxVersionResponse(pcommData,ucSelected);
   \                     ??UartProcess_1: (+1)
   \   0000009C   0x0039             MOVS     R1,R7
   \   0000009E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       CardBoxVersionResponse
   1594                
   1595                default:
   1596                  break;					
   1597              }
   1598            }
   1599          }
   \                     ??UartProcess_8: (+1)
   \                     ??UartProcess_0: (+1)
   \                     ??UartProcess_9: (+1)
   \   000000A6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1600          
   1601          /**********************************************************************************************************
   1602          *                                           UltraSoundSend()
   1603          *
   1604          * Description : Read a string from the serial terminal. 
   1605          *
   1606          * Argument(s) : p_str       Pointer to string.
   1607          *
   1608          *               len         String length.
   1609          *
   1610          * Return(s)   : The number of octets written.
   1611          *
   1612          * Caller(s)   : Application.
   1613          *
   1614          * Note(s)     : none.
   1615          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1616          void UltraSoundSend(INT8U ucStatus)
   1617          {
   \                     UltraSoundSend: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1618            INT32U ulKeyOutputNew;
   1619            INT32U ulTmp;
   1620            
   1621            ulKeyOutputNew=g_usrGetKey.ulKeyOutput;
   \   00000004   0x....             LDR.N    R0,??DataTable13_10
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0x0005             MOVS     R5,R0
   1622            ulTmp=KeyConvert(ulKeyOutputNew);
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x.... 0x....      BL       KeyConvert
   \   00000010   0x9002             STR      R0,[SP, #+8]
   1623            if(ucStatus){
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD004             BEQ.N    ??UltraSoundSend_0
   1624              ulTmp&=(~(1<<6));
   \   00000018   0x9802             LDR      R0,[SP, #+8]
   \   0000001A   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000001E   0x9002             STR      R0,[SP, #+8]
   \   00000020   0xE003             B.N      ??UltraSoundSend_1
   1625            }else{
   1626              ulTmp|=(1<<6);
   \                     ??UltraSoundSend_0: (+1)
   \   00000022   0x9802             LDR      R0,[SP, #+8]
   \   00000024   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000028   0x9002             STR      R0,[SP, #+8]
   1627            }
   1628            Uart0Pack(INFTYPE_DEVICE_STATUS,0,0,(INT8U *)&ulTmp,4,1);
   \                     ??UltraSoundSend_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x2004             MOVS     R0,#+4
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0xAB02             ADD      R3,SP,#+8
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2067             MOVS     R0,#+103
   \   0000003A   0x.... 0x....      BL       Uart0Pack
   1629          }
   \   0000003E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     m_UartBufPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     SerialDev_LPCxxxx_UART0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     SerialDev_LPCxxxx_UART1_Alt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     SerialDev_LPCxxxx_UART2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     SerialDev_LPCxxxx_UART3_Alt1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     Uart_SerTraceIF_Nbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     m_ucMachineAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     `Uart0Pack::ucTxSeq`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     m_ucMachineAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     m_ucUartBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     m_ucBoxToUart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     App_TaskUartProcessTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     Uart_SerTraceIF_Nbr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     g_pActionSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     App_TaskActionTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x........         DC32     g_usrGlobalFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x........         DC32     g_usrScan

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x........         DC32     g_ucScanCloseTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x........         DC32     m_ucUartToBox

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     g_usrGetKey

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x55 0x41          DC8 "UART0"
   \              0x52 0x54    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x55 0x41          DC8 "UART1"
   \              0x52 0x54    
   \              0x31 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x55 0x41          DC8 "UART2"
   \              0x52 0x54    
   \              0x32 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x55 0x41          DC8 "UART3"
   \              0x52 0x54    
   \              0x33 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
   1630          
   1631          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   App_SerialInit
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> DEV_TYPE
        40   -> Mem_PoolCreate
        40   -> Serial_DevDrvAdd
        40   -> Serial_Init
      56   Uart0Pack
        56   -> Mem_PoolBlkGet
        56   -> Serial_WrAsync
      40   Uart0Process
        40   -> AutoOutModeRead
        40   -> AutoOutModeWrite
        40   -> BSP_OS_SemWait
        40   -> BoxSelectRead
        40   -> BoxSelectWrite
        40   -> Box_TaskQPost
        40   -> BuzzEnRead
        40   -> BuzzEnWrite
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> CSP_GPIO_BitSet
        40   -> CardBoxCountAddSub
        40   -> CardBoxCountRead
        40   -> CardBoxCountWrite
        40   -> CardBoxIdRead
        40   -> CardBoxIdWrite
        40   -> CardBoxMaxCountRead
        40   -> CardBoxMaxCountWrite
        40   -> CardBoxMotoMove
        40   -> CardBoxRecordInit
        40   -> CardBoxSetSelected
        40   -> CardBoxVersionRead
        40   -> CardMachineAddrRead
        40   -> CardMachineAddrWrite
        40   -> CardMachineAlarmMaxRead
        40   -> CardMachineAlarmMaxWrite
        40   -> CardMachineAlarmMinRead
        40   -> CardMachineAlarmMinWrite
        40   -> CardMachineDataRead
        40   -> CardMachineDataWrite
        40   -> CardMachineIdRead
        40   -> CardMachineIdWrite
        40   -> CardMachineStateRead
        40   -> CardMachineTypeRead
        40   -> CardMachineVersionRead
        40   -> CardToBox
        40   -> CardToOut
        40   -> DEV_TYPE
        40   -> DMotoMove
        40   -> DMotoReadParams
        40   -> DMotoSelectRead
        40   -> DMotoSelectWrite
        40   -> DMotoWriteParams
        40   -> GroupSelectRead
        40   -> GroupSelectWrite
        40   -> KeySelectRead
        40   -> KeySelectWrite
        40   -> KeyTest
        40   -> SMotoMove
        40   -> SMotoReadParams
        40   -> SMotoSelectRead
        40   -> SMotoSelectWrite
        40   -> SMotoWriteParams
        40   -> ScanParamsRead
        40   -> ScanParamsWrite
        40   -> Uart0Pack
        40   -> UltraSoundRead
        40   -> UltraSoundWrite
      24   Uart0Receive
        24   -> Serial_Open
        24   -> Uart0UnPack
      56   Uart0UnPack
        56   -> Mem_PoolBlkFree
        56   -> Mem_PoolBlkGet
        56   -> OSTaskQPost
        56   -> Uart0Pack
        56   -> Uart_SerStrRd
      56   Uart1UnPack
        56   -> Mem_PoolBlkFree
        56   -> Mem_PoolBlkGet
        56   -> OSTaskQPost
        56   -> RevCrc16Bytes
        56   -> Uart0Pack
        56   -> Uart_SerStrRd
      64   Uart3UnPack
        64   -> EepromReadVerifyBytes
        64   -> Uart0Pack
        64   -> Uart_SerStrRd
        64   -> UltraSoundSend
      48   UartPack
        48   -> Mem_Copy
        48   -> Mem_PoolBlkGet
        48   -> RevCrc16Bytes
        48   -> Serial_WrAsync
      24   UartProcess
        24   -> CardBoxBasicInfoResponse
        24   -> CardBoxCountAddSubResponse
        24   -> CardBoxCountResponse
        24   -> CardBoxMachineIdResponse
        24   -> CardBoxMaxCountResponse
        24   -> CardBoxRecordInitResponse
        24   -> CardBoxVersionResponse
      48   UartReceive
        48   -> Serial_Open
        48   -> Uart1UnPack
        48   -> Uart3UnPack
        48   -> __aeabi_memcpy4
      24   UartTxFinish
        24   -> Mem_PoolBlkFree
      56   UartUnPack
        56   -> Mem_PoolBlkFree
        56   -> Mem_PoolBlkGet
        56   -> OSTaskQPost
        56   -> RevCrc16Bytes
        56   -> Uart0Pack
        56   -> Uart_SerStrRd
      24   Uart_Process
        24   -> Mem_PoolBlkFree
        24   -> OSTaskQPend
        24   -> Uart0Process
        24   -> UartProcess
      16   Uart_Receive
        16   -> Uart0Receive
        16   -> UartReceive
      32   Uart_SerStrRd
        32   -> Serial_Rd
      32   Uart_SerStrWr
        32   -> Serial_WrAsync
      24   UltraSoundSend
        24   -> KeyConvert
        24   -> Uart0Pack


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
      24  ?_4
     240  App_SerialInit
     512  App_TaskActionStk
     200  App_TaskActionTCB
     512  App_TaskBoxStk
     200  App_TaskBoxTCB
     512  App_TaskBuzzStk
     200  App_TaskBuzzTCB
     512  App_TaskLcdStk
     200  App_TaskLcdTCB
     512  App_TaskUart0ReceiveStk
     200  App_TaskUart0ReceiveTCB
     512  App_TaskUart1ReceiveStk
     200  App_TaskUart1ReceiveTCB
     512  App_TaskUart2ReceiveStk
     200  App_TaskUart2ReceiveTCB
     512  App_TaskUart3ReceiveStk
     200  App_TaskUart3ReceiveTCB
     512  App_TaskUartProcessStk
     200  App_TaskUartProcessTCB
     256  Uart0Pack
    1216  Uart0Process
      72  Uart0Receive
     494  Uart0UnPack
     382  Uart1UnPack
     452  Uart3UnPack
     182  UartPack
     168  UartProcess
     152  UartReceive
      24  UartTxFinish
     388  UartUnPack
      74  Uart_Process
      44  Uart_Receive
      40  Uart_SerStrRd
      34  Uart_SerStrWr
       4  Uart_SerTraceIF_Nbr
      64  UltraSoundSend
      72  m_UartBufPool
       4  m_ucBoxToUart
       4  m_ucUartToBox
       1  ucTxSeq

 
 6 484 bytes in section .bss
     9 bytes in section .data
    56 bytes in section .rodata
 4 382 bytes in section .text
 
 4 382 bytes of CODE  memory
    56 bytes of CONST memory
 6 493 bytes of DATA  memory

Errors: none
Warnings: none
