###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:02
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\BSP\bsp.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\BSP\bsp.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\bsp.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\bsp.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\BSP\bsp.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                          (c) Copyright 2004-2012; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/OS-III is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/OS-III in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/OS-III.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          
     25          /*
     26          *********************************************************************************************************
     27          *
     28          *                                       BOARD SUPPORT PACKAGE (BSP)
     29          *
     30          *                                        IAR Development Kits
     31          *                                               on the
     32          *
     33          *                                            NXP LPC1768
     34          *                                      LPC1766-SK KICKSTART KIT
     35          *
     36          * Filename      :bsp.c
     37          * Version       :V1.00
     38          * Programmer(s) :FT
     39          *                DC
     40          *********************************************************************************************************
     41          */
     42          
     43          
     44          /*
     45          *********************************************************************************************************
     46          *                                             INCLUDE FILES
     47          *********************************************************************************************************
     48          */
     49          
     50          #define  BSP_MODULE
     51          #include <bsp.h>
     52          #include <csp.h>
     53          #include <os_cpu.h>
     54          
     55          /*
     56          *********************************************************************************************************
     57          *                                             REGISTER & BIT DEFINES
     58          *********************************************************************************************************
     59          */
     60          
     61                                                                          /* - SYSTEM CONTROL AND STATUS REGISTER & BIT DEFINES  -*/
     62          #define  BSP_REG_SCS                             (*(CPU_REG32 *)(0x400FC1A0))
     63          #define  BSP_BIT_SCS_OSCRANGE                    DEF_BIT_04
     64          #define  BSP_BIT_SCS_OSCEN                       DEF_BIT_05
     65          #define  BSP_BIT_SCS_OSCSTAT                     DEF_BIT_06
     66          
     67                                                                          /* ------- CLOCK DIVIDERS REGISTER & BIT DEFINES ------ */
     68          #define  BSP_REG_CCLKCFG                         (*(CPU_REG32 *)(0x400FC104))
     69          #define  BSP_REG_CLKSRCSEL                       (*(CPU_REG32 *)(0x400FC10C))
     70          #define  BSP_REG_PCLKSEL0                        (*(CPU_REG32 *)(0x400FC1A8))
     71          #define  BSP_REG_PCLKSEL1                        (*(CPU_REG32 *)(0x400FC1AC))
     72          
     73                                                                          /* ------------ PLL REGISTER & BIT DEFINES ------------ */
     74          #define  BSP_ADDR_PLL                            (CPU_INT32U )0x400FC080u
     75          
     76          #define  BSP_REG_PLLCTRL(pll_id)                 (*(CPU_REG32 *)(BSP_ADDR_PLL + (0x20u * (pll_id)) + 0x00u))
     77          #define  BSP_REG_PLLCFG(pll_id)                  (*(CPU_REG32 *)(BSP_ADDR_PLL + (0x20u * (pll_id)) + 0x04u))
     78          #define  BSP_REG_PLLSTAT(pll_id)                 (*(CPU_REG32 *)(BSP_ADDR_PLL + (0x20u * (pll_id)) + 0x08u))
     79          #define  BSP_REG_PLLFEED(pll_id)                 (*(CPU_REG32 *)(BSP_ADDR_PLL + (0x20u * (pll_id)) + 0x0Cu))
     80          
     81          #define  BSP_MSK_PLLCFG0_MSEL                    0x00007FFFu
     82          #define  BSP_MSK_PLLCFG0_NSEL                    0x00FF0000u
     83          
     84          #define  BSP_MSK_PLLCFG1_MSEL                    0x0000001Fu
     85          #define  BSP_MSK_PLLCFG1_NSEL                    0x00000060u
     86          
     87          #define  BSP_BIT_PLLCTRL_PLLE                    DEF_BIT_00     /* PLL enable                                           */
     88          #define  BSP_BIT_PLLCTRL_PLLC                    DEF_BIT_01     /* PLL connect                                          */
     89          
     90          #define  BSP_BIT_PLLSTAT_PLLE0_STAT              DEF_BIT_24     /* Read-back for the PLL enable bit                     */
     91          #define  BSP_BIT_PLLSTAT_PLLC0_STAT              DEF_BIT_25     /* Read-back for the PLL connect bit                    */
     92          #define  BSP_BIT_PLLSTAT_PLOCK0                  DEF_BIT_26     /* Refkect the PLL lock status                          */
     93          
     94          #define  BSP_BIT_PLLSTAT_PLLE1_STAT              DEF_BIT_08     /* Read-back for the PLL enable bit                     */
     95          #define  BSP_BIT_PLLSTAT_PLLC1_STAT              DEF_BIT_09     /* Read-back for the PLL connect bit                    */
     96          #define  BSP_BIT_PLLSTAT_PLOCK1                  DEF_BIT_10     /* Refkect the PLL lock status                          */
     97          
     98          #define  BSP_BIT_PLLFEED_VAL0                    0x000000AAu
     99          #define  BSP_BIT_PLLFEED_VAL1                    0x00000055u
    100          
    101          #define  BSP_BIT_CLKSRCSEL_RC                    DEF_BIT_NONE
    102          #define  BSP_BIT_CLKSRCSEL_MAIN                  DEF_BIT_00
    103          #define  BSP_BIT_CLKSRCSEL_RTC                   DEF_BIT_01
    104          
    105                                                                          /* --- FLASH ACCELERATOR CFG REGISTER & BIT DEFINES --- */
    106          #define  BSP_REG_FLASHCFG                        (*(CPU_REG32 *)(0x400FC000u))
    107          
    108          #define  BSP_MSK_FLASHCFG_CLK_1                  DEF_BIT_MASK(1u, 12u)
    109          #define  BSP_MSK_FLASHCFG_CLK_2                  DEF_BIT_MASK(2u, 12u)
    110          #define  BSP_MSK_FLASHCFG_CLK_3                  DEF_BIT_MASK(3u, 12u)
    111          #define  BSP_MSK_FLASHCFG_CLK_4                  DEF_BIT_MASK(4u, 12u)
    112          #define  BSP_MSK_FLASHCFG_CLK_5                  DEF_BIT_MASK(5u, 12u)
    113          #define  BSP_MSK_FLASHCFG_CLK_6                  DEF_BIT_MASK(6u, 12u)
    114          #define  BSP_MSK_FLASHCFG_RST_VAL                0x0000003Au
    115          
    116          /*
    117          *********************************************************************************************************
    118          *                                             GPIO DEFINES
    119          *********************************************************************************************************
    120          */
    121                                                                         /* ----------------- GPIO PIN DEFINITION ------------- */
    122          #define  BSP_GPIO0_BUT1                          DEF_BIT_23    /* P0.23 Push Button 1                                 */
    123          #define  BSP_GPIO0_JOY_CENTER                    DEF_BIT_05    /* P0.5  Joystick Center  switch contact               */
    124          
    125          #define  BSP_GPIO2_JOY_UP                        DEF_BIT_00    /* P2.0  Joystick Up      switch contact               */
    126          #define  BSP_GPIO2_JOY_DOWN                      DEF_BIT_01    /* P2.1  Joystick Down    switch contact               */
    127          #define  BSP_GPIO2_JOY_LEFT                      DEF_BIT_07    /* P2.7  Joystick Left    switch contact               */
    128          #define  BSP_GPIO2_JOY_RIGHT                     DEF_BIT_08    /* P2.8  Joystick Right   switch contact               */
    129          
    130          #define  BSP_GPIO2_BUT2                          DEF_BIT_13    /* P2.13 Push Button 2                                 */
    131          
    132          #define  BSP_REG_DEMCR             (*(CPU_REG32 *)0xE000EDFC)
    133          #define  BSP_REG_DWT_CR            (*(CPU_REG32 *)0xE0001000)
    134          #define  BSP_REG_DWT_CYCCNT        (*(CPU_REG32 *)0xE0001004)
    135          
    136          //LED
    137          #define  BSP_GPIO_LED1_PORT                     CSP_GPIO_PORT_NBR_01    
    138          #define  BSP_GPIO_LED2_PORT                     CSP_GPIO_PORT_NBR_01
    139          #define  BSP_GPIO_LEDOUT_PORT                   CSP_GPIO_PORT_NBR_01
    140          
    141          #define  BSP_GPIO_LED1                          DEF_BIT_30    /* P1.30 LED1                                          */
    142          #define  BSP_GPIO_LED2                          DEF_BIT_00    /* P1.0 LED2                                          */
    143          #define  BSP_GPIO_LEDOUT                        DEF_BIT_31    /* P1.31 LED2                                          */
    144          
    145          
    146          //Switch
    147          #define  BSP_GPIO_SWITCH_PORT                   CSP_GPIO_PORT_NBR_00                                                 
    148          #define  BSP_GPIO_SWITCH_OUT                    DEF_BIT_30    //P0.30
    149          #define  BSP_GPIO_SWITCH1_OUT                   DEF_BIT_29    //P0.29
    150          
    151          /*
    152          
    153          *********************************************************************************************************
    154          *                                             BSP CONSTANS VALUES
    155          *********************************************************************************************************
    156          */
    157                                                                         /* Maximum register timeout                            */
    158          #define  BSP_VAL_MAX_TO                         (CPU_INT16U)(0xFFFF)
    159          
    160          
    161          
    162          
    163          /*
    164          *********************************************************************************************************
    165          *                                           LOCAL CONSTANTS
    166          *********************************************************************************************************
    167          */
    168          
    169          
    170          /*
    171          *********************************************************************************************************
    172          *                                          LOCAL DATA TYPES
    173          *********************************************************************************************************
    174          */
    175          
    176          
    177          /*
    178          *********************************************************************************************************
    179          *                                            LOCAL TABLES
    180          *********************************************************************************************************
    181          */
    182          
    183          
    184          /*
    185          *********************************************************************************************************
    186          *                                       LOCAL GLOBAL VARIABLES
    187          *********************************************************************************************************
    188          */
    189          
    190          
    191          /*
    192          *********************************************************************************************************
    193          *                                               MACRO'S
    194          *********************************************************************************************************
    195          */
    196          
    197          #define  BSP_PLL_FEED_SEQ(pll_nbr)              {    CPU_CRITICAL_ENTER();                             \
    198                                                                                                                 \
    199                                                               BSP_REG_PLLFEED(pll_nbr) = BSP_BIT_PLLFEED_VAL0;  \
    200                                                               BSP_REG_PLLFEED(pll_nbr) = BSP_BIT_PLLFEED_VAL1;  \
    201                                                                                                                 \
    202                                                               CPU_CRITICAL_EXIT();                              \
    203                                                          }
    204          
    205          
    206          /*
    207          *********************************************************************************************************
    208          *                                      LOCAL FUNCTION PROTOTYPES
    209          *********************************************************************************************************
    210          */
    211          
    212          
    213          
    214          /*
    215          *********************************************************************************************************
    216          *                                     LOCAL CONFIGURATION ERRORS
    217          *********************************************************************************************************
    218          */
    219          
    220          
    221          /*
    222          *********************************************************************************************************
    223          *********************************************************************************************************
    224          **                                         GLOBAL FUNCTIONS
    225          *********************************************************************************************************
    226          *********************************************************************************************************
    227          */
    228          
    229          
    230          /*
    231          *********************************************************************************************************
    232          *                                             BSP_Init()
    233          *
    234          * Description : Initialize the Board Support Package (BSP).
    235          *
    236          * Argument(s) : none.
    237          *
    238          * Return(s)   : none.
    239          *
    240          * Caller(s)   : Application.
    241          *
    242          * Note(s)     : (1) The PLL0 Frequency is determined by:
    243          *
    244          *                       Fcco = (2 x M x Fin) / N
    245          *
    246          *                       where M   = PLL0 Multipler
    247          *                             N   = PLL0 Pre-dividier
    248          *                            Fin  = PLL0 Input Frequency (Main oscillator).
    249          *
    250          *               (2) PLL0 settings must meet the following:
    251          *                       Fin is in the range of 32Khz to 50 Mhz.
    252          *                       Fcco is in the range of 275 Mhz to 550 Mhz
    253          *
    254          *               (3) The LPC17xx CPU frequency is determined by:
    255          *
    256          *                       CPU_freq = Fcc0 / CPU_Div
    257          *
    258          *               (4) The USB clock frequency is determined by:
    259          *
    260          *                       USB_Clk = M x Fosc x P, or USB_clk = Fcco / (2 x P)
    261          *
    262          *                       Fcco    =  Fosc x 2 x M x 2 x P
    263          *
    264          *                       where Fcco = PLL1 output frequency.
    265          *                             M    = PLL1 multiplier.
    266          *                             P    = PLL1 pre-divider.
    267          *                             Fosc = Oscialltor  frequency.
    268          *
    269          *               (5) The PLL1 inputs and settings must meet the following criteria:
    270          *                   Fosc    is in the range of 10 Mhz to 25 Mhz.
    271          *                   USBClk  is 48 Mhz
    272          *                   Fcco    is in the range of 156 Mhz to 320 Mhz
    273          *
    274          *               (6) In this example the LPC1768 operates:
    275          *
    276          *                       PLL0_Fcco = 2 x 25 x 12 / 2
    277          *                       PLL0_Fcco = 300mhz
    278          *
    279          *                       CPU_freq  =  300 Mhz  / 3
    280          *                                 =  100 Mhz
    281          *
    282          *                       PLL1_Fcc0 = 12 x 4 x 2 x 2 = 192 Mhz.
    283          *                       USB_Clk   = 12 x 4         =  48 Mhz.
    284          *********************************************************************************************************
    285          */
    286          

   \                                 In section .text, align 2, keep-with-next
    287          void  BSP_Init (void)
    288          {
   \                     BSP_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    289              CPU_INT16U    reg_to;
    290              CPU_INT32U    reg_val;
    291              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    292              
    293                                                                          /* ---------------- CLOCK INITIALIZATION -------------- */
    294              BSP_REG_FLASHCFG = BSP_MSK_FLASHCFG_CLK_6                   /* Set 6 cycles to acces the Flash memory.              */
    295                               | BSP_MSK_FLASHCFG_RST_VAL;
   \   00000006   0xF246 0x003A      MOVW     R0,#+24634
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable4  ;; 0x400fc000
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    296                                                                          /* ----------- MAIN OSCILLATOR INITIALIZATION --------- */
    297              DEF_BIT_CLR(BSP_REG_SCS, BSP_BIT_SCS_OSCRANGE);             /* Set the main oscillator range                        */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x400fc1a0
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF030 0x0010      BICS     R0,R0,#0x10
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable4_1  ;; 0x400fc1a0
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    298          
    299          
    300              reg_to = BSP_VAL_MAX_TO;
   \   00000020   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000024   0x0004             MOVS     R4,R0
    301          
    302              DEF_BIT_SET(BSP_REG_SCS, BSP_BIT_SCS_OSCEN);                /* Enable the Main Oscillator                           */
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x400fc1a0
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable4_1  ;; 0x400fc1a0
   \   00000034   0x6008             STR      R0,[R1, #+0]
    303          
    304                                                                          /* Wait until the main oscillator is enabled.           */
    305              while (DEF_BIT_IS_CLR(BSP_REG_SCS, BSP_BIT_SCS_OSCSTAT) &&
    306                    (reg_to > 0u)) {
   \                     ??BSP_Init_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable4_1  ;; 0x400fc1a0
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x0980             LSRS     R0,R0,#+6
   \   0000003E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000042   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD004             BEQ.N    ??BSP_Init_1
   \   0000004C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xD001             BEQ.N    ??BSP_Init_1
    307                  reg_to--;
   \   00000052   0x1E64             SUBS     R4,R4,#+1
   \   00000054   0xE7EF             B.N      ??BSP_Init_0
    308              }
    309          
    310              if (reg_to == 0u) {                                         /* Configuration fail                                   */
   \                     ??BSP_Init_1: (+1)
   \   00000056   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000058   0x2C00             CMP      R4,#+0
   \   0000005A   0xF000 0x8198      BEQ.W    ??BSP_Init_2
    311                  return;
    312              }
    313          
    314              BSP_REG_PCLKSEL0 = DEF_BIT_NONE;                            /* All peripheral clock runrs at CPU_Clk / 4 = 25 Mhz   */
   \                     ??BSP_Init_3: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable4_2  ;; 0x400fc1a8
   \   00000064   0x6008             STR      R0,[R1, #+0]
    315              BSP_REG_PCLKSEL1 = DEF_BIT_NONE;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable4_3  ;; 0x400fc1ac
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    316          
    317                                                                          /* ------------------ PLL0 CONFIGURATION -------------- */
    318          
    319              reg_val  = (((25u - 1u) <<  0u) & BSP_MSK_PLLCFG0_MSEL)     /* PLL0 values M = 25 & N = 2 (see note #6)             */
    320                       | ((( 2u - 1u) << 16u) & BSP_MSK_PLLCFG0_NSEL);
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable4_4  ;; 0x10018
   \   00000072   0x0005             MOVS     R5,R0
    321                                                                          /* 1. Disconnect PLL0 with one feed sequence if PLL ... */
    322                                                                          /* ... already connected.                               */
    323              if (DEF_BIT_IS_SET(BSP_REG_PLLSTAT(0u), BSP_BIT_PLLSTAT_PLLC0_STAT)) {
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable4_5  ;; 0x400fc088
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0E40             LSRS     R0,R0,#+25
   \   0000007C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD019             BEQ.N    ??BSP_Init_4
    324                  DEF_BIT_CLR(BSP_REG_PLLCTRL(0u), BSP_BIT_PLLCTRL_PLLC);
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable4_6  ;; 0x400fc080
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF030 0x0002      BICS     R0,R0,#0x2
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x400fc080
   \   00000092   0x6008             STR      R0,[R1, #+0]
    325                  BSP_PLL_FEED_SEQ(0u);
   \   00000094   0x.... 0x....      BL       CPU_SR_Save
   \   00000098   0x0006             MOVS     R6,R0
   \   0000009A   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000009E   0x20AA             MOVS     R0,#+170
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000000A4   0x6008             STR      R0,[R1, #+0]
   \   000000A6   0x2055             MOVS     R0,#+85
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000000AC   0x6008             STR      R0,[R1, #+0]
   \   000000AE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B2   0x0030             MOVS     R0,R6
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
    326              }
    327          
    328              DEF_BIT_CLR(BSP_REG_PLLCTRL(0u), BSP_BIT_PLLCTRL_PLLE);     /* 2. Disable PLL0 with one feed sequence               */
   \                     ??BSP_Init_4: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable4_6  ;; 0x400fc080
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x0840             LSRS     R0,R0,#+1
   \   000000C0   0x0040             LSLS     R0,R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x400fc080
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    329              BSP_PLL_FEED_SEQ(0u);
   \   000000C8   0x.... 0x....      BL       CPU_SR_Save
   \   000000CC   0x0006             MOVS     R6,R0
   \   000000CE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000D2   0x20AA             MOVS     R0,#+170
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0x2055             MOVS     R0,#+85
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000000E0   0x6008             STR      R0,[R1, #+0]
   \   000000E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x.... 0x....      BL       CPU_SR_Restore
    330          
    331              BSP_REG_CCLKCFG   = (1u - 1u);                              /* 3. Change the CPU clock divider setting to speed ... */
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable4_8  ;; 0x400fc104
   \   000000F2   0x6008             STR      R0,[R1, #+0]
    332                                                                          /* ... operation without PLL0                           */
    333          
    334              BSP_REG_CLKSRCSEL = BSP_BIT_CLKSRCSEL_MAIN;                 /* 4. Select the main osc. as the PLL0 clock source     */
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable4_9  ;; 0x400fc10c
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    335          
    336              BSP_REG_PLLCFG(0u) = reg_val;                               /* 5. Write to the PLLCFG and make it effective with... */
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable4_10  ;; 0x400fc084
   \   00000100   0x6005             STR      R5,[R0, #+0]
    337              BSP_PLL_FEED_SEQ(0u)                                        /* ... one one feed sequence                            */
   \   00000102   0x.... 0x....      BL       CPU_SR_Save
   \   00000106   0x0006             MOVS     R6,R0
   \   00000108   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   0000010C   0x20AA             MOVS     R0,#+170
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   00000112   0x6008             STR      R0,[R1, #+0]
   \   00000114   0x2055             MOVS     R0,#+85
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   0000011A   0x6008             STR      R0,[R1, #+0]
   \   0000011C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0x.... 0x....      BL       CPU_SR_Restore
    338          
    339              DEF_BIT_SET(BSP_REG_PLLCTRL(0u), BSP_BIT_PLLCTRL_PLLE);     /* 6. Enable PLL0 with one feed sequence                */
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable4_6  ;; 0x400fc080
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x400fc080
   \   00000134   0x6008             STR      R0,[R1, #+0]
    340              BSP_PLL_FEED_SEQ(0u);
   \   00000136   0x.... 0x....      BL       CPU_SR_Save
   \   0000013A   0x0006             MOVS     R6,R0
   \   0000013C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000140   0x20AA             MOVS     R0,#+170
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   00000146   0x6008             STR      R0,[R1, #+0]
   \   00000148   0x2055             MOVS     R0,#+85
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   0000014E   0x6008             STR      R0,[R1, #+0]
   \   00000150   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000154   0x0030             MOVS     R0,R6
   \   00000156   0x.... 0x....      BL       CPU_SR_Restore
    341          
    342              BSP_REG_CCLKCFG   = (3u - 1u);                              /* 7. Change the CPU clock divider setting for ...      */
   \   0000015A   0x2002             MOVS     R0,#+2
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable4_8  ;; 0x400fc104
   \   00000160   0x6008             STR      R0,[R1, #+0]
    343                                                                          /* ... operation with PLL0                              */
    344          
    345              reg_to = BSP_VAL_MAX_TO;                                    /* 8. Wait for PLL0 to achieve lock by monitoring ...   */
   \   00000162   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000166   0x0004             MOVS     R4,R0
    346                                                                          /* ... the PLOCK0 bit in the PLL0STAT                   */
    347              while (DEF_BIT_IS_CLR(BSP_REG_PLLSTAT(0u), BSP_BIT_PLLSTAT_PLOCK0) &&
    348                    (reg_to > 0u)) {
   \                     ??BSP_Init_5: (+1)
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable4_5  ;; 0x400fc088
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x0E80             LSRS     R0,R0,#+26
   \   00000170   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000174   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000178   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017A   0x2800             CMP      R0,#+0
   \   0000017C   0xD004             BEQ.N    ??BSP_Init_6
   \   0000017E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000180   0x2C00             CMP      R4,#+0
   \   00000182   0xD001             BEQ.N    ??BSP_Init_6
    349                  reg_to--;
   \   00000184   0x1E64             SUBS     R4,R4,#+1
   \   00000186   0xE7EF             B.N      ??BSP_Init_5
    350              }
    351          
    352              if (reg_to == 0u) {
   \                     ??BSP_Init_6: (+1)
   \   00000188   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000018A   0x2C00             CMP      R4,#+0
   \   0000018C   0xF000 0x80FF      BEQ.W    ??BSP_Init_2
    353                  return;
    354              }
    355          
    356              DEF_BIT_SET(BSP_REG_PLLCTRL(0u), BSP_BIT_PLLCTRL_PLLC);     /* 9. Connect PLL0 with one feed sequence               */
   \                     ??BSP_Init_7: (+1)
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable4_6  ;; 0x400fc080
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \   00000196   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable4_6  ;; 0x400fc080
   \   0000019E   0x6008             STR      R0,[R1, #+0]
    357              BSP_PLL_FEED_SEQ(0u);
   \   000001A0   0x.... 0x....      BL       CPU_SR_Save
   \   000001A4   0x0006             MOVS     R6,R0
   \   000001A6   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001AA   0x20AA             MOVS     R0,#+170
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000001B0   0x6008             STR      R0,[R1, #+0]
   \   000001B2   0x2055             MOVS     R0,#+85
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable4_7  ;; 0x400fc08c
   \   000001B8   0x6008             STR      R0,[R1, #+0]
   \   000001BA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001BE   0x0030             MOVS     R0,R6
   \   000001C0   0x.... 0x....      BL       CPU_SR_Restore
    358                                                                          /* ------------------ PLL1 CONFIGURATION -------------- */
    359              reg_val  = (((4u - 1u)  <<  0u) & BSP_MSK_PLLCFG1_MSEL)     /* PLL1 values M = 4; P = 2 coded as '01' (see note #6) */
    360                       | (((0x01u   ) <<  5u) & BSP_MSK_PLLCFG1_NSEL);
   \   000001C4   0x2023             MOVS     R0,#+35
   \   000001C6   0x0005             MOVS     R5,R0
    361          
    362              DEF_BIT_CLR(BSP_REG_PLLCTRL(1u), BSP_BIT_PLLCTRL_PLLC);     /* 1. Disconnect PLL1 with one feed sequence            */
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable4_11  ;; 0x400fc0a0
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000001D2   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x400fc0a0
   \   000001D6   0x6008             STR      R0,[R1, #+0]
    363              BSP_PLL_FEED_SEQ(1u);
   \   000001D8   0x.... 0x....      BL       CPU_SR_Save
   \   000001DC   0x0006             MOVS     R6,R0
   \   000001DE   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000001E2   0x20AA             MOVS     R0,#+170
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   000001E8   0x6008             STR      R0,[R1, #+0]
   \   000001EA   0x2055             MOVS     R0,#+85
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   000001F0   0x6008             STR      R0,[R1, #+0]
   \   000001F2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001F6   0x0030             MOVS     R0,R6
   \   000001F8   0x.... 0x....      BL       CPU_SR_Restore
    364          
    365              DEF_BIT_CLR(BSP_REG_PLLCTRL(1u), BSP_BIT_PLLCTRL_PLLE);     /* 2. Disable PLL1 with one feed sequence               */
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable4_11  ;; 0x400fc0a0
   \   00000200   0x6800             LDR      R0,[R0, #+0]
   \   00000202   0x0840             LSRS     R0,R0,#+1
   \   00000204   0x0040             LSLS     R0,R0,#+1
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x400fc0a0
   \   0000020A   0x6008             STR      R0,[R1, #+0]
    366              BSP_PLL_FEED_SEQ(1u);
   \   0000020C   0x.... 0x....      BL       CPU_SR_Save
   \   00000210   0x0006             MOVS     R6,R0
   \   00000212   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000216   0x20AA             MOVS     R0,#+170
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   0000021C   0x6008             STR      R0,[R1, #+0]
   \   0000021E   0x2055             MOVS     R0,#+85
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   00000224   0x6008             STR      R0,[R1, #+0]
   \   00000226   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000022A   0x0030             MOVS     R0,R6
   \   0000022C   0x.... 0x....      BL       CPU_SR_Restore
    367          
    368              BSP_REG_PLLCFG(1u) = reg_val;                               /* 3. Write to the PLLCFG and make it effective with... */
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable4_13  ;; 0x400fc0a4
   \   00000234   0x6005             STR      R5,[R0, #+0]
    369              BSP_PLL_FEED_SEQ(1u);                                       /* ... one one feed sequence                            */
   \   00000236   0x.... 0x....      BL       CPU_SR_Save
   \   0000023A   0x0006             MOVS     R6,R0
   \   0000023C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000240   0x20AA             MOVS     R0,#+170
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   00000246   0x6008             STR      R0,[R1, #+0]
   \   00000248   0x2055             MOVS     R0,#+85
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   0000024E   0x6008             STR      R0,[R1, #+0]
   \   00000250   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000254   0x0030             MOVS     R0,R6
   \   00000256   0x.... 0x....      BL       CPU_SR_Restore
    370          
    371              DEF_BIT_SET(BSP_REG_PLLCTRL(1u), BSP_BIT_PLLCTRL_PLLE);     /* 4. Enable PLL1 with one feed sequence                */
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable4_11  ;; 0x400fc0a0
   \   0000025E   0x6800             LDR      R0,[R0, #+0]
   \   00000260   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000264   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x400fc0a0
   \   00000268   0x6008             STR      R0,[R1, #+0]
    372              BSP_PLL_FEED_SEQ(1u);
   \   0000026A   0x.... 0x....      BL       CPU_SR_Save
   \   0000026E   0x0006             MOVS     R6,R0
   \   00000270   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000274   0x20AA             MOVS     R0,#+170
   \   00000276   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   0000027A   0x6008             STR      R0,[R1, #+0]
   \   0000027C   0x2055             MOVS     R0,#+85
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   00000282   0x6008             STR      R0,[R1, #+0]
   \   00000284   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000288   0x0030             MOVS     R0,R6
   \   0000028A   0x.... 0x....      BL       CPU_SR_Restore
    373          
    374              reg_to = BSP_VAL_MAX_TO;                                    /* 5. Wait for PLL1 to achieve lock by monitoring ...   */
   \   0000028E   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000292   0x0004             MOVS     R4,R0
    375                                                                          /* ... the PLOCK1 bit in the PLL1STAT                   */
    376              while (DEF_BIT_IS_CLR(BSP_REG_PLLSTAT(1u), BSP_BIT_PLLSTAT_PLOCK1) &&
    377                    (reg_to > 0u)) {
   \                     ??BSP_Init_8: (+1)
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable4_14  ;; 0x400fc0a8
   \   00000298   0x6800             LDR      R0,[R0, #+0]
   \   0000029A   0x0A80             LSRS     R0,R0,#+10
   \   0000029C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000002A0   0xF090 0x0001      EORS     R0,R0,#0x1
   \   000002A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD004             BEQ.N    ??BSP_Init_9
   \   000002AA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000002AC   0x2C00             CMP      R4,#+0
   \   000002AE   0xD001             BEQ.N    ??BSP_Init_9
    378                  reg_to--;
   \   000002B0   0x1E64             SUBS     R4,R4,#+1
   \   000002B2   0xE7EF             B.N      ??BSP_Init_8
    379              }
    380          
    381              if (reg_to == 0u) {
   \                     ??BSP_Init_9: (+1)
   \   000002B4   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000002B6   0x2C00             CMP      R4,#+0
   \   000002B8   0xD069             BEQ.N    ??BSP_Init_2
    382                  return;
    383              }
    384          
    385              DEF_BIT_SET(BSP_REG_PLLCTRL(1u), BSP_BIT_PLLCTRL_PLLC);     /* 6. Connect PLL1 with one feed sequence               */
   \                     ??BSP_Init_10: (+1)
   \   000002BA   0x.... 0x....      LDR.W    R0,??DataTable4_11  ;; 0x400fc0a0
   \   000002BE   0x6800             LDR      R0,[R0, #+0]
   \   000002C0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000002C4   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x400fc0a0
   \   000002C8   0x6008             STR      R0,[R1, #+0]
    386              BSP_PLL_FEED_SEQ(1u);
   \   000002CA   0x.... 0x....      BL       CPU_SR_Save
   \   000002CE   0x0006             MOVS     R6,R0
   \   000002D0   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000002D4   0x20AA             MOVS     R0,#+170
   \   000002D6   0x.... 0x....      LDR.W    R1,??DataTable4_12  ;; 0x400fc0ac
   \   000002DA   0x6008             STR      R0,[R1, #+0]
   \   000002DC   0x2055             MOVS     R0,#+85
   \   000002DE   0x....             LDR.N    R1,??DataTable4_12  ;; 0x400fc0ac
   \   000002E0   0x6008             STR      R0,[R1, #+0]
   \   000002E2   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000002E6   0x0030             MOVS     R0,R6
   \   000002E8   0x.... 0x....      BL       CPU_SR_Restore
    387          
    388          
    389              BSP_REG_FLASHCFG = BSP_MSK_FLASHCFG_CLK_5                   /* Set 5 cycles to acces the Flash memory.              */
    390                               | BSP_MSK_FLASHCFG_RST_VAL;
   \   000002EC   0xF245 0x003A      MOVW     R0,#+20538
   \   000002F0   0x....             LDR.N    R1,??DataTable4  ;; 0x400fc000
   \   000002F2   0x6008             STR      R0,[R1, #+0]
    391          
    392              
    393              //Led
    394              CSP_GPIO_Cfg(BSP_GPIO_LEDOUT_PORT,
    395                           BSP_GPIO_LEDOUT,
    396                           CSP_GPIO_DIR_OUT,
    397                           CSP_GPIO_FLAG_MODE_NONE,
    398                           DEF_NO,
    399                           0u,
    400                           CSP_GPIO_FNCT_00);
   \   000002F4   0x2000             MOVS     R0,#+0
   \   000002F6   0x9002             STR      R0,[SP, #+8]
   \   000002F8   0x2000             MOVS     R0,#+0
   \   000002FA   0x9001             STR      R0,[SP, #+4]
   \   000002FC   0x2000             MOVS     R0,#+0
   \   000002FE   0x9000             STR      R0,[SP, #+0]
   \   00000300   0x2301             MOVS     R3,#+1
   \   00000302   0x2201             MOVS     R2,#+1
   \   00000304   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000308   0x2001             MOVS     R0,#+1
   \   0000030A   0x.... 0x....      BL       CSP_GPIO_Cfg
    401          
    402              CSP_GPIO_Cfg(BSP_GPIO_LED2_PORT,
    403                           BSP_GPIO_LED2,
    404                           CSP_GPIO_DIR_OUT,
    405                           CSP_GPIO_FLAG_MODE_NONE,
    406                           DEF_NO,
    407                           0u,
    408                           CSP_GPIO_FNCT_00);
   \   0000030E   0x2000             MOVS     R0,#+0
   \   00000310   0x9002             STR      R0,[SP, #+8]
   \   00000312   0x2000             MOVS     R0,#+0
   \   00000314   0x9001             STR      R0,[SP, #+4]
   \   00000316   0x2000             MOVS     R0,#+0
   \   00000318   0x9000             STR      R0,[SP, #+0]
   \   0000031A   0x2301             MOVS     R3,#+1
   \   0000031C   0x2201             MOVS     R2,#+1
   \   0000031E   0x2101             MOVS     R1,#+1
   \   00000320   0x2001             MOVS     R0,#+1
   \   00000322   0x.... 0x....      BL       CSP_GPIO_Cfg
    409          
    410              CSP_GPIO_Cfg(BSP_GPIO_LED1_PORT,
    411                           BSP_GPIO_LED1,
    412                           CSP_GPIO_DIR_OUT,
    413                           CSP_GPIO_FLAG_MODE_NONE,
    414                           DEF_NO,
    415                           0u,
    416                           CSP_GPIO_FNCT_00);
   \   00000326   0x2000             MOVS     R0,#+0
   \   00000328   0x9002             STR      R0,[SP, #+8]
   \   0000032A   0x2000             MOVS     R0,#+0
   \   0000032C   0x9001             STR      R0,[SP, #+4]
   \   0000032E   0x2000             MOVS     R0,#+0
   \   00000330   0x9000             STR      R0,[SP, #+0]
   \   00000332   0x2301             MOVS     R3,#+1
   \   00000334   0x2201             MOVS     R2,#+1
   \   00000336   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000033A   0x2001             MOVS     R0,#+1
   \   0000033C   0x.... 0x....      BL       CSP_GPIO_Cfg
    417          
    418              //光电开关控制
    419              CSP_GPIO_Cfg(BSP_GPIO_SWITCH_PORT,
    420                           BSP_GPIO_SWITCH_OUT,
    421                           CSP_GPIO_DIR_OUT,
    422                           CSP_GPIO_FLAG_MODE_NONE,
    423                           DEF_NO,
    424                           0u,
    425                           CSP_GPIO_FNCT_00);
   \   00000340   0x2000             MOVS     R0,#+0
   \   00000342   0x9002             STR      R0,[SP, #+8]
   \   00000344   0x2000             MOVS     R0,#+0
   \   00000346   0x9001             STR      R0,[SP, #+4]
   \   00000348   0x2000             MOVS     R0,#+0
   \   0000034A   0x9000             STR      R0,[SP, #+0]
   \   0000034C   0x2301             MOVS     R3,#+1
   \   0000034E   0x2201             MOVS     R2,#+1
   \   00000350   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000354   0x2000             MOVS     R0,#+0
   \   00000356   0x.... 0x....      BL       CSP_GPIO_Cfg
    426              CSP_GPIO_Cfg(BSP_GPIO_SWITCH_PORT,
    427                           BSP_GPIO_SWITCH1_OUT,
    428                           CSP_GPIO_DIR_OUT,
    429                           CSP_GPIO_FLAG_MODE_NONE,
    430                           DEF_NO,
    431                           0u,
    432                           CSP_GPIO_FNCT_00);
   \   0000035A   0x2000             MOVS     R0,#+0
   \   0000035C   0x9002             STR      R0,[SP, #+8]
   \   0000035E   0x2000             MOVS     R0,#+0
   \   00000360   0x9001             STR      R0,[SP, #+4]
   \   00000362   0x2000             MOVS     R0,#+0
   \   00000364   0x9000             STR      R0,[SP, #+0]
   \   00000366   0x2301             MOVS     R3,#+1
   \   00000368   0x2201             MOVS     R2,#+1
   \   0000036A   0xF05F 0x5100      MOVS     R1,#+536870912
   \   0000036E   0x2000             MOVS     R0,#+0
   \   00000370   0x.... 0x....      BL       CSP_GPIO_Cfg
    433          
    434              CSP_GPIO_BitSet(BSP_GPIO_SWITCH_PORT,
    435                              BSP_GPIO_SWITCH_OUT);
   \   00000374   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0x.... 0x....      BL       CSP_GPIO_BitSet
    436            
    437              
    438              BSP_LED_Off(0);
   \   0000037E   0x2000             MOVS     R0,#+0
   \   00000380   0x.... 0x....      BL       BSP_LED_Off
    439              
    440              CSP_IntInit();
   \   00000384   0x.... 0x....      BL       CSP_IntInit
    441              CSP_IntDisAll(CSP_INT_CTRL_NBR_MAIN);
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0x.... 0x....      BL       CSP_IntDisAll
    442          }
   \                     ??BSP_Init_2: (+1)
   \   0000038E   0xBD7F             POP      {R0-R6,PC}       ;; return
    443          
    444          /*
    445          *********************************************************************************************************
    446          *                                              BSP_Start()
    447          *
    448          * Description : Initialize all the peripherals that required OS services (OS initialized)
    449          *
    450          * Argument(s) : tick_rate : The kernel tick rate in Hz.
    451          *
    452          * Return(s)   : none.
    453          *
    454          * Caller(s)   : Application.
    455          *
    456          * Note(s)     : none.
    457          *********************************************************************************************************
    458          */
    459          

   \                                 In section .text, align 2, keep-with-next
    460          void  BSP_Start (void)
    461          {
   \                     BSP_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    462              CPU_INT32U  cnts;
    463              CPU_INT32U  cpu_freq;
    464          
    465          
    466              cpu_freq = CSP_PM_CPU_ClkFreqGet();                         /* Get the CPU clock                                    */
   \   00000002   0x.... 0x....      BL       CSP_PM_CPU_ClkFreqGet
   \   00000006   0x0005             MOVS     R5,R0
    467          #if (OS_VERSION >= 30000u)
    468              cnts     = (cpu_freq / OSCfg_TickRate_Hz);                  /* Calculate the number of SysTick counts               */
   \   00000008   0x....             LDR.N    R0,??DataTable4_15
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000010   0x0004             MOVS     R4,R0
    469          #else
    470              cnts     = (cpu_freq / OS_TICKS_PER_SEC);
    471          #endif
    472              OS_CPU_SysTickInit(cnts);                                   /* Call the Generic OS Systick initialization           */
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       OS_CPU_SysTickInit
    473          
    474          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    475          
    476          
    477          /*
    478          *********************************************************************************************************
    479          *                                             BSP_Joy_GetPos()
    480          *
    481          * Description : Get the position of the Joystick on the board.
    482          *
    483          * Argument(s) : none.
    484          *
    485          * Return(s)   : The current position of the Joystick.
    486          *
    487          *                           BSP_JOY_NONE     If the Joystick is not being pressed.
    488          *                           BSP_JOY_UP       If the Joystick is toggled up.
    489          *                           BSP_JOY_DOWN     If the Joystick is toggled down.
    490          *                           BSP_JOY_RIGHT    If the Joystick is toggled right.
    491          *                           BSP_JOY_LEFT     If the Joystick is toggled left.
    492          *                           BSP_JOY_CENTER   If the Joystick is being pressed.
    493          *
    494          * Caller(s)  : Application.
    495          *
    496          * Note(s)    : none.
    497          *********************************************************************************************************
    498          */
    499          

   \                                 In section .text, align 2, keep-with-next
    500          CPU_INT08U  BSP_Joy_GetPos (void)
    501          {
   \                     BSP_Joy_GetPos: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    502              CPU_INT32U  port_val;
    503          
    504          
    505              port_val = CSP_GPIO_Rd(CSP_GPIO_PORT_NBR_02);
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000008   0x0004             MOVS     R4,R0
    506          
    507              if (DEF_BIT_IS_CLR(port_val, BSP_GPIO2_JOY_UP)) {
   \   0000000A   0xF014 0x0001      ANDS     R0,R4,#0x1
   \   0000000E   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??BSP_Joy_GetPos_0
    508                  return (BSP_JOY_UP);
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xE02C             B.N      ??BSP_Joy_GetPos_1
    509              }
    510          
    511              if (DEF_BIT_IS_CLR(port_val, BSP_GPIO2_JOY_DOWN)) {
   \                     ??BSP_Joy_GetPos_0: (+1)
   \   0000001C   0x0860             LSRS     R0,R4,#+1
   \   0000001E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000022   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ.N    ??BSP_Joy_GetPos_2
    512                  return (BSP_JOY_DOWN);
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xE022             B.N      ??BSP_Joy_GetPos_1
    513              }
    514          
    515              if (DEF_BIT_IS_CLR(port_val, BSP_GPIO2_JOY_LEFT)) {
   \                     ??BSP_Joy_GetPos_2: (+1)
   \   00000030   0x09E0             LSRS     R0,R4,#+7
   \   00000032   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000036   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??BSP_Joy_GetPos_3
    516                  return (BSP_JOY_LEFT);
   \   00000040   0x2010             MOVS     R0,#+16
   \   00000042   0xE018             B.N      ??BSP_Joy_GetPos_1
    517              }
    518          
    519              if (DEF_BIT_IS_CLR(port_val, BSP_GPIO2_JOY_RIGHT)) {
   \                     ??BSP_Joy_GetPos_3: (+1)
   \   00000044   0x0A20             LSRS     R0,R4,#+8
   \   00000046   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000004A   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD001             BEQ.N    ??BSP_Joy_GetPos_4
    520                  return (BSP_JOY_RIGHT);
   \   00000054   0x2008             MOVS     R0,#+8
   \   00000056   0xE00E             B.N      ??BSP_Joy_GetPos_1
    521              }
    522          
    523              port_val = CSP_GPIO_Rd(CSP_GPIO_PORT_NBR_00);
   \                     ??BSP_Joy_GetPos_4: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       CSP_GPIO_Rd
   \   0000005E   0x0004             MOVS     R4,R0
    524          
    525              if (DEF_BIT_IS_CLR(port_val, BSP_GPIO0_JOY_CENTER)) {
   \   00000060   0x0960             LSRS     R0,R4,#+5
   \   00000062   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000066   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD001             BEQ.N    ??BSP_Joy_GetPos_5
    526                  return (BSP_JOY_CENTER);
   \   00000070   0x2020             MOVS     R0,#+32
   \   00000072   0xE000             B.N      ??BSP_Joy_GetPos_1
    527              }
    528          
    529              return (BSP_JOY_NONE);
   \                     ??BSP_Joy_GetPos_5: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??BSP_Joy_GetPos_1: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
    530          }
    531          
    532          
    533          /*
    534          *********************************************************************************************************
    535          *                                             BSP_Joy_GetStatus()
    536          *
    537          * Description : Get the status of the Joystick at a given position.
    538          *
    539          * Argument(s) :   joy_pos.   Position of the Joystick.
    540          *
    541          *                             BSP_JOY_UP       If the Joystick is toggled up.
    542          *                             BSP_JOY_DOWN     If the Joystick is toggled down.
    543          *                             BSP_JOY_RIGHT    If the Joystick is toggled right.
    544          *                             BSP_JOY_LEFT     If the Joystick is toggled left.
    545          *                             BSP_JOY_CENTER   If the Joystick is being pressed.
    546          *
    547          * Return(s)   :  The current Joystick status at a given position.
    548          *
    549          *                             DEF_ON           If the Joystick is     in the position specifies by joy_position
    550          *                             DEF_OFF          If the Joystick is not in the position specifies by joy_position
    551          * Caller(s)   : Application.
    552          *
    553          * Note(s)     : none.
    554          *********************************************************************************************************
    555          */
    556          

   \                                 In section .text, align 2, keep-with-next
    557          CPU_INT08U  BSP_Joy_GetStatus (CPU_INT08U  joy_pos)
    558          {
   \                     BSP_Joy_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    559              CPU_INT08U joy_status;
    560          
    561          
    562              joy_status = BSP_Joy_GetPos();
   \   00000004   0x.... 0x....      BL       BSP_Joy_GetPos
   \   00000008   0x0005             MOVS     R5,R0
    563          
    564              if (joy_status == joy_pos) {
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??BSP_Joy_GetStatus_0
    565                  return (DEF_ON);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??BSP_Joy_GetStatus_1
    566              }
    567          
    568              return (DEF_OFF);
   \                     ??BSP_Joy_GetStatus_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??BSP_Joy_GetStatus_1: (+1)
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    569          }
    570          
    571          
    572          
    573          /*
    574          *********************************************************************************************************
    575          *                                                 BSP_LED_Off()
    576          *
    577          * Description : Turn OFF any or all the LEDs on the board.
    578          *
    579          * Argument(s) : led_id   The ID of the LED to control:
    580          *
    581          *                       0    turn OFF all LEDs on the board
    582          *                       1    turn OFF USB_UP_LED1
    583          *                       2    turn OFF USB_UP_LED2
    584          *
    585          * Return(s)   : none.
    586          *
    587          * Caller(s)   : Application.
    588          *
    589          * Note(s)     : none.
    590          *********************************************************************************************************
    591          */
    592          

   \                                 In section .text, align 2, keep-with-next
    593          void  BSP_LED_Off (CPU_INT08U  led)
    594          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    595              switch (led)  {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??BSP_LED_Off_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD014             BEQ.N    ??BSP_LED_Off_1
   \   0000000E   0xD30D             BCC.N    ??BSP_LED_Off_2
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD01C             BEQ.N    ??BSP_LED_Off_3
   \   00000014   0xD315             BCC.N    ??BSP_LED_Off_4
   \   00000016   0xE020             B.N      ??BSP_LED_Off_5
    596                  case 0u:
    597                       CSP_GPIO_BitSet(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_Off_0: (+1)
   \   00000018   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       CSP_GPIO_BitSet
    598                       CSP_GPIO_BitSet(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       CSP_GPIO_BitSet
    599                       break;
   \   0000002A   0xE016             B.N      ??BSP_LED_Off_6
    600          
    601                  case 1u:
    602                       CSP_GPIO_BitSet(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_Off_2: (+1)
   \   0000002C   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       CSP_GPIO_BitSet
    603                       break;
   \   00000036   0xE010             B.N      ??BSP_LED_Off_6
    604          
    605                  case 2u:
    606                       CSP_GPIO_BitSet(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \                     ??BSP_LED_Off_1: (+1)
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       CSP_GPIO_BitSet
    607                       break;
   \   00000040   0xE00B             B.N      ??BSP_LED_Off_6
    608          
    609                  case 3u:
    610                       CSP_GPIO_BitClr(BSP_GPIO_LEDOUT_PORT, BSP_GPIO_LEDOUT);
   \                     ??BSP_LED_Off_4: (+1)
   \   00000042   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       CSP_GPIO_BitClr
    611                       break;
   \   0000004C   0xE005             B.N      ??BSP_LED_Off_6
    612          
    613                  case 4u:
    614                       CSP_GPIO_BitClr(BSP_GPIO_SWITCH_PORT, BSP_GPIO_SWITCH_OUT);
   \                     ??BSP_LED_Off_3: (+1)
   \   0000004E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       CSP_GPIO_BitClr
    615                       break;
   \   00000058   0xE7FF             B.N      ??BSP_LED_Off_6
    616              default:
    617                      break;
    618              }
    619          }
   \                     ??BSP_LED_Off_5: (+1)
   \                     ??BSP_LED_Off_6: (+1)
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    620          
    621          
    622          /*
    623          *********************************************************************************************************
    624          *                                                 BSP_LED_On()
    625          *
    626          * Description : Turn ON any or all the LEDs on the board.
    627          *
    628          * Argument(s) : led_id   The ID of the LED to control:
    629          *
    630          *                       0    turn ON all LEDs on the board.
    631          *                       1    turn ON USB_UP_LED1.
    632          *                       2    turn ON USB_UP_LED2.
    633          *
    634          * Return(s)   : none.
    635          *
    636          * Caller(s)   : Application.
    637          *
    638          * Note(s)     : none.
    639          *********************************************************************************************************
    640          */
    641          

   \                                 In section .text, align 2, keep-with-next
    642          void  BSP_LED_On (CPU_INT08U  led)
    643          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    644              switch (led)  {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??BSP_LED_On_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD014             BEQ.N    ??BSP_LED_On_1
   \   0000000E   0xD30D             BCC.N    ??BSP_LED_On_2
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD01C             BEQ.N    ??BSP_LED_On_3
   \   00000014   0xD315             BCC.N    ??BSP_LED_On_4
   \   00000016   0xE020             B.N      ??BSP_LED_On_5
    645                  case 0u:
    646                       CSP_GPIO_BitClr(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_On_0: (+1)
   \   00000018   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       CSP_GPIO_BitClr
    647                       CSP_GPIO_BitClr(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       CSP_GPIO_BitClr
    648                       break;
   \   0000002A   0xE016             B.N      ??BSP_LED_On_6
    649          
    650                  case 1u:
    651                       CSP_GPIO_BitClr(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_On_2: (+1)
   \   0000002C   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       CSP_GPIO_BitClr
    652                       break;
   \   00000036   0xE010             B.N      ??BSP_LED_On_6
    653          
    654                  case 2u:
    655                       CSP_GPIO_BitClr(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \                     ??BSP_LED_On_1: (+1)
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       CSP_GPIO_BitClr
    656                       break;
   \   00000040   0xE00B             B.N      ??BSP_LED_On_6
    657          
    658                  case 3u:
    659                     CSP_GPIO_BitSet(BSP_GPIO_LEDOUT_PORT, BSP_GPIO_LEDOUT);
   \                     ??BSP_LED_On_4: (+1)
   \   00000042   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       CSP_GPIO_BitSet
    660                     break;
   \   0000004C   0xE005             B.N      ??BSP_LED_On_6
    661                     
    662                  case 4u:
    663                     CSP_GPIO_BitSet(BSP_GPIO_SWITCH_PORT, BSP_GPIO_SWITCH_OUT);
   \                     ??BSP_LED_On_3: (+1)
   \   0000004E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       CSP_GPIO_BitSet
    664                     break;
   \   00000058   0xE7FF             B.N      ??BSP_LED_On_6
    665                  default:
    666                      break;
    667              }
    668          }
   \                     ??BSP_LED_On_5: (+1)
   \                     ??BSP_LED_On_6: (+1)
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    669          
    670          
    671          /*
    672          *********************************************************************************************************
    673          *                                                 BSP_LED_Toggle()
    674          *
    675          * Description : Toggles any or all the LEDs on the board.
    676          *
    677          * Argument(s) : led_id   The ID of the LED to control:
    678          *
    679          *                       0    toggle all LEDs on the board
    680          *                       1    toggle USB_UP_LED1
    681          *                       2    toggle USB_UP_LED2
    682          *
    683          * Return(s)   : none.
    684          *
    685          * Caller(s)   : Application.
    686          *
    687          * Note(s)     : none.
    688          *********************************************************************************************************
    689          */
    690          

   \                                 In section .text, align 2, keep-with-next
    691          void  BSP_LED_Toggle (CPU_INT08U  led)
    692          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    693              switch (led)  {
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ.N    ??BSP_LED_Toggle_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD014             BEQ.N    ??BSP_LED_Toggle_1
   \   0000000E   0xD30D             BCC.N    ??BSP_LED_Toggle_2
   \   00000010   0x2C04             CMP      R4,#+4
   \   00000012   0xD01C             BEQ.N    ??BSP_LED_Toggle_3
   \   00000014   0xD315             BCC.N    ??BSP_LED_Toggle_4
   \   00000016   0xE020             B.N      ??BSP_LED_Toggle_5
    694                  case 0u:
    695                       CSP_GPIO_BitToggle(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_Toggle_0: (+1)
   \   00000018   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       CSP_GPIO_BitToggle
    696                       CSP_GPIO_BitToggle(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x.... 0x....      BL       CSP_GPIO_BitToggle
    697                       break;
   \   0000002A   0xE016             B.N      ??BSP_LED_Toggle_6
    698          
    699                  case 1u:
    700                       CSP_GPIO_BitToggle(BSP_GPIO_LED1_PORT, BSP_GPIO_LED1);
   \                     ??BSP_LED_Toggle_2: (+1)
   \   0000002C   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x.... 0x....      BL       CSP_GPIO_BitToggle
    701                       break;
   \   00000036   0xE010             B.N      ??BSP_LED_Toggle_6
    702          
    703                  case 2u:
    704                       CSP_GPIO_BitToggle(BSP_GPIO_LED2_PORT, BSP_GPIO_LED2);
   \                     ??BSP_LED_Toggle_1: (+1)
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       CSP_GPIO_BitToggle
    705                       break;
   \   00000040   0xE00B             B.N      ??BSP_LED_Toggle_6
    706          
    707                  case 3u:
    708                       CSP_GPIO_BitToggle(BSP_GPIO_LEDOUT_PORT, BSP_GPIO_LEDOUT);
   \                     ??BSP_LED_Toggle_4: (+1)
   \   00000042   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       CSP_GPIO_BitToggle
    709                       break;
   \   0000004C   0xE005             B.N      ??BSP_LED_Toggle_6
    710                       
    711                  case 4u:
    712                       CSP_GPIO_BitToggle(BSP_GPIO_SWITCH_PORT, BSP_GPIO_SWITCH_OUT);
   \                     ??BSP_LED_Toggle_3: (+1)
   \   0000004E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       CSP_GPIO_BitToggle
    713                       break;
   \   00000058   0xE7FF             B.N      ??BSP_LED_Toggle_6
    714                       
    715                  default:
    716                      break;
    717              }
    718          }
   \                     ??BSP_LED_Toggle_5: (+1)
   \                     ??BSP_LED_Toggle_6: (+1)
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    719          
    720          
    721          /*
    722          *********************************************************************************************************
    723          *                                           BSP_PB_GetStatus()
    724          *
    725          * Description : Get the status of a push button on the board.
    726          *
    727          * Argument(s) : pb_id   The ID of the push button to probe
    728          *
    729          *                       1    probe the push button B1
    730          *                       2    probe the push button B2
    731          *
    732          * Return(s)   : DEF_OFF  if the push button is not pressed
    733          *               DEF_ONN    if the push button is     pressed
    734          *
    735          * Caller(s)   : Application
    736          *
    737          * Note(s)     : none.
    738          *********************************************************************************************************
    739          */
    740          

   \                                 In section .text, align 2, keep-with-next
    741          CPU_BOOLEAN  BSP_PB_GetStatus (CPU_INT08U  pb_id)
    742          {
   \                     BSP_PB_GetStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    743              CPU_INT32U   port_val;
    744              CPU_BOOLEAN  pb_status;
    745          
    746          
    747              pb_status = DEF_OFF;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0006             MOVS     R6,R0
    748          
    749              if (pb_id == 1u) {
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD10E             BNE.N    ??BSP_PB_GetStatus_0
    750                  port_val = CSP_GPIO_Rd(CSP_GPIO_PORT_NBR_00);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000014   0x0005             MOVS     R5,R0
    751                  if (DEF_BIT_IS_CLR(port_val, BSP_GPIO0_BUT1)) {
   \   00000016   0x0DE8             LSRS     R0,R5,#+23
   \   00000018   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001C   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD013             BEQ.N    ??BSP_PB_GetStatus_1
    752                      pb_status = DEF_ON;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xE010             B.N      ??BSP_PB_GetStatus_1
    753                  }
    754              } else if (pb_id == 2u) {
   \                     ??BSP_PB_GetStatus_0: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C02             CMP      R4,#+2
   \   00000030   0xD10D             BNE.N    ??BSP_PB_GetStatus_1
    755                  port_val =  CSP_GPIO_Rd(CSP_GPIO_PORT_NBR_02);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       CSP_GPIO_Rd
   \   00000038   0x0005             MOVS     R5,R0
    756                  if (DEF_BIT_IS_CLR(port_val, BSP_GPIO2_BUT2)) {
   \   0000003A   0x0B68             LSRS     R0,R5,#+13
   \   0000003C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000040   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD001             BEQ.N    ??BSP_PB_GetStatus_1
    757                      pb_status = DEF_ON;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0006             MOVS     R6,R0
    758                  }
    759              } else {
    760                  ;
    761              }
    762          
    763              return (pb_status);
   \                     ??BSP_PB_GetStatus_1: (+1)
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    764          }
    765          
    766          /*$PAGE*/
    767          /*
    768          *********************************************************************************************************
    769          *                                          CPU_TS_TmrInit()
    770          *
    771          * Description : Initialize & start CPU timestamp timer.
    772          *
    773          * Argument(s) : none.
    774          *
    775          * Return(s)   : none.
    776          *
    777          * Caller(s)   : CPU_TS_Init().
    778          *
    779          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    780          *               BSP function(s) [see Note #1] but MUST NOT be called by application function(s).
    781          *
    782          * Note(s)     : (1) CPU_TS_TmrInit() is an application/BSP function that MUST be defined by the developer
    783          *                   if either of the following CPU features is enabled :
    784          *
    785          *                   (a) CPU timestamps
    786          *                   (b) CPU interrupts disabled time measurements
    787          *
    788          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    789          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    790          *
    791          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    792          *                       data type.
    793          *
    794          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    795          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    796          *
    797          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    798          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    799          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    800          *
    801          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    802          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    803          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    804          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    805          *
    806          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    807          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    808          *
    809          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    810          *
    811          *                   (c) When applicable, timer period SHOULD be less than the typical measured time
    812          *                       but MUST be less than the maximum measured time; otherwise, timer resolution
    813          *                       inadequate to measure desired times.
    814          *
    815          *                   See also 'CPU_TS_TmrRd()  Note #2'.
    816          *********************************************************************************************************
    817          */
    818          
    819          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    820          void  CPU_TS_TmrInit (void)
    821          {
   \                     CPU_TS_TmrInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    822              CPU_INT32U  fclk_freq;
    823          
    824              fclk_freq = CSP_PM_CPU_ClkFreqGet();
   \   00000002   0x.... 0x....      BL       CSP_PM_CPU_ClkFreqGet
   \   00000006   0x0004             MOVS     R4,R0
    825          
    826              BSP_REG_DEMCR  |= DEF_BIT_24;
   \   00000008   0x....             LDR.N    R0,??DataTable4_16  ;; 0xe000edfc
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000010   0x....             LDR.N    R1,??DataTable4_16  ;; 0xe000edfc
   \   00000012   0x6008             STR      R0,[R1, #+0]
    827              BSP_REG_DWT_CR |= DEF_BIT_00;
   \   00000014   0x....             LDR.N    R0,??DataTable4_17  ;; 0xe0001000
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000001C   0x....             LDR.N    R1,??DataTable4_17  ;; 0xe0001000
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    828          
    829              CPU_TS_TmrFreqSet((CPU_TS_TMR_FREQ)fclk_freq);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       CPU_TS_TmrFreqSet
    830          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    831          #endif
    832          
    833          
    834          /*$PAGE*/
    835          /*
    836          *********************************************************************************************************
    837          *                                           CPU_TS_TmrRd()
    838          *
    839          * Description : Get current CPU timestamp timer count value.
    840          *
    841          * Argument(s) : none.
    842          *
    843          * Return(s)   : Timestamp timer count (see Notes #2a & #2b).
    844          *
    845          * Caller(s)   : CPU_TS_Init(),
    846          *               CPU_TS_Get32(),
    847          *               CPU_TS_Get64(),
    848          *               CPU_IntDisMeasStart(),
    849          *               CPU_IntDisMeasStop().
    850          *
    851          *               This function is an INTERNAL CPU module function & MUST be implemented by application/
    852          *               BSP function(s) [see Note #1] but SHOULD NOT be called by application function(s).
    853          *
    854          * Note(s)     : (1) CPU_TS_TmrRd() is an application/BSP function that MUST be defined by the developer
    855          *                   if either of the following CPU features is enabled :
    856          *
    857          *                   (a) CPU timestamps
    858          *                   (b) CPU interrupts disabled time measurements
    859          *
    860          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    861          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    862          *
    863          *               (2) (a) Timer count values MUST be returned via word-size-configurable 'CPU_TS_TMR'
    864          *                       data type.
    865          *
    866          *                       (1) If timer has more bits, truncate timer values' higher-order bits greater
    867          *                           than the configured 'CPU_TS_TMR' timestamp timer data type word size.
    868          *
    869          *                       (2) Since the timer MUST NOT have less bits than the configured 'CPU_TS_TMR'
    870          *                           timestamp timer data type word size; 'CPU_CFG_TS_TMR_SIZE' MUST be
    871          *                           configured so that ALL bits in 'CPU_TS_TMR' data type are significant.
    872          *
    873          *                           In other words, if timer size is not a binary-multiple of 8-bit octets
    874          *                           (e.g. 20-bits or even 24-bits), then the next lower, binary-multiple
    875          *                           octet word size SHOULD be configured (e.g. to 16-bits).  However, the
    876          *                           minimum supported word size for CPU timestamp timers is 8-bits.
    877          *
    878          *                       See also 'cpu_cfg.h   CPU TIMESTAMP CONFIGURATION  Note #2'
    879          *                              & 'cpu_core.h  CPU TIMESTAMP DATA TYPES     Note #1'.
    880          *
    881          *                   (b) Timer SHOULD be an 'up'  counter whose values increase with each time count.
    882          *
    883          *                       (1) If timer is a 'down' counter whose values decrease with each time count,
    884          *                           then the returned timer value MUST be ones-complemented.
    885          *
    886          *                   (c) (1) When applicable, the amount of time measured by CPU timestamps is
    887          *                           calculated by either of the following equations :
    888          *
    889          *                           (A) Time measured  =  Number timer counts  *  Timer period
    890          *
    891          *                                   where
    892          *
    893          *                                       Number timer counts     Number of timer counts measured
    894          *                                       Timer period            Timer's period in some units of
    895          *                                                                   (fractional) seconds
    896          *                                       Time measured           Amount of time measured, in same
    897          *                                                                   units of (fractional) seconds
    898          *                                                                   as the Timer period
    899          *
    900          *                                                  Number timer counts
    901          *                           (B) Time measured  =  ---------------------
    902          *                                                    Timer frequency
    903          *
    904          *                                   where
    905          *
    906          *                                       Number timer counts     Number of timer counts measured
    907          *                                       Timer frequency         Timer's frequency in some units
    908          *                                                                   of counts per second
    909          *                                       Time measured           Amount of time measured, in seconds
    910          *
    911          *                       (2) Timer period SHOULD be less than the typical measured time but MUST be less
    912          *                           than the maximum measured time; otherwise, timer resolution inadequate to
    913          *                           measure desired times.
    914          *********************************************************************************************************
    915          */
    916          
    917          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    918          CPU_TS_TMR  CPU_TS_TmrRd (void)
    919          {
    920              CPU_TS_TMR  ts_tmr_cnts;
    921          
    922          
    923              ts_tmr_cnts  = (CPU_TS_TMR)BSP_REG_DWT_CYCCNT;
   \                     CPU_TS_TmrRd: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_18  ;; 0xe0001004
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x0008             MOVS     R0,R1
    924          
    925              return (ts_tmr_cnts);
   \   00000006   0x4770             BX       LR               ;; return
    926          }
    927          #endif
    928          
    929          
    930          /*$PAGE*/
    931          /*
    932          *********************************************************************************************************
    933          *                                         CPU_TSxx_to_uSec()
    934          *
    935          * Description : Convert a 32-/64-bit CPU timestamp from timer counts to microseconds.
    936          *
    937          * Argument(s) : ts_cnts   CPU timestamp (in timestamp timer counts [see Note #2aA]).
    938          *
    939          * Return(s)   : Converted CPU timestamp (in microseconds           [see Note #2aD]).
    940          *
    941          * Caller(s)   : Application.
    942          *
    943          *               This function is an (optional) CPU module application interface (API) function which
    944          *               MAY be implemented by application/BSP function(s) [see Note #1] & MAY be called by
    945          *               application function(s).
    946          *
    947          * Note(s)     : (1) CPU_TS32_to_uSec()/CPU_TS64_to_uSec() are application/BSP functions that MAY be
    948          *                   optionally defined by the developer when either of the following CPU features is
    949          *                   enabled :
    950          *
    951          *                   (a) CPU timestamps
    952          *                   (b) CPU interrupts disabled time measurements
    953          *
    954          *                   See 'cpu_cfg.h  CPU TIMESTAMP CONFIGURATION  Note #1'
    955          *                     & 'cpu_cfg.h  CPU INTERRUPTS DISABLED TIME MEASUREMENT CONFIGURATION  Note #1a'.
    956          *
    957          *               (2) (a) The amount of time measured by CPU timestamps is calculated by either of
    958          *                       the following equations :
    959          *
    960          *                                                                        10^6 microseconds
    961          *                       (1) Time measured  =   Number timer counts   *  -------------------  *  Timer period
    962          *                                                                            1 second
    963          *
    964          *                                              Number timer counts       10^6 microseconds
    965          *                       (2) Time measured  =  ---------------------  *  -------------------
    966          *                                                Timer frequency             1 second
    967          *
    968          *                               where
    969          *
    970          *                                   (A) Number timer counts     Number of timer counts measured
    971          *                                   (B) Timer frequency         Timer's frequency in some units
    972          *                                                                   of counts per second
    973          *                                   (C) Timer period            Timer's period in some units of
    974          *                                                                   (fractional)  seconds
    975          *                                   (D) Time measured           Amount of time measured,
    976          *                                                                   in microseconds
    977          *
    978          *                   (b) Timer period SHOULD be less than the typical measured time but MUST be less
    979          *                       than the maximum measured time; otherwise, timer resolution inadequate to
    980          *                       measure desired times.
    981          *
    982          *                   (c) Specific implementations may convert any number of CPU_TS32 or CPU_TS64 bits
    983          *                       -- up to 32 or 64, respectively -- into microseconds.
    984          *********************************************************************************************************
    985          */
    986          
    987          #if (CPU_CFG_TS_32_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    988          CPU_INT64U  CPU_TS32_to_uSec (CPU_TS32  ts_cnts)
    989          {
   \                     CPU_TS32_to_uSec: (+1)
   \   00000000   0xE92D 0x43D0      PUSH     {R4,R6-R9,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    990              CPU_INT64U  ts_us;
    991              CPU_INT64U  fclk_freq;
    992              CPU_ERR     err;
    993          
    994          
    995              fclk_freq = CPU_TS_TmrFreqGet(&err);
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       CPU_TS_TmrFreqGet
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x4680             MOV      R8,R0
   \   00000012   0x4689             MOV      R9,R1
    996              ts_us     = ts_cnts / (fclk_freq / DEF_TIME_NBR_uS_PER_SEC);
   \   00000014   0x4640             MOV      R0,R8
   \   00000016   0x4649             MOV      R1,R9
   \   00000018   0x....             LDR.N    R2,??DataTable4_19  ;; 0xf4240
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0x000B             MOVS     R3,R1
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000002C   0x0006             MOVS     R6,R0
   \   0000002E   0x000F             MOVS     R7,R1
    997          
    998              return (ts_us);
   \   00000030   0x0030             MOVS     R0,R6
   \   00000032   0x0039             MOVS     R1,R7
   \   00000034   0xE8BD 0x83DC      POP      {R2-R4,R6-R9,PC}  ;; return
    999          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x400FC000         DC32     0x400fc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x400FC1A0         DC32     0x400fc1a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x400FC1A8         DC32     0x400fc1a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x400FC1AC         DC32     0x400fc1ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x00010018         DC32     0x10018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x400FC088         DC32     0x400fc088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x400FC080         DC32     0x400fc080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x400FC08C         DC32     0x400fc08c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x400FC104         DC32     0x400fc104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x400FC10C         DC32     0x400fc10c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x400FC084         DC32     0x400fc084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x400FC0A0         DC32     0x400fc0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x400FC0AC         DC32     0x400fc0ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x400FC0A4         DC32     0x400fc0a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x400FC0A8         DC32     0x400fc0a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0xE000EDFC         DC32     0xe000edfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0xE0001000         DC32     0xe0001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   0xE0001004         DC32     0xe0001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \   00000000   0x000F4240         DC32     0xf4240
   1000          #endif
   1001          
   1002          
   1003          #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
   1004          CPU_INT64U  CPU_TS64_to_uSec (CPU_TS64  ts_cnts)
   1005          {
   1006          
   1007              return (0u);
   1008          
   1009          }
   1010          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   BSP_Init
        32   -> BSP_LED_Off
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CSP_GPIO_BitSet
        32   -> CSP_GPIO_Cfg
        32   -> CSP_IntDisAll
        32   -> CSP_IntInit
       8   BSP_Joy_GetPos
         8   -> CSP_GPIO_Rd
      16   BSP_Joy_GetStatus
        16   -> BSP_Joy_GetPos
       8   BSP_LED_Off
         8   -> CSP_GPIO_BitClr
         8   -> CSP_GPIO_BitSet
       8   BSP_LED_On
         8   -> CSP_GPIO_BitClr
         8   -> CSP_GPIO_BitSet
       8   BSP_LED_Toggle
         8   -> CSP_GPIO_BitToggle
      16   BSP_PB_GetStatus
        16   -> CSP_GPIO_Rd
      16   BSP_Start
        16   -> CSP_PM_CPU_ClkFreqGet
        16   -> OS_CPU_SysTickInit
      32   CPU_TS32_to_uSec
        32   -> CPU_TS_TmrFreqGet
        32 __aeabi_uldivmod
       8   CPU_TS_TmrInit
         8   -> CPU_TS_TmrFreqSet
         8   -> CSP_PM_CPU_ClkFreqGet
       0   CPU_TS_TmrRd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
     912  BSP_Init
     120  BSP_Joy_GetPos
      30  BSP_Joy_GetStatus
      92  BSP_LED_Off
      92  BSP_LED_On
      92  BSP_LED_Toggle
      84  BSP_PB_GetStatus
      26  BSP_Start
      56  CPU_TS32_to_uSec
      40  CPU_TS_TmrInit
       8  CPU_TS_TmrRd

 
 1 632 bytes in section .text
 
 1 632 bytes of CODE memory

Errors: none
Warnings: none
