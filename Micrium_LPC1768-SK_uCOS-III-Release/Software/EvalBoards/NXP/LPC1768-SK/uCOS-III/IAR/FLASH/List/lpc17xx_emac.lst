###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_emac.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_emac.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_emac.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_emac.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_emac.c
      1          /**
      2           * @file	: lpc17xx_emac.c
      3           * @brief	: Contains all functions support for Ethernet MAC firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 02. Jun. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup EMAC
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_emac.h"
     27          #include "lpc17xx_clkpwr.h"
     28          
     29          /* If this source file built with example, the LPC17xx FW library configuration
     30           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     31           * otherwise the default FW library configuration file must be included instead
     32           */
     33          #ifdef __BUILD_WITH_EXAMPLE__
     34          #include "lpc17xx_libcfg.h"
     35          #else
     36          #include "lpc17xx_libcfg_default.h"
     37          #endif /* __BUILD_WITH_EXAMPLE__ */
     38          
     39          
     40          #ifdef _EMAC
     41          
     42          /* Private Variables ---------------------------------------------------------- */
     43          /** @defgroup EMAC_Private_Variables
     44           * @{
     45           */
     46          
     47          /* MII Mgmt Configuration register - Clock divider setting */

   \                                 In section .rodata, align 4
     48          const uint8_t EMAC_clkdiv[] = { 4, 6, 8, 10, 14, 20, 28 };
   \                     EMAC_clkdiv:
   \   00000000   0x04 0x06          DC8 4, 6, 8, 10, 14, 20, 28, 0
   \              0x08 0x0A    
   \              0x0E 0x14    
   \              0x1C 0x00    
     49          
     50          /* EMAC local DMA Descriptors */
     51          
     52          /** Rx Descriptor data array */

   \                                 In section .bss, align 4
     53          static RX_Desc Rx_Desc[EMAC_NUM_RX_FRAG];
   \                     Rx_Desc:
   \   00000000                      DS8 32
     54          
     55          /** Rx Status data array - Must be 8-Byte aligned */
     56          #if defined ( __CC_ARM   )
     57          static __align(8) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
     58          #elif defined ( __ICCARM__ )
     59          #pragma data_alignment=8

   \                                 In section .bss, align 8
     60          static RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
   \                     Rx_Stat:
   \   00000000                      DS8 32
     61          #elif defined   (  __GNUC__  )
     62          static __attribute__ ((aligned (8))) RX_Stat Rx_Stat[EMAC_NUM_RX_FRAG];
     63          #endif
     64          
     65          /** Tx Descriptor data array */

   \                                 In section .bss, align 4
     66          static TX_Desc Tx_Desc[EMAC_NUM_TX_FRAG];
   \                     Tx_Desc:
   \   00000000                      DS8 24
     67          /** Tx Status data array */

   \                                 In section .bss, align 4
     68          static TX_Stat Tx_Stat[EMAC_NUM_TX_FRAG];
   \                     Tx_Stat:
   \   00000000                      DS8 12
     69          
     70          /* EMAC local DMA buffers */
     71          /** Rx buffer data */

   \                                 In section .bss, align 4
     72          static uint32_t rx_buf[EMAC_NUM_RX_FRAG][EMAC_ETH_MAX_FLEN>>2];
   \                     rx_buf:
   \   00000000                      DS8 6144
     73          /** Tx buffer data */

   \                                 In section .bss, align 4
     74          static uint32_t tx_buf[EMAC_NUM_TX_FRAG][EMAC_ETH_MAX_FLEN>>2];
   \                     tx_buf:
   \   00000000                      DS8 4608
     75          
     76          /* EMAC call-back function pointer data */

   \                                 In section .bss, align 4
     77          static EMAC_IntCBSType *_pfnIntCbDat[10];
   \                     _pfnIntCbDat:
   \   00000000                      DS8 40
     78          
     79          /**
     80           * @}
     81           */
     82          
     83          
     84          /* Private Functions ---------------------------------------------------------- */
     85          /** @defgroup EMAC_Private_Functions
     86           * @{
     87           */
     88          
     89          static void rx_descr_init (void);
     90          static void tx_descr_init (void);
     91          static int32_t write_PHY (uint32_t PhyReg, uint16_t Value);
     92          static int32_t  read_PHY (uint32_t PhyReg);
     93          
     94          
     95          /*--------------------------- rx_descr_init ---------------------------------*/
     96          
     97          /**
     98           * @brief 		Initializes RX Descriptor
     99           * @param[in]	None
    100           * @return		None
    101           */

   \                                 In section .text, align 2, keep-with-next
    102          static void rx_descr_init (void)
    103          {
    104          	/* Initialize Receive Descriptor and Status array. */
    105          	uint32_t i;
    106          
    107          	for (i = 0; i < EMAC_NUM_RX_FRAG; i++) {
   \                     rx_descr_init: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x0008             MOVS     R0,R1
   \                     ??rx_descr_init_0: (+1)
   \   00000004   0x2804             CMP      R0,#+4
   \   00000006   0xD21E             BCS.N    ??rx_descr_init_1
    108          		Rx_Desc[i].Packet  = (uint32_t)&rx_buf[i];
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000000C   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000010   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000014   0x4411             ADD      R1,R1,R2
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable24_1
   \   0000001A   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
    109          		Rx_Desc[i].Ctrl    = EMAC_RCTRL_INT | (EMAC_ETH_MAX_FLEN - 1);
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable24_2  ;; 0x800005ff
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable24_1
   \   00000026   0xEB02 0x02C0      ADD      R2,R2,R0, LSL #+3
   \   0000002A   0x6051             STR      R1,[R2, #+4]
    110          		Rx_Stat[i].Info    = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable24_3
   \   00000032   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
    111          		Rx_Stat[i].HashCRC = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable24_3
   \   0000003C   0xEB02 0x02C0      ADD      R2,R2,R0, LSL #+3
   \   00000040   0x6051             STR      R1,[R2, #+4]
    112          	}
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xE7DE             B.N      ??rx_descr_init_0
    113          
    114          	/* Set EMAC Receive Descriptor Registers. */
    115          	LPC_EMAC->RxDescriptor       = (uint32_t)&Rx_Desc[0];
   \                     ??rx_descr_init_1: (+1)
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable24_4  ;; 0x50000108
   \   0000004E   0x6011             STR      R1,[R2, #+0]
    116          	LPC_EMAC->RxStatus           = (uint32_t)&Rx_Stat[0];
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable24_3
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable24_5  ;; 0x5000010c
   \   00000058   0x6011             STR      R1,[R2, #+0]
    117          	LPC_EMAC->RxDescriptorNumber = EMAC_NUM_RX_FRAG - 1;
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable24_6  ;; 0x50000110
   \   00000060   0x6011             STR      R1,[R2, #+0]
    118          
    119          	/* Rx Descriptors Point to 0 */
    120          	LPC_EMAC->RxConsumeIndex  = 0;
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable24_7  ;; 0x50000118
   \   00000068   0x6011             STR      R1,[R2, #+0]
    121          }
   \   0000006A   0x4770             BX       LR               ;; return
    122          
    123          
    124          /*--------------------------- tx_descr_init ---- ----------------------------*/
    125          /**
    126           * @brief 		Initializes TX Descriptor
    127           * @param[in]	None
    128           * @return		None
    129           */

   \                                 In section .text, align 2, keep-with-next
    130          static void tx_descr_init (void) {
    131          	/* Initialize Transmit Descriptor and Status array. */
    132          	uint32_t i;
    133          
    134          	for (i = 0; i < EMAC_NUM_TX_FRAG; i++) {
   \                     tx_descr_init: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x0008             MOVS     R0,R1
   \                     ??tx_descr_init_0: (+1)
   \   00000004   0x2803             CMP      R0,#+3
   \   00000006   0xD217             BCS.N    ??tx_descr_init_1
    135          		Tx_Desc[i].Packet = (uint32_t)&tx_buf[i];
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable24_8
   \   0000000C   0xF44F 0x62C0      MOV      R2,#+1536
   \   00000010   0xFB02 0xF200      MUL      R2,R2,R0
   \   00000014   0x4411             ADD      R1,R1,R2
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable24_9
   \   0000001A   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
    136          		Tx_Desc[i].Ctrl   = 0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable24_9
   \   00000024   0xEB02 0x02C0      ADD      R2,R2,R0, LSL #+3
   \   00000028   0x6051             STR      R1,[R2, #+4]
    137          		Tx_Stat[i].Info   = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable24_10
   \   00000030   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    138          	}
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0xE7E5             B.N      ??tx_descr_init_0
    139          
    140          	/* Set EMAC Transmit Descriptor Registers. */
    141          	LPC_EMAC->TxDescriptor       = (uint32_t)&Tx_Desc[0];
   \                     ??tx_descr_init_1: (+1)
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable24_9
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable24_11  ;; 0x5000011c
   \   00000040   0x6011             STR      R1,[R2, #+0]
    142          	LPC_EMAC->TxStatus           = (uint32_t)&Tx_Stat[0];
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable24_12  ;; 0x50000120
   \   0000004A   0x6011             STR      R1,[R2, #+0]
    143          	LPC_EMAC->TxDescriptorNumber = EMAC_NUM_TX_FRAG - 1;
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable24_13  ;; 0x50000124
   \   00000052   0x6011             STR      R1,[R2, #+0]
    144          
    145          	/* Tx Descriptors Point to 0 */
    146          	LPC_EMAC->TxProduceIndex  = 0;
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable24_14  ;; 0x50000128
   \   0000005A   0x6011             STR      R1,[R2, #+0]
    147          }
   \   0000005C   0x4770             BX       LR               ;; return
    148          
    149          
    150          /*--------------------------- write_PHY -------------------------------------*/
    151          /**
    152           * @brief 		Write value to PHY device
    153           * @param[in]	PhyReg PHY Register address
    154           * @param[in]	Value Value to write
    155           * @return		(0) if sucess, otherwise return (-1)
    156           */

   \                                 In section .text, align 2, keep-with-next
    157          static int32_t write_PHY (uint32_t PhyReg, uint16_t Value)
    158          {
   \                     write_PHY: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    159          	/* Write a data 'Value' to PHY register 'PhyReg'. */
    160          	uint32_t tout;
    161          
    162          	LPC_EMAC->MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
   \   00000004   0xF452 0x7080      ORRS     R0,R2,#0x100
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable24_15  ;; 0x50000028
   \   0000000C   0x6020             STR      R0,[R4, #+0]
    163          	LPC_EMAC->MWTD = Value;
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_16  ;; 0x5000002c
   \   00000014   0x6001             STR      R1,[R0, #+0]
    164          
    165          	/* Wait until operation completed */
    166          	tout = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0003             MOVS     R3,R0
    167          	for (tout = 0; tout < EMAC_MII_WR_TOUT; tout++) {
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0003             MOVS     R3,R0
   \                     ??write_PHY_0: (+1)
   \   0000001E   0xF5B3 0x2FA0      CMP      R3,#+327680
   \   00000022   0xD208             BCS.N    ??write_PHY_1
    168          		if ((LPC_EMAC->MIND & EMAC_MIND_BUSY) == 0) {
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable24_17  ;; 0x50000034
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD401             BMI.N    ??write_PHY_2
    169          			return (0);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE003             B.N      ??write_PHY_3
    170          		}
    171          	}
   \                     ??write_PHY_2: (+1)
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   \   00000034   0xE7F3             B.N      ??write_PHY_0
    172          	// Time out!
    173          	return (-1);
   \                     ??write_PHY_1: (+1)
   \   00000036   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??write_PHY_3: (+1)
   \   0000003A   0xBC10             POP      {R4}
   \   0000003C   0x4770             BX       LR               ;; return
    174          }
    175          
    176          
    177          /*--------------------------- read_PHY --------------------------------------*/
    178          /**
    179           * @brief 		Read value from PHY device
    180           * @param[in]	PhyReg PHY Register address
    181           * @return		Return value if success, otherwise return (-1)
    182           */

   \                                 In section .text, align 2, keep-with-next
    183          static int32_t read_PHY (uint32_t PhyReg)
    184          {
   \                     read_PHY: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    185          	/* Read a PHY register 'PhyReg'. */
    186          	uint32_t tout;
    187          
    188          	LPC_EMAC->MADR = EMAC_DP83848C_DEF_ADR | PhyReg;
   \   00000002   0xF451 0x7080      ORRS     R0,R1,#0x100
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable24_15  ;; 0x50000028
   \   0000000A   0x6018             STR      R0,[R3, #+0]
    189          	LPC_EMAC->MCMD = EMAC_MCMD_READ;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable24_18  ;; 0x50000024
   \   00000012   0x6018             STR      R0,[R3, #+0]
    190          
    191          	/* Wait until operation completed */
    192          	tout = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0002             MOVS     R2,R0
    193          	for (tout = 0; tout < EMAC_MII_RD_TOUT; tout++) {
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0002             MOVS     R2,R0
   \                     ??read_PHY_0: (+1)
   \   0000001C   0xF5B2 0x2FA0      CMP      R2,#+327680
   \   00000020   0xD20E             BCS.N    ??read_PHY_1
    194          		if ((LPC_EMAC->MIND & EMAC_MIND_BUSY) == 0) {
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable24_17  ;; 0x50000034
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD407             BMI.N    ??read_PHY_2
    195          			LPC_EMAC->MCMD = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable24_18  ;; 0x50000024
   \   00000032   0x6018             STR      R0,[R3, #+0]
    196          			return (LPC_EMAC->MRDD);
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable24_19  ;; 0x50000030
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xE003             B.N      ??read_PHY_3
    197          		}
    198          	}
   \                     ??read_PHY_2: (+1)
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0xE7ED             B.N      ??read_PHY_0
    199          	// Time out!
    200          	return (-1);
   \                     ??read_PHY_1: (+1)
   \   00000040   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??read_PHY_3: (+1)
   \   00000044   0x4770             BX       LR               ;; return
    201          }
    202          
    203          /*********************************************************************//**
    204           * @brief		Set Station MAC address for EMAC module
    205           * @param[in]	abStationAddr Pointer to Station address that contains 6-bytes
    206           * 				of MAC address (should be in order from MAC Address 1 to MAC Address 6)
    207           * @return		None
    208           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          void setEmacAddr(uint8_t abStationAddr[])
    210          {
    211          	/* Set the Ethernet MAC Address registers */
    212          	LPC_EMAC->SA0 = ((uint32_t)abStationAddr[5] << 8) | (uint32_t)abStationAddr[4];
   \                     setEmacAddr: (+1)
   \   00000000   0x7941             LDRB     R1,[R0, #+5]
   \   00000002   0x7902             LDRB     R2,[R0, #+4]
   \   00000004   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable24_20  ;; 0x50000040
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    213          	LPC_EMAC->SA1 = ((uint32_t)abStationAddr[3] << 8) | (uint32_t)abStationAddr[2];
   \   0000000E   0x78C1             LDRB     R1,[R0, #+3]
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable24_21  ;; 0x50000044
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    214          	LPC_EMAC->SA2 = ((uint32_t)abStationAddr[1] << 8) | (uint32_t)abStationAddr[0];
   \   0000001C   0x7841             LDRB     R1,[R0, #+1]
   \   0000001E   0x7802             LDRB     R2,[R0, #+0]
   \   00000020   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable24_22  ;; 0x50000048
   \   00000028   0x6011             STR      R1,[R2, #+0]
    215          }
   \   0000002A   0x4770             BX       LR               ;; return
    216          
    217          /**
    218           * @}
    219           */
    220          
    221          
    222          /* Public Functions ----------------------------------------------------------- */
    223          /** @addtogroup EMAC_Public_Functions
    224           * @{
    225           */
    226          
    227          
    228          /*********************************************************************//**
    229           * @brief		Initializes the EMAC peripheral according to the specified
    230          *               parameters in the EMAC_ConfigStruct.
    231           * @param[in]	EMAC_ConfigStruct Pointer to a EMAC_CFG_Type structure
    232          *                    that contains the configuration information for the
    233          *                    specified EMAC peripheral.
    234           * @return		None
    235           *
    236           * Note: This function will initialize EMAC module according to procedure below:
    237           *  - Remove the soft reset condition from the MAC
    238           *  - Configure the PHY via the MIIM interface of the MAC
    239           *  - Select RMII mode
    240           *  - Configure the transmit and receive DMA engines, including the descriptor arrays
    241           *  - Configure the host registers (MAC1,MAC2 etc.) in the MAC
    242           *  - Enable the receive and transmit data paths
    243           *  In default state after initializing, only Rx Done and Tx Done interrupt are enabled,
    244           *  all remain interrupts are disabled
    245           *  (Ref. from LPC17xx UM)
    246           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          Status EMAC_Init(EMAC_CFG_Type *EMAC_ConfigStruct)
    248          {
   \                     EMAC_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    249          	/* Initialize the EMAC Ethernet controller. */
    250          	int32_t regv,tout, tmp;
    251          
    252          	/* Set up clock and power for Ethernet module */
    253          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000000A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    254          
    255          	/* Reset all EMAC internal modules */
    256          	LPC_EMAC->MAC1    = EMAC_MAC1_RES_TX | EMAC_MAC1_RES_MCS_TX | EMAC_MAC1_RES_RX |
    257          					EMAC_MAC1_RES_MCS_RX | EMAC_MAC1_SIM_RES | EMAC_MAC1_SOFT_RES;
   \   0000000E   0xF44F 0x404F      MOV      R0,#+52992
   \   00000012   0xF05F 0x41A0      MOVS     R1,#+1342177280
   \   00000016   0x6008             STR      R0,[R1, #+0]
    258          
    259          	LPC_EMAC->Command = EMAC_CR_REG_RES | EMAC_CR_TX_RES | EMAC_CR_RX_RES | EMAC_CR_PASS_RUNT_FRM;
   \   00000018   0x2078             MOVS     R0,#+120
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24_23  ;; 0x50000100
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    260          
    261          	/* A short delay after reset. */
    262          	for (tout = 100; tout; tout--);
   \   00000020   0x2064             MOVS     R0,#+100
   \   00000022   0x0006             MOVS     R6,R0
   \                     ??EMAC_Init_0: (+1)
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??EMAC_Init_1
   \   00000028   0x1E76             SUBS     R6,R6,#+1
   \   0000002A   0xE7FB             B.N      ??EMAC_Init_0
    263          
    264          	/* Initialize MAC control registers. */
    265          	LPC_EMAC->MAC1 = EMAC_MAC1_PASS_ALL;
   \                     ??EMAC_Init_1: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF05F 0x41A0      MOVS     R1,#+1342177280
   \   00000032   0x6008             STR      R0,[R1, #+0]
    266          	LPC_EMAC->MAC2 = EMAC_MAC2_CRC_EN | EMAC_MAC2_PAD_EN;
   \   00000034   0x2030             MOVS     R0,#+48
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable24_24  ;; 0x50000004
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    267          	LPC_EMAC->MAXF = EMAC_ETH_MAX_FLEN;
   \   0000003C   0xF44F 0x60C0      MOV      R0,#+1536
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable24_25  ;; 0x50000014
   \   00000044   0x6008             STR      R0,[R1, #+0]
    268          	/*
    269          	 * Find the clock that close to desired target clock
    270          	 */
    271          	tmp = SystemCoreClock / EMAC_MCFG_MII_MAXCLK;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable24_26
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable24_27  ;; 0x2625a0
   \   00000050   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000054   0x0007             MOVS     R7,R0
    272          	for (tout = 0; tout < sizeof (EMAC_clkdiv); tout++){
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0006             MOVS     R6,R0
   \                     ??EMAC_Init_2: (+1)
   \   0000005A   0x2E07             CMP      R6,#+7
   \   0000005C   0xD206             BCS.N    ??EMAC_Init_3
    273          		if (EMAC_clkdiv[tout] >= tmp) break;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable24_28
   \   00000062   0x5D80             LDRB     R0,[R0, R6]
   \   00000064   0x42B8             CMP      R0,R7
   \   00000066   0xDA01             BGE.N    ??EMAC_Init_3
    274          	}
   \                     ??EMAC_Init_4: (+1)
   \   00000068   0x1C76             ADDS     R6,R6,#+1
   \   0000006A   0xE7F6             B.N      ??EMAC_Init_2
    275          	tout++;
   \                     ??EMAC_Init_3: (+1)
   \   0000006C   0x1C76             ADDS     R6,R6,#+1
    276          	// Write to MAC configuration register and reset
    277          	LPC_EMAC->MCFG = EMAC_MCFG_CLK_SEL(tout) | EMAC_MCFG_RES_MII;
   \   0000006E   0x00B0             LSLS     R0,R6,#+2
   \   00000070   0xF010 0x003C      ANDS     R0,R0,#0x3C
   \   00000074   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable24_29  ;; 0x50000020
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    278          	// release reset
    279          	LPC_EMAC->MCFG &= ~(EMAC_MCFG_RES_MII);
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable24_29  ;; 0x50000020
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF430 0x4000      BICS     R0,R0,#0x8000
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable24_29  ;; 0x50000020
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    280          	LPC_EMAC->CLRT = EMAC_CLRT_DEF;
   \   0000008E   0xF243 0x700F      MOVW     R0,#+14095
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable24_30  ;; 0x50000010
   \   00000096   0x6008             STR      R0,[R1, #+0]
    281          	LPC_EMAC->IPGR = EMAC_IPGR_P2_DEF;
   \   00000098   0x2012             MOVS     R0,#+18
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable24_31  ;; 0x5000000c
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    282          
    283          	/* Enable Reduced MII interface. */
    284          	LPC_EMAC->Command = EMAC_CR_RMII | EMAC_CR_PASS_RUNT_FRM;
   \   000000A0   0xF44F 0x7010      MOV      R0,#+576
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable24_23  ;; 0x50000100
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    285          
    286          	/* Reset Reduced MII Logic. */
    287          	LPC_EMAC->SUPP = EMAC_SUPP_RES_RMII;
   \   000000AA   0xF44F 0x6000      MOV      R0,#+2048
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable24_32  ;; 0x50000018
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    288          
    289          	for (tout = 100; tout; tout--);
   \   000000B4   0x2064             MOVS     R0,#+100
   \   000000B6   0x0006             MOVS     R6,R0
   \                     ??EMAC_Init_5: (+1)
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD001             BEQ.N    ??EMAC_Init_6
   \   000000BC   0x1E76             SUBS     R6,R6,#+1
   \   000000BE   0xE7FB             B.N      ??EMAC_Init_5
    290          	LPC_EMAC->SUPP = 0;
   \                     ??EMAC_Init_6: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable24_32  ;; 0x50000018
   \   000000C6   0x6008             STR      R0,[R1, #+0]
    291          
    292          	/* Put the DP83848C in reset mode */
    293          	write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_BMCR_RESET);
   \   000000C8   0xF44F 0x4100      MOV      R1,#+32768
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x.... 0x....      BL       write_PHY
    294          
    295          	/* Wait for hardware reset to end. */
    296          	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
   \   000000D2   0xF45F 0x1080      MOVS     R0,#+1048576
   \   000000D6   0x0006             MOVS     R6,R0
   \                     ??EMAC_Init_7: (+1)
   \   000000D8   0x2E00             CMP      R6,#+0
   \   000000DA   0xD00C             BEQ.N    ??EMAC_Init_8
    297          		regv = read_PHY (EMAC_PHY_REG_BMCR);
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      BL       read_PHY
   \   000000E2   0x0005             MOVS     R5,R0
    298          		if (!(regv & (EMAC_PHY_BMCR_RESET | EMAC_PHY_BMCR_POWERDOWN))) {
   \   000000E4   0xF415 0x4F08      TST      R5,#0x8800
   \   000000E8   0xD005             BEQ.N    ??EMAC_Init_8
    299          			/* Reset complete, device not Power Down. */
    300          			break;
    301          		}
    302          		if (tout == 0){
   \                     ??EMAC_Init_9: (+1)
   \   000000EA   0x2E00             CMP      R6,#+0
   \   000000EC   0xD101             BNE.N    ??EMAC_Init_10
    303          			// Time out, return ERROR
    304          			return (ERROR);
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE02D             B.N      ??EMAC_Init_11
    305          		}
    306          	}
   \                     ??EMAC_Init_10: (+1)
   \   000000F2   0x1E76             SUBS     R6,R6,#+1
   \   000000F4   0xE7F0             B.N      ??EMAC_Init_7
    307          
    308          	// Set PHY mode
    309          	if (EMAC_SetPHYMode(EMAC_ConfigStruct->Mode) < 0){
   \                     ??EMAC_Init_8: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x.... 0x....      BL       EMAC_SetPHYMode
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD501             BPL.N    ??EMAC_Init_12
    310          		return (ERROR);
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xE024             B.N      ??EMAC_Init_11
    311          	}
    312          
    313          	// Set EMAC address
    314          	setEmacAddr(EMAC_ConfigStruct->pbEMAC_Addr);
   \                     ??EMAC_Init_12: (+1)
   \   00000104   0x6860             LDR      R0,[R4, #+4]
   \   00000106   0x.... 0x....      BL       setEmacAddr
    315          
    316          	/* Initialize Tx and Rx DMA Descriptors */
    317          	rx_descr_init ();
   \   0000010A   0x.... 0x....      BL       rx_descr_init
    318          	tx_descr_init ();
   \   0000010E   0x.... 0x....      BL       tx_descr_init
    319          
    320          	// Set Receive Filter register: enable broadcast and multicast
    321          	LPC_EMAC->RxFilterCtrl = EMAC_RFC_MCAST_EN | EMAC_RFC_BCAST_EN | EMAC_RFC_PERFECT_EN;
   \   00000112   0x2026             MOVS     R0,#+38
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable24_33  ;; 0x50000200
   \   00000118   0x6008             STR      R0,[R1, #+0]
    322          
    323          	/* Enable Rx Done and Tx Done interrupt for EMAC */
    324          	LPC_EMAC->IntEnable = EMAC_INT_RX_DONE | EMAC_INT_TX_DONE;
   \   0000011A   0x2088             MOVS     R0,#+136
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable24_34  ;; 0x50000fe4
   \   00000120   0x6008             STR      R0,[R1, #+0]
    325          
    326          	/* Reset all interrupts */
    327          	LPC_EMAC->IntClear  = 0xFFFF;
   \   00000122   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable24_35  ;; 0x50000fe8
   \   0000012A   0x6008             STR      R0,[R1, #+0]
    328          
    329          	/* Enable receive and transmit mode of MAC Ethernet core */
    330          	LPC_EMAC->Command  |= (EMAC_CR_RX_EN | EMAC_CR_TX_EN);
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable24_23  ;; 0x50000100
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable24_23  ;; 0x50000100
   \   0000013A   0x6008             STR      R0,[R1, #+0]
    331          	LPC_EMAC->MAC1     |= EMAC_MAC1_REC_EN;
   \   0000013C   0xF05F 0x40A0      MOVS     R0,#+1342177280
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000146   0xF05F 0x41A0      MOVS     R1,#+1342177280
   \   0000014A   0x6008             STR      R0,[R1, #+0]
    332          
    333          	return SUCCESS;
   \   0000014C   0x2001             MOVS     R0,#+1
   \                     ??EMAC_Init_11: (+1)
   \   0000014E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    334          }
    335          
    336          
    337          /*********************************************************************//**
    338           * @brief		De-initializes the EMAC peripheral registers to their
    339          *                  default reset values.
    340           * @param[in]	None
    341           * @return 		None
    342           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    343          void EMAC_DeInit(void)
    344          {
   \                     EMAC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    345          	// Disable all interrupt
    346          	LPC_EMAC->IntEnable = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable24_34  ;; 0x50000fe4
   \   00000008   0x6008             STR      R0,[R1, #+0]
    347          	// Clear all pending interrupt
    348          	LPC_EMAC->IntClear = (0xFF) | (EMAC_INT_SOFT_INT | EMAC_INT_WAKEUP);
   \   0000000A   0xF243 0x00FF      MOVW     R0,#+12543
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable24_35  ;; 0x50000fe8
   \   00000012   0x6008             STR      R0,[R1, #+0]
    349          
    350          	/* TurnOff clock and power for Ethernet module */
    351          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCENET, DISABLE);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000001A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    352          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    353          
    354          
    355          /*********************************************************************//**
    356           * @brief		Check specified PHY status in EMAC peripheral
    357           * @param[in]	ulPHYState	Specified PHY Status Type, should be:
    358           * 							- EMAC_PHY_STAT_LINK: Link Status
    359           * 							- EMAC_PHY_STAT_SPEED: Speed Status
    360           * 							- EMAC_PHY_STAT_DUP: Duplex Status
    361           * @return		Status of specified PHY status (0 or 1).
    362           * 				(-1) if error.
    363           *
    364           * Note:
    365           * For EMAC_PHY_STAT_LINK, return value:
    366           * - 0: Link Down
    367           * - 1: Link Up
    368           * For EMAC_PHY_STAT_SPEED, return value:
    369           * - 0: 10Mbps
    370           * - 1: 100Mbps
    371           * For EMAC_PHY_STAT_DUP, return value:
    372           * - 0: Half-Duplex
    373           * - 1: Full-Duplex
    374           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          int32_t EMAC_CheckPHYStatus(uint32_t ulPHYState)
    376          {
   \                     EMAC_CheckPHYStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    377          	int32_t regv, tmp;
    378          
    379          	regv = read_PHY (EMAC_PHY_REG_STS);
   \   00000004   0x2010             MOVS     R0,#+16
   \   00000006   0x.... 0x....      BL       read_PHY
   \   0000000A   0x0005             MOVS     R5,R0
    380          	switch(ulPHYState){
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD003             BEQ.N    ??EMAC_CheckPHYStatus_0
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD00E             BEQ.N    ??EMAC_CheckPHYStatus_1
   \   00000014   0xD304             BCC.N    ??EMAC_CheckPHYStatus_2
   \   00000016   0xE012             B.N      ??EMAC_CheckPHYStatus_3
    381          	case EMAC_PHY_STAT_LINK:
    382          		tmp = (regv & EMAC_PHY_SR_LINK) ? 1 : 0;
   \                     ??EMAC_CheckPHYStatus_0: (+1)
   \   00000018   0xF015 0x0001      ANDS     R0,R5,#0x1
   \   0000001C   0x0006             MOVS     R6,R0
    383          		break;
   \   0000001E   0xE011             B.N      ??EMAC_CheckPHYStatus_4
    384          	case EMAC_PHY_STAT_SPEED:
    385          		tmp = (regv & EMAC_PHY_SR_SPEED) ? 0 : 1;
   \                     ??EMAC_CheckPHYStatus_2: (+1)
   \   00000020   0xF3C5 0x0040      UBFX     R0,R5,#+1,#+1
   \   00000024   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000028   0xF090 0x0001      EORS     R0,R0,#0x1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x0006             MOVS     R6,R0
    386          		break;
   \   00000030   0xE008             B.N      ??EMAC_CheckPHYStatus_4
    387          	case EMAC_PHY_STAT_DUP:
    388          		tmp = (regv & EMAC_PHY_SR_DUP) ? 1 : 0;
   \                     ??EMAC_CheckPHYStatus_1: (+1)
   \   00000032   0xF3C5 0x0080      UBFX     R0,R5,#+2,#+1
   \   00000036   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000003A   0x0006             MOVS     R6,R0
    389          		break;
   \   0000003C   0xE002             B.N      ??EMAC_CheckPHYStatus_4
    390          	default:
    391          		tmp = -1;
   \                     ??EMAC_CheckPHYStatus_3: (+1)
   \   0000003E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000042   0x0006             MOVS     R6,R0
    392          		break;
    393          	}
    394          	return (tmp);
   \                     ??EMAC_CheckPHYStatus_4: (+1)
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    395          }
    396          
    397          
    398          /*********************************************************************//**
    399           * @brief		Set specified PHY mode in EMAC peripheral
    400           * @param[in]	ulPHYMode	Specified PHY mode, should be:
    401           * 							- EMAC_MODE_AUTO
    402           * 							- EMAC_MODE_10M_FULL
    403           * 							- EMAC_MODE_10M_HALF
    404           * 							- EMAC_MODE_100M_FULL
    405           * 							- EMAC_MODE_100M_HALF
    406           * @return		Return (0) if no error, otherwise return (-1)
    407           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          int32_t EMAC_SetPHYMode(uint32_t ulPHYMode)
    409          {
   \                     EMAC_SetPHYMode: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    410          	int32_t id1, id2, tout, regv;
    411          
    412          	/* Check if this is a DP83848C PHY. */
    413          	id1 = read_PHY (EMAC_PHY_REG_IDR1);
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x.... 0x....      BL       read_PHY
   \   0000000C   0x0005             MOVS     R5,R0
    414          	id2 = read_PHY (EMAC_PHY_REG_IDR2);
   \   0000000E   0x2003             MOVS     R0,#+3
   \   00000010   0x.... 0x....      BL       read_PHY
   \   00000014   0x0006             MOVS     R6,R0
    415          
    416          	if (((id1 << 16) | (id2 & 0xFFF0)) == EMAC_DP83848C_ID) {
   \   00000016   0xF64F 0x70F0      MOVW     R0,#+65520
   \   0000001A   0x4030             ANDS     R0,R0,R6
   \   0000001C   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable24_36  ;; 0x20005c90
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD140             BNE.N    ??EMAC_SetPHYMode_0
    417          		/* Configure the PHY device */
    418          		switch(ulPHYMode){
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD006             BEQ.N    ??EMAC_SetPHYMode_1
   \   0000002C   0x2C02             CMP      R4,#+2
   \   0000002E   0xD023             BEQ.N    ??EMAC_SetPHYMode_2
   \   00000030   0xD31C             BCC.N    ??EMAC_SetPHYMode_3
   \   00000032   0x2C04             CMP      R4,#+4
   \   00000034   0xD02B             BEQ.N    ??EMAC_SetPHYMode_4
   \   00000036   0xD324             BCC.N    ??EMAC_SetPHYMode_5
   \   00000038   0xE02F             B.N      ??EMAC_SetPHYMode_6
    419          		case EMAC_MODE_AUTO:
    420          			/* Use auto-negotiation about the link speed. */
    421          			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_AUTO_NEG);
   \                     ??EMAC_SetPHYMode_1: (+1)
   \   0000003A   0xF44F 0x5140      MOV      R1,#+12288
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       write_PHY
    422          			/* Wait to complete Auto_Negotiation */
    423          			for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
   \   00000044   0xF45F 0x1080      MOVS     R0,#+1048576
   \   00000048   0x0007             MOVS     R7,R0
   \                     ??EMAC_SetPHYMode_7: (+1)
   \   0000004A   0x2F00             CMP      R7,#+0
   \   0000004C   0xD00D             BEQ.N    ??EMAC_SetPHYMode_8
    424          				regv = read_PHY (EMAC_PHY_REG_BMSR);
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x.... 0x....      BL       read_PHY
   \   00000054   0x4680             MOV      R8,R0
    425          				if (regv & EMAC_PHY_BMSR_AUTO_DONE) {
   \   00000056   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \   0000005A   0xD406             BMI.N    ??EMAC_SetPHYMode_8
    426          					/* Auto-negotiation Complete. */
    427          					break;
    428          				}
    429          				if (tout == 0){
   \                     ??EMAC_SetPHYMode_9: (+1)
   \   0000005C   0x2F00             CMP      R7,#+0
   \   0000005E   0xD102             BNE.N    ??EMAC_SetPHYMode_10
    430          					// Time out, return error
    431          					return (-1);
   \   00000060   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000064   0xE028             B.N      ??EMAC_SetPHYMode_11
    432          				}
    433          			}
   \                     ??EMAC_SetPHYMode_10: (+1)
   \   00000066   0x1E7F             SUBS     R7,R7,#+1
   \   00000068   0xE7EF             B.N      ??EMAC_SetPHYMode_7
    434          			break;
   \                     ??EMAC_SetPHYMode_8: (+1)
   \   0000006A   0xE019             B.N      ??EMAC_SetPHYMode_12
    435          		case EMAC_MODE_10M_FULL:
    436          			/* Connect at 10MBit full-duplex */
    437          			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_10M);
   \                     ??EMAC_SetPHYMode_3: (+1)
   \   0000006C   0xF44F 0x7180      MOV      R1,#+256
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x.... 0x....      BL       write_PHY
    438          			break;
   \   00000076   0xE013             B.N      ??EMAC_SetPHYMode_12
    439          		case EMAC_MODE_10M_HALF:
    440          			/* Connect at 10MBit half-duplex */
    441          			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_10M);
   \                     ??EMAC_SetPHYMode_2: (+1)
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       write_PHY
    442          			break;
   \   00000080   0xE00E             B.N      ??EMAC_SetPHYMode_12
    443          		case EMAC_MODE_100M_FULL:
    444          			/* Connect at 100MBit full-duplex */
    445          			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_FULLD_100M);
   \                     ??EMAC_SetPHYMode_5: (+1)
   \   00000082   0xF44F 0x5104      MOV      R1,#+8448
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      BL       write_PHY
    446          			break;
   \   0000008C   0xE008             B.N      ??EMAC_SetPHYMode_12
    447          		case EMAC_MODE_100M_HALF:
    448          			/* Connect at 100MBit half-duplex */
    449          			write_PHY (EMAC_PHY_REG_BMCR, EMAC_PHY_HALFD_100M);
   \                     ??EMAC_SetPHYMode_4: (+1)
   \   0000008E   0xF44F 0x5100      MOV      R1,#+8192
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      BL       write_PHY
    450          			break;
   \   00000098   0xE002             B.N      ??EMAC_SetPHYMode_12
    451          		default:
    452          			// un-supported
    453          			return (-1);
   \                     ??EMAC_SetPHYMode_6: (+1)
   \   0000009A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000009E   0xE00B             B.N      ??EMAC_SetPHYMode_11
    454          		}
    455          	}
    456          	// It's not correct module ID
    457          	else {
    458          		return (-1);
    459          	}
    460          
    461          	// Update EMAC configuration with current PHY status
    462          	if (EMAC_UpdatePHYStatus() < 0){
   \                     ??EMAC_SetPHYMode_12: (+1)
   \   000000A0   0x.... 0x....      BL       EMAC_UpdatePHYStatus
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD506             BPL.N    ??EMAC_SetPHYMode_13
   \   000000A8   0xE002             B.N      ??EMAC_SetPHYMode_14
   \                     ??EMAC_SetPHYMode_0: (+1)
   \   000000AA   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000AE   0xE003             B.N      ??EMAC_SetPHYMode_11
    463          		return (-1);
   \                     ??EMAC_SetPHYMode_14: (+1)
   \   000000B0   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000B4   0xE000             B.N      ??EMAC_SetPHYMode_11
    464          	}
    465          
    466          	// Complete
    467          	return (0);
   \                     ??EMAC_SetPHYMode_13: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??EMAC_SetPHYMode_11: (+1)
   \   000000B8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    468          }
    469          
    470          
    471          /*********************************************************************//**
    472           * @brief		Auto-Configures value for the EMAC configuration register to
    473           * 				match with current PHY mode
    474           * @param[in]	None
    475           * @return		Return (0) if no error, otherwise return (-1)
    476           *
    477           * Note: The EMAC configuration will be auto-configured:
    478           * 		- Speed mode.
    479           * 		- Half/Full duplex mode
    480           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          int32_t EMAC_UpdatePHYStatus(void)
    482          {
   \                     EMAC_UpdatePHYStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    483          	int32_t regv, tout;
    484          
    485          	/* Check the link status. */
    486          	for (tout = EMAC_PHY_RESP_TOUT; tout; tout--) {
   \   00000002   0xF45F 0x1080      MOVS     R0,#+1048576
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??EMAC_UpdatePHYStatus_0: (+1)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD00C             BEQ.N    ??EMAC_UpdatePHYStatus_1
    487          		regv = read_PHY (EMAC_PHY_REG_STS);
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       read_PHY
   \   00000012   0x0004             MOVS     R4,R0
    488          		if (regv & EMAC_PHY_SR_LINK) {
   \   00000014   0x07E0             LSLS     R0,R4,#+31
   \   00000016   0xD406             BMI.N    ??EMAC_UpdatePHYStatus_1
    489          			/* Link is on. */
    490          			break;
    491          		}
    492          		if (tout == 0){
   \                     ??EMAC_UpdatePHYStatus_2: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD102             BNE.N    ??EMAC_UpdatePHYStatus_3
    493          			// time out
    494          			return (-1);
   \   0000001C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000020   0xE029             B.N      ??EMAC_UpdatePHYStatus_4
    495          		}
    496          	}
   \                     ??EMAC_UpdatePHYStatus_3: (+1)
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
   \   00000024   0xE7F0             B.N      ??EMAC_UpdatePHYStatus_0
    497          
    498          	/* Configure Full/Half Duplex mode. */
    499          	if (regv & EMAC_PHY_SR_DUP) {
   \                     ??EMAC_UpdatePHYStatus_1: (+1)
   \   00000026   0x0760             LSLS     R0,R4,#+29
   \   00000028   0xD514             BPL.N    ??EMAC_UpdatePHYStatus_5
    500          		/* Full duplex is enabled. */
    501          		LPC_EMAC->MAC2    |= EMAC_MAC2_FULL_DUP;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable24_24  ;; 0x50000004
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable24_24  ;; 0x50000004
   \   00000038   0x6008             STR      R0,[R1, #+0]
    502          		LPC_EMAC->Command |= EMAC_CR_FULL_DUP;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable24_23  ;; 0x50000100
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable24_23  ;; 0x50000100
   \   00000048   0x6008             STR      R0,[R1, #+0]
    503          		LPC_EMAC->IPGT     = EMAC_IPGT_FULL_DUP;
   \   0000004A   0x2015             MOVS     R0,#+21
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable24_37  ;; 0x50000008
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE003             B.N      ??EMAC_UpdatePHYStatus_6
    504          	} else {
    505          		/* Half duplex mode. */
    506          		LPC_EMAC->IPGT = EMAC_IPGT_HALF_DUP;
   \                     ??EMAC_UpdatePHYStatus_5: (+1)
   \   00000054   0x2012             MOVS     R0,#+18
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable24_37  ;; 0x50000008
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    507          	}
    508          
    509          	/* Configure 100MBit/10MBit mode. */
    510          	if (regv & EMAC_PHY_SR_SPEED) {
   \                     ??EMAC_UpdatePHYStatus_6: (+1)
   \   0000005C   0x07A0             LSLS     R0,R4,#+30
   \   0000005E   0xD504             BPL.N    ??EMAC_UpdatePHYStatus_7
    511          		/* 10MBit mode. */
    512          		LPC_EMAC->SUPP = 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable24_32  ;; 0x50000018
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE004             B.N      ??EMAC_UpdatePHYStatus_8
    513          	} else {
    514          		/* 100MBit mode. */
    515          		LPC_EMAC->SUPP = EMAC_SUPP_SPEED;
   \                     ??EMAC_UpdatePHYStatus_7: (+1)
   \   0000006A   0xF44F 0x7080      MOV      R0,#+256
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable24_32  ;; 0x50000018
   \   00000072   0x6008             STR      R0,[R1, #+0]
    516          	}
    517          
    518          	// Complete
    519          	return (0);
   \                     ??EMAC_UpdatePHYStatus_8: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \                     ??EMAC_UpdatePHYStatus_4: (+1)
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    520          }
    521          
    522          
    523          /*********************************************************************//**
    524           * @brief		Enable/Disable hash filter functionality for specified destination
    525           * 				MAC address in EMAC module
    526           * @param[in]	dstMAC_addr		Pointer to the first MAC destination address, should
    527           * 								be 6-bytes length, in order LSB to the MSB
    528           * @param[in]	NewState		New State of this command, should be:
    529           *									- ENABLE.
    530           *									- DISABLE.
    531           * @return		None
    532           *
    533           * Note:
    534           * The standard Ethernet cyclic redundancy check (CRC) function is calculated from
    535           * the 6 byte destination address in the Ethernet frame (this CRC is calculated
    536           * anyway as part of calculating the CRC of the whole frame), then bits [28:23] out of
    537           * the 32 bits CRC result are taken to form the hash. The 6 bit hash is used to access
    538           * the hash table: it is used as an index in the 64 bit HashFilter register that has been
    539           * programmed with accept values. If the selected accept value is 1, the frame is
    540           * accepted.
    541           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    542          void EMAC_SetHashFilter(uint8_t dstMAC_addr[], FunctionalState NewState)
    543          {
   \                     EMAC_SetHashFilter: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    544          	uint32_t *pReg;
    545          	uint32_t tmp;
    546          	int32_t crc;
    547          
    548          	// Calculate the CRC from the destination MAC address
    549          	crc = EMAC_CRCCalc(dstMAC_addr, 6);
   \   00000008   0x2106             MOVS     R1,#+6
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       EMAC_CRCCalc
   \   00000010   0x0006             MOVS     R6,R0
    550          	// Extract the value from CRC to get index value for hash filter table
    551          	crc = (crc >> 23) & 0x3F;
   \   00000012   0xF3C6 0x56C5      UBFX     R6,R6,#+23,#+6
    552          
    553          	pReg = (crc > 31) ? ((uint32_t *)&LPC_EMAC->HashFilterH) \
    554          								: ((uint32_t *)&LPC_EMAC->HashFilterL);
   \   00000016   0x2E20             CMP      R6,#+32
   \   00000018   0xDB02             BLT.N    ??EMAC_SetHashFilter_0
   \   0000001A   0x.... 0x....      LDR.W    R7,??DataTable24_38  ;; 0x50000214
   \   0000001E   0xE001             B.N      ??EMAC_SetHashFilter_1
   \                     ??EMAC_SetHashFilter_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R7,??DataTable24_39  ;; 0x50000210
    555          	tmp = (crc > 31) ? (crc - 32) : crc;
   \                     ??EMAC_SetHashFilter_1: (+1)
   \   00000024   0x2E20             CMP      R6,#+32
   \   00000026   0xDB02             BLT.N    ??EMAC_SetHashFilter_2
   \   00000028   0xF1B6 0x0820      SUBS     R8,R6,#+32
   \   0000002C   0xE000             B.N      ??EMAC_SetHashFilter_3
   \                     ??EMAC_SetHashFilter_2: (+1)
   \   0000002E   0x46B0             MOV      R8,R6
    556          	if (NewState == ENABLE) {
   \                     ??EMAC_SetHashFilter_3: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD106             BNE.N    ??EMAC_SetHashFilter_4
    557          		(*pReg) |= (1UL << tmp);
   \   00000036   0x6838             LDR      R0,[R7, #+0]
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xFA11 0xF108      LSLS     R1,R1,R8
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x6038             STR      R0,[R7, #+0]
   \   00000042   0xE005             B.N      ??EMAC_SetHashFilter_5
    558          	} else {
    559          		(*pReg) &= ~(1UL << tmp);
   \                     ??EMAC_SetHashFilter_4: (+1)
   \   00000044   0x6838             LDR      R0,[R7, #+0]
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0xFA11 0xF108      LSLS     R1,R1,R8
   \   0000004C   0x4388             BICS     R0,R0,R1
   \   0000004E   0x6038             STR      R0,[R7, #+0]
    560          	}
    561          	// Enable Rx Filter
    562          	LPC_EMAC->Command &= ~EMAC_CR_PASS_RX_FILT;
   \                     ??EMAC_SetHashFilter_5: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable24_23  ;; 0x50000100
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000058   0x....             LDR.N    R1,??DataTable24_23  ;; 0x50000100
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    563          }
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    564          
    565          
    566          /*********************************************************************//**
    567           * @brief		Calculates CRC code for number of bytes in the frame
    568           * @param[in]	frame_no_fcs	Pointer to the first byte of the frame
    569           * @param[in]	frame_len		length of the frame without the FCS
    570           * @return		the CRC as a 32 bit integer
    571           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    572          int32_t EMAC_CRCCalc(uint8_t frame_no_fcs[], int32_t frame_len)
    573          {
   \                     EMAC_CRCCalc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0003             MOVS     R3,R0
   \   00000006   0x000A             MOVS     R2,R1
    574          	int i; 		// iterator
    575          	int j; 		// another iterator
    576          	char byte; 	// current byte
    577          	int crc; 	// CRC result
    578          	int q0, q1, q2, q3; // temporary variables
    579          	crc = 0xFFFFFFFF;
   \   00000008   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000C   0x0008             MOVS     R0,R1
    580          	for (i = 0; i < frame_len; i++) {
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x000C             MOVS     R4,R1
   \                     ??EMAC_CRCCalc_0: (+1)
   \   00000012   0x4294             CMP      R4,R2
   \   00000014   0xDA44             BGE.N    ??EMAC_CRCCalc_1
    581          		byte = *frame_no_fcs++;
   \   00000016   0x7819             LDRB     R1,[R3, #+0]
   \   00000018   0x000E             MOVS     R6,R1
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
    582          		for (j = 0; j < 2; j++) {
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x000D             MOVS     R5,R1
   \                     ??EMAC_CRCCalc_2: (+1)
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xDA3B             BGE.N    ??EMAC_CRCCalc_3
    583          			if (((crc >> 28) ^ (byte >> 3)) & 0x00000001) {
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x08C9             LSRS     R1,R1,#+3
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0xEA91 0x7120      EORS     R1,R1,R0, ASR #+28
   \   00000030   0x07C9             LSLS     R1,R1,#+31
   \   00000032   0xD502             BPL.N    ??EMAC_CRCCalc_4
    584          				q3 = 0x04C11DB7;
   \   00000034   0x....             LDR.N    R1,??DataTable24_40  ;; 0x4c11db7
   \   00000036   0x4688             MOV      R8,R1
   \   00000038   0xE001             B.N      ??EMAC_CRCCalc_5
    585          			} else {
    586          				q3 = 0x00000000;
   \                     ??EMAC_CRCCalc_4: (+1)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x4688             MOV      R8,R1
    587          			}
    588          			if (((crc >> 29) ^ (byte >> 2)) & 0x00000001) {
   \                     ??EMAC_CRCCalc_5: (+1)
   \   0000003E   0x0031             MOVS     R1,R6
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x0889             LSRS     R1,R1,#+2
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xEA91 0x7160      EORS     R1,R1,R0, ASR #+29
   \   0000004A   0x07C9             LSLS     R1,R1,#+31
   \   0000004C   0xD502             BPL.N    ??EMAC_CRCCalc_6
    589          				q2 = 0x09823B6E;
   \   0000004E   0x....             LDR.N    R1,??DataTable24_41  ;; 0x9823b6e
   \   00000050   0x468E             MOV      LR,R1
   \   00000052   0xE001             B.N      ??EMAC_CRCCalc_7
    590          			} else {
    591          				q2 = 0x00000000;
   \                     ??EMAC_CRCCalc_6: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x468E             MOV      LR,R1
    592          			}
    593          			if (((crc >> 30) ^ (byte >> 1)) & 0x00000001) {
   \                     ??EMAC_CRCCalc_7: (+1)
   \   00000058   0x0031             MOVS     R1,R6
   \   0000005A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005C   0x0849             LSRS     R1,R1,#+1
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0xEA91 0x71A0      EORS     R1,R1,R0, ASR #+30
   \   00000064   0x07C9             LSLS     R1,R1,#+31
   \   00000066   0xD502             BPL.N    ??EMAC_CRCCalc_8
    594          				q1 = 0x130476DC;
   \   00000068   0x....             LDR.N    R1,??DataTable24_42  ;; 0x130476dc
   \   0000006A   0x468C             MOV      R12,R1
   \   0000006C   0xE001             B.N      ??EMAC_CRCCalc_9
    595          			} else {
    596          				q1 = 0x00000000;
   \                     ??EMAC_CRCCalc_8: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x468C             MOV      R12,R1
    597          			}
    598          			if (((crc >> 31) ^ (byte >> 0)) & 0x00000001) {
   \                     ??EMAC_CRCCalc_9: (+1)
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xEA96 0x71E0      EORS     R1,R6,R0, ASR #+31
   \   00000078   0x07C9             LSLS     R1,R1,#+31
   \   0000007A   0xD502             BPL.N    ??EMAC_CRCCalc_10
    599          				q0 = 0x2608EDB8;
   \   0000007C   0x....             LDR.N    R1,??DataTable24_43  ;; 0x2608edb8
   \   0000007E   0x000F             MOVS     R7,R1
   \   00000080   0xE001             B.N      ??EMAC_CRCCalc_11
    600          			} else {
    601          				q0 = 0x00000000;
   \                     ??EMAC_CRCCalc_10: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x000F             MOVS     R7,R1
    602          			}
    603          			crc = (crc << 4) ^ q3 ^ q2 ^ q1 ^ q0;
   \                     ??EMAC_CRCCalc_11: (+1)
   \   00000086   0xEA98 0x1000      EORS     R0,R8,R0, LSL #+4
   \   0000008A   0xEA9E 0x0000      EORS     R0,LR,R0
   \   0000008E   0xEA9C 0x0000      EORS     R0,R12,R0
   \   00000092   0x4078             EORS     R0,R7,R0
    604          			byte >>= 4;
   \   00000094   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000096   0x0936             LSRS     R6,R6,#+4
    605          		}
   \   00000098   0x1C6D             ADDS     R5,R5,#+1
   \   0000009A   0xE7C1             B.N      ??EMAC_CRCCalc_2
    606          	}
   \                     ??EMAC_CRCCalc_3: (+1)
   \   0000009C   0x1C64             ADDS     R4,R4,#+1
   \   0000009E   0xE7B8             B.N      ??EMAC_CRCCalc_0
    607          	return crc;
   \                     ??EMAC_CRCCalc_1: (+1)
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    608          }
    609          
    610          /*********************************************************************//**
    611           * @brief		Enable/Disable Filter mode for each specified type EMAC peripheral
    612           * @param[in]	ulFilterMode	Filter mode, should be:
    613           * 								- EMAC_RFC_UCAST_EN: all frames of unicast types
    614           * 								will be accepted
    615           * 								- EMAC_RFC_BCAST_EN: broadcast frame will be
    616           * 								accepted
    617           * 								- EMAC_RFC_MCAST_EN: all frames of multicast
    618           * 								types will be accepted
    619           * 								- EMAC_RFC_UCAST_HASH_EN: The imperfect hash
    620           * 								filter will be applied to unicast addresses
    621           * 								- EMAC_RFC_MCAST_HASH_EN: The imperfect hash
    622           * 								filter will be applied to multicast addresses
    623           * 								- EMAC_RFC_PERFECT_EN: the destination address
    624           * 								will be compared with the 6 byte station address
    625           * 								programmed in the station address by the filter
    626           * 								- EMAC_RFC_MAGP_WOL_EN: the result of the magic
    627           * 								packet filter will generate a WoL interrupt when
    628           * 								there is a match
    629           * 								- EMAC_RFC_PFILT_WOL_EN: the result of the perfect address
    630           * 								matching filter and the imperfect hash filter will
    631           * 								generate a WoL interrupt when there is a match
    632           * @param[in]	NewState	New State of this command, should be:
    633           * 								- ENABLE
    634           * 								- DISABLE
    635           * @return		None
    636           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    637          void EMAC_SetFilterMode(uint32_t ulFilterMode, FunctionalState NewState)
    638          {
    639          	if (NewState == ENABLE){
   \                     EMAC_SetFilterMode: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD105             BNE.N    ??EMAC_SetFilterMode_0
    640          		LPC_EMAC->RxFilterCtrl |= ulFilterMode;
   \   00000006   0x....             LDR.N    R2,??DataTable24_33  ;; 0x50000200
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable24_33  ;; 0x50000200
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??EMAC_SetFilterMode_1
    641          	} else {
    642          		LPC_EMAC->RxFilterCtrl &= ~ulFilterMode;
   \                     ??EMAC_SetFilterMode_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable24_33  ;; 0x50000200
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable24_33  ;; 0x50000200
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    643          	}
    644          }
   \                     ??EMAC_SetFilterMode_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    645          
    646          /*********************************************************************//**
    647           * @brief		Get status of Wake On LAN Filter for each specified
    648           * 				type in EMAC peripheral, clear this status if it is set
    649           * @param[in]	ulWoLMode	WoL Filter mode, should be:
    650           * 								- EMAC_WOL_UCAST: unicast frames caused WoL
    651           * 								- EMAC_WOL_UCAST: broadcast frame caused WoL
    652           * 								- EMAC_WOL_MCAST: multicast frame caused WoL
    653           * 								- EMAC_WOL_UCAST_HASH: unicast frame that passes the
    654           * 								imperfect hash filter caused WoL
    655           * 								- EMAC_WOL_MCAST_HASH: multicast frame that passes the
    656           * 								imperfect hash filter caused WoL
    657           * 								- EMAC_WOL_PERFECT:perfect address matching filter
    658           * 								caused WoL
    659           * 								- EMAC_WOL_RX_FILTER: the receive filter caused WoL
    660           * 								- EMAC_WOL_MAG_PACKET: the magic packet filter caused WoL
    661           * @return		SET/RESET
    662           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    663          FlagStatus EMAC_GetWoLStatus(uint32_t ulWoLMode)
    664          {
   \                     EMAC_GetWoLStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    665          	if (LPC_EMAC->RxFilterWoLStatus & ulWoLMode) {
   \   00000002   0x....             LDR.N    R0,??DataTable24_44  ;; 0x50000204
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD003             BEQ.N    ??EMAC_GetWoLStatus_0
    666          		LPC_EMAC->RxFilterWoLClear = ulWoLMode;
   \   0000000A   0x....             LDR.N    R0,??DataTable24_45  ;; 0x50000208
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    667          		return SET;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??EMAC_GetWoLStatus_1
    668          	} else {
    669          		return RESET;
   \                     ??EMAC_GetWoLStatus_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??EMAC_GetWoLStatus_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    670          	}
    671          }
    672          
    673          
    674          /*********************************************************************//**
    675           * @brief		Write data to Tx packet data buffer at current index due to
    676           * 				TxProduceIndex
    677           * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
    678           * 							data that contain specified information about
    679           * 							Packet data buffer.
    680           * @return		None
    681           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    682          void EMAC_WritePacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
    683          {
   \                     EMAC_WritePacketBuffer: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    684          	uint32_t idx,len;
    685          	uint32_t *sp,*dp;
    686          
    687          	idx = LPC_EMAC->TxProduceIndex;
   \   00000002   0x....             LDR.N    R5,??DataTable24_14  ;; 0x50000128
   \   00000004   0x682D             LDR      R5,[R5, #+0]
   \   00000006   0x0029             MOVS     R1,R5
    688          	sp  = (uint32_t *)pDataStruct->pbDataBuf;
   \   00000008   0x6845             LDR      R5,[R0, #+4]
   \   0000000A   0x002A             MOVS     R2,R5
    689          	dp  = (uint32_t *)Tx_Desc[idx].Packet;
   \   0000000C   0x....             LDR.N    R5,??DataTable24_9
   \   0000000E   0xF855 0x5031      LDR      R5,[R5, R1, LSL #+3]
   \   00000012   0x002B             MOVS     R3,R5
    690          	/* Copy frame data to EMAC packet buffers. */
    691          	for (len = (pDataStruct->ulDataLen + 3) >> 2; len; len--) {
   \   00000014   0x6805             LDR      R5,[R0, #+0]
   \   00000016   0x1CED             ADDS     R5,R5,#+3
   \   00000018   0x08AD             LSRS     R5,R5,#+2
   \   0000001A   0x002C             MOVS     R4,R5
   \                     ??EMAC_WritePacketBuffer_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD005             BEQ.N    ??EMAC_WritePacketBuffer_1
    692          		*dp++ = *sp++;
   \   00000020   0x6815             LDR      R5,[R2, #+0]
   \   00000022   0x601D             STR      R5,[R3, #+0]
   \   00000024   0x1D12             ADDS     R2,R2,#+4
   \   00000026   0x1D1B             ADDS     R3,R3,#+4
    693          	}
   \   00000028   0x1E64             SUBS     R4,R4,#+1
   \   0000002A   0xE7F7             B.N      ??EMAC_WritePacketBuffer_0
    694          	Tx_Desc[idx].Ctrl = (pDataStruct->ulDataLen - 1) | (EMAC_TCTRL_INT | EMAC_TCTRL_LAST);
   \                     ??EMAC_WritePacketBuffer_1: (+1)
   \   0000002C   0x6805             LDR      R5,[R0, #+0]
   \   0000002E   0x1E6D             SUBS     R5,R5,#+1
   \   00000030   0xF055 0x4540      ORRS     R5,R5,#0xC0000000
   \   00000034   0x....             LDR.N    R6,??DataTable24_9
   \   00000036   0xEB06 0x06C1      ADD      R6,R6,R1, LSL #+3
   \   0000003A   0x6075             STR      R5,[R6, #+4]
    695          }
   \   0000003C   0xBC70             POP      {R4-R6}
   \   0000003E   0x4770             BX       LR               ;; return
    696          
    697          /*********************************************************************//**
    698           * @brief		Read data from Rx packet data buffer at current index due
    699           * 				to RxConsumeIndex
    700           * @param[in]	pDataStruct		Pointer to a EMAC_PACKETBUF_Type structure
    701           * 							data that contain specified information about
    702           * 							Packet data buffer.
    703           * @return		None
    704           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    705          void EMAC_ReadPacketBuffer(EMAC_PACKETBUF_Type *pDataStruct)
    706          {
   \                     EMAC_ReadPacketBuffer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    707          	uint32_t idx, len;
    708          	uint32_t *dp, *sp;
    709          
    710          	idx = LPC_EMAC->RxConsumeIndex;
   \   00000002   0x....             LDR.N    R5,??DataTable24_7  ;; 0x50000118
   \   00000004   0x682D             LDR      R5,[R5, #+0]
   \   00000006   0x0029             MOVS     R1,R5
    711          	dp = (uint32_t *)pDataStruct->pbDataBuf;
   \   00000008   0x6845             LDR      R5,[R0, #+4]
   \   0000000A   0x002B             MOVS     R3,R5
    712          	sp = (uint32_t *)Rx_Desc[idx].Packet;
   \   0000000C   0x....             LDR.N    R5,??DataTable24_1
   \   0000000E   0xF855 0x5031      LDR      R5,[R5, R1, LSL #+3]
   \   00000012   0x002C             MOVS     R4,R5
    713          
    714          	if (pDataStruct->pbDataBuf != NULL) {
   \   00000014   0x6845             LDR      R5,[R0, #+4]
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD00B             BEQ.N    ??EMAC_ReadPacketBuffer_0
    715          		for (len = (pDataStruct->ulDataLen + 3) >> 2; len; len--) {
   \   0000001A   0x6805             LDR      R5,[R0, #+0]
   \   0000001C   0x1CED             ADDS     R5,R5,#+3
   \   0000001E   0x08AD             LSRS     R5,R5,#+2
   \   00000020   0x002A             MOVS     R2,R5
   \                     ??EMAC_ReadPacketBuffer_1: (+1)
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD005             BEQ.N    ??EMAC_ReadPacketBuffer_0
    716          			*dp++ = *sp++;
   \   00000026   0x6825             LDR      R5,[R4, #+0]
   \   00000028   0x601D             STR      R5,[R3, #+0]
   \   0000002A   0x1D24             ADDS     R4,R4,#+4
   \   0000002C   0x1D1B             ADDS     R3,R3,#+4
    717          		}
   \   0000002E   0x1E52             SUBS     R2,R2,#+1
   \   00000030   0xE7F7             B.N      ??EMAC_ReadPacketBuffer_1
    718          	}
    719          }
   \                     ??EMAC_ReadPacketBuffer_0: (+1)
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
    720          
    721          /*********************************************************************//**
    722           * @brief		Standard EMAC IRQ Handler. This sub-routine will check
    723           * 				these following interrupt and call the call-back function
    724           * 				if they're already installed:
    725           * 				- Overrun Error interrupt in RX Queue
    726           * 				- Receive Error interrupt: AlignmentError, RangeError,
    727           * 				LengthError, SymbolError, CRCError or NoDescriptor or Overrun
    728           * 				- RX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
    729           * 				- Receive Done interrupt
    730           * 				- Transmit Under-run interrupt
    731           * 				- Transmit errors interrupt : LateCollision, ExcessiveCollision
    732           * 				and ExcessiveDefer, NoDescriptor or Under-run
    733           * 				- TX Finished Process Descriptors interrupt (ProduceIndex == ConsumeIndex)
    734           * 				- Transmit Done interrupt
    735           * 				- Interrupt triggered by software
    736           *				- Interrupt triggered by a Wakeup event detected by the receive filter
    737           * @param[in]	None
    738           * @return		None
    739           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    740          void EMAC_StandardIRQHandler(void)
    741          {
   \                     EMAC_StandardIRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    742          	/* EMAC Ethernet Controller Interrupt function. */
    743          	uint32_t n, int_stat;
    744          
    745          	// Get EMAC interrupt status
    746          	while ((int_stat = (LPC_EMAC->IntStatus & LPC_EMAC->IntEnable)) != 0) {
   \                     ??EMAC_StandardIRQHandler_0: (+1)
   \   00000002   0x....             LDR.N    R0,??DataTable24_46  ;; 0x50000fe0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable24_34  ;; 0x50000fe4
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x0005             MOVS     R5,R0
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD02B             BEQ.N    ??EMAC_StandardIRQHandler_1
    747          		// Clear interrupt status
    748          		LPC_EMAC->IntClear = int_stat;
   \   00000012   0x....             LDR.N    R0,??DataTable24_35  ;; 0x50000fe8
   \   00000014   0x6005             STR      R5,[R0, #+0]
    749          		// Execute call-back function
    750          		for (n = 0; n <= 7; n++) {
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0004             MOVS     R4,R0
   \                     ??EMAC_StandardIRQHandler_2: (+1)
   \   0000001A   0x2C08             CMP      R4,#+8
   \   0000001C   0xD20E             BCS.N    ??EMAC_StandardIRQHandler_3
    751          			if ((int_stat & (1 << n)) && (_pfnIntCbDat[n] != NULL)) {
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x40E0             LSRS     R0,R0,R4
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD508             BPL.N    ??EMAC_StandardIRQHandler_4
   \   00000026   0x....             LDR.N    R0,??DataTable24_47
   \   00000028   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??EMAC_StandardIRQHandler_4
    752          				_pfnIntCbDat[n]();
   \   00000030   0x....             LDR.N    R0,??DataTable24_47
   \   00000032   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000036   0x4780             BLX      R0
    753          			}
    754          		}
   \                     ??EMAC_StandardIRQHandler_4: (+1)
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0xE7EE             B.N      ??EMAC_StandardIRQHandler_2
    755          		// Soft interrupt
    756          		if ((int_stat & EMAC_INT_SOFT_INT) && (_pfnIntCbDat[8] != NULL)) {
   \                     ??EMAC_StandardIRQHandler_3: (+1)
   \   0000003C   0x04E8             LSLS     R0,R5,#+19
   \   0000003E   0xD506             BPL.N    ??EMAC_StandardIRQHandler_5
   \   00000040   0x....             LDR.N    R0,??DataTable24_47
   \   00000042   0x6A00             LDR      R0,[R0, #+32]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ.N    ??EMAC_StandardIRQHandler_5
    757          			_pfnIntCbDat[8]();
   \   00000048   0x....             LDR.N    R0,??DataTable24_47
   \   0000004A   0x6A00             LDR      R0,[R0, #+32]
   \   0000004C   0x4780             BLX      R0
    758          		}
    759          		// WakeUp interrupt
    760          		if ((int_stat & EMAC_INT_WAKEUP) && (_pfnIntCbDat[9] != NULL)) {
   \                     ??EMAC_StandardIRQHandler_5: (+1)
   \   0000004E   0x04A8             LSLS     R0,R5,#+18
   \   00000050   0xD5D7             BPL.N    ??EMAC_StandardIRQHandler_0
   \   00000052   0x....             LDR.N    R0,??DataTable24_47
   \   00000054   0x6A40             LDR      R0,[R0, #+36]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD0D3             BEQ.N    ??EMAC_StandardIRQHandler_0
    761          			// Clear WoL interrupt
    762          			LPC_EMAC->RxFilterWoLClear = EMAC_WOL_BITMASK;
   \   0000005A   0xF240 0x10BF      MOVW     R0,#+447
   \   0000005E   0x....             LDR.N    R1,??DataTable24_45  ;; 0x50000208
   \   00000060   0x6008             STR      R0,[R1, #+0]
    763          			_pfnIntCbDat[9]();
   \   00000062   0x....             LDR.N    R0,??DataTable24_47
   \   00000064   0x6A40             LDR      R0,[R0, #+36]
   \   00000066   0x4780             BLX      R0
   \   00000068   0xE7CB             B.N      ??EMAC_StandardIRQHandler_0
    764          		}
    765          	}
    766          }
   \                     ??EMAC_StandardIRQHandler_1: (+1)
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    767          
    768          
    769          /*********************************************************************//**
    770           * @brief		Setup/register Call-back function for each interrupt type
    771           * 				in EMAC module.
    772           * @param[in]	ulIntType	Interrupt type, should be one of the following:
    773           * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
    774           * 							- EMAC_INT_RX_ERR: Receive Error
    775           * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
    776           * 							- EMAC_INT_RX_DONE: Receive Done
    777           * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
    778           * 							- EMAC_INT_TX_ERR: Transmit Error
    779           * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
    780           * 							- EMAC_INT_TX_DONE: Transmit Done
    781           * 							- EMAC_INT_SOFT_INT: Software interrupt
    782           * 							- EMAC_INT_WAKEUP: Wakeup interrupt
    783           * @param[in]	pfnIntCb	Pointer to Call-back function used for this
    784           * 							interrupt type
    785           * @return		None
    786           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    787          void EMAC_SetupIntCBS(uint32_t ulIntType, EMAC_IntCBSType *pfnIntCb)
    788          {
    789          	/* EMAC Ethernet Controller Interrupt function. */
    790          	uint32_t n;
    791          
    792          	if (ulIntType <= EMAC_INT_TX_DONE){
   \                     EMAC_SetupIntCBS: (+1)
   \   00000000   0x2881             CMP      R0,#+129
   \   00000002   0xD20D             BCS.N    ??EMAC_SetupIntCBS_0
    793          		for (n = 0; n <= 7; n++) {
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x001A             MOVS     R2,R3
   \                     ??EMAC_SetupIntCBS_1: (+1)
   \   00000008   0x2A08             CMP      R2,#+8
   \   0000000A   0xD212             BCS.N    ??EMAC_SetupIntCBS_2
    794          			// Found it, install cbs now
    795          			if (ulIntType & (1 << n)) {
   \   0000000C   0x0003             MOVS     R3,R0
   \   0000000E   0x40D3             LSRS     R3,R3,R2
   \   00000010   0x07DB             LSLS     R3,R3,#+31
   \   00000012   0xD503             BPL.N    ??EMAC_SetupIntCBS_3
    796          				_pfnIntCbDat[n] = pfnIntCb;
   \   00000014   0x....             LDR.N    R3,??DataTable24_47
   \   00000016   0xF843 0x1022      STR      R1,[R3, R2, LSL #+2]
    797          				// Don't install cbs any more
    798          				break;
   \   0000001A   0xE00A             B.N      ??EMAC_SetupIntCBS_2
    799          			}
    800          		}
   \                     ??EMAC_SetupIntCBS_3: (+1)
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \   0000001E   0xE7F3             B.N      ??EMAC_SetupIntCBS_1
    801          	} else if (ulIntType & EMAC_INT_SOFT_INT) {
   \                     ??EMAC_SetupIntCBS_0: (+1)
   \   00000020   0x04C3             LSLS     R3,R0,#+19
   \   00000022   0xD502             BPL.N    ??EMAC_SetupIntCBS_4
    802          		_pfnIntCbDat[8] = pfnIntCb;
   \   00000024   0x....             LDR.N    R3,??DataTable24_47
   \   00000026   0x6219             STR      R1,[R3, #+32]
   \   00000028   0xE003             B.N      ??EMAC_SetupIntCBS_2
    803          	} else if (ulIntType & EMAC_INT_WAKEUP) {
   \                     ??EMAC_SetupIntCBS_4: (+1)
   \   0000002A   0x0483             LSLS     R3,R0,#+18
   \   0000002C   0xD501             BPL.N    ??EMAC_SetupIntCBS_2
    804          		_pfnIntCbDat[9] = pfnIntCb;
   \   0000002E   0x....             LDR.N    R3,??DataTable24_47
   \   00000030   0x6259             STR      R1,[R3, #+36]
    805          	}
    806          }
   \                     ??EMAC_SetupIntCBS_2: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    807          
    808          /*********************************************************************//**
    809           * @brief 		Enable/Disable interrupt for each type in EMAC
    810           * @param[in]	ulIntType	Interrupt Type, should be:
    811           * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
    812           * 							- EMAC_INT_RX_ERR: Receive Error
    813           * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
    814           * 							- EMAC_INT_RX_DONE: Receive Done
    815           * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
    816           * 							- EMAC_INT_TX_ERR: Transmit Error
    817           * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
    818           * 							- EMAC_INT_TX_DONE: Transmit Done
    819           * 							- EMAC_INT_SOFT_INT: Software interrupt
    820           * 							- EMAC_INT_WAKEUP: Wakeup interrupt
    821           * @param[in]	NewState	New State of this function, should be:
    822           * 							- ENABLE.
    823           * 							- DISABLE.
    824           * @return		None
    825           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    826          void EMAC_IntCmd(uint32_t ulIntType, FunctionalState NewState)
    827          {
    828          	if (NewState == ENABLE) {
   \                     EMAC_IntCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD105             BNE.N    ??EMAC_IntCmd_0
    829          		LPC_EMAC->IntEnable |= ulIntType;
   \   00000006   0x....             LDR.N    R2,??DataTable24_34  ;; 0x50000fe4
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable24_34  ;; 0x50000fe4
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??EMAC_IntCmd_1
    830          	} else {
    831          		LPC_EMAC->IntEnable &= ~(ulIntType);
   \                     ??EMAC_IntCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable24_34  ;; 0x50000fe4
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable24_34  ;; 0x50000fe4
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    832          	}
    833          }
   \                     ??EMAC_IntCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    834          
    835          /*********************************************************************//**
    836           * @brief 		Check whether if specified interrupt flag is set or not
    837           * 				for each interrupt type in EMAC and clear interrupt pending
    838           * 				if it is set.
    839           * @param[in]	ulIntType	Interrupt Type, should be:
    840           * 							- EMAC_INT_RX_OVERRUN: Receive Overrun
    841           * 							- EMAC_INT_RX_ERR: Receive Error
    842           * 							- EMAC_INT_RX_FIN: Receive Descriptor Finish
    843           * 							- EMAC_INT_RX_DONE: Receive Done
    844           * 							- EMAC_INT_TX_UNDERRUN: Transmit Under-run
    845           * 							- EMAC_INT_TX_ERR: Transmit Error
    846           * 							- EMAC_INT_TX_FIN: Transmit descriptor finish
    847           * 							- EMAC_INT_TX_DONE: Transmit Done
    848           * 							- EMAC_INT_SOFT_INT: Software interrupt
    849           * 							- EMAC_INT_WAKEUP: Wakeup interrupt
    850           * @return		New state of specified interrupt (SET or RESET)
    851           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    852          IntStatus EMAC_IntGetStatus(uint32_t ulIntType)
    853          {
   \                     EMAC_IntGetStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    854          	if (LPC_EMAC->IntStatus & ulIntType) {
   \   00000002   0x....             LDR.N    R0,??DataTable24_46  ;; 0x50000fe0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD003             BEQ.N    ??EMAC_IntGetStatus_0
    855          		LPC_EMAC->IntClear = ulIntType;
   \   0000000A   0x....             LDR.N    R0,??DataTable24_35  ;; 0x50000fe8
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    856          		return SET;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??EMAC_IntGetStatus_1
    857          	} else {
    858          		return RESET;
   \                     ??EMAC_IntGetStatus_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??EMAC_IntGetStatus_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    859          	}
    860          }
    861          
    862          
    863          /*********************************************************************//**
    864           * @brief		Check whether if the current RxConsumeIndex is not equal to the
    865           * 				current RxProduceIndex.
    866           * @param[in]	None
    867           * @return		TRUE if they're not equal, otherwise return FALSE
    868           *
    869           * Note: In case the RxConsumeIndex is not equal to the RxProduceIndex,
    870           * it means there're available data has been received. They should be read
    871           * out and released the Receive Data Buffer by updating the RxConsumeIndex value.
    872           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    873          Bool EMAC_CheckReceiveIndex(void)
    874          {
    875          	if (LPC_EMAC->RxConsumeIndex != LPC_EMAC->RxProduceIndex) {
   \                     EMAC_CheckReceiveIndex: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24_7  ;; 0x50000118
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR.N    R1,??DataTable24_48  ;; 0x50000114
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD001             BEQ.N    ??EMAC_CheckReceiveIndex_0
    876          		return TRUE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??EMAC_CheckReceiveIndex_1
    877          	} else {
    878          		return FALSE;
   \                     ??EMAC_CheckReceiveIndex_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??EMAC_CheckReceiveIndex_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    879          	}
    880          }
    881          
    882          
    883          /*********************************************************************//**
    884           * @brief		Check whether if the current TxProduceIndex is not equal to the
    885           * 				current RxProduceIndex - 1.
    886           * @param[in]	None
    887           * @return		TRUE if they're not equal, otherwise return FALSE
    888           *
    889           * Note: In case the RxConsumeIndex is equal to the RxProduceIndex - 1,
    890           * it means the transmit buffer is available and data can be written to transmit
    891           * buffer to be sent.
    892           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    893          Bool EMAC_CheckTransmitIndex(void)
    894          {
    895          	uint32_t tmp = LPC_EMAC->TxConsumeIndex -1;
   \                     EMAC_CheckTransmitIndex: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24_49  ;; 0x5000012c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E41             SUBS     R1,R0,#+1
    896          	if (LPC_EMAC->TxProduceIndex == tmp) {
   \   00000006   0x....             LDR.N    R0,??DataTable24_14  ;; 0x50000128
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD101             BNE.N    ??EMAC_CheckTransmitIndex_0
    897          		return FALSE;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE000             B.N      ??EMAC_CheckTransmitIndex_1
    898          	} else {
    899          		return TRUE;
   \                     ??EMAC_CheckTransmitIndex_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??EMAC_CheckTransmitIndex_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    900          	}
    901          }
    902          
    903          
    904          /*********************************************************************//**
    905           * @brief		Get current status value of receive data (due to RxConsumeIndex)
    906           * @param[in]	ulRxStatType	Received Status type, should be one of following:
    907           * 							- EMAC_RINFO_CTRL_FRAME: Control Frame
    908           * 							- EMAC_RINFO_VLAN: VLAN Frame
    909           * 							- EMAC_RINFO_FAIL_FILT: RX Filter Failed
    910           * 							- EMAC_RINFO_MCAST: Multicast Frame
    911           * 							- EMAC_RINFO_BCAST: Broadcast Frame
    912           * 							- EMAC_RINFO_CRC_ERR: CRC Error in Frame
    913           * 							- EMAC_RINFO_SYM_ERR: Symbol Error from PHY
    914           * 							- EMAC_RINFO_LEN_ERR: Length Error
    915           * 							- EMAC_RINFO_RANGE_ERR: Range error(exceeded max size)
    916           * 							- EMAC_RINFO_ALIGN_ERR: Alignment error
    917           * 							- EMAC_RINFO_OVERRUN: Receive overrun
    918           * 							- EMAC_RINFO_NO_DESCR: No new Descriptor available
    919           * 							- EMAC_RINFO_LAST_FLAG: last Fragment in Frame
    920           * 							- EMAC_RINFO_ERR: Error Occurred (OR of all error)
    921           * @return		Current value of receive data (due to RxConsumeIndex)
    922           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    923          FlagStatus EMAC_CheckReceiveDataStatus(uint32_t ulRxStatType)
    924          {
    925          	uint32_t idx;
    926          	idx = LPC_EMAC->RxConsumeIndex;
   \                     EMAC_CheckReceiveDataStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable24_7  ;; 0x50000118
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x0011             MOVS     R1,R2
    927          	return (((Rx_Stat[idx].Info) & ulRxStatType) ? SET : RESET);
   \   00000006   0x....             LDR.N    R2,??DataTable24_3
   \   00000008   0xF852 0x1031      LDR      R1,[R2, R1, LSL #+3]
   \   0000000C   0x4201             TST      R1,R0
   \   0000000E   0xD001             BEQ.N    ??EMAC_CheckReceiveDataStatus_0
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE000             B.N      ??EMAC_CheckReceiveDataStatus_1
   \                     ??EMAC_CheckReceiveDataStatus_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??EMAC_CheckReceiveDataStatus_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4770             BX       LR               ;; return
    928          }
    929          
    930          
    931          /*********************************************************************//**
    932           * @brief		Get size of current Received data in received buffer (due to
    933           * 				RxConsumeIndex)
    934           * @param[in]	None
    935           * @return		Size of received data
    936           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    937          uint32_t EMAC_GetReceiveDataSize(void)
    938          {
    939          	uint32_t idx;
    940          	idx =LPC_EMAC->RxConsumeIndex;
   \                     EMAC_GetReceiveDataSize: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable24_7  ;; 0x50000118
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x0008             MOVS     R0,R1
    941          	return ((Rx_Stat[idx].Info) & EMAC_RINFO_SIZE);
   \   00000006   0x....             LDR.N    R1,??DataTable24_3
   \   00000008   0xF851 0x0030      LDR      R0,[R1, R0, LSL #+3]
   \   0000000C   0x0540             LSLS     R0,R0,#+21       ;; ZeroExtS R0,R0,#+21,#+21
   \   0000000E   0x0D40             LSRS     R0,R0,#+21
   \   00000010   0x4770             BX       LR               ;; return
    942          }
    943          
    944          /*********************************************************************//**
    945           * @brief		Increase the RxConsumeIndex (after reading the Receive buffer
    946           * 				to release the Receive buffer) and wrap-around the index if
    947           * 				it reaches the maximum Receive Number
    948           * @param[in]	None
    949           * @return		None
    950           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    951          void EMAC_UpdateRxConsumeIndex(void)
    952          {
    953          	// Get current Rx consume index
    954          	uint32_t idx = LPC_EMAC->RxConsumeIndex;
   \                     EMAC_UpdateRxConsumeIndex: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24_7  ;; 0x50000118
   \   00000002   0x6800             LDR      R0,[R0, #+0]
    955          
    956          	/* Release frame from EMAC buffer */
    957          	if (++idx == EMAC_NUM_RX_FRAG) idx = 0;
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xD101             BNE.N    ??EMAC_UpdateRxConsumeIndex_0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0008             MOVS     R0,R1
    958          	LPC_EMAC->RxConsumeIndex = idx;
   \                     ??EMAC_UpdateRxConsumeIndex_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable24_7  ;; 0x50000118
   \   00000010   0x6008             STR      R0,[R1, #+0]
    959          }
   \   00000012   0x4770             BX       LR               ;; return
    960          
    961          /*********************************************************************//**
    962           * @brief		Increase the TxProduceIndex (after writting to the Transmit buffer
    963           * 				to enable the Transmit buffer) and wrap-around the index if
    964           * 				it reaches the maximum Transmit Number
    965           * @param[in]	None
    966           * @return		None
    967           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    968          void EMAC_UpdateTxProduceIndex(void)
    969          {
    970          	// Get current Tx produce index
    971          	uint32_t idx = LPC_EMAC->TxProduceIndex;
   \                     EMAC_UpdateTxProduceIndex: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24_14  ;; 0x50000128
   \   00000002   0x6800             LDR      R0,[R0, #+0]
    972          
    973          	/* Start frame transmission */
    974          	if (++idx == EMAC_NUM_TX_FRAG) idx = 0;
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD101             BNE.N    ??EMAC_UpdateTxProduceIndex_0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0008             MOVS     R0,R1
    975          	LPC_EMAC->TxProduceIndex = idx;
   \                     ??EMAC_UpdateTxProduceIndex_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable24_14  ;; 0x50000128
   \   00000010   0x6008             STR      R0,[R1, #+0]
    976          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     rx_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     Rx_Desc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x800005FF         DC32     0x800005ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     Rx_Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x50000108         DC32     0x50000108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x5000010C         DC32     0x5000010c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x50000110         DC32     0x50000110

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x50000118         DC32     0x50000118

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     tx_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     Tx_Desc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     Tx_Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x5000011C         DC32     0x5000011c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x50000120         DC32     0x50000120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x50000124         DC32     0x50000124

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x50000128         DC32     0x50000128

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x50000028         DC32     0x50000028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x5000002C         DC32     0x5000002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x50000034         DC32     0x50000034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x50000024         DC32     0x50000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x50000030         DC32     0x50000030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x50000040         DC32     0x50000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x50000044         DC32     0x50000044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x50000048         DC32     0x50000048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_23:
   \   00000000   0x50000100         DC32     0x50000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_24:
   \   00000000   0x50000004         DC32     0x50000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_25:
   \   00000000   0x50000014         DC32     0x50000014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_26:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_27:
   \   00000000   0x002625A0         DC32     0x2625a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_28:
   \   00000000   0x........         DC32     EMAC_clkdiv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_29:
   \   00000000   0x50000020         DC32     0x50000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_30:
   \   00000000   0x50000010         DC32     0x50000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_31:
   \   00000000   0x5000000C         DC32     0x5000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_32:
   \   00000000   0x50000018         DC32     0x50000018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_33:
   \   00000000   0x50000200         DC32     0x50000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_34:
   \   00000000   0x50000FE4         DC32     0x50000fe4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_35:
   \   00000000   0x50000FE8         DC32     0x50000fe8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_36:
   \   00000000   0x20005C90         DC32     0x20005c90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_37:
   \   00000000   0x50000008         DC32     0x50000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_38:
   \   00000000   0x50000214         DC32     0x50000214

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_39:
   \   00000000   0x50000210         DC32     0x50000210

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_40:
   \   00000000   0x04C11DB7         DC32     0x4c11db7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_41:
   \   00000000   0x09823B6E         DC32     0x9823b6e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_42:
   \   00000000   0x130476DC         DC32     0x130476dc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_43:
   \   00000000   0x2608EDB8         DC32     0x2608edb8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_44:
   \   00000000   0x50000204         DC32     0x50000204

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_45:
   \   00000000   0x50000208         DC32     0x50000208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_46:
   \   00000000   0x50000FE0         DC32     0x50000fe0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_47:
   \   00000000   0x........         DC32     _pfnIntCbDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_48:
   \   00000000   0x50000114         DC32     0x50000114

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_49:
   \   00000000   0x5000012C         DC32     0x5000012c
    977          
    978          
    979          /**
    980           * @}
    981           */
    982          
    983          #endif /* _EMAC */
    984          
    985          /**
    986           * @}
    987           */
    988          
    989          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   EMAC_CRCCalc
      16   EMAC_CheckPHYStatus
        16   -> read_PHY
       0   EMAC_CheckReceiveDataStatus
       0   EMAC_CheckReceiveIndex
       0   EMAC_CheckTransmitIndex
       8   EMAC_DeInit
         8   -> CLKPWR_ConfigPPWR
       0   EMAC_GetReceiveDataSize
       0   EMAC_GetWoLStatus
      24   EMAC_Init
        24   -> CLKPWR_ConfigPPWR
        24   -> EMAC_SetPHYMode
        24   -> read_PHY
        24   -> rx_descr_init
        24   -> setEmacAddr
        24   -> tx_descr_init
        24   -> write_PHY
       0   EMAC_IntCmd
       0   EMAC_IntGetStatus
       8   EMAC_ReadPacketBuffer
       0   EMAC_SetFilterMode
      24   EMAC_SetHashFilter
        24   -> EMAC_CRCCalc
      24   EMAC_SetPHYMode
        24   -> EMAC_UpdatePHYStatus
        24   -> read_PHY
        24   -> write_PHY
       0   EMAC_SetupIntCBS
      16   EMAC_StandardIRQHandler
        16   -- Indirect call
      16   EMAC_UpdatePHYStatus
        16   -> read_PHY
       0   EMAC_UpdateRxConsumeIndex
       0   EMAC_UpdateTxProduceIndex
      12   EMAC_WritePacketBuffer
       0   read_PHY
       0   rx_descr_init
       0   setEmacAddr
       0   tx_descr_init
       4   write_PHY


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_25
       4  ??DataTable24_26
       4  ??DataTable24_27
       4  ??DataTable24_28
       4  ??DataTable24_29
       4  ??DataTable24_3
       4  ??DataTable24_30
       4  ??DataTable24_31
       4  ??DataTable24_32
       4  ??DataTable24_33
       4  ??DataTable24_34
       4  ??DataTable24_35
       4  ??DataTable24_36
       4  ??DataTable24_37
       4  ??DataTable24_38
       4  ??DataTable24_39
       4  ??DataTable24_4
       4  ??DataTable24_40
       4  ??DataTable24_41
       4  ??DataTable24_42
       4  ??DataTable24_43
       4  ??DataTable24_44
       4  ??DataTable24_45
       4  ??DataTable24_46
       4  ??DataTable24_47
       4  ??DataTable24_48
       4  ??DataTable24_49
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
     164  EMAC_CRCCalc
      72  EMAC_CheckPHYStatus
      26  EMAC_CheckReceiveDataStatus
      20  EMAC_CheckReceiveIndex
      22  EMAC_CheckTransmitIndex
      32  EMAC_DeInit
      18  EMAC_GetReceiveDataSize
      22  EMAC_GetWoLStatus
     336  EMAC_Init
      30  EMAC_IntCmd
      22  EMAC_IntGetStatus
      54  EMAC_ReadPacketBuffer
      30  EMAC_SetFilterMode
      96  EMAC_SetHashFilter
     188  EMAC_SetPHYMode
      52  EMAC_SetupIntCBS
     108  EMAC_StandardIRQHandler
     120  EMAC_UpdatePHYStatus
      20  EMAC_UpdateRxConsumeIndex
      20  EMAC_UpdateTxProduceIndex
      64  EMAC_WritePacketBuffer
       8  EMAC_clkdiv
      32  Rx_Desc
      32  Rx_Stat
      24  Tx_Desc
      12  Tx_Stat
      40  _pfnIntCbDat
      70  read_PHY
    6144  rx_buf
     108  rx_descr_init
      44  setEmacAddr
    4608  tx_buf
      94  tx_descr_init
      62  write_PHY

 
 10 892 bytes in section .bss
      8 bytes in section .rodata
  2 094 bytes in section .text
 
  2 094 bytes of CODE  memory
      8 bytes of CONST memory
 10 892 bytes of DATA  memory

Errors: none
Warnings: 2
