###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:06
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_i2c.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_i2c.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_i2c.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_i2c.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_i2c.c
      1          /**
      2           * @file	: lpc17xx_i2c.c
      3           * @brief	: Contains all functions support for I2C firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 9. April. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup I2C
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable18_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     27          #include "lpc17xx_clkpwr.h"
     28          #include "lpc17xx_pinsel.h"
     29          
     30          
     31          /* If this source file built with example, the LPC17xx FW library configuration
     32           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     33           * otherwise the default FW library configuration file must be included instead
     34           */
     35          #ifdef __BUILD_WITH_EXAMPLE__
     36          #include "lpc17xx_libcfg.h"
     37          #else
     38          #include "lpc17xx_libcfg_default.h"
     39          #endif /* __BUILD_WITH_EXAMPLE__ */
     40          
     41          
     42          #ifdef _I2C
     43          
     44          
     45          /* Private Types -------------------------------------------------------------- */
     46          /** @defgroup I2C_Private_Types
     47           * @{
     48           */
     49          
     50          /**
     51           * @brief I2C device configuration structure type
     52           */
     53          typedef struct
     54          {
     55            uint32_t      txrx_setup; 						/* Transmission setup */
     56            int32_t		dir;								/* Current direction phase, 0 - write, 1 - read */
     57            void		(*inthandler)(LPC_I2C_TypeDef *I2Cx);   	/* Transmission interrupt handler */
     58          } I2C_CFG_T;
     59          
     60          /**
     61           * @}
     62           */
     63          
     64          /* Private Variables ---------------------------------------------------------- */
     65          /**
     66           * @brief II2C driver data for I2C0, I2C1 and I2C2
     67           */

   \                                 In section .bss, align 4
     68          static I2C_CFG_T i2cdat[3];
   \                     i2cdat:
   \   00000000                      DS8 36
     69          
     70          
     71          
     72          /* Private Functions ---------------------------------------------------------- */
     73          /** @defgroup I2C_Private_Functions
     74           * @{
     75           */
     76          
     77          /* Generate a start condition on I2C bus (in master mode only) */
     78          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx);
     79          
     80          /* Generate a stop condition on I2C bus (in master mode only) */
     81          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx);
     82          
     83          /* I2C send byte subroutine */
     84          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte);
     85          
     86          /* I2C get byte subroutine */
     87          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack);
     88          
     89          /* I2C interrupt master handler */
     90          void I2C_MasterHandler (LPC_I2C_TypeDef *I2Cx);
     91          
     92          /* I2C interrupt master handler */
     93          void I2C_SlaveHandler (LPC_I2C_TypeDef *I2Cx);
     94          
     95          /* Enable interrupt for I2C device */
     96          void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState);
     97          
     98          /*--------------------------------------------------------------------------------*/
     99          
    100          /**
    101           * @brief Convert from I2C peripheral to number
    102           */

   \                                 In section .text, align 2, keep-with-next
    103          static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx){
   \                     I2C_getNum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    104          	if (I2Cx == LPC_I2C0) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??I2C_getNum_0
    105          		return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE00D             B.N      ??I2C_getNum_1
    106          	} else if (I2Cx == LPC_I2C1) {
   \                     ??I2C_getNum_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD101             BNE.N    ??I2C_getNum_2
    107          		return (1);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE007             B.N      ??I2C_getNum_1
    108          	} else if (I2Cx == LPC_I2C2) {
   \                     ??I2C_getNum_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD101             BNE.N    ??I2C_getNum_3
    109          		return (2);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE001             B.N      ??I2C_getNum_1
    110          	}
    111          	return (-1);
   \                     ??I2C_getNum_3: (+1)
   \   00000026   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??I2C_getNum_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    112          }
    113          
    114          /***********************************************************************
    115           * Function: I2C_Start
    116           * Purpose: Generate a start condition on I2C bus (in master mode only)
    117           * Parameters:
    118           *     i2cdev: Pointer to I2C register
    119           *     blocking: blocking or none blocking mode
    120           * Returns: value of I2C status register after generate a start condition
    121           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    122          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx)
    123          {
    124          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     I2C_Start: (+1)
   \   00000000   0x2108             MOVS     R1,#+8
   \   00000002   0x6181             STR      R1,[R0, #+24]
    125          	I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x6001             STR      R1,[R0, #+0]
    126          
    127          	// Wait for complete
    128          	while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
   \                     ??I2C_Start_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0709             LSLS     R1,R1,#+28
   \   0000000C   0xD5FC             BPL.N    ??I2C_Start_0
    129          	I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x6181             STR      R1,[R0, #+24]
    130          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000018   0x4770             BX       LR               ;; return
    131          }
    132          
    133          
    134          /***********************************************************************
    135           * Function: I2C_Stop
    136           * Purpose: Generate a stop condition on I2C bus (in master mode only)
    137           * Parameters:
    138           *     I2Cx: Pointer to I2C register
    139           * Returns: None
    140           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    141          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx)
    142          {
    143          
    144          	/* Make sure start bit is not active */
    145          	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
   \                     I2C_Stop: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0689             LSLS     R1,R1,#+26
   \   00000004   0xD501             BPL.N    ??I2C_Stop_0
    146          	{
    147          		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x6181             STR      R1,[R0, #+24]
    148          	}
    149          	I2Cx->I2CONSET = I2C_I2CONSET_STO;
   \                     ??I2C_Stop_0: (+1)
   \   0000000A   0x2110             MOVS     R1,#+16
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    150          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x6181             STR      R1,[R0, #+24]
    151          }
   \   00000012   0x4770             BX       LR               ;; return
    152          
    153          
    154          /***********************************************************************
    155           * Function: I2C_SendByte
    156           * Purpose: Send a byte
    157           * Parameters:
    158           *     I2Cx: Pointer to I2C register
    159           * Returns: value of I2C status register after sending
    160           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    161          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte)
    162          {
    163          	/* Make sure start bit is not active */
    164          	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
   \                     I2C_SendByte: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x0692             LSLS     R2,R2,#+26
   \   00000004   0xD501             BPL.N    ??I2C_SendByte_0
    165          	{
    166          		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   00000006   0x2220             MOVS     R2,#+32
   \   00000008   0x6182             STR      R2,[R0, #+24]
    167          	}
    168          	I2Cx->I2DAT = databyte & I2C_I2DAT_BITMASK;
   \                     ??I2C_SendByte_0: (+1)
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    169          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000000E   0x2208             MOVS     R2,#+8
   \   00000010   0x6182             STR      R2,[R0, #+24]
    170          
    171          	while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
   \                     ??I2C_SendByte_1: (+1)
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x0712             LSLS     R2,R2,#+28
   \   00000016   0xD5FC             BPL.N    ??I2C_SendByte_1
    172          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   0000001E   0x4770             BX       LR               ;; return
    173          }
    174          
    175          
    176          /***********************************************************************
    177           * Function: I2C_GetByte
    178           * Purpose: Get a byte
    179           * Parameters:
    180           *     I2Cx: Pointer to I2C register
    181           * Returns: value of I2C status register after receiving
    182           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    183          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
    184          {
    185          	if (ack == TRUE)
   \                     I2C_GetByte: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xD102             BNE.N    ??I2C_GetByte_0
    186          	{
    187          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000006   0x2304             MOVS     R3,#+4
   \   00000008   0x6003             STR      R3,[R0, #+0]
   \   0000000A   0xE001             B.N      ??I2C_GetByte_1
    188          	}
    189          	else
    190          	{
    191          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   \                     ??I2C_GetByte_0: (+1)
   \   0000000C   0x2304             MOVS     R3,#+4
   \   0000000E   0x6183             STR      R3,[R0, #+24]
    192          	}
    193          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_GetByte_1: (+1)
   \   00000010   0x2308             MOVS     R3,#+8
   \   00000012   0x6183             STR      R3,[R0, #+24]
    194          
    195          	while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
   \                     ??I2C_GetByte_2: (+1)
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0x071B             LSLS     R3,R3,#+28
   \   00000018   0xD5FC             BPL.N    ??I2C_GetByte_2
    196          	*retdat = (uint8_t) (I2Cx->I2DAT & I2C_I2DAT_BITMASK);
   \   0000001A   0x6883             LDR      R3,[R0, #+8]
   \   0000001C   0x700B             STRB     R3,[R1, #+0]
    197          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   0000001E   0x6840             LDR      R0,[R0, #+4]
   \   00000020   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000024   0x4770             BX       LR               ;; return
    198          }
    199          
    200          
    201          
    202          /*********************************************************************//**
    203           * @brief 		Enable/Disable interrupt for I2C peripheral
    204           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    205           * @param[in]	NewState	New State of I2C peripheral interrupt in NVIC core
    206           * 							should be:
    207           * 							- ENABLE: enable interrupt for this I2C peripheral
    208           * 							- DISABLE: disable interrupt for this I2C peripheral
    209           * @return 		None
    210           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    211          void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState)
    212          {
   \                     I2C_IntCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    213          	if (NewState)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD017             BEQ.N    ??I2C_IntCmd_0
    214          	{
    215          		if(I2Cx == LPC_I2C0)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD103             BNE.N    ??I2C_IntCmd_1
    216          		{
    217          			NVIC_EnableIRQ(I2C0_IRQn);
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000001A   0xE026             B.N      ??I2C_IntCmd_2
    218          		}
    219          		else if (I2Cx == LPC_I2C1)
   \                     ??I2C_IntCmd_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD103             BNE.N    ??I2C_IntCmd_3
    220          		{
    221          			NVIC_EnableIRQ(I2C1_IRQn);
   \   00000024   0x200B             MOVS     R0,#+11
   \   00000026   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000002A   0xE01E             B.N      ??I2C_IntCmd_2
    222          		}
    223          		else if (I2Cx == LPC_I2C2)
   \                     ??I2C_IntCmd_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD11A             BNE.N    ??I2C_IntCmd_2
    224          		{
    225          			NVIC_EnableIRQ(I2C2_IRQn);
   \   00000034   0x200C             MOVS     R0,#+12
   \   00000036   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000003A   0xE016             B.N      ??I2C_IntCmd_2
    226          		}
    227          	}
    228          	else
    229          	{
    230          		if(I2Cx == LPC_I2C0)
   \                     ??I2C_IntCmd_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD103             BNE.N    ??I2C_IntCmd_4
    231          		{
    232          			NVIC_DisableIRQ(I2C0_IRQn);
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0x.... 0x....      BL       NVIC_DisableIRQ
   \   0000004A   0xE00E             B.N      ??I2C_IntCmd_2
    233          		}
    234          		else if (I2Cx == LPC_I2C1)
   \                     ??I2C_IntCmd_4: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD103             BNE.N    ??I2C_IntCmd_5
    235          		{
    236          			NVIC_DisableIRQ(I2C1_IRQn);
   \   00000054   0x200B             MOVS     R0,#+11
   \   00000056   0x.... 0x....      BL       NVIC_DisableIRQ
   \   0000005A   0xE006             B.N      ??I2C_IntCmd_2
    237          		}
    238          		else if (I2Cx == LPC_I2C2)
   \                     ??I2C_IntCmd_5: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD102             BNE.N    ??I2C_IntCmd_2
    239          		{
    240          			NVIC_DisableIRQ(I2C2_IRQn);
   \   00000064   0x200C             MOVS     R0,#+12
   \   00000066   0x.... 0x....      BL       NVIC_DisableIRQ
    241          		}
    242          	}
    243              return;
   \                     ??I2C_IntCmd_2: (+1)
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    244          }
    245          
    246          
    247          /*********************************************************************//**
    248           * @brief 		General Master Interrupt handler for I2C peripheral
    249           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    250           * @return 		None
    251           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    252          void I2C_MasterHandler (LPC_I2C_TypeDef  *I2Cx)
    253          {
   \                     I2C_MasterHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    254          	int32_t tmp;
    255          	uint8_t returnCode;
    256          	I2C_M_SETUP_Type *txrx_setup;
    257          
    258          	tmp = I2C_getNum(I2Cx);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       I2C_getNum
   \   0000000A   0x0005             MOVS     R5,R0
    259          	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[tmp].txrx_setup;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000010   0x210C             MOVS     R1,#+12
   \   00000012   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000016   0x5840             LDR      R0,[R0, R1]
   \   00000018   0x0007             MOVS     R7,R0
    260          
    261          	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000020   0x0006             MOVS     R6,R0
    262          	// Save current status
    263          	txrx_setup->status = returnCode;
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x627E             STR      R6,[R7, #+36]
    264          	// there's no relevant information
    265          	if (returnCode == I2C_I2STAT_NO_INF){
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0x2EF8             CMP      R6,#+248
   \   0000002A   0xD102             BNE.N    ??I2C_MasterHandler_0
    266          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000002C   0x2008             MOVS     R0,#+8
   \   0000002E   0x61A0             STR      R0,[R4, #+24]
    267          		return;
   \   00000030   0xE0F1             B.N      ??I2C_MasterHandler_1
    268          	}
    269          
    270          	/* ----------------------------- TRANSMIT PHASE --------------------------*/
    271          	if (i2cdat[tmp].dir == 0){
   \                     ??I2C_MasterHandler_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000036   0x210C             MOVS     R1,#+12
   \   00000038   0xFB01 0xF105      MUL      R1,R1,R5
   \   0000003C   0x4408             ADD      R0,R0,R1
   \   0000003E   0x6840             LDR      R0,[R0, #+4]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD15A             BNE.N    ??I2C_MasterHandler_2
    272          		switch (returnCode)
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x2808             CMP      R0,#+8
   \   0000004A   0xD00C             BEQ.N    ??I2C_MasterHandler_3
   \   0000004C   0x2810             CMP      R0,#+16
   \   0000004E   0xD00A             BEQ.N    ??I2C_MasterHandler_3
   \   00000050   0x2818             CMP      R0,#+24
   \   00000052   0xD017             BEQ.N    ??I2C_MasterHandler_4
   \   00000054   0x2820             CMP      R0,#+32
   \   00000056   0xD046             BEQ.N    ??I2C_MasterHandler_5
   \   00000058   0x2828             CMP      R0,#+40
   \   0000005A   0xD013             BEQ.N    ??I2C_MasterHandler_4
   \   0000005C   0x2830             CMP      R0,#+48
   \   0000005E   0xD042             BEQ.N    ??I2C_MasterHandler_5
   \   00000060   0x2838             CMP      R0,#+56
   \   00000062   0xD045             BEQ.N    ??I2C_MasterHandler_6
   \   00000064   0xE048             B.N      ??I2C_MasterHandler_7
    273          		{
    274          		/* A start/repeat start condition has been transmitted -------------------*/
    275          		case I2C_I2STAT_M_TX_START:
    276          		case I2C_I2STAT_M_TX_RESTART:
    277          			I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \                     ??I2C_MasterHandler_3: (+1)
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0x61A0             STR      R0,[R4, #+24]
    278          			/*
    279          			 * If there's any transmit data, then start to
    280          			 * send SLA+W right now, otherwise check whether if there's
    281          			 * any receive data for next state.
    282          			 */
    283          			if ((txrx_setup->tx_data != NULL) && (txrx_setup->tx_length != 0)){
   \   0000006A   0x6878             LDR      R0,[R7, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD008             BEQ.N    ??I2C_MasterHandler_8
   \   00000070   0x68B8             LDR      R0,[R7, #+8]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD005             BEQ.N    ??I2C_MasterHandler_8
    284          				I2Cx->I2DAT = (txrx_setup->sl_addr7bit << 1);
   \   00000076   0x6838             LDR      R0,[R7, #+0]
   \   00000078   0x0040             LSLS     R0,R0,#+1
   \   0000007A   0x60A0             STR      R0,[R4, #+8]
    285          				I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000007C   0x2008             MOVS     R0,#+8
   \   0000007E   0x61A0             STR      R0,[R4, #+24]
    286          			} else {
    287          				goto next_stage;
    288          			}
    289          			break;
   \   00000080   0xE0C9             B.N      ??I2C_MasterHandler_9
   \                     ??I2C_MasterHandler_8: (+1)
   \   00000082   0xE010             B.N      ??I2C_MasterHandler_10
    290          
    291          		/* SLA+W has been transmitted, ACK has been received ----------------------*/
    292          		case I2C_I2STAT_M_TX_SLAW_ACK:
    293          		/* Data has been transmitted, ACK has been received */
    294          		case I2C_I2STAT_M_TX_DAT_ACK:
    295          			/* Send more data */
    296          			if ((txrx_setup->tx_count < txrx_setup->tx_length) \
    297          					&& (txrx_setup->tx_data != NULL)){
   \                     ??I2C_MasterHandler_4: (+1)
   \   00000084   0x68F8             LDR      R0,[R7, #+12]
   \   00000086   0x68B9             LDR      R1,[R7, #+8]
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xD20C             BCS.N    ??I2C_MasterHandler_10
   \   0000008C   0x6878             LDR      R0,[R7, #+4]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD009             BEQ.N    ??I2C_MasterHandler_10
    298          				I2Cx->I2DAT =  *(uint8_t *)(txrx_setup->tx_data + txrx_setup->tx_count);
   \   00000092   0x6878             LDR      R0,[R7, #+4]
   \   00000094   0x68F9             LDR      R1,[R7, #+12]
   \   00000096   0x5C40             LDRB     R0,[R0, R1]
   \   00000098   0x60A0             STR      R0,[R4, #+8]
    299          				txrx_setup->tx_count++;
   \   0000009A   0x68F8             LDR      R0,[R7, #+12]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x60F8             STR      R0,[R7, #+12]
    300          				I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000A0   0x2008             MOVS     R0,#+8
   \   000000A2   0x61A0             STR      R0,[R4, #+24]
   \   000000A4   0xE01E             B.N      ??I2C_MasterHandler_11
    301          			}
    302          			// no more data, switch to next stage
    303          			else {
    304          next_stage:
    305          				// change direction
    306          				i2cdat[tmp].dir = 1;
   \                     ??I2C_MasterHandler_10: (+1)
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   000000AC   0x220C             MOVS     R2,#+12
   \   000000AE   0xFB02 0xF205      MUL      R2,R2,R5
   \   000000B2   0x4411             ADD      R1,R1,R2
   \   000000B4   0x6048             STR      R0,[R1, #+4]
    307          				// Check if any data to receive
    308          				if ((txrx_setup->rx_length != 0) && (txrx_setup->rx_data != NULL)){
   \   000000B6   0x6978             LDR      R0,[R7, #+20]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD00E             BEQ.N    ??I2C_MasterHandler_12
   \   000000BC   0x6938             LDR      R0,[R7, #+16]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD00B             BEQ.N    ??I2C_MasterHandler_12
    309          						// check whether if we need to issue an repeat start
    310          						if ((txrx_setup->tx_length != 0) && (txrx_setup->tx_data != NULL)){
   \   000000C2   0x68B8             LDR      R0,[R7, #+8]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD007             BEQ.N    ??I2C_MasterHandler_13
   \   000000C8   0x6878             LDR      R0,[R7, #+4]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD004             BEQ.N    ??I2C_MasterHandler_13
    311          							// Send out an repeat start command
    312          							I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   000000CE   0x2020             MOVS     R0,#+32
   \   000000D0   0x6020             STR      R0,[R4, #+0]
    313          							I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
   \   000000D2   0x200C             MOVS     R0,#+12
   \   000000D4   0x61A0             STR      R0,[R4, #+24]
   \   000000D6   0xE005             B.N      ??I2C_MasterHandler_11
    314          						}
    315          						// Don't need issue an repeat start, just goto send SLA+R
    316          						else {
    317          							goto send_slar;
   \                     ??I2C_MasterHandler_13: (+1)
   \   000000D8   0xE032             B.N      ??I2C_MasterHandler_14
    318          						}
    319          				}
    320          				// no more data send, the go to end stage now
    321          				else {
    322          					// success, goto end stage
    323          					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \                     ??I2C_MasterHandler_12: (+1)
   \   000000DA   0x6A78             LDR      R0,[R7, #+36]
   \   000000DC   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000E0   0x6278             STR      R0,[R7, #+36]
    324          					goto end_stage;
   \   000000E2   0xE08C             B.N      ??I2C_MasterHandler_15
    325          				}
    326          			}
    327          			break;
   \                     ??I2C_MasterHandler_11: (+1)
   \   000000E4   0xE097             B.N      ??I2C_MasterHandler_9
    328          
    329          		/* SLA+W has been transmitted, NACK has been received ----------------------*/
    330          		case I2C_I2STAT_M_TX_SLAW_NACK:
    331          		/* Data has been transmitted, NACK has been received -----------------------*/
    332          		case I2C_I2STAT_M_TX_DAT_NACK:
    333          			// update status
    334          			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
   \                     ??I2C_MasterHandler_5: (+1)
   \   000000E6   0x6A78             LDR      R0,[R7, #+36]
   \   000000E8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000EC   0x6278             STR      R0,[R7, #+36]
    335          			goto retry;
   \   000000EE   0xE078             B.N      ??I2C_MasterHandler_16
    336          			break;
    337          		/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
    338          		case I2C_I2STAT_M_TX_ARB_LOST:
    339          			// update status
    340          			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
   \                     ??I2C_MasterHandler_6: (+1)
   \   000000F0   0x6A78             LDR      R0,[R7, #+36]
   \   000000F2   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000000F6   0x6278             STR      R0,[R7, #+36]
    341          		default:
    342          			goto retry;
   \                     ??I2C_MasterHandler_7: (+1)
   \   000000F8   0xE073             B.N      ??I2C_MasterHandler_16
    343          			break;
    344          		}
    345          	}
    346          
    347          	/* ----------------------------- RECEIVE PHASE --------------------------*/
    348          	else if (i2cdat[tmp].dir == 1){
   \                     ??I2C_MasterHandler_2: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   000000FE   0x210C             MOVS     R1,#+12
   \   00000100   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000104   0x4408             ADD      R0,R0,R1
   \   00000106   0x6840             LDR      R0,[R0, #+4]
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xF040 0x8084      BNE.W    ??I2C_MasterHandler_9
    349          		switch (returnCode){
   \   0000010E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000110   0x0030             MOVS     R0,R6
   \   00000112   0x2808             CMP      R0,#+8
   \   00000114   0xD00C             BEQ.N    ??I2C_MasterHandler_17
   \   00000116   0x2810             CMP      R0,#+16
   \   00000118   0xD00A             BEQ.N    ??I2C_MasterHandler_17
   \   0000011A   0x2838             CMP      R0,#+56
   \   0000011C   0xD05D             BEQ.N    ??I2C_MasterHandler_18
   \   0000011E   0x2840             CMP      R0,#+64
   \   00000120   0xD01B             BEQ.N    ??I2C_MasterHandler_19
   \   00000122   0x2848             CMP      R0,#+72
   \   00000124   0xD054             BEQ.N    ??I2C_MasterHandler_20
   \   00000126   0x2850             CMP      R0,#+80
   \   00000128   0xD024             BEQ.N    ??I2C_MasterHandler_21
   \   0000012A   0x2858             CMP      R0,#+88
   \   0000012C   0xD03D             BEQ.N    ??I2C_MasterHandler_22
   \   0000012E   0xE058             B.N      ??I2C_MasterHandler_16
    350          			/* A start/repeat start condition has been transmitted ---------------------*/
    351          		case I2C_I2STAT_M_RX_START:
    352          		case I2C_I2STAT_M_RX_RESTART:
    353          			I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \                     ??I2C_MasterHandler_17: (+1)
   \   00000130   0x2020             MOVS     R0,#+32
   \   00000132   0x61A0             STR      R0,[R4, #+24]
    354          			/*
    355          			 * If there's any receive data, then start to
    356          			 * send SLA+R right now, otherwise check whether if there's
    357          			 * any receive data for end of state.
    358          			 */
    359          			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_length != 0)){
   \   00000134   0x6938             LDR      R0,[R7, #+16]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD00A             BEQ.N    ??I2C_MasterHandler_23
   \   0000013A   0x6978             LDR      R0,[R7, #+20]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD007             BEQ.N    ??I2C_MasterHandler_23
    360          send_slar:
    361          				I2Cx->I2DAT = (txrx_setup->sl_addr7bit << 1) | 0x01;
   \                     ??I2C_MasterHandler_14: (+1)
   \   00000140   0x6838             LDR      R0,[R7, #+0]
   \   00000142   0x0040             LSLS     R0,R0,#+1
   \   00000144   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000148   0x60A0             STR      R0,[R4, #+8]
    362          				I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000014A   0x2008             MOVS     R0,#+8
   \   0000014C   0x61A0             STR      R0,[R4, #+24]
    363          			} else {
    364          				// Success, goto end stage
    365          				txrx_setup->status |= I2C_SETUP_STATUS_DONE;
    366          				goto end_stage;
    367          			}
    368          			break;
   \   0000014E   0xE062             B.N      ??I2C_MasterHandler_9
   \                     ??I2C_MasterHandler_23: (+1)
   \   00000150   0x6A78             LDR      R0,[R7, #+36]
   \   00000152   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000156   0x6278             STR      R0,[R7, #+36]
   \   00000158   0xE051             B.N      ??I2C_MasterHandler_15
    369          
    370          		/* SLA+R has been transmitted, ACK has been received -----------------*/
    371          		case I2C_I2STAT_M_RX_SLAR_ACK:
    372          			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
   \                     ??I2C_MasterHandler_19: (+1)
   \   0000015A   0x69B8             LDR      R0,[R7, #+24]
   \   0000015C   0x6979             LDR      R1,[R7, #+20]
   \   0000015E   0x1E49             SUBS     R1,R1,#+1
   \   00000160   0x4288             CMP      R0,R1
   \   00000162   0xD202             BCS.N    ??I2C_MasterHandler_24
    373          				/*Data will be received,  ACK will be return*/
    374          				I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000164   0x2004             MOVS     R0,#+4
   \   00000166   0x6020             STR      R0,[R4, #+0]
   \   00000168   0xE001             B.N      ??I2C_MasterHandler_25
    375          			}
    376          			else {
    377          				/*Last data will be received,  NACK will be return*/
    378          				I2Cx->I2CONCLR = I2C_I2CONSET_AA;
   \                     ??I2C_MasterHandler_24: (+1)
   \   0000016A   0x2004             MOVS     R0,#+4
   \   0000016C   0x61A0             STR      R0,[R4, #+24]
    379          			}
    380          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_MasterHandler_25: (+1)
   \   0000016E   0x2008             MOVS     R0,#+8
   \   00000170   0x61A0             STR      R0,[R4, #+24]
    381          			break;
   \   00000172   0xE050             B.N      ??I2C_MasterHandler_9
    382          
    383          		/* Data has been received, ACK has been returned ----------------------*/
    384          		case I2C_I2STAT_M_RX_DAT_ACK:
    385          			// Note save data and increase counter first, then check later
    386          			/* Save data  */
    387          			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
   \                     ??I2C_MasterHandler_21: (+1)
   \   00000174   0x6938             LDR      R0,[R7, #+16]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD00A             BEQ.N    ??I2C_MasterHandler_26
   \   0000017A   0x69B8             LDR      R0,[R7, #+24]
   \   0000017C   0x6979             LDR      R1,[R7, #+20]
   \   0000017E   0x4288             CMP      R0,R1
   \   00000180   0xD206             BCS.N    ??I2C_MasterHandler_26
    388          				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->I2DAT & I2C_I2DAT_BITMASK);
   \   00000182   0x68A0             LDR      R0,[R4, #+8]
   \   00000184   0x6939             LDR      R1,[R7, #+16]
   \   00000186   0x69BA             LDR      R2,[R7, #+24]
   \   00000188   0x5488             STRB     R0,[R1, R2]
    389          				txrx_setup->rx_count++;
   \   0000018A   0x69B8             LDR      R0,[R7, #+24]
   \   0000018C   0x1C40             ADDS     R0,R0,#+1
   \   0000018E   0x61B8             STR      R0,[R7, #+24]
    390          			}
    391          			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
   \                     ??I2C_MasterHandler_26: (+1)
   \   00000190   0x69B8             LDR      R0,[R7, #+24]
   \   00000192   0x6979             LDR      R1,[R7, #+20]
   \   00000194   0x1E49             SUBS     R1,R1,#+1
   \   00000196   0x4288             CMP      R0,R1
   \   00000198   0xD202             BCS.N    ??I2C_MasterHandler_27
    392          				/*Data will be received,  ACK will be return*/
    393          				I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   0000019A   0x2004             MOVS     R0,#+4
   \   0000019C   0x6020             STR      R0,[R4, #+0]
   \   0000019E   0xE001             B.N      ??I2C_MasterHandler_28
    394          			}
    395          			else {
    396          				/*Last data will be received,  NACK will be return*/
    397          				I2Cx->I2CONCLR = I2C_I2CONSET_AA;
   \                     ??I2C_MasterHandler_27: (+1)
   \   000001A0   0x2004             MOVS     R0,#+4
   \   000001A2   0x61A0             STR      R0,[R4, #+24]
    398          			}
    399          
    400          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_MasterHandler_28: (+1)
   \   000001A4   0x2008             MOVS     R0,#+8
   \   000001A6   0x61A0             STR      R0,[R4, #+24]
    401          			break;
   \   000001A8   0xE035             B.N      ??I2C_MasterHandler_9
    402          
    403          		/* Data has been received, NACK has been return -------------------------*/
    404          		case I2C_I2STAT_M_RX_DAT_NACK:
    405          			/* Save the last data */
    406          			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
   \                     ??I2C_MasterHandler_22: (+1)
   \   000001AA   0x6938             LDR      R0,[R7, #+16]
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD00A             BEQ.N    ??I2C_MasterHandler_29
   \   000001B0   0x69B8             LDR      R0,[R7, #+24]
   \   000001B2   0x6979             LDR      R1,[R7, #+20]
   \   000001B4   0x4288             CMP      R0,R1
   \   000001B6   0xD206             BCS.N    ??I2C_MasterHandler_29
    407          				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->I2DAT & I2C_I2DAT_BITMASK);
   \   000001B8   0x68A0             LDR      R0,[R4, #+8]
   \   000001BA   0x6939             LDR      R1,[R7, #+16]
   \   000001BC   0x69BA             LDR      R2,[R7, #+24]
   \   000001BE   0x5488             STRB     R0,[R1, R2]
    408          				txrx_setup->rx_count++;
   \   000001C0   0x69B8             LDR      R0,[R7, #+24]
   \   000001C2   0x1C40             ADDS     R0,R0,#+1
   \   000001C4   0x61B8             STR      R0,[R7, #+24]
    409          			}
    410          			// success, go to end stage
    411          			txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \                     ??I2C_MasterHandler_29: (+1)
   \   000001C6   0x6A78             LDR      R0,[R7, #+36]
   \   000001C8   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000001CC   0x6278             STR      R0,[R7, #+36]
    412          			goto end_stage;
   \   000001CE   0xE016             B.N      ??I2C_MasterHandler_15
    413          			break;
    414          
    415          		/* SLA+R has been transmitted, NACK has been received ------------------*/
    416          		case I2C_I2STAT_M_RX_SLAR_NACK:
    417          			// update status
    418          			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
   \                     ??I2C_MasterHandler_20: (+1)
   \   000001D0   0x6A78             LDR      R0,[R7, #+36]
   \   000001D2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000001D6   0x6278             STR      R0,[R7, #+36]
    419          			goto retry;
   \   000001D8   0xE003             B.N      ??I2C_MasterHandler_16
    420          			break;
    421          
    422          		/* Arbitration lost ----------------------------------------------------*/
    423          		case I2C_I2STAT_M_RX_ARB_LOST:
    424          			// update status
    425          			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
   \                     ??I2C_MasterHandler_18: (+1)
   \   000001DA   0x6A78             LDR      R0,[R7, #+36]
   \   000001DC   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000001E0   0x6278             STR      R0,[R7, #+36]
    426          		default:
    427          retry:
    428          			// check if retransmission is available
    429          			if (txrx_setup->retransmissions_count < txrx_setup->retransmissions_max){
   \                     ??I2C_MasterHandler_16: (+1)
   \   000001E2   0x6A38             LDR      R0,[R7, #+32]
   \   000001E4   0x69F9             LDR      R1,[R7, #+28]
   \   000001E6   0x4288             CMP      R0,R1
   \   000001E8   0xD209             BCS.N    ??I2C_MasterHandler_15
    430          				// Clear tx count
    431          				txrx_setup->tx_count = 0;
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0x60F8             STR      R0,[R7, #+12]
    432          				I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   000001EE   0x2020             MOVS     R0,#+32
   \   000001F0   0x6020             STR      R0,[R4, #+0]
    433          				I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
   \   000001F2   0x200C             MOVS     R0,#+12
   \   000001F4   0x61A0             STR      R0,[R4, #+24]
    434          				txrx_setup->retransmissions_count++;
   \   000001F6   0x6A38             LDR      R0,[R7, #+32]
   \   000001F8   0x1C40             ADDS     R0,R0,#+1
   \   000001FA   0x6238             STR      R0,[R7, #+32]
   \   000001FC   0xE00B             B.N      ??I2C_MasterHandler_30
    435          			}
    436          			// End of stage
    437          			else {
    438          end_stage:
    439          				// Disable interrupt
    440          				I2C_IntCmd(I2Cx, 0);
   \                     ??I2C_MasterHandler_15: (+1)
   \   000001FE   0x2100             MOVS     R1,#+0
   \   00000200   0x0020             MOVS     R0,R4
   \   00000202   0x.... 0x....      BL       I2C_IntCmd
    441          				// Send stop
    442          				I2C_Stop(I2Cx);
   \   00000206   0x0020             MOVS     R0,R4
   \   00000208   0x.... 0x....      BL       I2C_Stop
    443          				// Call callback if installed
    444          				if (txrx_setup->callback != NULL){
   \   0000020C   0x6AB8             LDR      R0,[R7, #+40]
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD001             BEQ.N    ??I2C_MasterHandler_30
    445          					txrx_setup->callback();
   \   00000212   0x6AB8             LDR      R0,[R7, #+40]
   \   00000214   0x4780             BLX      R0
    446          				}
    447          			}
    448          			break;
    449          		}
    450          	}
    451          }
   \                     ??I2C_MasterHandler_30: (+1)
   \                     ??I2C_MasterHandler_9: (+1)
   \                     ??I2C_MasterHandler_1: (+1)
   \   00000216   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    452          
    453          
    454          /*********************************************************************//**
    455           * @brief 		General Slave Interrupt handler for I2C peripheral
    456           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    457           * @return 		None
    458           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    459          void I2C_SlaveHandler (LPC_I2C_TypeDef  *I2Cx)
    460          {
   \                     I2C_SlaveHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    461          	int32_t tmp;
    462          	uint8_t returnCode;
    463          	I2C_S_SETUP_Type *txrx_setup;
    464          	uint32_t timeout;
    465          
    466          	tmp = I2C_getNum(I2Cx);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_getNum
   \   0000000C   0x0005             MOVS     R5,R0
    467          	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[tmp].txrx_setup;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000018   0x5840             LDR      R0,[R0, R1]
   \   0000001A   0x0007             MOVS     R7,R0
    468          
    469          	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000022   0x0006             MOVS     R6,R0
    470          	// Save current status
    471          	txrx_setup->status = returnCode;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x61BE             STR      R6,[R7, #+24]
    472          	// there's no relevant information
    473          	if (returnCode == I2C_I2STAT_NO_INF){
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2EF8             CMP      R6,#+248
   \   0000002C   0xD102             BNE.N    ??I2C_SlaveHandler_0
    474          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x61A0             STR      R0,[R4, #+24]
    475          		return;
   \   00000032   0xE078             B.N      ??I2C_SlaveHandler_1
    476          	}
    477          
    478          
    479          	switch (returnCode)
   \                     ??I2C_SlaveHandler_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x2860             CMP      R0,#+96
   \   0000003A   0xD018             BEQ.N    ??I2C_SlaveHandler_2
   \   0000003C   0x2870             CMP      R0,#+112
   \   0000003E   0xD016             BEQ.N    ??I2C_SlaveHandler_2
   \   00000040   0x2880             CMP      R0,#+128
   \   00000042   0xD019             BEQ.N    ??I2C_SlaveHandler_3
   \   00000044   0x2888             CMP      R0,#+136
   \   00000046   0xD02A             BEQ.N    ??I2C_SlaveHandler_4
   \   00000048   0x2890             CMP      R0,#+144
   \   0000004A   0xD015             BEQ.N    ??I2C_SlaveHandler_3
   \   0000004C   0x2898             CMP      R0,#+152
   \   0000004E   0xD026             BEQ.N    ??I2C_SlaveHandler_4
   \   00000050   0x28A0             CMP      R0,#+160
   \   00000052   0xD027             BEQ.N    ??I2C_SlaveHandler_5
   \   00000054   0x28A8             CMP      R0,#+168
   \   00000056   0xD040             BEQ.N    ??I2C_SlaveHandler_6
   \   00000058   0x28B8             CMP      R0,#+184
   \   0000005A   0xD03E             BEQ.N    ??I2C_SlaveHandler_6
   \   0000005C   0x28C0             CMP      R0,#+192
   \   0000005E   0xD04F             BEQ.N    ??I2C_SlaveHandler_7
   \   00000060   0x28F8             CMP      R0,#+248
   \   00000062   0xD155             BNE.N    ??I2C_SlaveHandler_8
    480          	{
    481          
    482          	/* No status information */
    483          	case I2C_I2STAT_NO_INF:
    484          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_9: (+1)
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x6020             STR      R0,[R4, #+0]
    485          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000068   0x2008             MOVS     R0,#+8
   \   0000006A   0x61A0             STR      R0,[R4, #+24]
    486          		break;
   \   0000006C   0xE05B             B.N      ??I2C_SlaveHandler_10
    487          
    488          	/* Reading phase -------------------------------------------------------- */
    489          	/* Own SLA+R has been received, ACK has been returned */
    490          	case I2C_I2STAT_S_RX_SLAW_ACK:
    491          	/* General call address has been received, ACK has been returned */
    492          	case I2C_I2STAT_S_RX_GENCALL_ACK:
    493          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_2: (+1)
   \   0000006E   0x2004             MOVS     R0,#+4
   \   00000070   0x6020             STR      R0,[R4, #+0]
    494          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0x61A0             STR      R0,[R4, #+24]
    495          		break;
   \   00000076   0xE056             B.N      ??I2C_SlaveHandler_10
    496          
    497          	/* Previously addressed with own SLA;
    498          	 * DATA byte has been received;
    499          	 * ACK has been returned */
    500          	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
    501          	/* DATA has been received, ACK hasn been return */
    502          	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
    503          		/*
    504          		 * All data bytes that over-flow the specified receive
    505          		 * data length, just ignore them.
    506          		 */
    507          		if ((txrx_setup->rx_count < txrx_setup->rx_length) \
    508          				&& (txrx_setup->rx_data != NULL)){
   \                     ??I2C_SlaveHandler_3: (+1)
   \   00000078   0x6978             LDR      R0,[R7, #+20]
   \   0000007A   0x6939             LDR      R1,[R7, #+16]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD209             BCS.N    ??I2C_SlaveHandler_11
   \   00000080   0x68F8             LDR      R0,[R7, #+12]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD006             BEQ.N    ??I2C_SlaveHandler_11
    509          			*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (uint8_t)I2Cx->I2DAT;
   \   00000086   0x68A0             LDR      R0,[R4, #+8]
   \   00000088   0x68F9             LDR      R1,[R7, #+12]
   \   0000008A   0x697A             LDR      R2,[R7, #+20]
   \   0000008C   0x5488             STRB     R0,[R1, R2]
    510          			txrx_setup->rx_count++;
   \   0000008E   0x6978             LDR      R0,[R7, #+20]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x6178             STR      R0,[R7, #+20]
    511          		}
    512          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_11: (+1)
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0x6020             STR      R0,[R4, #+0]
    513          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000098   0x2008             MOVS     R0,#+8
   \   0000009A   0x61A0             STR      R0,[R4, #+24]
    514          		break;
   \   0000009C   0xE043             B.N      ??I2C_SlaveHandler_10
    515          
    516          	/* Previously addressed with own SLA;
    517          	 * DATA byte has been received;
    518          	 * NOT ACK has been returned */
    519          	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
    520          	/* DATA has been received, NOT ACK has been returned */
    521          	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
    522          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveHandler_4: (+1)
   \   0000009E   0x2008             MOVS     R0,#+8
   \   000000A0   0x61A0             STR      R0,[R4, #+24]
    523          		break;
   \   000000A2   0xE040             B.N      ??I2C_SlaveHandler_10
    524          
    525          	/*
    526          	 * Note that: Return code only let us know a stop condition mixed
    527          	 * with a repeat start condition in the same code value.
    528          	 * So we should provide a time-out. In case this is really a stop
    529          	 * condition, this will return back after time out condition. Otherwise,
    530          	 * next session that is slave receive data will be completed.
    531          	 */
    532          
    533          	/* A Stop or a repeat start condition */
    534          	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
    535          		// Temporally lock the interrupt for timeout condition
    536          		I2C_IntCmd(I2Cx, 0);
   \                     ??I2C_SlaveHandler_5: (+1)
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       I2C_IntCmd
    537          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000AC   0x2008             MOVS     R0,#+8
   \   000000AE   0x61A0             STR      R0,[R4, #+24]
    538          		// enable time out
    539          		timeout = I2C_SLAVE_TIME_OUT;
   \   000000B0   0xF45F 0x3080      MOVS     R0,#+65536
   \   000000B4   0x4680             MOV      R8,R0
    540          		while(1){
    541          			if (I2Cx->I2CONSET & I2C_I2CONSET_SI){
   \                     ??I2C_SlaveHandler_12: (+1)
   \   000000B6   0x6820             LDR      R0,[R4, #+0]
   \   000000B8   0x0700             LSLS     R0,R0,#+28
   \   000000BA   0xD504             BPL.N    ??I2C_SlaveHandler_13
    542          				// re-Enable interrupt
    543          				I2C_IntCmd(I2Cx, 1);
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       I2C_IntCmd
    544          				break;
    545          			} else {
    546          				timeout--;
    547          				if (timeout == 0){
    548          					// timeout occur, it's really a stop condition
    549          					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
    550          					goto s_int_end;
    551          				}
    552          			}
    553          		}
    554          		break;
   \   000000C4   0xE02F             B.N      ??I2C_SlaveHandler_10
   \                     ??I2C_SlaveHandler_13: (+1)
   \   000000C6   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000CA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000CE   0xD1F2             BNE.N    ??I2C_SlaveHandler_12
   \   000000D0   0x69B8             LDR      R0,[R7, #+24]
   \   000000D2   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   000000D6   0x61B8             STR      R0,[R7, #+24]
   \   000000D8   0xE01A             B.N      ??I2C_SlaveHandler_8
    555          
    556          	/* Writing phase -------------------------------------------------------- */
    557          	/* Own SLA+R has been received, ACK has been returned */
    558          	case I2C_I2STAT_S_TX_SLAR_ACK:
    559          	/* Data has been transmitted, ACK has been received */
    560          	case I2C_I2STAT_S_TX_DAT_ACK:
    561          		/*
    562          		 * All data bytes that over-flow the specified receive
    563          		 * data length, just ignore them.
    564          		 */
    565          		if ((txrx_setup->tx_count < txrx_setup->tx_length) \
    566          				&& (txrx_setup->tx_data != NULL)){
   \                     ??I2C_SlaveHandler_6: (+1)
   \   000000DA   0x68B8             LDR      R0,[R7, #+8]
   \   000000DC   0x6879             LDR      R1,[R7, #+4]
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD209             BCS.N    ??I2C_SlaveHandler_14
   \   000000E2   0x6838             LDR      R0,[R7, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD006             BEQ.N    ??I2C_SlaveHandler_14
    567          			I2Cx->I2DAT = *(uint8_t *) (txrx_setup->tx_data + txrx_setup->tx_count);
   \   000000E8   0x6838             LDR      R0,[R7, #+0]
   \   000000EA   0x68B9             LDR      R1,[R7, #+8]
   \   000000EC   0x5C40             LDRB     R0,[R0, R1]
   \   000000EE   0x60A0             STR      R0,[R4, #+8]
    568          			txrx_setup->tx_count++;
   \   000000F0   0x68B8             LDR      R0,[R7, #+8]
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0x60B8             STR      R0,[R7, #+8]
    569          		}
    570          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_14: (+1)
   \   000000F6   0x2004             MOVS     R0,#+4
   \   000000F8   0x6020             STR      R0,[R4, #+0]
    571          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000FA   0x2008             MOVS     R0,#+8
   \   000000FC   0x61A0             STR      R0,[R4, #+24]
    572          		break;
   \   000000FE   0xE012             B.N      ??I2C_SlaveHandler_10
    573          
    574          	/* Data has been transmitted, NACK has been received,
    575          	 * that means there's no more data to send, exit now */
    576          	/*
    577          	 * Note: Don't wait for stop event since in slave transmit mode,
    578          	 * since there no proof lets us know when a stop signal has been received
    579          	 * on slave side.
    580          	 */
    581          	case I2C_I2STAT_S_TX_DAT_NACK:
    582          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHandler_7: (+1)
   \   00000100   0x2004             MOVS     R0,#+4
   \   00000102   0x6020             STR      R0,[R4, #+0]
    583          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000104   0x2008             MOVS     R0,#+8
   \   00000106   0x61A0             STR      R0,[R4, #+24]
    584          		txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \   00000108   0x69B8             LDR      R0,[R7, #+24]
   \   0000010A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000010E   0x61B8             STR      R0,[R7, #+24]
    585          		goto s_int_end;
    586          		break;
    587          
    588          	// Other status must be captured
    589          	default:
    590          s_int_end:
    591          		// Disable interrupt
    592          		I2C_IntCmd(I2Cx, 0);
   \                     ??I2C_SlaveHandler_8: (+1)
   \   00000110   0x2100             MOVS     R1,#+0
   \   00000112   0x0020             MOVS     R0,R4
   \   00000114   0x.... 0x....      BL       I2C_IntCmd
    593          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000118   0x202C             MOVS     R0,#+44
   \   0000011A   0x61A0             STR      R0,[R4, #+24]
    594          		// Call callback if installed
    595          		if (txrx_setup->callback != NULL){
   \   0000011C   0x69F8             LDR      R0,[R7, #+28]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD001             BEQ.N    ??I2C_SlaveHandler_15
    596          			txrx_setup->callback();
   \   00000122   0x69F8             LDR      R0,[R7, #+28]
   \   00000124   0x4780             BLX      R0
    597          		}
    598          		break;
    599          	}
    600          }
   \                     ??I2C_SlaveHandler_15: (+1)
   \                     ??I2C_SlaveHandler_10: (+1)
   \                     ??I2C_SlaveHandler_1: (+1)
   \   00000126   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    601          
    602          /**
    603           * @}
    604           */
    605          
    606          
    607          /* Public Functions ----------------------------------------------------------- */
    608          /** @addtogroup I2C_Public_Functions
    609           * @{
    610           */
    611          
    612          /*********************************************************************//**
    613           * @brief 		Setup clock rate for I2C peripheral
    614           * @param[in] 	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    615           * @param[in]	target_clock : clock of SSP (Hz)
    616           * @return 		None
    617           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    618          void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock)
    619          {
   \                     I2C_SetClock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    620          	uint32_t temp;
    621          
    622          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_SetClock_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_SetClock_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_SetClock_0
   \   0000001E   0xF240 0x216E      MOVW     R1,#+622
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   00000026   0x.... 0x....      BL       check_failed
    623          
    624          	// Get PCLK of I2C controller
    625          	if (I2Cx == LPC_I2C0)
   \                     ??I2C_SetClock_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD106             BNE.N    ??I2C_SetClock_1
    626          	{
    627          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C0) / target_clock;
   \   00000032   0x200E             MOVS     R0,#+14
   \   00000034   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000038   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0xE014             B.N      ??I2C_SetClock_2
    628          	}
    629          	else if (I2Cx == LPC_I2C1)
   \                     ??I2C_SetClock_1: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD106             BNE.N    ??I2C_SetClock_3
    630          	{
    631          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
   \   00000048   0x2026             MOVS     R0,#+38
   \   0000004A   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000004E   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000052   0x0006             MOVS     R6,R0
   \   00000054   0xE009             B.N      ??I2C_SetClock_2
    632          	}
    633          	else if (I2Cx == LPC_I2C2)
   \                     ??I2C_SetClock_3: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD105             BNE.N    ??I2C_SetClock_2
    634          	{
    635          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
   \   0000005E   0x2026             MOVS     R0,#+38
   \   00000060   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000064   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000068   0x0006             MOVS     R6,R0
    636          	}
    637          
    638          	/* Set the I2C clock value to register */
    639          	I2Cx->I2SCLH = (uint32_t)(temp / 2);
   \                     ??I2C_SetClock_2: (+1)
   \   0000006A   0x0870             LSRS     R0,R6,#+1
   \   0000006C   0x6120             STR      R0,[R4, #+16]
    640          	I2Cx->I2SCLL = (uint32_t)(temp - I2Cx->I2SCLH);
   \   0000006E   0x6920             LDR      R0,[R4, #+16]
   \   00000070   0x1A30             SUBS     R0,R6,R0
   \   00000072   0x6160             STR      R0,[R4, #+20]
    641          }
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
    642          
    643          
    644          /*********************************************************************//**
    645           * @brief		De-initializes the I2C peripheral registers to their
    646          *                  default reset values.
    647           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    648           * @return 		None
    649           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    650          void I2C_DeInit(LPC_I2C_TypeDef* I2Cx)
    651          {
   \                     I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    652          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??I2C_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??I2C_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??I2C_DeInit_0
   \   0000001C   0xF44F 0x7123      MOV      R1,#+652
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   00000024   0x.... 0x....      BL       check_failed
    653          
    654          	/* Disable I2C control */
    655          	I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
   \                     ??I2C_DeInit_0: (+1)
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x61A0             STR      R0,[R4, #+24]
    656          
    657          	if (I2Cx==LPC_I2C0)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD104             BNE.N    ??I2C_DeInit_1
    658          	{
    659          		/* Disable power for I2C0 module */
    660          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, DISABLE);
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x2080             MOVS     R0,#+128
   \   00000038   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   0000003C   0xE012             B.N      ??I2C_DeInit_2
    661          	}
    662          	else if (I2Cx==LPC_I2C1)
   \                     ??I2C_DeInit_1: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD105             BNE.N    ??I2C_DeInit_3
    663          	{
    664          		/* Disable power for I2C1 module */
    665          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000004C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000050   0xE008             B.N      ??I2C_DeInit_2
    666          	}
    667          	else if (I2Cx==LPC_I2C2)
   \                     ??I2C_DeInit_3: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD104             BNE.N    ??I2C_DeInit_2
    668          	{
    669          		/* Disable power for I2C2 module */
    670          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, DISABLE);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000060   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    671          	}
    672          }
   \                     ??I2C_DeInit_2: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    673          
    674          
    675          /********************************************************************//**
    676           * @brief		Initializes the I2Cx peripheral with specified parameter.
    677           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
    678           * @param[in]	clockrate Target clock rate value to initialized I2C
    679           * 				peripheral
    680           * @return 		None
    681           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    682          void I2C_Init(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate)
    683          {
   \                     I2C_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    684          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_Init_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_Init_0
   \   0000001E   0xF44F 0x712B      MOV      R1,#+684
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   00000026   0x.... 0x....      BL       check_failed
    685          
    686          	if (I2Cx==LPC_I2C0)
   \                     ??I2C_Init_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD108             BNE.N    ??I2C_Init_1
    687          	{
    688          		/* Set up clock and power for I2C0 module */
    689          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x2080             MOVS     R0,#+128
   \   00000036   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    690          		/* As default, peripheral clock for I2C0 module
    691          		 * is set to FCCLK / 2 */
    692          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C0, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x200E             MOVS     R0,#+14
   \   0000003E   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   00000042   0xE01C             B.N      ??I2C_Init_2
    693          	}
    694          	else if (I2Cx==LPC_I2C1)
   \                     ??I2C_Init_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD109             BNE.N    ??I2C_Init_3
    695          	{
    696          		/* Set up clock and power for I2C1 module */
    697          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, ENABLE);
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000052   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    698          		/* As default, peripheral clock for I2C1 module
    699          		 * is set to FCCLK / 2 */
    700          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C1, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x2026             MOVS     R0,#+38
   \   0000005A   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   0000005E   0xE00E             B.N      ??I2C_Init_2
    701          	}
    702          	else if (I2Cx==LPC_I2C2)
   \                     ??I2C_Init_3: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD109             BNE.N    ??I2C_Init_4
    703          	{
    704          		/* Set up clock and power for I2C2 module */
    705          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, ENABLE);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xF05F 0x6080      MOVS     R0,#+67108864
   \   0000006E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    706          		/* As default, peripheral clock for I2C2 module
    707          		 * is set to FCCLK / 2 */
    708          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C2, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x2034             MOVS     R0,#+52
   \   00000076   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   0000007A   0xE000             B.N      ??I2C_Init_2
    709          	}
    710          	else {
    711          		// Up-Support this device
    712          		return;
   \                     ??I2C_Init_4: (+1)
   \   0000007C   0xE005             B.N      ??I2C_Init_5
    713          	}
    714          
    715              /* Set clock rate */
    716              I2C_SetClock(I2Cx, clockrate);
   \                     ??I2C_Init_2: (+1)
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       I2C_SetClock
    717              /* Set I2C operation to default */
    718              I2Cx->I2CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
   \   00000086   0x2064             MOVS     R0,#+100
   \   00000088   0x61A0             STR      R0,[R4, #+24]
    719          }
   \                     ??I2C_Init_5: (+1)
   \   0000008A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    720          
    721          
    722          /*********************************************************************//**
    723           * @brief		Enable or disable I2C peripheral's operation
    724           * @param[in]	I2Cx I2C peripheral selected, should be I2C0, I2C1 or I2C2
    725           * @param[in]	NewState New State of I2Cx peripheral's operation
    726           * @return 		none
    727           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    728          void I2C_Cmd(LPC_I2C_TypeDef* I2Cx, FunctionalState NewState)
    729          {
   \                     I2C_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    730          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD008             BEQ.N    ??I2C_Cmd_0
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD005             BEQ.N    ??I2C_Cmd_0
   \   00000012   0xF240 0x21DA      MOVW     R1,#+730
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   0000001A   0x.... 0x....      BL       check_failed
    731          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \                     ??I2C_Cmd_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??I2C_Cmd_1
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??I2C_Cmd_1
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??I2C_Cmd_1
   \   00000036   0xF240 0x21DB      MOVW     R1,#+731
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   0000003E   0x.... 0x....      BL       check_failed
    732          
    733          	if (NewState == ENABLE)
   \                     ??I2C_Cmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D01             CMP      R5,#+1
   \   00000046   0xD102             BNE.N    ??I2C_Cmd_2
    734          	{
    735          		I2Cx->I2CONSET = I2C_I2CONSET_I2EN;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x6020             STR      R0,[R4, #+0]
   \   0000004C   0xE001             B.N      ??I2C_Cmd_3
    736          	}
    737          	else
    738          	{
    739          		I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
   \                     ??I2C_Cmd_2: (+1)
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x61A0             STR      R0,[R4, #+24]
    740          	}
    741          }
   \                     ??I2C_Cmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    742          
    743          
    744          /*********************************************************************//**
    745           * @brief 		Transmit and Receive data in master mode
    746           * @param[in]	I2Cx			I2C peripheral selected, should be I2C0, I2C1 or I2C2
    747           * @param[in]	TransferCfg		Pointer to a I2C_M_SETUP_Type structure that
    748           * 								contains specified information about the
    749           * 								configuration for master transfer.
    750           * @param[in]	Opt				a I2C_TRANSFER_OPT_Type type that selected for
    751           * 								interrupt or polling mode.
    752           * @return 		SUCCESS or ERROR
    753           *
    754           * Note:
    755           * - In case of using I2C to transmit data only, either transmit length set to 0
    756           * or transmit data pointer set to NULL.
    757           * - In case of using I2C to receive data only, either receive length set to 0
    758           * or receive data pointer set to NULL.
    759           * - In case of using I2C to transmit followed by receive data, transmit length,
    760           * transmit data pointer, receive length and receive data pointer should be set
    761           * corresponding.
    762           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    763          Status I2C_MasterTransferData(LPC_I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
    764          								I2C_TRANSFER_OPT_Type Opt)
    765          {
   \                     I2C_MasterTransferData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    766          	uint8_t *txdat;
    767          	uint8_t *rxdat;
    768          	uint32_t CodeStatus;
    769          	uint8_t tmp;
    770          
    771          	// reset all default state
    772          	txdat = (uint8_t *) TransferCfg->tx_data;
   \   0000000A   0x6868             LDR      R0,[R5, #+4]
   \   0000000C   0x0007             MOVS     R7,R0
    773          	rxdat = (uint8_t *) TransferCfg->rx_data;
   \   0000000E   0x6928             LDR      R0,[R5, #+16]
   \   00000010   0x4680             MOV      R8,R0
    774          	// Reset I2C setup value to default state
    775          	TransferCfg->tx_count = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60E8             STR      R0,[R5, #+12]
    776          	TransferCfg->rx_count = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x61A8             STR      R0,[R5, #+24]
    777          	TransferCfg->status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6268             STR      R0,[R5, #+36]
    778          
    779          	if (Opt == I2C_TRANSFER_POLLING){
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xF040 0x80DE      BNE.W    ??I2C_MasterTransferData_0
    780          
    781          		/* First Start condition -------------------------------------------------------------- */
    782          		TransferCfg->retransmissions_count = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6228             STR      R0,[R5, #+32]
    783          retry:
    784          		// reset all default state
    785          		txdat = (uint8_t *) TransferCfg->tx_data;
   \                     ??I2C_MasterTransferData_1: (+1)
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x0007             MOVS     R7,R0
    786          		rxdat = (uint8_t *) TransferCfg->rx_data;
   \   0000002E   0x6928             LDR      R0,[R5, #+16]
   \   00000030   0x4680             MOV      R8,R0
    787          		// Reset I2C setup value to default state
    788          		TransferCfg->tx_count = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x60E8             STR      R0,[R5, #+12]
    789          		TransferCfg->rx_count = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x61A8             STR      R0,[R5, #+24]
    790          		CodeStatus = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4681             MOV      R9,R0
    791          
    792          		// Start command
    793          		CodeStatus = I2C_Start(I2Cx);
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       I2C_Start
   \   00000044   0x4681             MOV      R9,R0
    794          		if ((CodeStatus != I2C_I2STAT_M_TX_START) \
    795          				&& (CodeStatus != I2C_I2STAT_M_TX_RESTART)){
   \   00000046   0xF1B9 0x0F08      CMP      R9,#+8
   \   0000004A   0xD00D             BEQ.N    ??I2C_MasterTransferData_2
   \   0000004C   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000050   0xD00A             BEQ.N    ??I2C_MasterTransferData_2
    796          			TransferCfg->retransmissions_count++;
   \   00000052   0x6A28             LDR      R0,[R5, #+32]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x6228             STR      R0,[R5, #+32]
    797          			if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   00000058   0x69E8             LDR      R0,[R5, #+28]
   \   0000005A   0x6A29             LDR      R1,[R5, #+32]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD202             BCS.N    ??I2C_MasterTransferData_3
    798          				// save status
    799          				TransferCfg->status = CodeStatus;
   \   00000060   0xF8C5 0x9024      STR      R9,[R5, #+36]
    800          				goto error;
   \   00000064   0xE0B8             B.N      ??I2C_MasterTransferData_4
    801          			} else {
    802          				goto retry;
   \                     ??I2C_MasterTransferData_3: (+1)
   \   00000066   0xE7E0             B.N      ??I2C_MasterTransferData_1
    803          			}
    804          		}
    805          
    806          		/* In case of sending data first --------------------------------------------------- */
    807          		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL)){
   \                     ??I2C_MasterTransferData_2: (+1)
   \   00000068   0x68A8             LDR      R0,[R5, #+8]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD035             BEQ.N    ??I2C_MasterTransferData_5
   \   0000006E   0x6868             LDR      R0,[R5, #+4]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD032             BEQ.N    ??I2C_MasterTransferData_5
    808          
    809          			/* Send slave address + WR direction bit = 0 ----------------------------------- */
    810          			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x0041             LSLS     R1,R0,#+1
   \   00000078   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       I2C_SendByte
   \   00000080   0x4681             MOV      R9,R0
    811          			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK){
   \   00000082   0xF1B9 0x0F18      CMP      R9,#+24
   \   00000086   0xD00B             BEQ.N    ??I2C_MasterTransferData_6
    812          				TransferCfg->retransmissions_count++;
   \   00000088   0x6A28             LDR      R0,[R5, #+32]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x6228             STR      R0,[R5, #+32]
    813          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   0000008E   0x69E8             LDR      R0,[R5, #+28]
   \   00000090   0x6A29             LDR      R1,[R5, #+32]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD203             BCS.N    ??I2C_MasterTransferData_7
    814          					// save status
    815          					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   00000096   0xF459 0x7000      ORRS     R0,R9,#0x200
   \   0000009A   0x6268             STR      R0,[R5, #+36]
    816          					goto error;
   \   0000009C   0xE09C             B.N      ??I2C_MasterTransferData_4
    817          				} else {
    818          					goto retry;
   \                     ??I2C_MasterTransferData_7: (+1)
   \   0000009E   0xE7C4             B.N      ??I2C_MasterTransferData_1
    819          				}
    820          			}
    821          
    822          			/* Send a number of data bytes ---------------------------------------- */
    823          			while (TransferCfg->tx_count < TransferCfg->tx_length)
   \                     ??I2C_MasterTransferData_6: (+1)
   \   000000A0   0x68E8             LDR      R0,[R5, #+12]
   \   000000A2   0x68A9             LDR      R1,[R5, #+8]
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD218             BCS.N    ??I2C_MasterTransferData_5
    824          			{
    825          				CodeStatus = I2C_SendByte(I2Cx, *txdat);
   \   000000A8   0x7839             LDRB     R1,[R7, #+0]
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       I2C_SendByte
   \   000000B0   0x4681             MOV      R9,R0
    826          				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK){
   \   000000B2   0xF1B9 0x0F28      CMP      R9,#+40
   \   000000B6   0xD00B             BEQ.N    ??I2C_MasterTransferData_8
    827          					TransferCfg->retransmissions_count++;
   \   000000B8   0x6A28             LDR      R0,[R5, #+32]
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
   \   000000BC   0x6228             STR      R0,[R5, #+32]
    828          					if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   000000BE   0x69E8             LDR      R0,[R5, #+28]
   \   000000C0   0x6A29             LDR      R1,[R5, #+32]
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xD203             BCS.N    ??I2C_MasterTransferData_9
    829          						// save status
    830          						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   000000C6   0xF459 0x7000      ORRS     R0,R9,#0x200
   \   000000CA   0x6268             STR      R0,[R5, #+36]
    831          						goto error;
   \   000000CC   0xE084             B.N      ??I2C_MasterTransferData_4
    832          					} else {
    833          						goto retry;
   \                     ??I2C_MasterTransferData_9: (+1)
   \   000000CE   0xE7AC             B.N      ??I2C_MasterTransferData_1
    834          					}
    835          				}
    836          
    837          				txdat++;
   \                     ??I2C_MasterTransferData_8: (+1)
   \   000000D0   0x1C7F             ADDS     R7,R7,#+1
    838          				TransferCfg->tx_count++;
   \   000000D2   0x68E8             LDR      R0,[R5, #+12]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x60E8             STR      R0,[R5, #+12]
   \   000000D8   0xE7E2             B.N      ??I2C_MasterTransferData_6
    839          			}
    840          		}
    841          
    842          		/* Second Start condition (Repeat Start) ------------------------------------------- */
    843          		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL) \
    844          				&& (TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
   \                     ??I2C_MasterTransferData_5: (+1)
   \   000000DA   0x68A8             LDR      R0,[R5, #+8]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD01D             BEQ.N    ??I2C_MasterTransferData_10
   \   000000E0   0x6868             LDR      R0,[R5, #+4]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD01A             BEQ.N    ??I2C_MasterTransferData_10
   \   000000E6   0x6968             LDR      R0,[R5, #+20]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD017             BEQ.N    ??I2C_MasterTransferData_10
   \   000000EC   0x6928             LDR      R0,[R5, #+16]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD014             BEQ.N    ??I2C_MasterTransferData_10
    845          
    846          			CodeStatus = I2C_Start(I2Cx);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       I2C_Start
   \   000000F8   0x4681             MOV      R9,R0
    847          			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
    848          					&& (CodeStatus != I2C_I2STAT_M_RX_RESTART)){
   \   000000FA   0xF1B9 0x0F08      CMP      R9,#+8
   \   000000FE   0xD00D             BEQ.N    ??I2C_MasterTransferData_10
   \   00000100   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000104   0xD00A             BEQ.N    ??I2C_MasterTransferData_10
    849          				TransferCfg->retransmissions_count++;
   \   00000106   0x6A28             LDR      R0,[R5, #+32]
   \   00000108   0x1C40             ADDS     R0,R0,#+1
   \   0000010A   0x6228             STR      R0,[R5, #+32]
    850          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   0000010C   0x69E8             LDR      R0,[R5, #+28]
   \   0000010E   0x6A29             LDR      R1,[R5, #+32]
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xD202             BCS.N    ??I2C_MasterTransferData_11
    851          					// Update status
    852          					TransferCfg->status = CodeStatus;
   \   00000114   0xF8C5 0x9024      STR      R9,[R5, #+36]
    853          					goto error;
   \   00000118   0xE05E             B.N      ??I2C_MasterTransferData_4
    854          				} else {
    855          					goto retry;
   \                     ??I2C_MasterTransferData_11: (+1)
   \   0000011A   0xE786             B.N      ??I2C_MasterTransferData_1
    856          				}
    857          			}
    858          		}
    859          
    860          		/* Then, start reading after sending data -------------------------------------- */
    861          		if ((TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
   \                     ??I2C_MasterTransferData_10: (+1)
   \   0000011C   0x6968             LDR      R0,[R5, #+20]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD055             BEQ.N    ??I2C_MasterTransferData_12
   \   00000122   0x6928             LDR      R0,[R5, #+16]
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD052             BEQ.N    ??I2C_MasterTransferData_12
    862          			/* Send slave address + RD direction bit = 1 ----------------------------------- */
    863          
    864          			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
   \   00000128   0x6828             LDR      R0,[R5, #+0]
   \   0000012A   0x0040             LSLS     R0,R0,#+1
   \   0000012C   0xF050 0x0101      ORRS     R1,R0,#0x1
   \   00000130   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       I2C_SendByte
   \   00000138   0x4681             MOV      R9,R0
    865          			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK){
   \   0000013A   0xF1B9 0x0F40      CMP      R9,#+64
   \   0000013E   0xD00B             BEQ.N    ??I2C_MasterTransferData_13
    866          				TransferCfg->retransmissions_count++;
   \   00000140   0x6A28             LDR      R0,[R5, #+32]
   \   00000142   0x1C40             ADDS     R0,R0,#+1
   \   00000144   0x6228             STR      R0,[R5, #+32]
    867          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   00000146   0x69E8             LDR      R0,[R5, #+28]
   \   00000148   0x6A29             LDR      R1,[R5, #+32]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD203             BCS.N    ??I2C_MasterTransferData_14
    868          					// update status
    869          					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   0000014E   0xF459 0x7000      ORRS     R0,R9,#0x200
   \   00000152   0x6268             STR      R0,[R5, #+36]
    870          					goto error;
   \   00000154   0xE040             B.N      ??I2C_MasterTransferData_4
    871          				} else {
    872          					goto retry;
   \                     ??I2C_MasterTransferData_14: (+1)
   \   00000156   0xE768             B.N      ??I2C_MasterTransferData_1
    873          				}
    874          			}
    875          
    876          			/* Receive a number of data bytes ------------------------------------------------- */
    877          			while (TransferCfg->rx_count < TransferCfg->rx_length){
   \                     ??I2C_MasterTransferData_13: (+1)
   \   00000158   0x69A8             LDR      R0,[R5, #+24]
   \   0000015A   0x6969             LDR      R1,[R5, #+20]
   \   0000015C   0x4288             CMP      R0,R1
   \   0000015E   0xD236             BCS.N    ??I2C_MasterTransferData_12
    878          
    879          				/*
    880          				 * Note that: if data length is only one, the master should not
    881          				 * issue an ACK signal on bus after reading to avoid of next data frame
    882          				 * on slave side
    883          				 */
    884          				if (TransferCfg->rx_count < (TransferCfg->rx_length - 1)){
   \   00000160   0x69A8             LDR      R0,[R5, #+24]
   \   00000162   0x6969             LDR      R1,[R5, #+20]
   \   00000164   0x1E49             SUBS     R1,R1,#+1
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xD213             BCS.N    ??I2C_MasterTransferData_15
    885          					// Issue an ACK signal for next data frame
    886          					CodeStatus = I2C_GetByte(I2Cx, &tmp, 1);
   \   0000016A   0x2201             MOVS     R2,#+1
   \   0000016C   0x4669             MOV      R1,SP
   \   0000016E   0x0020             MOVS     R0,R4
   \   00000170   0x.... 0x....      BL       I2C_GetByte
   \   00000174   0x4681             MOV      R9,R0
    887          					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK){
   \   00000176   0xF1B9 0x0F50      CMP      R9,#+80
   \   0000017A   0xD01E             BEQ.N    ??I2C_MasterTransferData_16
    888          						TransferCfg->retransmissions_count++;
   \   0000017C   0x6A28             LDR      R0,[R5, #+32]
   \   0000017E   0x1C40             ADDS     R0,R0,#+1
   \   00000180   0x6228             STR      R0,[R5, #+32]
    889          						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   00000182   0x69E8             LDR      R0,[R5, #+28]
   \   00000184   0x6A29             LDR      R1,[R5, #+32]
   \   00000186   0x4288             CMP      R0,R1
   \   00000188   0xD202             BCS.N    ??I2C_MasterTransferData_17
    890          							// update status
    891          							TransferCfg->status = CodeStatus;
   \   0000018A   0xF8C5 0x9024      STR      R9,[R5, #+36]
    892          							goto error;
   \   0000018E   0xE023             B.N      ??I2C_MasterTransferData_4
    893          						} else {
    894          							goto retry;
   \                     ??I2C_MasterTransferData_17: (+1)
   \   00000190   0xE74B             B.N      ??I2C_MasterTransferData_1
    895          						}
    896          					}
    897          				} else {
    898          					// Do not issue an ACK signal
    899          					CodeStatus = I2C_GetByte(I2Cx, &tmp, 0);
   \                     ??I2C_MasterTransferData_15: (+1)
   \   00000192   0x2200             MOVS     R2,#+0
   \   00000194   0x4669             MOV      R1,SP
   \   00000196   0x0020             MOVS     R0,R4
   \   00000198   0x.... 0x....      BL       I2C_GetByte
   \   0000019C   0x4681             MOV      R9,R0
    900          					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK){
   \   0000019E   0xF1B9 0x0F58      CMP      R9,#+88
   \   000001A2   0xD00A             BEQ.N    ??I2C_MasterTransferData_16
    901          						TransferCfg->retransmissions_count++;
   \   000001A4   0x6A28             LDR      R0,[R5, #+32]
   \   000001A6   0x1C40             ADDS     R0,R0,#+1
   \   000001A8   0x6228             STR      R0,[R5, #+32]
    902          						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   000001AA   0x69E8             LDR      R0,[R5, #+28]
   \   000001AC   0x6A29             LDR      R1,[R5, #+32]
   \   000001AE   0x4288             CMP      R0,R1
   \   000001B0   0xD202             BCS.N    ??I2C_MasterTransferData_18
    903          							// update status
    904          							TransferCfg->status = CodeStatus;
   \   000001B2   0xF8C5 0x9024      STR      R9,[R5, #+36]
    905          							goto error;
   \   000001B6   0xE00F             B.N      ??I2C_MasterTransferData_4
    906          						} else {
    907          							goto retry;
   \                     ??I2C_MasterTransferData_18: (+1)
   \   000001B8   0xE737             B.N      ??I2C_MasterTransferData_1
    908          						}
    909          					}
    910          				}
    911          				*rxdat++ = tmp;
   \                     ??I2C_MasterTransferData_16: (+1)
   \   000001BA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000001BE   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001C2   0xF118 0x0801      ADDS     R8,R8,#+1
    912          				TransferCfg->rx_count++;
   \   000001C6   0x69A8             LDR      R0,[R5, #+24]
   \   000001C8   0x1C40             ADDS     R0,R0,#+1
   \   000001CA   0x61A8             STR      R0,[R5, #+24]
   \   000001CC   0xE7C4             B.N      ??I2C_MasterTransferData_13
    913          			}
    914          		}
    915          
    916          		/* Send STOP condition ------------------------------------------------- */
    917          		I2C_Stop(I2Cx);
   \                     ??I2C_MasterTransferData_12: (+1)
   \   000001CE   0x0020             MOVS     R0,R4
   \   000001D0   0x.... 0x....      BL       I2C_Stop
    918          		return SUCCESS;
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0xE031             B.N      ??I2C_MasterTransferData_19
    919          
    920          error:
    921          		// Send stop condition
    922          		I2C_Stop(I2Cx);
   \                     ??I2C_MasterTransferData_4: (+1)
   \   000001D8   0x0020             MOVS     R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_Stop
    923          		return ERROR;
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0xE02C             B.N      ??I2C_MasterTransferData_19
    924          	}
    925          
    926          	else if (Opt == I2C_TRANSFER_INTERRUPT){
   \                     ??I2C_MasterTransferData_0: (+1)
   \   000001E2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001E4   0x2E01             CMP      R6,#+1
   \   000001E6   0xD128             BNE.N    ??I2C_MasterTransferData_20
    927          		// Setup tx_rx data, callback and interrupt handler
    928          		tmp = I2C_getNum(I2Cx);
   \   000001E8   0x0020             MOVS     R0,R4
   \   000001EA   0x.... 0x....      BL       I2C_getNum
   \   000001EE   0xF88D 0x0000      STRB     R0,[SP, #+0]
    929          		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   000001F6   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000001FA   0x220C             MOVS     R2,#+12
   \   000001FC   0x4351             MULS     R1,R2,R1
   \   000001FE   0x5045             STR      R5,[R0, R1]
    930          		i2cdat[tmp].inthandler = I2C_MasterHandler;
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   00000208   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000020C   0x230C             MOVS     R3,#+12
   \   0000020E   0x435A             MULS     R2,R3,R2
   \   00000210   0x4411             ADD      R1,R1,R2
   \   00000212   0x6088             STR      R0,[R1, #+8]
    931          		// Set direction phase, write first
    932          		i2cdat[tmp].dir = 0;
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   0000021A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   0000021E   0x230C             MOVS     R3,#+12
   \   00000220   0x435A             MULS     R2,R3,R2
   \   00000222   0x4411             ADD      R1,R1,R2
   \   00000224   0x6048             STR      R0,[R1, #+4]
    933          
    934          		/* First Start condition -------------------------------------------------------------- */
    935          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000226   0x2008             MOVS     R0,#+8
   \   00000228   0x61A0             STR      R0,[R4, #+24]
    936          		I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   0000022A   0x2020             MOVS     R0,#+32
   \   0000022C   0x6020             STR      R0,[R4, #+0]
    937          		I2C_IntCmd(I2Cx, 1);
   \   0000022E   0x2101             MOVS     R1,#+1
   \   00000230   0x0020             MOVS     R0,R4
   \   00000232   0x.... 0x....      BL       I2C_IntCmd
    938          
    939          		return (SUCCESS);
   \   00000236   0x2001             MOVS     R0,#+1
   \   00000238   0xE000             B.N      ??I2C_MasterTransferData_19
    940          	}
    941          
    942          	return ERROR;
   \                     ??I2C_MasterTransferData_20: (+1)
   \   0000023A   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterTransferData_19: (+1)
   \   0000023C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    943          }
    944          
    945          /*********************************************************************//**
    946           * @brief 		Receive and Transmit data in slave mode
    947           * @param[in]	I2Cx			I2C peripheral selected, should be I2C0, I2C1 or I2C2
    948           * @param[in]	TransferCfg		Pointer to a I2C_S_SETUP_Type structure that
    949           * 								contains specified information about the
    950           * 								configuration for master transfer.
    951           * @param[in]	Opt				I2C_TRANSFER_OPT_Type type that selected for
    952           * 								interrupt or polling mode.
    953           * @return 		SUCCESS or ERROR
    954           *
    955           * Note:
    956           * The mode of slave's operation depends on the command sent from master on
    957           * the I2C bus. If the master send a SLA+W command, this sub-routine will
    958           * use receive data length and receive data pointer. If the master send a SLA+R
    959           * command, this sub-routine will use transmit data length and transmit data
    960           * pointer.
    961           * If the master issue an repeat start command or a stop command, the slave will
    962           * enable an time out condition, during time out condition, if there's no activity
    963           * on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W),
    964           * the slave then switch to relevant operation mode. The time out should be used
    965           * because the return status code can not show difference from stop and repeat
    966           * start command in slave operation.
    967           * In case of the expected data length from master is greater than data length
    968           * that slave can support:
    969           * - In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR
    970           * value.
    971           * - In case of writing operation (from master): slave will ignore remain data from master.
    972           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    973          Status I2C_SlaveTransferData(LPC_I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
    974          								I2C_TRANSFER_OPT_Type Opt)
    975          {
   \                     I2C_SlaveTransferData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    976          	uint8_t *txdat;
    977          	uint8_t *rxdat;
    978          	uint32_t CodeStatus;
    979          	uint32_t timeout;
    980          	int32_t time_en;
    981          	int32_t tmp;
    982          
    983          	// reset all default state
    984          	txdat = (uint8_t *) TransferCfg->tx_data;
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x4682             MOV      R10,R0
    985          	rxdat = (uint8_t *) TransferCfg->rx_data;
   \   0000000E   0x68E8             LDR      R0,[R5, #+12]
   \   00000010   0x4681             MOV      R9,R0
    986          	// Reset I2C setup value to default state
    987          	TransferCfg->tx_count = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60A8             STR      R0,[R5, #+8]
    988          	TransferCfg->rx_count = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6168             STR      R0,[R5, #+20]
    989          	TransferCfg->status = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x61A8             STR      R0,[R5, #+24]
    990          
    991          
    992          	// Polling option
    993          	if (Opt == I2C_TRANSFER_POLLING){
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xF040 0x8084      BNE.W    ??I2C_SlaveTransferData_0
    994          
    995          		/* Set AA bit to ACK command on I2C bus */
    996          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x6020             STR      R0,[R4, #+0]
    997          		/* Clear SI bit to be ready ... */
    998          		I2Cx->I2CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
   \   0000002A   0x2028             MOVS     R0,#+40
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
    999          
   1000          		time_en = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4680             MOV      R8,R0
   1001          		timeout = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4683             MOV      R11,R0
   1002          
   1003          		while (1)
   1004          		{
   1005          			/* Check SI flag ready */
   1006          			if (I2Cx->I2CONSET & I2C_I2CONSET_SI)
   \                     ??I2C_SlaveTransferData_1: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x0700             LSLS     R0,R0,#+28
   \   0000003A   0xD568             BPL.N    ??I2C_SlaveTransferData_2
   1007          			{
   1008          				time_en = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4680             MOV      R8,R0
   1009          
   1010          				switch (CodeStatus = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK))
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000046   0x0007             MOVS     R7,R0
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x2860             CMP      R0,#+96
   \   0000004C   0xD018             BEQ.N    ??I2C_SlaveTransferData_3
   \   0000004E   0x2870             CMP      R0,#+112
   \   00000050   0xD016             BEQ.N    ??I2C_SlaveTransferData_3
   \   00000052   0x2880             CMP      R0,#+128
   \   00000054   0xD019             BEQ.N    ??I2C_SlaveTransferData_4
   \   00000056   0x2888             CMP      R0,#+136
   \   00000058   0xD02B             BEQ.N    ??I2C_SlaveTransferData_5
   \   0000005A   0x2890             CMP      R0,#+144
   \   0000005C   0xD015             BEQ.N    ??I2C_SlaveTransferData_4
   \   0000005E   0x2898             CMP      R0,#+152
   \   00000060   0xD027             BEQ.N    ??I2C_SlaveTransferData_5
   \   00000062   0x28A0             CMP      R0,#+160
   \   00000064   0xD028             BEQ.N    ??I2C_SlaveTransferData_6
   \   00000066   0x28A8             CMP      R0,#+168
   \   00000068   0xD02D             BEQ.N    ??I2C_SlaveTransferData_7
   \   0000006A   0x28B8             CMP      R0,#+184
   \   0000006C   0xD02B             BEQ.N    ??I2C_SlaveTransferData_7
   \   0000006E   0x28C0             CMP      R0,#+192
   \   00000070   0xD03D             BEQ.N    ??I2C_SlaveTransferData_8
   \   00000072   0x28F8             CMP      R0,#+248
   \   00000074   0xD144             BNE.N    ??I2C_SlaveTransferData_9
   1011          				{
   1012          
   1013          				/* No status information */
   1014          				case I2C_I2STAT_NO_INF:
   1015          					I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_10: (+1)
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0x6020             STR      R0,[R4, #+0]
   1016          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0x61A0             STR      R0,[R4, #+24]
   1017          					break;
   \   0000007E   0xE7DA             B.N      ??I2C_SlaveTransferData_1
   1018          
   1019          				/* Reading phase -------------------------------------------------------- */
   1020          				/* Own SLA+R has been received, ACK has been returned */
   1021          				case I2C_I2STAT_S_RX_SLAW_ACK:
   1022          				/* General call address has been received, ACK has been returned */
   1023          				case I2C_I2STAT_S_RX_GENCALL_ACK:
   1024          					I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_3: (+1)
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0x6020             STR      R0,[R4, #+0]
   1025          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0x61A0             STR      R0,[R4, #+24]
   1026          					break;
   \   00000088   0xE7D5             B.N      ??I2C_SlaveTransferData_1
   1027          
   1028          				/* Previously addressed with own SLA;
   1029          				 * DATA byte has been received;
   1030          				 * ACK has been returned */
   1031          				case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
   1032          				/* DATA has been received, ACK hasn been return */
   1033          				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
   1034          					/*
   1035          					 * All data bytes that over-flow the specified receive
   1036          					 * data length, just ignore them.
   1037          					 */
   1038          					if ((TransferCfg->rx_count < TransferCfg->rx_length) \
   1039          							&& (TransferCfg->rx_data != NULL)){
   \                     ??I2C_SlaveTransferData_4: (+1)
   \   0000008A   0x6968             LDR      R0,[R5, #+20]
   \   0000008C   0x6929             LDR      R1,[R5, #+16]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD20A             BCS.N    ??I2C_SlaveTransferData_11
   \   00000092   0x68E8             LDR      R0,[R5, #+12]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD007             BEQ.N    ??I2C_SlaveTransferData_11
   1040          						*rxdat++ = (uint8_t)I2Cx->I2DAT;
   \   00000098   0x68A0             LDR      R0,[R4, #+8]
   \   0000009A   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000009E   0xF119 0x0901      ADDS     R9,R9,#+1
   1041          						TransferCfg->rx_count++;
   \   000000A2   0x6968             LDR      R0,[R5, #+20]
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0x6168             STR      R0,[R5, #+20]
   1042          					}
   1043          					I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_11: (+1)
   \   000000A8   0x2004             MOVS     R0,#+4
   \   000000AA   0x6020             STR      R0,[R4, #+0]
   1044          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000AC   0x2008             MOVS     R0,#+8
   \   000000AE   0x61A0             STR      R0,[R4, #+24]
   1045          					break;
   \   000000B0   0xE7C1             B.N      ??I2C_SlaveTransferData_1
   1046          
   1047          				/* Previously addressed with own SLA;
   1048          				 * DATA byte has been received;
   1049          				 * NOT ACK has been returned */
   1050          				case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
   1051          				/* DATA has been received, NOT ACK has been returned */
   1052          				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
   1053          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_5: (+1)
   \   000000B2   0x2008             MOVS     R0,#+8
   \   000000B4   0x61A0             STR      R0,[R4, #+24]
   1054          					break;
   \   000000B6   0xE7BE             B.N      ??I2C_SlaveTransferData_1
   1055          
   1056          				/*
   1057          				 * Note that: Return code only let us know a stop condition mixed
   1058          				 * with a repeat start condition in the same code value.
   1059          				 * So we should provide a time-out. In case this is really a stop
   1060          				 * condition, this will return back after time out condition. Otherwise,
   1061          				 * next session that is slave receive data will be completed.
   1062          				 */
   1063          
   1064          				/* A Stop or a repeat start condition */
   1065          				case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
   1066          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_6: (+1)
   \   000000B8   0x2008             MOVS     R0,#+8
   \   000000BA   0x61A0             STR      R0,[R4, #+24]
   1067          					// enable time out
   1068          					time_en = 1;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x4680             MOV      R8,R0
   1069          					timeout = 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x4683             MOV      R11,R0
   1070          					break;
   \   000000C4   0xE7B7             B.N      ??I2C_SlaveTransferData_1
   1071          
   1072          				/* Writing phase -------------------------------------------------------- */
   1073          				/* Own SLA+R has been received, ACK has been returned */
   1074          				case I2C_I2STAT_S_TX_SLAR_ACK:
   1075          				/* Data has been transmitted, ACK has been received */
   1076          				case I2C_I2STAT_S_TX_DAT_ACK:
   1077          					/*
   1078          					 * All data bytes that over-flow the specified receive
   1079          					 * data length, just ignore them.
   1080          					 */
   1081          					if ((TransferCfg->tx_count < TransferCfg->tx_length) \
   1082          							&& (TransferCfg->tx_data != NULL)){
   \                     ??I2C_SlaveTransferData_7: (+1)
   \   000000C6   0x68A8             LDR      R0,[R5, #+8]
   \   000000C8   0x6869             LDR      R1,[R5, #+4]
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xD20A             BCS.N    ??I2C_SlaveTransferData_12
   \   000000CE   0x6828             LDR      R0,[R5, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD007             BEQ.N    ??I2C_SlaveTransferData_12
   1083          						I2Cx->I2DAT = *txdat++;
   \   000000D4   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   000000D8   0x60A0             STR      R0,[R4, #+8]
   \   000000DA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1084          						TransferCfg->tx_count++;
   \   000000DE   0x68A8             LDR      R0,[R5, #+8]
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0x60A8             STR      R0,[R5, #+8]
   1085          					}
   1086          					I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_12: (+1)
   \   000000E4   0x2004             MOVS     R0,#+4
   \   000000E6   0x6020             STR      R0,[R4, #+0]
   1087          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000E8   0x2008             MOVS     R0,#+8
   \   000000EA   0x61A0             STR      R0,[R4, #+24]
   1088          					break;
   \   000000EC   0xE7A3             B.N      ??I2C_SlaveTransferData_1
   1089          
   1090          				/* Data has been transmitted, NACK has been received,
   1091          				 * that means there's no more data to send, exit now */
   1092          				/*
   1093          				 * Note: Don't wait for stop event since in slave transmit mode,
   1094          				 * since there no proof lets us know when a stop signal has been received
   1095          				 * on slave side.
   1096          				 */
   1097          				case I2C_I2STAT_S_TX_DAT_NACK:
   1098          					I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveTransferData_8: (+1)
   \   000000EE   0x2004             MOVS     R0,#+4
   \   000000F0   0x6020             STR      R0,[R4, #+0]
   1099          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000F2   0x2008             MOVS     R0,#+8
   \   000000F4   0x61A0             STR      R0,[R4, #+24]
   1100          					// enable time out
   1101          					time_en = 1;
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x4680             MOV      R8,R0
   1102          					timeout = 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x4683             MOV      R11,R0
   1103          					break;
   \   000000FE   0xE79A             B.N      ??I2C_SlaveTransferData_1
   1104          
   1105          				// Other status must be captured
   1106          				default:
   1107          					I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveTransferData_9: (+1)
   \   00000100   0x2008             MOVS     R0,#+8
   \   00000102   0x61A0             STR      R0,[R4, #+24]
   1108          					goto s_error;
   1109          					break;
   1110          				}
   1111          			} else if (time_en){
   1112          				if (timeout++ > I2C_SLAVE_TIME_OUT){
   1113          					// it's really a stop condition, goto end stage
   1114          					goto s_end_stage;
   1115          				}
   1116          			}
   1117          		}
   1118          
   1119          s_end_stage:
   1120          		/* Clear AA bit to disable ACK on I2C bus */
   1121          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   1122          		// Check if there's no error during operation
   1123          		// Update status
   1124          		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
   1125          		return SUCCESS;
   1126          
   1127          s_error:
   1128          		/* Clear AA bit to disable ACK on I2C bus */
   1129          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   \   00000104   0x2004             MOVS     R0,#+4
   \   00000106   0x61A0             STR      R0,[R4, #+24]
   1130          		// Update status
   1131          		TransferCfg->status = CodeStatus;
   \   00000108   0x61AF             STR      R7,[R5, #+24]
   1132          		return ERROR;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xE034             B.N      ??I2C_SlaveTransferData_13
   \                     ??I2C_SlaveTransferData_2: (+1)
   \   0000010E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000112   0xD090             BEQ.N    ??I2C_SlaveTransferData_1
   \   00000114   0x4658             MOV      R0,R11
   \   00000116   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   0000011A   0xF1B0 0x1F01      CMP      R0,#+65537
   \   0000011E   0xD38A             BCC.N    ??I2C_SlaveTransferData_1
   \   00000120   0x2004             MOVS     R0,#+4
   \   00000122   0x61A0             STR      R0,[R4, #+24]
   \   00000124   0xF457 0x6080      ORRS     R0,R7,#0x400
   \   00000128   0x61A8             STR      R0,[R5, #+24]
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0xE024             B.N      ??I2C_SlaveTransferData_13
   1133          	}
   1134          
   1135          	else if (Opt == I2C_TRANSFER_INTERRUPT){
   \                     ??I2C_SlaveTransferData_0: (+1)
   \   0000012E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000130   0x2E01             CMP      R6,#+1
   \   00000132   0xD120             BNE.N    ??I2C_SlaveTransferData_14
   1136          		// Setup tx_rx data, callback and interrupt handler
   1137          		tmp = I2C_getNum(I2Cx);
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x.... 0x....      BL       I2C_getNum
   \   0000013A   0x9000             STR      R0,[SP, #+0]
   1138          		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
   \   0000013C   0x....             LDR.N    R0,??DataTable18_5
   \   0000013E   0x9900             LDR      R1,[SP, #+0]
   \   00000140   0x220C             MOVS     R2,#+12
   \   00000142   0x4351             MULS     R1,R2,R1
   \   00000144   0x5045             STR      R5,[R0, R1]
   1139          		i2cdat[tmp].inthandler = I2C_SlaveHandler;
   \   00000146   0x....             LDR.N    R0,??DataTable18_8
   \   00000148   0x....             LDR.N    R1,??DataTable18_5
   \   0000014A   0x9A00             LDR      R2,[SP, #+0]
   \   0000014C   0x230C             MOVS     R3,#+12
   \   0000014E   0x435A             MULS     R2,R3,R2
   \   00000150   0x4411             ADD      R1,R1,R2
   \   00000152   0x6088             STR      R0,[R1, #+8]
   1140          		// Set direction phase, read first
   1141          		i2cdat[tmp].dir = 1;
   \   00000154   0x2001             MOVS     R0,#+1
   \   00000156   0x....             LDR.N    R1,??DataTable18_5
   \   00000158   0x9A00             LDR      R2,[SP, #+0]
   \   0000015A   0x230C             MOVS     R3,#+12
   \   0000015C   0x435A             MULS     R2,R3,R2
   \   0000015E   0x4411             ADD      R1,R1,R2
   \   00000160   0x6048             STR      R0,[R1, #+4]
   1142          
   1143          		// Enable AA
   1144          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000162   0x2004             MOVS     R0,#+4
   \   00000164   0x6020             STR      R0,[R4, #+0]
   1145          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000166   0x2028             MOVS     R0,#+40
   \   00000168   0x61A0             STR      R0,[R4, #+24]
   1146          		I2C_IntCmd(I2Cx, 1);
   \   0000016A   0x2101             MOVS     R1,#+1
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x.... 0x....      BL       I2C_IntCmd
   1147          
   1148          		return (SUCCESS);
   \   00000172   0x2001             MOVS     R0,#+1
   \   00000174   0xE000             B.N      ??I2C_SlaveTransferData_13
   1149          	}
   1150          
   1151          	return ERROR;
   \                     ??I2C_SlaveTransferData_14: (+1)
   \   00000176   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferData_13: (+1)
   \   00000178   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1152          }
   1153          
   1154          /*********************************************************************//**
   1155           * @brief		Set Own slave address in I2C peripheral corresponding to
   1156           * 				parameter specified in OwnSlaveAddrConfigStruct.
   1157           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
   1158           * @param[in]	OwnSlaveAddrConfigStruct	Pointer to a I2C_OWNSLAVEADDR_CFG_Type
   1159           * 				structure that contains the configuration information for the
   1160          *               specified I2C slave address.
   1161           * @return 		None
   1162           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1163          void I2C_SetOwnSlaveAddr(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
   1164          {
   \                     I2C_SetOwnSlaveAddr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1165          	uint32_t tmp;
   1166          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   00000012   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   00000018   0xF240 0x418E      MOVW     R1,#+1166
   \   0000001C   0x....             LDR.N    R0,??DataTable18_6
   \   0000001E   0x.... 0x....      BL       check_failed
   1167          	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct->SlaveAddrChannel));
   \                     ??I2C_SetOwnSlaveAddr_0: (+1)
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xDB04             BLT.N    ??I2C_SetOwnSlaveAddr_1
   \   00000028   0xF240 0x418F      MOVW     R1,#+1167
   \   0000002C   0x....             LDR.N    R0,??DataTable18_6
   \   0000002E   0x.... 0x....      BL       check_failed
   1168          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct->GeneralCallState));
   \                     ??I2C_SetOwnSlaveAddr_1: (+1)
   \   00000032   0x78A8             LDRB     R0,[R5, #+2]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??I2C_SetOwnSlaveAddr_2
   \   00000038   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD004             BEQ.N    ??I2C_SetOwnSlaveAddr_2
   \   0000003E   0xF44F 0x6192      MOV      R1,#+1168
   \   00000042   0x....             LDR.N    R0,??DataTable18_6
   \   00000044   0x.... 0x....      BL       check_failed
   1169          
   1170          	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
   1171          			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
   \                     ??I2C_SetOwnSlaveAddr_2: (+1)
   \   00000048   0x78A8             LDRB     R0,[R5, #+2]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??I2C_SetOwnSlaveAddr_3
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??I2C_SetOwnSlaveAddr_4
   \                     ??I2C_SetOwnSlaveAddr_3: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??I2C_SetOwnSlaveAddr_4: (+1)
   \   00000054   0x7869             LDRB     R1,[R5, #+1]
   \   00000056   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \   0000005A   0xF000 0x06FF      AND      R6,R0,#0xFF
   1172          	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
   \   0000005E   0x7828             LDRB     R0,[R5, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD005             BEQ.N    ??I2C_SetOwnSlaveAddr_5
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD00F             BEQ.N    ??I2C_SetOwnSlaveAddr_6
   \   00000068   0xD308             BCC.N    ??I2C_SetOwnSlaveAddr_7
   \   0000006A   0x2803             CMP      R0,#+3
   \   0000006C   0xD012             BEQ.N    ??I2C_SetOwnSlaveAddr_8
   \   0000006E   0xE016             B.N      ??I2C_SetOwnSlaveAddr_9
   1173          	{
   1174          	case 0:
   1175          		I2Cx->I2ADR0 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_5: (+1)
   \   00000070   0x60E6             STR      R6,[R4, #+12]
   1176          		I2Cx->I2MASK0 = I2C_I2MASK_MASK((uint32_t) \
   1177          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000072   0x78E8             LDRB     R0,[R5, #+3]
   \   00000074   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000078   0x6320             STR      R0,[R4, #+48]
   1178          		break;
   \   0000007A   0xE010             B.N      ??I2C_SetOwnSlaveAddr_9
   1179          	case 1:
   1180          		I2Cx->I2ADR1 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_7: (+1)
   \   0000007C   0x6226             STR      R6,[R4, #+32]
   1181          		I2Cx->I2MASK1 = I2C_I2MASK_MASK((uint32_t) \
   1182          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   0000007E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000080   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000084   0x6360             STR      R0,[R4, #+52]
   1183          		break;
   \   00000086   0xE00A             B.N      ??I2C_SetOwnSlaveAddr_9
   1184          	case 2:
   1185          		I2Cx->I2ADR2 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_6: (+1)
   \   00000088   0x6266             STR      R6,[R4, #+36]
   1186          		I2Cx->I2MASK2 = I2C_I2MASK_MASK((uint32_t) \
   1187          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   0000008A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000008C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000090   0x63A0             STR      R0,[R4, #+56]
   1188          		break;
   \   00000092   0xE004             B.N      ??I2C_SetOwnSlaveAddr_9
   1189          	case 3:
   1190          		I2Cx->I2ADR3 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_8: (+1)
   \   00000094   0x62A6             STR      R6,[R4, #+40]
   1191          		I2Cx->I2MASK3 = I2C_I2MASK_MASK((uint32_t) \
   1192          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000096   0x78E8             LDRB     R0,[R5, #+3]
   \   00000098   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000009C   0x63E0             STR      R0,[R4, #+60]
   1193          		break;
   1194          	}
   1195          }
   \                     ??I2C_SetOwnSlaveAddr_9: (+1)
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   1196          
   1197          
   1198          /*********************************************************************//**
   1199           * @brief		Configures functionality in I2C monitor mode
   1200           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
   1201           * @param[in]	MonitorCfgType Monitor Configuration type, should be:
   1202           * 				- I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch'
   1203           * 				the clock line (hold it low) until it has had time to
   1204           * 				respond to an I2C interrupt.
   1205           * 				- I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1'
   1206           * 				and the I2C is in monitor mode, an interrupt will be
   1207           * 				generated on ANY address received.
   1208           * @param[in]	NewState New State of this function, should be:
   1209           * 				- ENABLE: Enable this function.
   1210           * 				- DISABLE: Disable this function.
   1211           * @return		None
   1212           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1213          void I2C_MonitorModeConfig(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
   1214          {
   \                     I2C_MonitorModeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1215          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??I2C_MonitorModeConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??I2C_MonitorModeConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??I2C_MonitorModeConfig_0
   \   0000001A   0xF240 0x41BF      MOVW     R1,#+1215
   \   0000001E   0x....             LDR.N    R0,??DataTable18_6
   \   00000020   0x.... 0x....      BL       check_failed
   1216          	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
   1217          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??I2C_MonitorModeConfig_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_MonitorModeConfig_1
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD004             BEQ.N    ??I2C_MonitorModeConfig_1
   \   00000030   0xF240 0x41C1      MOVW     R1,#+1217
   \   00000034   0x....             LDR.N    R0,??DataTable18_6
   \   00000036   0x.... 0x....      BL       check_failed
   1218          
   1219          	if (NewState == ENABLE)
   \                     ??I2C_MonitorModeConfig_1: (+1)
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD103             BNE.N    ??I2C_MonitorModeConfig_2
   1220          	{
   1221          		I2Cx->MMCTRL |= MonitorCfgType;
   \   00000040   0x69E0             LDR      R0,[R4, #+28]
   \   00000042   0x4328             ORRS     R0,R5,R0
   \   00000044   0x61E0             STR      R0,[R4, #+28]
   \   00000046   0xE005             B.N      ??I2C_MonitorModeConfig_3
   1222          	}
   1223          	else
   1224          	{
   1225          		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeConfig_2: (+1)
   \   00000048   0x69E0             LDR      R0,[R4, #+28]
   \   0000004A   0x43E9             MVNS     R1,R5
   \   0000004C   0xF011 0x0107      ANDS     R1,R1,#0x7
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x61E0             STR      R0,[R4, #+28]
   1226          	}
   1227          }
   \                     ??I2C_MonitorModeConfig_3: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   1228          
   1229          
   1230          /*********************************************************************//**
   1231           * @brief		Enable/Disable I2C monitor mode
   1232           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
   1233           * @param[in]	NewState New State of this function, should be:
   1234           * 				- ENABLE: Enable monitor mode.
   1235           * 				- DISABLE: Disable monitor mode.
   1236           * @return		None
   1237           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1238          void I2C_MonitorModeCmd(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)
   1239          {
   \                     I2C_MonitorModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1240          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??I2C_MonitorModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??I2C_MonitorModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??I2C_MonitorModeCmd_0
   \   00000018   0xF44F 0x619B      MOV      R1,#+1240
   \   0000001C   0x....             LDR.N    R0,??DataTable18_6
   \   0000001E   0x.... 0x....      BL       check_failed
   1241          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??I2C_MonitorModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??I2C_MonitorModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??I2C_MonitorModeCmd_1
   \   0000002E   0xF240 0x41D9      MOVW     R1,#+1241
   \   00000032   0x....             LDR.N    R0,??DataTable18_6
   \   00000034   0x.... 0x....      BL       check_failed
   1242          
   1243          	if (NewState == ENABLE)
   \                     ??I2C_MonitorModeCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD104             BNE.N    ??I2C_MonitorModeCmd_2
   1244          	{
   1245          		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x61E0             STR      R0,[R4, #+28]
   \   00000046   0xE003             B.N      ??I2C_MonitorModeCmd_3
   1246          	}
   1247          	else
   1248          	{
   1249          		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeCmd_2: (+1)
   \   00000048   0x69E0             LDR      R0,[R4, #+28]
   \   0000004A   0xF010 0x0006      ANDS     R0,R0,#0x6
   \   0000004E   0x61E0             STR      R0,[R4, #+28]
   1250          	}
   1251          }
   \                     ??I2C_MonitorModeCmd_3: (+1)
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1252          
   1253          
   1254          /*********************************************************************//**
   1255           * @brief		Get data from I2C data buffer in monitor mode.
   1256           * @param[in]	I2Cx	I2C peripheral selected, should be I2C0, I2C1 or I2C2
   1257           * @return		None
   1258           * Note:	In monitor mode, the I2C module may lose the ability to stretch
   1259           * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
   1260           * the processor will have a limited amount of time to read the contents of
   1261           * the data received on the bus. If the processor reads the I2DAT shift
   1262           * register, as it ordinarily would, it could have only one bit-time to
   1263           * respond to the interrupt before the received data is overwritten by
   1264           * new data.
   1265           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1266          uint8_t I2C_MonitorGetDatabuffer(LPC_I2C_TypeDef *I2Cx)
   1267          {
   \                     I2C_MonitorGetDatabuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1268          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   00000010   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   00000016   0xF240 0x41F4      MOVW     R1,#+1268
   \   0000001A   0x....             LDR.N    R0,??DataTable18_6
   \   0000001C   0x.... 0x....      BL       check_failed
   1269          	return ((uint8_t)(I2Cx->I2DATA_BUFFER));
   \                     ??I2C_MonitorGetDatabuffer_0: (+1)
   \   00000020   0x6AE0             LDR      R0,[R4, #+44]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1270          }
   1271          
   1272          /*********************************************************************//**
   1273           * @brief 		Standard Interrupt handler for I2C0 peripheral
   1274           * @param[in]	None
   1275           * @return 		None
   1276           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1277          void I2C0_StdIntHandler(void)
   1278          {
   \                     I2C0_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1279          	i2cdat[0].inthandler(LPC_I2C0);
   \   00000002   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000004   0x....             LDR.N    R1,??DataTable18_5
   \   00000006   0x6889             LDR      R1,[R1, #+8]
   \   00000008   0x4788             BLX      R1
   1280          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   1281          
   1282          /*********************************************************************//**
   1283           * @brief 		Standard Interrupt handler for I2C1 peripheral
   1284           * @param[in]	None
   1285           * @return 		None
   1286           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1287          void I2C1_StdIntHandler(void)
   1288          {
   \                     I2C1_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1289          	i2cdat[1].inthandler(LPC_I2C1);
   \   00000002   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   00000004   0x....             LDR.N    R1,??DataTable18_5
   \   00000006   0x6949             LDR      R1,[R1, #+20]
   \   00000008   0x4788             BLX      R1
   1290          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   1291          
   1292          /*********************************************************************//**
   1293           * @brief 		Standard Interrupt handler for I2C2 peripheral
   1294           * @param[in]	None
   1295           * @return 		None
   1296           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1297          void I2C2_StdIntHandler(void)
   1298          {
   \                     I2C2_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1299          	i2cdat[2].inthandler(LPC_I2C2);
   \   00000002   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000004   0x....             LDR.N    R1,??DataTable18_5
   \   00000006   0x6A09             LDR      R1,[R1, #+32]
   \   00000008   0x4788             BLX      R1
   1300          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x4001C000         DC32     0x4001c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x4005C000         DC32     0x4005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x400A0000         DC32     0x400a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x........         DC32     i2cdat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x........         DC32     I2C_MasterHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     I2C_SlaveHandler

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x69          DC8 5FH, 69H, 32H, 63H, 2EH, 63H, 0
   \              0x32 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
   1301          
   1302          
   1303          /**
   1304           * @}
   1305           */
   1306          
   1307          #endif /* _I2C */
   1308          
   1309          /**
   1310           * @}
   1311           */
   1312          
   1313          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   I2C0_StdIntHandler
         8   -- Indirect call
       8   I2C1_StdIntHandler
         8   -- Indirect call
       8   I2C2_StdIntHandler
         8   -- Indirect call
      16   I2C_Cmd
        16   -> check_failed
       8   I2C_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
       0   I2C_GetByte
      16   I2C_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> CLKPWR_SetPCLKDiv
        16   -> I2C_SetClock
        16   -> check_failed
      16   I2C_IntCmd
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
      24   I2C_MasterHandler
        24   -- Indirect call
        24   -> I2C_IntCmd
        24   -> I2C_Stop
        24   -> I2C_getNum
      32   I2C_MasterTransferData
        32   -> I2C_GetByte
        32   -> I2C_IntCmd
        32   -> I2C_SendByte
        32   -> I2C_Start
        32   -> I2C_Stop
        32   -> I2C_getNum
       8   I2C_MonitorGetDatabuffer
         8   -> check_failed
      16   I2C_MonitorModeCmd
        16   -> check_failed
      16   I2C_MonitorModeConfig
        16   -> check_failed
       0   I2C_SendByte
      16   I2C_SetClock
        16   -> CLKPWR_GetPCLK
        16   -> check_failed
      16   I2C_SetOwnSlaveAddr
        16   -> check_failed
      24   I2C_SlaveHandler
        24   -- Indirect call
        24   -> I2C_IntCmd
        24   -> I2C_getNum
      40   I2C_SlaveTransferData
        40   -> I2C_IntCmd
        40   -> I2C_getNum
       0   I2C_Start
       0   I2C_Stop
       0   I2C_getNum
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
     152  ?_0
      12  I2C0_StdIntHandler
      12  I2C1_StdIntHandler
      12  I2C2_StdIntHandler
      84  I2C_Cmd
     102  I2C_DeInit
      38  I2C_GetByte
     140  I2C_Init
     108  I2C_IntCmd
     536  I2C_MasterHandler
     576  I2C_MasterTransferData
      38  I2C_MonitorGetDatabuffer
      82  I2C_MonitorModeCmd
      86  I2C_MonitorModeConfig
      32  I2C_SendByte
     118  I2C_SetClock
     160  I2C_SetOwnSlaveAddr
     298  I2C_SlaveHandler
     380  I2C_SlaveTransferData
      26  I2C_Start
      20  I2C_Stop
      44  I2C_getNum
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      36  i2cdat

 
    36 bytes in section .bss
   152 bytes in section .rodata
 2 984 bytes in section .text
 
 2 984 bytes of CODE  memory
   152 bytes of CONST memory
    36 bytes of DATA  memory

Errors: none
Warnings: 9
