###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:07
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_mcpwm.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_mcpwm.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_mcpwm.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_mcpwm.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_mcpwm.c
      1          /**
      2           * @file	: lpc17xx_mcpwm.c
      3           * @brief	: Contains all functions support for Motor Control PWM firmware
      4           * 				library on LPC17xx
      5           * @version	: 1.0
      6           * @date	: 26. May. 2009
      7           * @author	: HieuNguyen
      8           **************************************************************************
      9           * Software that is described herein is for illustrative purposes only
     10           * which provides customers with programming information regarding the
     11           * products. This software is supplied "AS IS" without any warranties.
     12           * NXP Semiconductors assumes no responsibility or liability for the
     13           * use of the software, conveys no license or title under any patent,
     14           * copyright, or mask work right to the product. NXP Semiconductors
     15           * reserves the right to make changes in the software without
     16           * notification. NXP Semiconductors also make no representation or
     17           * warranty that such application will be suitable for the specified
     18           * use without further testing or modification.
     19           **********************************************************************/
     20          
     21          /* Peripheral group ----------------------------------------------------------- */
     22          /** @addtogroup MCPWM
     23           * @{
     24           */
     25          
     26          /* Includes ------------------------------------------------------------------- */
     27          #include "lpc17xx_mcpwm.h"
     28          #include "lpc17xx_clkpwr.h"
     29          
     30          /* If this source file built with example, the LPC17xx FW library configuration
     31           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     32           * otherwise the default FW library configuration file must be included instead
     33           */
     34          #ifdef __BUILD_WITH_EXAMPLE__
     35          #include "lpc17xx_libcfg.h"
     36          #else
     37          #include "lpc17xx_libcfg_default.h"
     38          #endif /* __BUILD_WITH_EXAMPLE__ */
     39          
     40          
     41          #ifdef _MCPWM
     42          
     43          /* Public Functions ----------------------------------------------------------- */
     44          /** @addtogroup MCPWM_Public_Functions
     45           * @{
     46           */
     47          
     48          /*********************************************************************//**
     49           * @brief		Initializes the MCPWM peripheral
     50           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
     51           * @return		None
     52           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          void MCPWM_Init(LPC_MCPWM_TypeDef *MCPWMx)
     54          {
   \                     MCPWM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     55          
     56          	/* Turn On MCPWM PCLK */
     57          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCMC, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000000A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     58          	/* As default, peripheral clock for MCPWM module
     59          	 * is set to FCCLK / 2 */
     60          	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_MC, CLKPWR_PCLKSEL_CCLK_DIV_2);
     61          
     62          	MCPWMx->MCCAP_CLR = MCPWM_CAPCLR_CAP(0) | MCPWM_CAPCLR_CAP(1) | MCPWM_CAPCLR_CAP(2);
   \   0000000E   0x2007             MOVS     R0,#+7
   \   00000010   0x6760             STR      R0,[R4, #+116]
     63          	MCPWMx->MCINTFLAG_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
     64          							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
     65          							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
   \   00000012   0xF240 0x7077      MOVW     R0,#+1911
   \   00000016   0x6720             STR      R0,[R4, #+112]
     66          	MCPWMx->MCINTEN_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
     67          							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
     68          							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
   \   00000018   0xF240 0x7077      MOVW     R0,#+1911
   \   0000001C   0x65A0             STR      R0,[R4, #+88]
     69          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     70          
     71          
     72          /*********************************************************************//**
     73           * @brief		Configures each channel in MCPWM peripheral according to the
     74           * 				specified parameters in the MCPWM_CHANNEL_CFG_Type.
     75           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
     76           * @param[in]	channelNum		Channel number, should be in range from 0 to 2.
     77           * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
     78          *                    			that contains the configuration information for the
     79          *                    			specified MCPWM channel.
     80           * @return		None
     81           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          void MCPWM_ConfigChannel(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
     83          						MCPWM_CHANNEL_CFG_Type * channelSetup)
     84          {
   \                     MCPWM_ConfigChannel: (+1)
   \   00000000   0xB410             PUSH     {R4}
     85          	if ((channelNum >= 0) && (channelNum <= 2)) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xF080 0x8090      BCS.W    ??MCPWM_ConfigChannel_0
     86          		if (channelNum == 0) {
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD106             BNE.N    ??MCPWM_ConfigChannel_1
     87          			MCPWMx->MCTIM0 = channelSetup->channelTimercounterValue;
   \   0000000C   0x6953             LDR      R3,[R2, #+20]
   \   0000000E   0x6183             STR      R3,[R0, #+24]
     88          			MCPWMx->MCPER0 = channelSetup->channelPeriodValue;
   \   00000010   0x6993             LDR      R3,[R2, #+24]
   \   00000012   0x6243             STR      R3,[R0, #+36]
     89          			MCPWMx->MCPW0 = channelSetup->channelPulsewidthValue;
   \   00000014   0x69D3             LDR      R3,[R2, #+28]
   \   00000016   0x6303             STR      R3,[R0, #+48]
   \   00000018   0xE012             B.N      ??MCPWM_ConfigChannel_2
     90          		} else if (channelNum == 1) {
   \                     ??MCPWM_ConfigChannel_1: (+1)
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD106             BNE.N    ??MCPWM_ConfigChannel_3
     91          			MCPWMx->MCTIM1 = channelSetup->channelTimercounterValue;
   \   0000001E   0x6953             LDR      R3,[R2, #+20]
   \   00000020   0x61C3             STR      R3,[R0, #+28]
     92          			MCPWMx->MCPER1 = channelSetup->channelPeriodValue;
   \   00000022   0x6993             LDR      R3,[R2, #+24]
   \   00000024   0x6283             STR      R3,[R0, #+40]
     93          			MCPWMx->MCPW1 = channelSetup->channelPulsewidthValue;
   \   00000026   0x69D3             LDR      R3,[R2, #+28]
   \   00000028   0x6343             STR      R3,[R0, #+52]
   \   0000002A   0xE009             B.N      ??MCPWM_ConfigChannel_2
     94          		} else if (channelNum == 2) {
   \                     ??MCPWM_ConfigChannel_3: (+1)
   \   0000002C   0x2902             CMP      R1,#+2
   \   0000002E   0xD106             BNE.N    ??MCPWM_ConfigChannel_4
     95          			MCPWMx->MCTIM2 = channelSetup->channelTimercounterValue;
   \   00000030   0x6953             LDR      R3,[R2, #+20]
   \   00000032   0x6203             STR      R3,[R0, #+32]
     96          			MCPWMx->MCPER2 = channelSetup->channelPeriodValue;
   \   00000034   0x6993             LDR      R3,[R2, #+24]
   \   00000036   0x62C3             STR      R3,[R0, #+44]
     97          			MCPWMx->MCPW2 = channelSetup->channelPulsewidthValue;
   \   00000038   0x69D3             LDR      R3,[R2, #+28]
   \   0000003A   0x6383             STR      R3,[R0, #+56]
   \   0000003C   0xE000             B.N      ??MCPWM_ConfigChannel_2
     98          		} else {
     99          			return;
   \                     ??MCPWM_ConfigChannel_4: (+1)
   \   0000003E   0xE073             B.N      ??MCPWM_ConfigChannel_5
    100          		}
    101          
    102          		if (channelSetup->channelType /* == MCPWM_CHANNEL_CENTER_MODE */){
   \                     ??MCPWM_ConfigChannel_2: (+1)
   \   00000040   0x6813             LDR      R3,[R2, #+0]
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD009             BEQ.N    ??MCPWM_ConfigChannel_6
    103          			MCPWMx->MCCON_SET = MCPWM_CON_CENTER(channelNum);
   \   00000046   0x2903             CMP      R1,#+3
   \   00000048   0xD204             BCS.N    ??MCPWM_ConfigChannel_7
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x00CC             LSLS     R4,R1,#+3
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
   \   00000050   0x40A3             LSLS     R3,R3,R4
   \   00000052   0xE000             B.N      ??MCPWM_ConfigChannel_8
   \                     ??MCPWM_ConfigChannel_7: (+1)
   \   00000054   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_8: (+1)
   \   00000056   0x6043             STR      R3,[R0, #+4]
   \   00000058   0xE008             B.N      ??MCPWM_ConfigChannel_9
    104          		} else {
    105          			MCPWMx->MCCON_CLR = MCPWM_CON_CENTER(channelNum);
   \                     ??MCPWM_ConfigChannel_6: (+1)
   \   0000005A   0x2903             CMP      R1,#+3
   \   0000005C   0xD204             BCS.N    ??MCPWM_ConfigChannel_10
   \   0000005E   0x2301             MOVS     R3,#+1
   \   00000060   0x00CC             LSLS     R4,R1,#+3
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0x40A3             LSLS     R3,R3,R4
   \   00000066   0xE000             B.N      ??MCPWM_ConfigChannel_11
   \                     ??MCPWM_ConfigChannel_10: (+1)
   \   00000068   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_11: (+1)
   \   0000006A   0x6083             STR      R3,[R0, #+8]
    106          		}
    107          
    108          		if (channelSetup->channelPolarity /* == MCPWM_CHANNEL_PASSIVE_HI */){
   \                     ??MCPWM_ConfigChannel_9: (+1)
   \   0000006C   0x6853             LDR      R3,[R2, #+4]
   \   0000006E   0x2B00             CMP      R3,#+0
   \   00000070   0xD009             BEQ.N    ??MCPWM_ConfigChannel_12
    109          			MCPWMx->MCCON_SET = MCPWM_CON_POLAR(channelNum);
   \   00000072   0x2903             CMP      R1,#+3
   \   00000074   0xD204             BCS.N    ??MCPWM_ConfigChannel_13
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0x00CC             LSLS     R4,R1,#+3
   \   0000007A   0x1CA4             ADDS     R4,R4,#+2
   \   0000007C   0x40A3             LSLS     R3,R3,R4
   \   0000007E   0xE000             B.N      ??MCPWM_ConfigChannel_14
   \                     ??MCPWM_ConfigChannel_13: (+1)
   \   00000080   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_14: (+1)
   \   00000082   0x6043             STR      R3,[R0, #+4]
   \   00000084   0xE008             B.N      ??MCPWM_ConfigChannel_15
    110          		} else {
    111          			MCPWMx->MCCON_CLR = MCPWM_CON_POLAR(channelNum);
   \                     ??MCPWM_ConfigChannel_12: (+1)
   \   00000086   0x2903             CMP      R1,#+3
   \   00000088   0xD204             BCS.N    ??MCPWM_ConfigChannel_16
   \   0000008A   0x2301             MOVS     R3,#+1
   \   0000008C   0x00CC             LSLS     R4,R1,#+3
   \   0000008E   0x1CA4             ADDS     R4,R4,#+2
   \   00000090   0x40A3             LSLS     R3,R3,R4
   \   00000092   0xE000             B.N      ??MCPWM_ConfigChannel_17
   \                     ??MCPWM_ConfigChannel_16: (+1)
   \   00000094   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_17: (+1)
   \   00000096   0x6083             STR      R3,[R0, #+8]
    112          		}
    113          
    114          		if (channelSetup->channelDeadtimeEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigChannel_15: (+1)
   \   00000098   0x6893             LDR      R3,[R2, #+8]
   \   0000009A   0x2B00             CMP      R3,#+0
   \   0000009C   0xD025             BEQ.N    ??MCPWM_ConfigChannel_18
    115          			MCPWMx->MCCON_SET = MCPWM_CON_DTE(channelNum);
   \   0000009E   0x2903             CMP      R1,#+3
   \   000000A0   0xD204             BCS.N    ??MCPWM_ConfigChannel_19
   \   000000A2   0x2301             MOVS     R3,#+1
   \   000000A4   0x00CC             LSLS     R4,R1,#+3
   \   000000A6   0x1CE4             ADDS     R4,R4,#+3
   \   000000A8   0x40A3             LSLS     R3,R3,R4
   \   000000AA   0xE000             B.N      ??MCPWM_ConfigChannel_20
   \                     ??MCPWM_ConfigChannel_19: (+1)
   \   000000AC   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_20: (+1)
   \   000000AE   0x6043             STR      R3,[R0, #+4]
    116          			MCPWMx->MCDEADTIME &= ~(MCPWM_DT(channelNum, 0x3FF));
   \   000000B0   0x2903             CMP      R1,#+3
   \   000000B2   0xD206             BCS.N    ??MCPWM_ConfigChannel_21
   \   000000B4   0xF240 0x33FF      MOVW     R3,#+1023
   \   000000B8   0x240A             MOVS     R4,#+10
   \   000000BA   0xFB04 0xF401      MUL      R4,R4,R1
   \   000000BE   0x40A3             LSLS     R3,R3,R4
   \   000000C0   0xE000             B.N      ??MCPWM_ConfigChannel_22
   \                     ??MCPWM_ConfigChannel_21: (+1)
   \   000000C2   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_22: (+1)
   \   000000C4   0x6BC4             LDR      R4,[R0, #+60]
   \   000000C6   0xEA34 0x0303      BICS     R3,R4,R3
   \   000000CA   0x63C3             STR      R3,[R0, #+60]
    117          			MCPWMx->MCDEADTIME |= MCPWM_DT(channelNum, channelSetup->channelDeadtimeValue);
   \   000000CC   0x2903             CMP      R1,#+3
   \   000000CE   0xD207             BCS.N    ??MCPWM_ConfigChannel_23
   \   000000D0   0x68D3             LDR      R3,[R2, #+12]
   \   000000D2   0x059B             LSLS     R3,R3,#+22       ;; ZeroExtS R3,R3,#+22,#+22
   \   000000D4   0x0D9B             LSRS     R3,R3,#+22
   \   000000D6   0x240A             MOVS     R4,#+10
   \   000000D8   0xFB04 0xF401      MUL      R4,R4,R1
   \   000000DC   0x40A3             LSLS     R3,R3,R4
   \   000000DE   0xE000             B.N      ??MCPWM_ConfigChannel_24
   \                     ??MCPWM_ConfigChannel_23: (+1)
   \   000000E0   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_24: (+1)
   \   000000E2   0x6BC4             LDR      R4,[R0, #+60]
   \   000000E4   0x4323             ORRS     R3,R3,R4
   \   000000E6   0x63C3             STR      R3,[R0, #+60]
   \   000000E8   0xE008             B.N      ??MCPWM_ConfigChannel_25
    118          		} else {
    119          			MCPWMx->MCCON_CLR = MCPWM_CON_DTE(channelNum);
   \                     ??MCPWM_ConfigChannel_18: (+1)
   \   000000EA   0x2903             CMP      R1,#+3
   \   000000EC   0xD204             BCS.N    ??MCPWM_ConfigChannel_26
   \   000000EE   0x2301             MOVS     R3,#+1
   \   000000F0   0x00CC             LSLS     R4,R1,#+3
   \   000000F2   0x1CE4             ADDS     R4,R4,#+3
   \   000000F4   0x40A3             LSLS     R3,R3,R4
   \   000000F6   0xE000             B.N      ??MCPWM_ConfigChannel_27
   \                     ??MCPWM_ConfigChannel_26: (+1)
   \   000000F8   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_27: (+1)
   \   000000FA   0x6083             STR      R3,[R0, #+8]
    120          		}
    121          
    122          		if (channelSetup->channelUpdateEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigChannel_25: (+1)
   \   000000FC   0x6913             LDR      R3,[R2, #+16]
   \   000000FE   0x2B00             CMP      R3,#+0
   \   00000100   0xD009             BEQ.N    ??MCPWM_ConfigChannel_28
    123          			MCPWMx->MCCON_CLR = MCPWM_CON_DISUP(channelNum);
   \   00000102   0x2903             CMP      R1,#+3
   \   00000104   0xD204             BCS.N    ??MCPWM_ConfigChannel_29
   \   00000106   0x2301             MOVS     R3,#+1
   \   00000108   0x00CC             LSLS     R4,R1,#+3
   \   0000010A   0x1D24             ADDS     R4,R4,#+4
   \   0000010C   0x40A3             LSLS     R3,R3,R4
   \   0000010E   0xE000             B.N      ??MCPWM_ConfigChannel_30
   \                     ??MCPWM_ConfigChannel_29: (+1)
   \   00000110   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_30: (+1)
   \   00000112   0x6083             STR      R3,[R0, #+8]
   \   00000114   0xE008             B.N      ??MCPWM_ConfigChannel_0
    124          		} else {
    125          			MCPWMx->MCCON_SET = MCPWM_CON_DISUP(channelNum);
   \                     ??MCPWM_ConfigChannel_28: (+1)
   \   00000116   0x2903             CMP      R1,#+3
   \   00000118   0xD204             BCS.N    ??MCPWM_ConfigChannel_31
   \   0000011A   0x2301             MOVS     R3,#+1
   \   0000011C   0x00CC             LSLS     R4,R1,#+3
   \   0000011E   0x1D24             ADDS     R4,R4,#+4
   \   00000120   0x40A3             LSLS     R3,R3,R4
   \   00000122   0xE000             B.N      ??MCPWM_ConfigChannel_32
   \                     ??MCPWM_ConfigChannel_31: (+1)
   \   00000124   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_32: (+1)
   \   00000126   0x6043             STR      R3,[R0, #+4]
    126          		}
    127          	}
    128          }
   \                     ??MCPWM_ConfigChannel_0: (+1)
   \                     ??MCPWM_ConfigChannel_5: (+1)
   \   00000128   0xBC10             POP      {R4}
   \   0000012A   0x4770             BX       LR               ;; return
    129          
    130          
    131          /*********************************************************************//**
    132           * @brief		Write to MCPWM shadow registers - Update the value for period
    133           * 				and pulse width in MCPWM peripheral.
    134           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
    135           * @param[in]	channelNum		Channel Number, should be in range from 0 to 2.
    136           * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
    137          *                    			that contains the configuration information for the
    138          *                    			specified MCPWM channel.
    139           * @return		None
    140           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    141          void MCPWM_WriteToShadow(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    142          								MCPWM_CHANNEL_CFG_Type *channelSetup)
    143          {
    144          	if (channelNum == 0){
   \                     MCPWM_WriteToShadow: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD104             BNE.N    ??MCPWM_WriteToShadow_0
    145          		MCPWMx->MCPER0 = channelSetup->channelPeriodValue;
   \   00000004   0x6993             LDR      R3,[R2, #+24]
   \   00000006   0x6243             STR      R3,[R0, #+36]
    146          		MCPWMx->MCPW0 = channelSetup->channelPulsewidthValue;
   \   00000008   0x69D3             LDR      R3,[R2, #+28]
   \   0000000A   0x6303             STR      R3,[R0, #+48]
   \   0000000C   0xE00C             B.N      ??MCPWM_WriteToShadow_1
    147          	} else if (channelNum == 1) {
   \                     ??MCPWM_WriteToShadow_0: (+1)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD104             BNE.N    ??MCPWM_WriteToShadow_2
    148          		MCPWMx->MCPER1 = channelSetup->channelPeriodValue;
   \   00000012   0x6993             LDR      R3,[R2, #+24]
   \   00000014   0x6283             STR      R3,[R0, #+40]
    149          		MCPWMx->MCPW1 = channelSetup->channelPulsewidthValue;
   \   00000016   0x69D3             LDR      R3,[R2, #+28]
   \   00000018   0x6343             STR      R3,[R0, #+52]
   \   0000001A   0xE005             B.N      ??MCPWM_WriteToShadow_1
    150          	} else if (channelNum == 2) {
   \                     ??MCPWM_WriteToShadow_2: (+1)
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD103             BNE.N    ??MCPWM_WriteToShadow_1
    151          		MCPWMx->MCPER2 = channelSetup->channelPeriodValue;
   \   00000020   0x6993             LDR      R3,[R2, #+24]
   \   00000022   0x62C3             STR      R3,[R0, #+44]
    152          		MCPWMx->MCPW2 = channelSetup->channelPulsewidthValue;
   \   00000024   0x69D3             LDR      R3,[R2, #+28]
   \   00000026   0x6383             STR      R3,[R0, #+56]
    153          	}
    154          }
   \                     ??MCPWM_WriteToShadow_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    155          
    156          
    157          
    158          /*********************************************************************//**
    159           * @brief		Configures capture function in MCPWM peripheral
    160           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
    161           * @param[in]	channelNum		MCI (Motor Control Input pin) number, should be in range from 0 to 2.
    162           * @param[in]	captureConfig	Pointer to a MCPWM_CAPTURE_CFG_Type structure
    163          *                    			that contains the configuration information for the
    164          *                    			specified MCPWM capture.
    165           * @return
    166           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void MCPWM_ConfigCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    168          						MCPWM_CAPTURE_CFG_Type *captureConfig)
    169          {
   \                     MCPWM_ConfigCapture: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    170          	if ((channelNum >= 0) && (channelNum <= 2)) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xD277             BCS.N    ??MCPWM_ConfigCapture_0
    171          
    172          		if (captureConfig->captureFalling /* == ENABLE */) {
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD012             BEQ.N    ??MCPWM_ConfigCapture_1
    173          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_FE(captureConfig->captureChannel, channelNum);
   \   0000000C   0x6813             LDR      R3,[R2, #+0]
   \   0000000E   0x2B03             CMP      R3,#+3
   \   00000010   0xD20C             BCS.N    ??MCPWM_ConfigCapture_2
   \   00000012   0x2903             CMP      R1,#+3
   \   00000014   0xD20A             BCS.N    ??MCPWM_ConfigCapture_2
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x6814             LDR      R4,[R2, #+0]
   \   0000001A   0x2506             MOVS     R5,#+6
   \   0000001C   0x000E             MOVS     R6,R1
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x0076             LSLS     R6,R6,#+1
   \   00000022   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x40A3             LSLS     R3,R3,R4
   \   0000002A   0xE000             B.N      ??MCPWM_ConfigCapture_3
   \                     ??MCPWM_ConfigCapture_2: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_3: (+1)
   \   0000002E   0x6103             STR      R3,[R0, #+16]
   \   00000030   0xE011             B.N      ??MCPWM_ConfigCapture_4
    174          		} else {
    175          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_FE(captureConfig->captureChannel, channelNum);
   \                     ??MCPWM_ConfigCapture_1: (+1)
   \   00000032   0x6813             LDR      R3,[R2, #+0]
   \   00000034   0x2B03             CMP      R3,#+3
   \   00000036   0xD20C             BCS.N    ??MCPWM_ConfigCapture_5
   \   00000038   0x2903             CMP      R1,#+3
   \   0000003A   0xD20A             BCS.N    ??MCPWM_ConfigCapture_5
   \   0000003C   0x2301             MOVS     R3,#+1
   \   0000003E   0x6814             LDR      R4,[R2, #+0]
   \   00000040   0x2506             MOVS     R5,#+6
   \   00000042   0x000E             MOVS     R6,R1
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x0076             LSLS     R6,R6,#+1
   \   00000048   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x40A3             LSLS     R3,R3,R4
   \   00000050   0xE000             B.N      ??MCPWM_ConfigCapture_6
   \                     ??MCPWM_ConfigCapture_5: (+1)
   \   00000052   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_6: (+1)
   \   00000054   0x6143             STR      R3,[R0, #+20]
    176          		}
    177          
    178          		if (captureConfig->captureRising /* == ENABLE */) {
   \                     ??MCPWM_ConfigCapture_4: (+1)
   \   00000056   0x6853             LDR      R3,[R2, #+4]
   \   00000058   0x2B00             CMP      R3,#+0
   \   0000005A   0xD00F             BEQ.N    ??MCPWM_ConfigCapture_7
    179          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_RE(captureConfig->captureChannel, channelNum);
   \   0000005C   0x6813             LDR      R3,[R2, #+0]
   \   0000005E   0x2B03             CMP      R3,#+3
   \   00000060   0xD209             BCS.N    ??MCPWM_ConfigCapture_8
   \   00000062   0x2903             CMP      R1,#+3
   \   00000064   0xD207             BCS.N    ??MCPWM_ConfigCapture_8
   \   00000066   0x2301             MOVS     R3,#+1
   \   00000068   0x6814             LDR      R4,[R2, #+0]
   \   0000006A   0x2506             MOVS     R5,#+6
   \   0000006C   0x004E             LSLS     R6,R1,#+1
   \   0000006E   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000072   0x40A3             LSLS     R3,R3,R4
   \   00000074   0xE000             B.N      ??MCPWM_ConfigCapture_9
   \                     ??MCPWM_ConfigCapture_8: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_9: (+1)
   \   00000078   0x6103             STR      R3,[R0, #+16]
   \   0000007A   0xE00E             B.N      ??MCPWM_ConfigCapture_10
    180          		} else {
    181          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_RE(captureConfig->captureChannel, channelNum);
   \                     ??MCPWM_ConfigCapture_7: (+1)
   \   0000007C   0x6813             LDR      R3,[R2, #+0]
   \   0000007E   0x2B03             CMP      R3,#+3
   \   00000080   0xD209             BCS.N    ??MCPWM_ConfigCapture_11
   \   00000082   0x2903             CMP      R1,#+3
   \   00000084   0xD207             BCS.N    ??MCPWM_ConfigCapture_11
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0x6814             LDR      R4,[R2, #+0]
   \   0000008A   0x2506             MOVS     R5,#+6
   \   0000008C   0x004E             LSLS     R6,R1,#+1
   \   0000008E   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000092   0x40A3             LSLS     R3,R3,R4
   \   00000094   0xE000             B.N      ??MCPWM_ConfigCapture_12
   \                     ??MCPWM_ConfigCapture_11: (+1)
   \   00000096   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_12: (+1)
   \   00000098   0x6143             STR      R3,[R0, #+20]
    182          		}
    183          
    184          		if (captureConfig->timerReset /* == ENABLE */){
   \                     ??MCPWM_ConfigCapture_10: (+1)
   \   0000009A   0x68D3             LDR      R3,[R2, #+12]
   \   0000009C   0x2B00             CMP      R3,#+0
   \   0000009E   0xD00A             BEQ.N    ??MCPWM_ConfigCapture_13
    185          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_RT(captureConfig->captureChannel);
   \   000000A0   0x6813             LDR      R3,[R2, #+0]
   \   000000A2   0x2B03             CMP      R3,#+3
   \   000000A4   0xD204             BCS.N    ??MCPWM_ConfigCapture_14
   \   000000A6   0x2301             MOVS     R3,#+1
   \   000000A8   0x6814             LDR      R4,[R2, #+0]
   \   000000AA   0x3412             ADDS     R4,R4,#+18
   \   000000AC   0x40A3             LSLS     R3,R3,R4
   \   000000AE   0xE000             B.N      ??MCPWM_ConfigCapture_15
   \                     ??MCPWM_ConfigCapture_14: (+1)
   \   000000B0   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_15: (+1)
   \   000000B2   0x6103             STR      R3,[R0, #+16]
   \   000000B4   0xE009             B.N      ??MCPWM_ConfigCapture_16
    186          		} else {
    187          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_RT(captureConfig->captureChannel);
   \                     ??MCPWM_ConfigCapture_13: (+1)
   \   000000B6   0x6813             LDR      R3,[R2, #+0]
   \   000000B8   0x2B03             CMP      R3,#+3
   \   000000BA   0xD204             BCS.N    ??MCPWM_ConfigCapture_17
   \   000000BC   0x2301             MOVS     R3,#+1
   \   000000BE   0x6814             LDR      R4,[R2, #+0]
   \   000000C0   0x3412             ADDS     R4,R4,#+18
   \   000000C2   0x40A3             LSLS     R3,R3,R4
   \   000000C4   0xE000             B.N      ??MCPWM_ConfigCapture_18
   \                     ??MCPWM_ConfigCapture_17: (+1)
   \   000000C6   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_18: (+1)
   \   000000C8   0x6143             STR      R3,[R0, #+20]
    188          		}
    189          
    190          		if (captureConfig->hnfEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigCapture_16: (+1)
   \   000000CA   0x6913             LDR      R3,[R2, #+16]
   \   000000CC   0x2B00             CMP      R3,#+0
   \   000000CE   0xD009             BEQ.N    ??MCPWM_ConfigCapture_19
    191          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_HNFCAP(channelNum);
   \   000000D0   0x2903             CMP      R1,#+3
   \   000000D2   0xD204             BCS.N    ??MCPWM_ConfigCapture_20
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0xF111 0x0415      ADDS     R4,R1,#+21
   \   000000DA   0x40A3             LSLS     R3,R3,R4
   \   000000DC   0xE000             B.N      ??MCPWM_ConfigCapture_21
   \                     ??MCPWM_ConfigCapture_20: (+1)
   \   000000DE   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_21: (+1)
   \   000000E0   0x6103             STR      R3,[R0, #+16]
   \   000000E2   0xE008             B.N      ??MCPWM_ConfigCapture_0
    192          		} else {
    193          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_HNFCAP(channelNum);
   \                     ??MCPWM_ConfigCapture_19: (+1)
   \   000000E4   0x2903             CMP      R1,#+3
   \   000000E6   0xD204             BCS.N    ??MCPWM_ConfigCapture_22
   \   000000E8   0x2301             MOVS     R3,#+1
   \   000000EA   0xF111 0x0415      ADDS     R4,R1,#+21
   \   000000EE   0x40A3             LSLS     R3,R3,R4
   \   000000F0   0xE000             B.N      ??MCPWM_ConfigCapture_23
   \                     ??MCPWM_ConfigCapture_22: (+1)
   \   000000F2   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_23: (+1)
   \   000000F4   0x6143             STR      R3,[R0, #+20]
    194          		}
    195          	}
    196          }
   \                     ??MCPWM_ConfigCapture_0: (+1)
   \   000000F6   0xBC70             POP      {R4-R6}
   \   000000F8   0x4770             BX       LR               ;; return
    197          
    198          
    199          /*********************************************************************//**
    200           * @brief		Clears current captured value in specified capture channel
    201           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    202           * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
    203           * @return		None
    204           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          void MCPWM_ClearCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
    206          {
    207          	MCPWMx->MCCAP_CLR = MCPWM_CAPCLR_CAP(captureChannel);
   \                     MCPWM_ClearCapture: (+1)
   \   00000000   0x2903             CMP      R1,#+3
   \   00000002   0xD202             BCS.N    ??MCPWM_ClearCapture_0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x408A             LSLS     R2,R2,R1
   \   00000008   0xE000             B.N      ??MCPWM_ClearCapture_1
   \                     ??MCPWM_ClearCapture_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??MCPWM_ClearCapture_1: (+1)
   \   0000000C   0x6742             STR      R2,[R0, #+116]
    208          }
   \   0000000E   0x4770             BX       LR               ;; return
    209          
    210          /*********************************************************************//**
    211           * @brief		Get current captured value in specified capture channel
    212           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    213           * @param[in]	captureChannel	Capture channel number, should be in range from 0 to 2
    214           * @return		None
    215           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    216          uint32_t MCPWM_GetCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
    217          {
   \                     MCPWM_GetCapture: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    218          	if (captureChannel == 0){
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??MCPWM_GetCapture_0
    219          		return (MCPWMx->MCCR0);
   \   00000006   0x6C50             LDR      R0,[R2, #+68]
   \   00000008   0xE008             B.N      ??MCPWM_GetCapture_1
    220          	} else if (captureChannel == 1) {
   \                     ??MCPWM_GetCapture_0: (+1)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD101             BNE.N    ??MCPWM_GetCapture_2
    221          		return (MCPWMx->MCCR1);
   \   0000000E   0x6C90             LDR      R0,[R2, #+72]
   \   00000010   0xE004             B.N      ??MCPWM_GetCapture_1
    222          	} else if (captureChannel == 2) {
   \                     ??MCPWM_GetCapture_2: (+1)
   \   00000012   0x2902             CMP      R1,#+2
   \   00000014   0xD101             BNE.N    ??MCPWM_GetCapture_3
    223          		return (MCPWMx->MCCR2);
   \   00000016   0x6CD0             LDR      R0,[R2, #+76]
   \   00000018   0xE000             B.N      ??MCPWM_GetCapture_1
    224          	}
    225          	return (0);
   \                     ??MCPWM_GetCapture_3: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??MCPWM_GetCapture_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    226          }
    227          
    228          
    229          /*********************************************************************//**
    230           * @brief		Configures Count control in MCPWM peripheral
    231           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    232           * @param[in]	channelNum	Channel number, should be in range from 0 to 2
    233           * @param[in]	countMode	Count mode, should be:
    234           * 							- ENABLE: Enables count mode.
    235           * 							- DISABLE: Disable count mode, the channel is in timer mode.
    236           * @param[in]	countConfig	Pointer to a MCPWM_COUNT_CFG_Type structure
    237          *                    		that contains the configuration information for the
    238          *                    		specified MCPWM count control.
    239           * @return		None
    240           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    241          void MCPWM_CountConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    242          					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig)
    243          {
   \                     MCPWM_CountConfig: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    244          	if ((channelNum >= 0) && (channelNum <= 2)) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xD25E             BCS.N    ??MCPWM_CountConfig_0
    245          		if (countMode /* == ENABLE */){
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD053             BEQ.N    ??MCPWM_CountConfig_1
    246          			MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_CNTR(channelNum);
   \   0000000A   0x2903             CMP      R1,#+3
   \   0000000C   0xD204             BCS.N    ??MCPWM_CountConfig_2
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF111 0x051D      ADDS     R5,R1,#+29
   \   00000014   0x40AC             LSLS     R4,R4,R5
   \   00000016   0xE000             B.N      ??MCPWM_CountConfig_3
   \                     ??MCPWM_CountConfig_2: (+1)
   \   00000018   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_3: (+1)
   \   0000001A   0x6604             STR      R4,[R0, #+96]
    247          			if (countConfig->countFalling /* == ENABLE */) {
   \   0000001C   0x689C             LDR      R4,[R3, #+8]
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD012             BEQ.N    ??MCPWM_CountConfig_4
    248          				MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_TCMCI_FE(countConfig->counterChannel,channelNum);
   \   00000022   0x681C             LDR      R4,[R3, #+0]
   \   00000024   0x2C03             CMP      R4,#+3
   \   00000026   0xD20C             BCS.N    ??MCPWM_CountConfig_5
   \   00000028   0x2903             CMP      R1,#+3
   \   0000002A   0xD20A             BCS.N    ??MCPWM_CountConfig_5
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0x681D             LDR      R5,[R3, #+0]
   \   00000030   0x2606             MOVS     R6,#+6
   \   00000032   0x000F             MOVS     R7,R1
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x007F             LSLS     R7,R7,#+1
   \   00000038   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0x40AC             LSLS     R4,R4,R5
   \   00000040   0xE000             B.N      ??MCPWM_CountConfig_6
   \                     ??MCPWM_CountConfig_5: (+1)
   \   00000042   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_6: (+1)
   \   00000044   0x6604             STR      R4,[R0, #+96]
   \   00000046   0xE011             B.N      ??MCPWM_CountConfig_7
    249          			} else {
    250          				MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_FE(countConfig->counterChannel,channelNum);
   \                     ??MCPWM_CountConfig_4: (+1)
   \   00000048   0x681C             LDR      R4,[R3, #+0]
   \   0000004A   0x2C03             CMP      R4,#+3
   \   0000004C   0xD20C             BCS.N    ??MCPWM_CountConfig_8
   \   0000004E   0x2903             CMP      R1,#+3
   \   00000050   0xD20A             BCS.N    ??MCPWM_CountConfig_8
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0x681D             LDR      R5,[R3, #+0]
   \   00000056   0x2606             MOVS     R6,#+6
   \   00000058   0x000F             MOVS     R7,R1
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x007F             LSLS     R7,R7,#+1
   \   0000005E   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \   00000064   0x40AC             LSLS     R4,R4,R5
   \   00000066   0xE000             B.N      ??MCPWM_CountConfig_9
   \                     ??MCPWM_CountConfig_8: (+1)
   \   00000068   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_9: (+1)
   \   0000006A   0x6644             STR      R4,[R0, #+100]
    251          			}
    252          			if (countConfig->countRising /* == ENABLE */) {
   \                     ??MCPWM_CountConfig_7: (+1)
   \   0000006C   0x685C             LDR      R4,[R3, #+4]
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD00F             BEQ.N    ??MCPWM_CountConfig_10
    253          				MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_TCMCI_RE(countConfig->counterChannel,channelNum);
   \   00000072   0x681C             LDR      R4,[R3, #+0]
   \   00000074   0x2C03             CMP      R4,#+3
   \   00000076   0xD209             BCS.N    ??MCPWM_CountConfig_11
   \   00000078   0x2903             CMP      R1,#+3
   \   0000007A   0xD207             BCS.N    ??MCPWM_CountConfig_11
   \   0000007C   0x2401             MOVS     R4,#+1
   \   0000007E   0x681D             LDR      R5,[R3, #+0]
   \   00000080   0x2606             MOVS     R6,#+6
   \   00000082   0x004F             LSLS     R7,R1,#+1
   \   00000084   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   00000088   0x40AC             LSLS     R4,R4,R5
   \   0000008A   0xE000             B.N      ??MCPWM_CountConfig_12
   \                     ??MCPWM_CountConfig_11: (+1)
   \   0000008C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_12: (+1)
   \   0000008E   0x6604             STR      R4,[R0, #+96]
   \   00000090   0xE018             B.N      ??MCPWM_CountConfig_0
    254          			} else {
    255          				MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_RE(countConfig->counterChannel,channelNum);
   \                     ??MCPWM_CountConfig_10: (+1)
   \   00000092   0x681C             LDR      R4,[R3, #+0]
   \   00000094   0x2C03             CMP      R4,#+3
   \   00000096   0xD209             BCS.N    ??MCPWM_CountConfig_13
   \   00000098   0x2903             CMP      R1,#+3
   \   0000009A   0xD207             BCS.N    ??MCPWM_CountConfig_13
   \   0000009C   0x2401             MOVS     R4,#+1
   \   0000009E   0x681D             LDR      R5,[R3, #+0]
   \   000000A0   0x2606             MOVS     R6,#+6
   \   000000A2   0x004F             LSLS     R7,R1,#+1
   \   000000A4   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   000000A8   0x40AC             LSLS     R4,R4,R5
   \   000000AA   0xE000             B.N      ??MCPWM_CountConfig_14
   \                     ??MCPWM_CountConfig_13: (+1)
   \   000000AC   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_14: (+1)
   \   000000AE   0x6644             STR      R4,[R0, #+100]
   \   000000B0   0xE008             B.N      ??MCPWM_CountConfig_0
    256          			}
    257          		} else {
    258          			MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_CNTR(channelNum);
   \                     ??MCPWM_CountConfig_1: (+1)
   \   000000B2   0x2903             CMP      R1,#+3
   \   000000B4   0xD204             BCS.N    ??MCPWM_CountConfig_15
   \   000000B6   0x2401             MOVS     R4,#+1
   \   000000B8   0xF111 0x051D      ADDS     R5,R1,#+29
   \   000000BC   0x40AC             LSLS     R4,R4,R5
   \   000000BE   0xE000             B.N      ??MCPWM_CountConfig_16
   \                     ??MCPWM_CountConfig_15: (+1)
   \   000000C0   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_16: (+1)
   \   000000C2   0x6644             STR      R4,[R0, #+100]
    259          		}
    260          	}
    261          }
   \                     ??MCPWM_CountConfig_0: (+1)
   \   000000C4   0xBCF0             POP      {R4-R7}
   \   000000C6   0x4770             BX       LR               ;; return
    262          
    263          
    264          /*********************************************************************//**
    265           * @brief		Start MCPWM activity for each MCPWM channel
    266           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    267           * @param[in]	channel0	State of this command on channel 0:
    268           * 							- ENABLE: 'Start' command will effect on channel 0
    269           * 							- DISABLE: 'Start' command will not effect on channel 0
    270           * @param[in]	channel1	State of this command on channel 1:
    271           * 							- ENABLE: 'Start' command will effect on channel 1
    272           * 							- DISABLE: 'Start' command will not effect on channel 1
    273           * @param[in]	channel2	State of this command on channel 2:
    274           * 							- ENABLE: 'Start' command will effect on channel 2
    275           * 							- DISABLE: 'Start' command will not effect on channel 2
    276           * @return		None
    277           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          void MCPWM_Start(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
    279          					uint32_t channel1, uint32_t channel2)
    280          {
   \                     MCPWM_Start: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    281          	uint32_t regVal = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    282          	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
    283          				| (channel2 ? MCPWM_CON_RUN(2) : 0);
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??MCPWM_Start_0
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0xE000             B.N      ??MCPWM_Start_1
   \                     ??MCPWM_Start_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_Start_1: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD002             BEQ.N    ??MCPWM_Start_2
   \   00000012   0xF44F 0x7580      MOV      R5,#+256
   \   00000016   0xE000             B.N      ??MCPWM_Start_3
   \                     ??MCPWM_Start_2: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??MCPWM_Start_3: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD002             BEQ.N    ??MCPWM_Start_4
   \   0000001E   0xF45F 0x3680      MOVS     R6,#+65536
   \   00000022   0xE000             B.N      ??MCPWM_Start_5
   \                     ??MCPWM_Start_4: (+1)
   \   00000024   0x2600             MOVS     R6,#+0
   \                     ??MCPWM_Start_5: (+1)
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x4334             ORRS     R4,R6,R4
    284          	MCPWMx->MCCON_SET = regVal;
   \   0000002A   0x6044             STR      R4,[R0, #+4]
    285          }
   \   0000002C   0xBC70             POP      {R4-R6}
   \   0000002E   0x4770             BX       LR               ;; return
    286          
    287          
    288          /*********************************************************************//**
    289           * @brief		Stop MCPWM activity for each MCPWM channel
    290           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    291           * @param[in]	channel0	State of this command on channel 0:
    292           * 							- ENABLE: 'Stop' command will effect on channel 0
    293           * 							- DISABLE: 'Stop' command will not effect on channel 0
    294           * @param[in]	channel1	State of this command on channel 1:
    295           * 							- ENABLE: 'Stop' command will effect on channel 1
    296           * 							- DISABLE: 'Stop' command will not effect on channel 1
    297           * @param[in]	channel2	State of this command on channel 2:
    298           * 							- ENABLE: 'Stop' command will effect on channel 2
    299           * 							- DISABLE: 'Stop' command will not effect on channel 2
    300           * @return		None
    301           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    302          void MCPWM_Stop(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
    303          		uint32_t channel1, uint32_t channel2)
    304          {
   \                     MCPWM_Stop: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    305          	uint32_t regVal = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    306          	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
    307          				| (channel2 ? MCPWM_CON_RUN(2) : 0);
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??MCPWM_Stop_0
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0xE000             B.N      ??MCPWM_Stop_1
   \                     ??MCPWM_Stop_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_Stop_1: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD002             BEQ.N    ??MCPWM_Stop_2
   \   00000012   0xF44F 0x7580      MOV      R5,#+256
   \   00000016   0xE000             B.N      ??MCPWM_Stop_3
   \                     ??MCPWM_Stop_2: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??MCPWM_Stop_3: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD002             BEQ.N    ??MCPWM_Stop_4
   \   0000001E   0xF45F 0x3680      MOVS     R6,#+65536
   \   00000022   0xE000             B.N      ??MCPWM_Stop_5
   \                     ??MCPWM_Stop_4: (+1)
   \   00000024   0x2600             MOVS     R6,#+0
   \                     ??MCPWM_Stop_5: (+1)
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x4334             ORRS     R4,R6,R4
    308          	MCPWMx->MCCON_CLR = regVal;
   \   0000002A   0x6084             STR      R4,[R0, #+8]
    309          }
   \   0000002C   0xBC70             POP      {R4-R6}
   \   0000002E   0x4770             BX       LR               ;; return
    310          
    311          
    312          /*********************************************************************//**
    313           * @brief		Enables/Disables 3-phase AC motor mode on MCPWM peripheral
    314           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    315           * @param[in]	acMode		State of this command, should be:
    316           * 							- ENABLE.
    317           * 							- DISABLE.
    318           * @return		None
    319           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    320          void MCPWM_ACMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t acMode)
    321          {
    322          	if (acMode){
   \                     MCPWM_ACMode: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD003             BEQ.N    ??MCPWM_ACMode_0
    323          		MCPWMx->MCCON_SET = MCPWM_CON_ACMODE;
   \   00000004   0xF05F 0x4280      MOVS     R2,#+1073741824
   \   00000008   0x6042             STR      R2,[R0, #+4]
   \   0000000A   0xE002             B.N      ??MCPWM_ACMode_1
    324          	} else {
    325          		MCPWMx->MCCON_CLR = MCPWM_CON_ACMODE;
   \                     ??MCPWM_ACMode_0: (+1)
   \   0000000C   0xF05F 0x4280      MOVS     R2,#+1073741824
   \   00000010   0x6082             STR      R2,[R0, #+8]
    326          	}
    327          }
   \                     ??MCPWM_ACMode_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    328          
    329          
    330          /*********************************************************************//**
    331           * @brief		Enables/Disables 3-phase DC motor mode on MCPWM peripheral
    332           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected, should be MCPWM
    333           * @param[in]	dcMode			State of this command, should be:
    334           * 								- ENABLE.
    335           * 								- DISABLE.
    336           * @param[in]	outputInvered	Polarity of the MCOB outputs for all 3 channels,
    337           * 								should be:
    338           * 								- ENABLE: The MCOB outputs have opposite polarity
    339           * 									from the MCOA outputs.
    340           * 								- DISABLE: The MCOB outputs have the same basic
    341           * 									polarity as the MCOA outputs.
    342           * @param[in]	outputPattern	A value contains bits that enables/disables the specified
    343           * 								output pins route to the internal MCOA0 signal, should be:
    344          								- MCPWM_PATENT_A0: 	 MCOA0 tracks internal MCOA0
    345          								- MCPWM_PATENT_B0: 	 MCOB0 tracks internal MCOA0
    346          								- MCPWM_PATENT_A1: 	 MCOA1 tracks internal MCOA0
    347          								- MCPWM_PATENT_B1: 	 MCOB1 tracks internal MCOA0
    348          								- MCPWM_PATENT_A2: 	 MCOA2 tracks internal MCOA0
    349          								- MCPWM_PATENT_B2: 	 MCOB2 tracks internal MCOA0
    350           * @return		None
    351           *
    352           * Note: all these outputPatent values above can be ORed together for using as input parameter.
    353           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          void MCPWM_DCMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
    355          					uint32_t outputInvered, uint32_t outputPattern)
    356          {
   \                     MCPWM_DCMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
    357          	if (dcMode){
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??MCPWM_DCMode_0
    358          		MCPWMx->MCCON_SET = MCPWM_CON_DCMODE;
   \   00000006   0xF05F 0x4400      MOVS     R4,#-2147483648
   \   0000000A   0x6044             STR      R4,[R0, #+4]
   \   0000000C   0xE002             B.N      ??MCPWM_DCMode_1
    359          	} else {
    360          		MCPWMx->MCCON_CLR = MCPWM_CON_DCMODE;
   \                     ??MCPWM_DCMode_0: (+1)
   \   0000000E   0xF05F 0x4400      MOVS     R4,#-2147483648
   \   00000012   0x6084             STR      R4,[R0, #+8]
    361          	}
    362          
    363          	if (outputInvered) {
   \                     ??MCPWM_DCMode_1: (+1)
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD003             BEQ.N    ??MCPWM_DCMode_2
    364          		MCPWMx->MCCON_SET = MCPWM_CON_INVBDC;
   \   00000018   0xF05F 0x5400      MOVS     R4,#+536870912
   \   0000001C   0x6044             STR      R4,[R0, #+4]
   \   0000001E   0xE002             B.N      ??MCPWM_DCMode_3
    365          	} else {
    366          		MCPWMx->MCCON_CLR = MCPWM_CON_INVBDC;
   \                     ??MCPWM_DCMode_2: (+1)
   \   00000020   0xF05F 0x5400      MOVS     R4,#+536870912
   \   00000024   0x6084             STR      R4,[R0, #+8]
    367          	}
    368          
    369          	MCPWMx->MCCCP = outputPattern;
   \                     ??MCPWM_DCMode_3: (+1)
   \   00000026   0x6403             STR      R3,[R0, #+64]
    370          }
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    371          
    372          
    373          /*********************************************************************//**
    374           * @brief		Configures the specified interrupt in MCPWM peripheral
    375           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    376           * @param[in]	ulIntType	Interrupt type, should be:
    377           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    378           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    379           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    380           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    381           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    382           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    383           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    384           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    385           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    386           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    387           * @param[in]	NewState	New State of this command, should be:
    388           * 							- ENABLE.
    389           * 							- DISABLE.
    390           * @return		None
    391           *
    392           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    393           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    394          void MCPWM_IntConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState)
    395          {
    396          	if (NewState) {
   \                     MCPWM_IntConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ.N    ??MCPWM_IntConfig_0
    397          		MCPWMx->MCINTEN_SET = ulIntType;
   \   00000006   0x6541             STR      R1,[R0, #+84]
   \   00000008   0xE000             B.N      ??MCPWM_IntConfig_1
    398          	} else {
    399          		MCPWMx->MCINTEN_CLR = ulIntType;
   \                     ??MCPWM_IntConfig_0: (+1)
   \   0000000A   0x6581             STR      R1,[R0, #+88]
    400          	}
    401          }
   \                     ??MCPWM_IntConfig_1: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    402          
    403          
    404          /*********************************************************************//**
    405           * @brief		Sets/Forces the specified interrupt for MCPWM peripheral
    406           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    407           * @param[in]	ulIntType	Interrupt type, should be:
    408           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    409           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    410           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    411           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    412           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    413           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    414           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    415           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    416           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    417           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    418           * @return		None
    419           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    420           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          void MCPWM_IntSet(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    422          {
    423          	MCPWMx->MCINTFLAG_SET = ulIntType;
   \                     MCPWM_IntSet: (+1)
   \   00000000   0x66C1             STR      R1,[R0, #+108]
    424          }
   \   00000002   0x4770             BX       LR               ;; return
    425          
    426          
    427          /*********************************************************************//**
    428           * @brief		Clear the specified interrupt pending for MCPWM peripheral
    429           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    430           * @param[in]	ulIntType	Interrupt type, should be:
    431           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    432           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    433           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    434           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    435           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    436           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    437           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    438           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    439           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    440           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    441           * @return		None
    442           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    443           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    444          void MCPWM_IntClear(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    445          {
    446          	MCPWMx->MCINTFLAG_CLR = ulIntType;
   \                     MCPWM_IntClear: (+1)
   \   00000000   0x6701             STR      R1,[R0, #+112]
    447          }
   \   00000002   0x4770             BX       LR               ;; return
    448          
    449          
    450          /*********************************************************************//**
    451           * @brief		Check whether if the specified interrupt in MCPWM is set or not
    452           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected, should be MCPWM
    453           * @param[in]	ulIntType	Interrupt type, should be:
    454           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    455           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    456           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    457           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    458           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    459           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    460           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    461           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    462           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    463           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    464           * @return		None
    465           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    466          FlagStatus MCPWM_GetIntStatus(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    467          {
    468          	return ((MCPWMx->MCINTFLAG & ulIntType) ? SET : RESET);
   \                     MCPWM_GetIntStatus: (+1)
   \   00000000   0x6E80             LDR      R0,[R0, #+104]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??MCPWM_GetIntStatus_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??MCPWM_GetIntStatus_1
   \                     ??MCPWM_GetIntStatus_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??MCPWM_GetIntStatus_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    469          }
    470          
    471          /**
    472           * @}
    473           */
    474          
    475          #endif /* _MCPWM */
    476          
    477          /**
    478           * @}
    479           */
    480          
    481          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MCPWM_ACMode
       0   MCPWM_ClearCapture
      12   MCPWM_ConfigCapture
       4   MCPWM_ConfigChannel
      16   MCPWM_CountConfig
       4   MCPWM_DCMode
       0   MCPWM_GetCapture
       0   MCPWM_GetIntStatus
       8   MCPWM_Init
         8   -> CLKPWR_ConfigPPWR
       0   MCPWM_IntClear
       0   MCPWM_IntConfig
       0   MCPWM_IntSet
      12   MCPWM_Start
      12   MCPWM_Stop
       0   MCPWM_WriteToShadow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  MCPWM_ACMode
      16  MCPWM_ClearCapture
     250  MCPWM_ConfigCapture
     300  MCPWM_ConfigChannel
     200  MCPWM_CountConfig
      44  MCPWM_DCMode
      30  MCPWM_GetCapture
      16  MCPWM_GetIntStatus
      32  MCPWM_Init
       4  MCPWM_IntClear
      14  MCPWM_IntConfig
       4  MCPWM_IntSet
      48  MCPWM_Start
      48  MCPWM_Stop
      42  MCPWM_WriteToShadow

 
 1 068 bytes in section .text
 
 1 068 bytes of CODE memory

Errors: none
Warnings: 36
