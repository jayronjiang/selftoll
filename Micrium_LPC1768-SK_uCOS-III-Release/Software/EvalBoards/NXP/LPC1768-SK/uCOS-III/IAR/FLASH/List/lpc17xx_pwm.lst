###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:07
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_pwm.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_pwm.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_pwm.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_pwm.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_pwm.c
      1          /**
      2           * @file	: lpc17xx_pwm.c
      3           * @brief	: Contains all functions support for PWM firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 22. Apr. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup PWM
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_pwm.h"
     27          #include "lpc17xx_clkpwr.h"
     28          
     29          /* If this source file built with example, the LPC17xx FW library configuration
     30           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     31           * otherwise the default FW library configuration file must be included instead
     32           */
     33          #ifdef __BUILD_WITH_EXAMPLE__
     34          #include "lpc17xx_libcfg.h"
     35          #else
     36          #include "lpc17xx_libcfg_default.h"
     37          #endif /* __BUILD_WITH_EXAMPLE__ */
     38          
     39          
     40          #ifdef _PWM
     41          
     42          
     43          /* Public Functions ----------------------------------------------------------- */
     44          /** @addtogroup PWM_Public_Functions
     45           * @{
     46           */
     47          
     48          
     49          /*********************************************************************//**
     50           * @brief 		Check whether specified interrupt flag in PWM is set or not
     51           * @param[in]	PWMx: PWM peripheral, should be PWM1
     52           * @param[in]	IntFlag: PWM interrupt flag, should be:
     53           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
     54           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
     55           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
     56           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
     57           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
     58           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
     59           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
     60           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
     61           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
     62           * @return 		New State of PWM interrupt flag (SET or RESET)
     63           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          IntStatus PWM_GetIntStatus(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
     65          {
   \                     PWM_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     66          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_GetIntStatus_0
   \   0000000E   0x2142             MOVS     R1,#+66
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
     67          	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
   \                     ??PWM_GetIntStatus_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD017             BEQ.N    ??PWM_GetIntStatus_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD015             BEQ.N    ??PWM_GetIntStatus_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD013             BEQ.N    ??PWM_GetIntStatus_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD011             BEQ.N    ??PWM_GetIntStatus_1
   \   00000028   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000002C   0xD00E             BEQ.N    ??PWM_GetIntStatus_1
   \   0000002E   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000032   0xD00B             BEQ.N    ??PWM_GetIntStatus_1
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD008             BEQ.N    ??PWM_GetIntStatus_1
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD006             BEQ.N    ??PWM_GetIntStatus_1
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD004             BEQ.N    ??PWM_GetIntStatus_1
   \   00000042   0x2143             MOVS     R1,#+67
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000048   0x.... 0x....      BL       check_failed
     68          
     69          	return ((PWMx->IR & IntFlag) ? SET : RESET);
   \                     ??PWM_GetIntStatus_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x4228             TST      R0,R5
   \   00000050   0xD001             BEQ.N    ??PWM_GetIntStatus_2
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE000             B.N      ??PWM_GetIntStatus_3
   \                     ??PWM_GetIntStatus_2: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetIntStatus_3: (+1)
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     70          }
     71          
     72          
     73          
     74          /*********************************************************************//**
     75           * @brief 		Clear specified PWM Interrupt pending
     76           * @param[in]	PWMx: PWM peripheral, should be PWM1
     77           * @param[in]	IntFlag: PWM interrupt flag, should be:
     78           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
     79           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
     80           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
     81           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
     82           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
     83           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
     84           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
     85           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
     86           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
     87           * @return 		None
     88           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          void PWM_ClearIntPending(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
     90          {
   \                     PWM_ClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     91          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ClearIntPending_0
   \   0000000E   0x215B             MOVS     R1,#+91
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
     92          	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
   \                     ??PWM_ClearIntPending_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD017             BEQ.N    ??PWM_ClearIntPending_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD015             BEQ.N    ??PWM_ClearIntPending_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD013             BEQ.N    ??PWM_ClearIntPending_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD011             BEQ.N    ??PWM_ClearIntPending_1
   \   00000028   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000002C   0xD00E             BEQ.N    ??PWM_ClearIntPending_1
   \   0000002E   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000032   0xD00B             BEQ.N    ??PWM_ClearIntPending_1
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD008             BEQ.N    ??PWM_ClearIntPending_1
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD006             BEQ.N    ??PWM_ClearIntPending_1
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD004             BEQ.N    ??PWM_ClearIntPending_1
   \   00000042   0x215C             MOVS     R1,#+92
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000048   0x.... 0x....      BL       check_failed
     93          	PWMx->IR = IntFlag;
   \                     ??PWM_ClearIntPending_1: (+1)
   \   0000004C   0x6025             STR      R5,[R4, #+0]
     94          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     95          
     96          
     97          
     98          /*****************************************************************************//**
     99          * @brief		Fills each PWM_InitStruct member with its default value:
    100          * 				- If PWMCounterMode = PWM_MODE_TIMER:
    101          * 					+ PrescaleOption = PWM_TIMER_PRESCALE_USVAL
    102          * 					+ PrescaleValue = 1
    103          * 				- If PWMCounterMode = PWM_MODE_COUNTER:
    104          * 					+ CountInputSelect = PWM_COUNTER_PCAP1_0
    105          * 					+ CounterOption = PWM_COUNTER_RISING
    106          * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    107          * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    108          * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    109          * @param[in]	PWM_InitStruct Pointer to structure (PWM_TIMERCFG_Type or
    110          * 				 PWM_COUNTERCFG_Type) which will be initialized.
    111          * @return		None
    112          * Note: PWM_InitStruct pointer will be assigned to corresponding structure
    113          * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    114          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct)
    116          {
   \                     PWM_ConfigStructInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    117          	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??PWM_ConfigStructInit_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??PWM_ConfigStructInit_0
   \   00000012   0x2175             MOVS     R1,#+117
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000018   0x.... 0x....      BL       check_failed
    118          
    119          	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *) PWM_InitStruct;
   \                     ??PWM_ConfigStructInit_0: (+1)
   \   0000001C   0x0028             MOVS     R0,R5
    120          	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *) PWM_InitStruct;
   \   0000001E   0x0029             MOVS     R1,R5
    121          
    122          	if (PWMTimerCounterMode == PWM_MODE_TIMER )
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??PWM_ConfigStructInit_1
    123          	{
    124          		pTimeCfg->PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x7002             STRB     R2,[R0, #+0]
    125          		pTimeCfg->PrescaleValue = 1;
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x6042             STR      R2,[R0, #+4]
   \   0000002E   0xE006             B.N      ??PWM_ConfigStructInit_2
    126          	}
    127          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_ConfigStructInit_1: (+1)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD103             BNE.N    ??PWM_ConfigStructInit_2
    128          	{
    129          		pCounterCfg->CountInputSelect = PWM_COUNTER_PCAP1_0;
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x704A             STRB     R2,[R1, #+1]
    130          		pCounterCfg->CounterOption = PWM_COUNTER_RISING;
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0x700A             STRB     R2,[R1, #+0]
    131          	}
    132          }
   \                     ??PWM_ConfigStructInit_2: (+1)
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    133          
    134          
    135          /*********************************************************************//**
    136           * @brief 		Initializes the PWMx peripheral corresponding to the specified
    137           *               parameters in the PWM_ConfigStruct.
    138           * @param[in]	PWMx PWM peripheral, should be PWM1
    139           * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    140           * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    141           * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    142           * @param[in]	PWM_ConfigStruct Pointer to structure (PWM_TIMERCFG_Type or
    143           * 				 PWM_COUNTERCFG_Type) which will be initialized.
    144           * @return 		None
    145           * Note: PWM_ConfigStruct pointer will be assigned to corresponding structure
    146           * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    147           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          void PWM_Init(LPC_PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct)
    149          {
   \                     PWM_Init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4691             MOV      R9,R2
    150          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD004             BEQ.N    ??PWM_Init_0
   \   00000012   0x2196             MOVS     R1,#+150
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000018   0x.... 0x....      BL       check_failed
    151          	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
   \                     ??PWM_Init_0: (+1)
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD006             BEQ.N    ??PWM_Init_1
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xD004             BEQ.N    ??PWM_Init_1
   \   00000024   0x2197             MOVS     R1,#+151
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000002A   0x.... 0x....      BL       check_failed
    152          
    153          	PWM_TIMERCFG_Type *pTimeCfg = (PWM_TIMERCFG_Type *)PWM_ConfigStruct;
   \                     ??PWM_Init_1: (+1)
   \   0000002E   0x46CA             MOV      R10,R9
    154          	PWM_COUNTERCFG_Type *pCounterCfg = (PWM_COUNTERCFG_Type *)PWM_ConfigStruct;
   \   00000030   0x46C8             MOV      R8,R9
    155          	uint64_t clkdlycnt;
    156          
    157          	if (PWMx == LPC_PWM1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0xD10D             BNE.N    ??PWM_Init_2
    158          	{
    159          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, ENABLE);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    160          		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_PWM1, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x200C             MOVS     R0,#+12
   \   00000046   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
    161          		// Get peripheral clock of PWM1
    162          		clkdlycnt = (uint64_t) CLKPWR_GetPCLK (CLKPWR_PCLKSEL_PWM1);
   \   0000004A   0x200C             MOVS     R0,#+12
   \   0000004C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x0004             MOVS     R4,R0
   \   00000054   0x000D             MOVS     R5,R1
    163          	}
    164          
    165          	// Clear all interrupts pending
    166          	PWMx->IR = 0xFF & PWM_IR_BITMASK;
   \                     ??PWM_Init_2: (+1)
   \   00000056   0x203F             MOVS     R0,#+63
   \   00000058   0x6030             STR      R0,[R6, #+0]
    167          	PWMx->TCR = 0x00;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6070             STR      R0,[R6, #+4]
    168          	PWMx->CTCR = 0x00;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6730             STR      R0,[R6, #+112]
    169          	PWMx->MCR = 0x00;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x6170             STR      R0,[R6, #+20]
    170          	PWMx->CCR = 0x00;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x62B0             STR      R0,[R6, #+40]
    171          	PWMx->PCR = 0x00;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x64F0             STR      R0,[R6, #+76]
    172          	PWMx->LER = 0x00;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6530             STR      R0,[R6, #+80]
    173          
    174          	if (PWMTimerCounterMode == PWM_MODE_TIMER)
   \   00000072   0x2F00             CMP      R7,#+0
   \   00000074   0xD128             BNE.N    ??PWM_Init_3
    175          	{
    176          		CHECK_PARAM(PARAM_PWM_TIMER_PRESCALE(pTimeCfg->PrescaleOption));
   \   00000076   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD008             BEQ.N    ??PWM_Init_4
   \   0000007E   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD004             BEQ.N    ??PWM_Init_4
   \   00000086   0x21B0             MOVS     R1,#+176
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000008C   0x.... 0x....      BL       check_failed
    177          
    178          		/* Absolute prescale value */
    179          		if (pTimeCfg->PrescaleOption == PWM_TIMER_PRESCALE_TICKVAL)
   \                     ??PWM_Init_4: (+1)
   \   00000090   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD104             BNE.N    ??PWM_Init_5
    180          		{
    181          			PWMx->PR   = pTimeCfg->PrescaleValue - 1;
   \   00000098   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   \   0000009E   0x60F0             STR      R0,[R6, #+12]
   \   000000A0   0xE03F             B.N      ??PWM_Init_6
    182          		}
    183          		/* uSecond prescale value */
    184          		else
    185          		{
    186          			clkdlycnt = (clkdlycnt * pTimeCfg->PrescaleValue) / 1000000;
   \                     ??PWM_Init_5: (+1)
   \   000000A2   0xF8DA 0x2004      LDR      R2,[R10, #+4]
   \   000000A6   0x2300             MOVS     R3,#+0
   \   000000A8   0xFBA2 0x0104      UMULL    R0,R1,R2,R4
   \   000000AC   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000000B0   0xFB03 0x1104      MLA      R1,R3,R4,R1
   \   000000B4   0x.... 0x....      LDR.W    R2,??DataTable13_2  ;; 0xf4240
   \   000000B8   0x2300             MOVS     R3,#+0
   \   000000BA   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000BE   0x0004             MOVS     R4,R0
   \   000000C0   0x000D             MOVS     R5,R1
    187          			PWMx->PR = ((uint32_t) clkdlycnt) - 1;
   \   000000C2   0x1E60             SUBS     R0,R4,#+1
   \   000000C4   0x60F0             STR      R0,[R6, #+12]
   \   000000C6   0xE02C             B.N      ??PWM_Init_6
    188          		}
    189          
    190          	}
    191          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_Init_3: (+1)
   \   000000C8   0x2F01             CMP      R7,#+1
   \   000000CA   0xD12A             BNE.N    ??PWM_Init_6
    192          	{
    193          		CHECK_PARAM(PARAM_PWM_COUNTER_INPUTSEL(pCounterCfg->CountInputSelect));
   \   000000CC   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD008             BEQ.N    ??PWM_Init_7
   \   000000D4   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD004             BEQ.N    ??PWM_Init_7
   \   000000DC   0x21C1             MOVS     R1,#+193
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   000000E2   0x.... 0x....      BL       check_failed
    194          		CHECK_PARAM(PARAM_PWM_COUNTER_EDGE(pCounterCfg->CounterOption));
   \                     ??PWM_Init_7: (+1)
   \   000000E6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD00C             BEQ.N    ??PWM_Init_8
   \   000000EE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000F2   0x2802             CMP      R0,#+2
   \   000000F4   0xD008             BEQ.N    ??PWM_Init_8
   \   000000F6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000FA   0x2803             CMP      R0,#+3
   \   000000FC   0xD004             BEQ.N    ??PWM_Init_8
   \   000000FE   0x21C2             MOVS     R1,#+194
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000104   0x.... 0x....      BL       check_failed
    195          
    196          		PWMx->CTCR |= (PWM_CTCR_MODE((uint32_t)pCounterCfg->CounterOption)) \
    197          						| (PWM_CTCR_SELECT_INPUT((uint32_t)pCounterCfg->CountInputSelect));
   \                     ??PWM_Init_8: (+1)
   \   00000108   0x6F30             LDR      R0,[R6, #+112]
   \   0000010A   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   0000010E   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000112   0xF898 0x2001      LDRB     R2,[R8, #+1]
   \   00000116   0x0092             LSLS     R2,R2,#+2
   \   00000118   0xF012 0x020C      ANDS     R2,R2,#0xC
   \   0000011C   0x4311             ORRS     R1,R2,R1
   \   0000011E   0x4308             ORRS     R0,R1,R0
   \   00000120   0x6730             STR      R0,[R6, #+112]
    198          	}
    199          }
   \                     ??PWM_Init_6: (+1)
   \   00000122   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    200          
    201          /*********************************************************************//**
    202           * @brief		De-initializes the PWM peripheral registers to their
    203          *                  default reset values.
    204           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    205           * @return 		None
    206           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    207          void PWM_DeInit (LPC_PWM_TypeDef *PWMx)
    208          {
   \                     PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    209          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??PWM_DeInit_0
   \   0000000C   0x21D1             MOVS     R1,#+209
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000012   0x.... 0x....      BL       check_failed
    210          
    211          	// Disable PWM control (timer, counter and PWM)
    212          	PWMx->TCR = 0x00;
   \                     ??PWM_DeInit_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6060             STR      R0,[R4, #+4]
    213          
    214          	if (PWMx == LPC_PWM1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD103             BNE.N    ??PWM_DeInit_1
    215          	{
    216          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, DISABLE);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x2040             MOVS     R0,#+64
   \   00000026   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    217          	}
    218          }
   \                     ??PWM_DeInit_1: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    219          
    220          
    221          /*********************************************************************//**
    222           * @brief	 	Enable/Disable PWM peripheral
    223           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    224           * @param[in]	NewState	New State of this function, should be:
    225           * 							- ENABLE: Enable PWM peripheral
    226           * 							- DISABLE: Disable PWM peripheral
    227           * @return 		None
    228           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          void PWM_Cmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
    230          {
   \                     PWM_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    231          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_Cmd_0
   \   0000000E   0x21E7             MOVS     R1,#+231
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
    232          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??PWM_Cmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??PWM_Cmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD004             BEQ.N    ??PWM_Cmd_1
   \   00000024   0x21E8             MOVS     R1,#+232
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000002A   0x.... 0x....      BL       check_failed
    233          
    234          	if (NewState == ENABLE)
   \                     ??PWM_Cmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD104             BNE.N    ??PWM_Cmd_2
    235          	{
    236          		PWMx->TCR	|=  PWM_TCR_PWM_ENABLE;
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003A   0x6060             STR      R0,[R4, #+4]
   \   0000003C   0xE003             B.N      ??PWM_Cmd_3
    237          	}
    238          	else
    239          	{
    240          		PWMx->TCR &= (~PWM_TCR_PWM_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_Cmd_2: (+1)
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000044   0x6060             STR      R0,[R4, #+4]
    241          	}
    242          }
   \                     ??PWM_Cmd_3: (+1)
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    243          
    244          
    245          /*********************************************************************//**
    246           * @brief 		Enable/Disable Counter in PWM peripheral
    247           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    248           * @param[in]	NewState New State of this function, should be:
    249           * 							- ENABLE: Enable Counter in PWM peripheral
    250           * 							- DISABLE: Disable Counter in PWM peripheral
    251           * @return 		None
    252           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void PWM_CounterCmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
    254          {
   \                     PWM_CounterCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    255          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_CounterCmd_0
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
    256          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??PWM_CounterCmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD008             BEQ.N    ??PWM_CounterCmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??PWM_CounterCmd_1
   \   00000024   0xF44F 0x7180      MOV      R1,#+256
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000002C   0x.... 0x....      BL       check_failed
    257          	if (NewState == ENABLE)
   \                     ??PWM_CounterCmd_1: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD104             BNE.N    ??PWM_CounterCmd_2
    258          	{
    259          		PWMx->TCR	|=  PWM_TCR_COUNTER_ENABLE;
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003C   0x6060             STR      R0,[R4, #+4]
   \   0000003E   0xE003             B.N      ??PWM_CounterCmd_3
    260          	}
    261          	else
    262          	{
    263          		PWMx->TCR &= (~PWM_TCR_COUNTER_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_CounterCmd_2: (+1)
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF010 0x000A      ANDS     R0,R0,#0xA
   \   00000046   0x6060             STR      R0,[R4, #+4]
    264          	}
    265          }
   \                     ??PWM_CounterCmd_3: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    266          
    267          
    268          /*********************************************************************//**
    269           * @brief 		Reset Counter in PWM peripheral
    270           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    271           * @return 		None
    272           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    273          void PWM_ResetCounter(LPC_PWM_TypeDef *PWMx)
    274          {
   \                     PWM_ResetCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    275          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD005             BEQ.N    ??PWM_ResetCounter_0
   \   0000000C   0xF240 0x1113      MOVW     R1,#+275
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
    276          	PWMx->TCR |= PWM_TCR_COUNTER_RESET;
   \                     ??PWM_ResetCounter_0: (+1)
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
    277          	PWMx->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   00000026   0x6060             STR      R0,[R4, #+4]
    278          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    279          
    280          
    281          /*********************************************************************//**
    282           * @brief 		Configures match for PWM peripheral
    283           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    284           * @param[in]   PWM_MatchConfigStruct	Pointer to a PWM_MATCHCFG_Type structure
    285          *                    that contains the configuration information for the
    286          *                    specified PWM match function.
    287           * @return 		None
    288           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    289          void PWM_ConfigMatch(LPC_PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct)
    290          {
   \                     PWM_ConfigMatch: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    291          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??PWM_ConfigMatch_0
   \   0000000E   0xF240 0x1123      MOVW     R1,#+291
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000016   0x.... 0x....      BL       check_failed
    292          	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(PWM_MatchConfigStruct->MatchChannel));
   \                     ??PWM_ConfigMatch_0: (+1)
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x2807             CMP      R0,#+7
   \   0000001E   0xDB05             BLT.N    ??PWM_ConfigMatch_1
   \   00000020   0xF44F 0x7192      MOV      R1,#+292
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000028   0x.... 0x....      BL       check_failed
    293          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->IntOnMatch));
   \                     ??PWM_ConfigMatch_1: (+1)
   \   0000002C   0x7868             LDRB     R0,[R5, #+1]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD008             BEQ.N    ??PWM_ConfigMatch_2
   \   00000032   0x7868             LDRB     R0,[R5, #+1]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD005             BEQ.N    ??PWM_ConfigMatch_2
   \   00000038   0xF240 0x1125      MOVW     R1,#+293
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000040   0x.... 0x....      BL       check_failed
    294          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->ResetOnMatch));
   \                     ??PWM_ConfigMatch_2: (+1)
   \   00000044   0x78E8             LDRB     R0,[R5, #+3]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD008             BEQ.N    ??PWM_ConfigMatch_3
   \   0000004A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD005             BEQ.N    ??PWM_ConfigMatch_3
   \   00000050   0xF44F 0x7193      MOV      R1,#+294
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000058   0x.... 0x....      BL       check_failed
    295          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->StopOnMatch));
   \                     ??PWM_ConfigMatch_3: (+1)
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD008             BEQ.N    ??PWM_ConfigMatch_4
   \   00000062   0x78A8             LDRB     R0,[R5, #+2]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD005             BEQ.N    ??PWM_ConfigMatch_4
   \   00000068   0xF240 0x1127      MOVW     R1,#+295
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000070   0x.... 0x....      BL       check_failed
    296          
    297          	//interrupt on MRn
    298          	if (PWM_MatchConfigStruct->IntOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_4: (+1)
   \   00000074   0x7868             LDRB     R0,[R5, #+1]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD10D             BNE.N    ??PWM_ConfigMatch_5
    299          	{
    300          		PWMx->MCR |= PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   0000007A   0x6960             LDR      R0,[R4, #+20]
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x782A             LDRB     R2,[R5, #+0]
   \   00000080   0x0052             LSLS     R2,R2,#+1
   \   00000082   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   00000086   0x782B             LDRB     R3,[R5, #+0]
   \   00000088   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   0000008C   0x189A             ADDS     R2,R3,R2
   \   0000008E   0x4091             LSLS     R1,R1,R2
   \   00000090   0x4308             ORRS     R0,R1,R0
   \   00000092   0x6160             STR      R0,[R4, #+20]
   \   00000094   0xE00F             B.N      ??PWM_ConfigMatch_6
    301          	}
    302          	else
    303          	{
    304          		PWMx->MCR &= (~PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    305          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_5: (+1)
   \   00000096   0x6960             LDR      R0,[R4, #+20]
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x782A             LDRB     R2,[R5, #+0]
   \   0000009C   0x0052             LSLS     R2,R2,#+1
   \   0000009E   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   000000A2   0x782B             LDRB     R3,[R5, #+0]
   \   000000A4   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000A8   0x189A             ADDS     R2,R3,R2
   \   000000AA   0x4091             LSLS     R1,R1,R2
   \   000000AC   0x43C9             MVNS     R1,R1
   \   000000AE   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   000000B0   0x0AC9             LSRS     R1,R1,#+11
   \   000000B2   0x4008             ANDS     R0,R1,R0
   \   000000B4   0x6160             STR      R0,[R4, #+20]
    306          	}
    307          
    308          	//reset on MRn
    309          	if (PWM_MatchConfigStruct->ResetOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_6: (+1)
   \   000000B6   0x78E8             LDRB     R0,[R5, #+3]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD10E             BNE.N    ??PWM_ConfigMatch_7
    310          	{
    311          		PWMx->MCR |= PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   000000BC   0x6960             LDR      R0,[R4, #+20]
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x782A             LDRB     R2,[R5, #+0]
   \   000000C2   0x0052             LSLS     R2,R2,#+1
   \   000000C4   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   000000C8   0x782B             LDRB     R3,[R5, #+0]
   \   000000CA   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000CE   0x189A             ADDS     R2,R3,R2
   \   000000D0   0x1C52             ADDS     R2,R2,#+1
   \   000000D2   0x4091             LSLS     R1,R1,R2
   \   000000D4   0x4308             ORRS     R0,R1,R0
   \   000000D6   0x6160             STR      R0,[R4, #+20]
   \   000000D8   0xE010             B.N      ??PWM_ConfigMatch_8
    312          	}
    313          	else
    314          	{
    315          		PWMx->MCR &= (~PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    316          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_7: (+1)
   \   000000DA   0x6960             LDR      R0,[R4, #+20]
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x782A             LDRB     R2,[R5, #+0]
   \   000000E0   0x0052             LSLS     R2,R2,#+1
   \   000000E2   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   000000E6   0x782B             LDRB     R3,[R5, #+0]
   \   000000E8   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000EC   0x189A             ADDS     R2,R3,R2
   \   000000EE   0x1C52             ADDS     R2,R2,#+1
   \   000000F0   0x4091             LSLS     R1,R1,R2
   \   000000F2   0x43C9             MVNS     R1,R1
   \   000000F4   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   000000F6   0x0AC9             LSRS     R1,R1,#+11
   \   000000F8   0x4008             ANDS     R0,R1,R0
   \   000000FA   0x6160             STR      R0,[R4, #+20]
    317          	}
    318          
    319          	//stop on MRn
    320          	if (PWM_MatchConfigStruct->StopOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_8: (+1)
   \   000000FC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD10E             BNE.N    ??PWM_ConfigMatch_9
    321          	{
    322          		PWMx->MCR |= PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   00000102   0x6960             LDR      R0,[R4, #+20]
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x782A             LDRB     R2,[R5, #+0]
   \   00000108   0x0052             LSLS     R2,R2,#+1
   \   0000010A   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   0000010E   0x782B             LDRB     R3,[R5, #+0]
   \   00000110   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000114   0x189A             ADDS     R2,R3,R2
   \   00000116   0x1C92             ADDS     R2,R2,#+2
   \   00000118   0x4091             LSLS     R1,R1,R2
   \   0000011A   0x4308             ORRS     R0,R1,R0
   \   0000011C   0x6160             STR      R0,[R4, #+20]
   \   0000011E   0xE010             B.N      ??PWM_ConfigMatch_10
    323          	}
    324          	else
    325          	{
    326          		PWMx->MCR &= (~PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    327          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_9: (+1)
   \   00000120   0x6960             LDR      R0,[R4, #+20]
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x782A             LDRB     R2,[R5, #+0]
   \   00000126   0x0052             LSLS     R2,R2,#+1
   \   00000128   0xF012 0x020E      ANDS     R2,R2,#0xE
   \   0000012C   0x782B             LDRB     R3,[R5, #+0]
   \   0000012E   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000132   0x189A             ADDS     R2,R3,R2
   \   00000134   0x1C92             ADDS     R2,R2,#+2
   \   00000136   0x4091             LSLS     R1,R1,R2
   \   00000138   0x43C9             MVNS     R1,R1
   \   0000013A   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   0000013C   0x0AC9             LSRS     R1,R1,#+11
   \   0000013E   0x4008             ANDS     R0,R1,R0
   \   00000140   0x6160             STR      R0,[R4, #+20]
    328          	}
    329          }
   \                     ??PWM_ConfigMatch_10: (+1)
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    330          
    331          
    332          /*********************************************************************//**
    333           * @brief 		Configures capture input for PWM peripheral
    334           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    335           * @param[in]   PWM_CaptureConfigStruct	Pointer to a PWM_CAPTURECFG_Type structure
    336          *                    that contains the configuration information for the
    337          *                    specified PWM capture input function.
    338           * @return 		None
    339           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    340          void PWM_ConfigCapture(LPC_PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct)
    341          {
   \                     PWM_ConfigCapture: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    342          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x....             LDR.N    R0,??DataTable13  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??PWM_ConfigCapture_0
   \   0000000C   0xF44F 0x71AB      MOV      R1,#+342
   \   00000010   0x....             LDR.N    R0,??DataTable13_1
   \   00000012   0x.... 0x....      BL       check_failed
    343          	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(PWM_CaptureConfigStruct->CaptureChannel));
   \                     ??PWM_ConfigCapture_0: (+1)
   \   00000016   0x7828             LDRB     R0,[R5, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??PWM_ConfigCapture_1
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD004             BEQ.N    ??PWM_ConfigCapture_1
   \   00000022   0xF240 0x1157      MOVW     R1,#+343
   \   00000026   0x....             LDR.N    R0,??DataTable13_1
   \   00000028   0x.... 0x....      BL       check_failed
    344          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->FallingEdge));
   \                     ??PWM_ConfigCapture_1: (+1)
   \   0000002C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD007             BEQ.N    ??PWM_ConfigCapture_2
   \   00000032   0x78A8             LDRB     R0,[R5, #+2]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD004             BEQ.N    ??PWM_ConfigCapture_2
   \   00000038   0xF44F 0x71AC      MOV      R1,#+344
   \   0000003C   0x....             LDR.N    R0,??DataTable13_1
   \   0000003E   0x.... 0x....      BL       check_failed
    345          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->IntOnCaption));
   \                     ??PWM_ConfigCapture_2: (+1)
   \   00000042   0x78E8             LDRB     R0,[R5, #+3]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD007             BEQ.N    ??PWM_ConfigCapture_3
   \   00000048   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD004             BEQ.N    ??PWM_ConfigCapture_3
   \   0000004E   0xF240 0x1159      MOVW     R1,#+345
   \   00000052   0x....             LDR.N    R0,??DataTable13_1
   \   00000054   0x.... 0x....      BL       check_failed
    346          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->RisingEdge));
   \                     ??PWM_ConfigCapture_3: (+1)
   \   00000058   0x7868             LDRB     R0,[R5, #+1]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD007             BEQ.N    ??PWM_ConfigCapture_4
   \   0000005E   0x7868             LDRB     R0,[R5, #+1]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD004             BEQ.N    ??PWM_ConfigCapture_4
   \   00000064   0xF44F 0x71AD      MOV      R1,#+346
   \   00000068   0x....             LDR.N    R0,??DataTable13_1
   \   0000006A   0x.... 0x....      BL       check_failed
    347          
    348          	if (PWM_CaptureConfigStruct->RisingEdge == ENABLE)
   \                     ??PWM_ConfigCapture_4: (+1)
   \   0000006E   0x7868             LDRB     R0,[R5, #+1]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD10D             BNE.N    ??PWM_ConfigCapture_5
    349          	{
    350          		PWMx->CCR |= PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel);
   \   00000074   0x6AA0             LDR      R0,[R4, #+40]
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x782A             LDRB     R2,[R5, #+0]
   \   0000007A   0x0052             LSLS     R2,R2,#+1
   \   0000007C   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   00000080   0x782B             LDRB     R3,[R5, #+0]
   \   00000082   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000086   0x189A             ADDS     R2,R3,R2
   \   00000088   0x4091             LSLS     R1,R1,R2
   \   0000008A   0x4308             ORRS     R0,R1,R0
   \   0000008C   0x62A0             STR      R0,[R4, #+40]
   \   0000008E   0xE00F             B.N      ??PWM_ConfigCapture_6
    351          	}
    352          	else
    353          	{
    354          		PWMx->CCR &= (~PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel)) \
    355          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_5: (+1)
   \   00000090   0x6AA0             LDR      R0,[R4, #+40]
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x782A             LDRB     R2,[R5, #+0]
   \   00000096   0x0052             LSLS     R2,R2,#+1
   \   00000098   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   0000009C   0x782B             LDRB     R3,[R5, #+0]
   \   0000009E   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000A2   0x189A             ADDS     R2,R3,R2
   \   000000A4   0x4091             LSLS     R1,R1,R2
   \   000000A6   0x43C9             MVNS     R1,R1
   \   000000A8   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   000000AC   0x4008             ANDS     R0,R1,R0
   \   000000AE   0x62A0             STR      R0,[R4, #+40]
    356          	}
    357          
    358          	if (PWM_CaptureConfigStruct->FallingEdge == ENABLE)
   \                     ??PWM_ConfigCapture_6: (+1)
   \   000000B0   0x78A8             LDRB     R0,[R5, #+2]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD10E             BNE.N    ??PWM_ConfigCapture_7
    359          	{
    360          		PWMx->CCR |= PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel);
   \   000000B6   0x6AA0             LDR      R0,[R4, #+40]
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0x782A             LDRB     R2,[R5, #+0]
   \   000000BC   0x0052             LSLS     R2,R2,#+1
   \   000000BE   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   000000C2   0x782B             LDRB     R3,[R5, #+0]
   \   000000C4   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000C8   0x189A             ADDS     R2,R3,R2
   \   000000CA   0x1C52             ADDS     R2,R2,#+1
   \   000000CC   0x4091             LSLS     R1,R1,R2
   \   000000CE   0x4308             ORRS     R0,R1,R0
   \   000000D0   0x62A0             STR      R0,[R4, #+40]
   \   000000D2   0xE010             B.N      ??PWM_ConfigCapture_8
    361          	}
    362          	else
    363          	{
    364          		PWMx->CCR &= (~PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel)) \
    365          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_7: (+1)
   \   000000D4   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D6   0x2101             MOVS     R1,#+1
   \   000000D8   0x782A             LDRB     R2,[R5, #+0]
   \   000000DA   0x0052             LSLS     R2,R2,#+1
   \   000000DC   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   000000E0   0x782B             LDRB     R3,[R5, #+0]
   \   000000E2   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000E6   0x189A             ADDS     R2,R3,R2
   \   000000E8   0x1C52             ADDS     R2,R2,#+1
   \   000000EA   0x4091             LSLS     R1,R1,R2
   \   000000EC   0x43C9             MVNS     R1,R1
   \   000000EE   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   000000F2   0x4008             ANDS     R0,R1,R0
   \   000000F4   0x62A0             STR      R0,[R4, #+40]
    366          	}
    367          
    368          	if (PWM_CaptureConfigStruct->IntOnCaption == ENABLE)
   \                     ??PWM_ConfigCapture_8: (+1)
   \   000000F6   0x78E8             LDRB     R0,[R5, #+3]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD10E             BNE.N    ??PWM_ConfigCapture_9
    369          	{
    370          		PWMx->CCR |= PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel);
   \   000000FC   0x6AA0             LDR      R0,[R4, #+40]
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x782A             LDRB     R2,[R5, #+0]
   \   00000102   0x0052             LSLS     R2,R2,#+1
   \   00000104   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   00000108   0x782B             LDRB     R3,[R5, #+0]
   \   0000010A   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   0000010E   0x189A             ADDS     R2,R3,R2
   \   00000110   0x1C92             ADDS     R2,R2,#+2
   \   00000112   0x4091             LSLS     R1,R1,R2
   \   00000114   0x4308             ORRS     R0,R1,R0
   \   00000116   0x62A0             STR      R0,[R4, #+40]
   \   00000118   0xE010             B.N      ??PWM_ConfigCapture_10
    371          	}
    372          	else
    373          	{
    374          		PWMx->CCR &= (~PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel)) \
    375          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_9: (+1)
   \   0000011A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0x782A             LDRB     R2,[R5, #+0]
   \   00000120   0x0052             LSLS     R2,R2,#+1
   \   00000122   0xF012 0x0204      ANDS     R2,R2,#0x4
   \   00000126   0x782B             LDRB     R3,[R5, #+0]
   \   00000128   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   0000012C   0x189A             ADDS     R2,R3,R2
   \   0000012E   0x1C92             ADDS     R2,R2,#+2
   \   00000130   0x4091             LSLS     R1,R1,R2
   \   00000132   0x43C9             MVNS     R1,R1
   \   00000134   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   00000138   0x4008             ANDS     R0,R1,R0
   \   0000013A   0x62A0             STR      R0,[R4, #+40]
    376          	}
    377          }
   \                     ??PWM_ConfigCapture_10: (+1)
   \   0000013C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    378          
    379          
    380          /*********************************************************************//**
    381           * @brief 		Read value of capture register PWM peripheral
    382           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    383           * @param[in]	CaptureChannel: capture channel number, should be in
    384           * 				range 0 to 1
    385           * @return 		Value of capture register
    386           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          uint32_t PWM_GetCaptureValue(LPC_PWM_TypeDef *PWMx, uint8_t CaptureChannel)
    388          {
   \                     PWM_GetCaptureValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    389          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x....             LDR.N    R0,??DataTable13  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??PWM_GetCaptureValue_0
   \   0000000C   0xF240 0x1185      MOVW     R1,#+389
   \   00000010   0x....             LDR.N    R0,??DataTable13_1
   \   00000012   0x.... 0x....      BL       check_failed
    390          	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(CaptureChannel));
   \                     ??PWM_GetCaptureValue_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??PWM_GetCaptureValue_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??PWM_GetCaptureValue_1
   \   00000022   0xF44F 0x71C3      MOV      R1,#+390
   \   00000026   0x....             LDR.N    R0,??DataTable13_1
   \   00000028   0x.... 0x....      BL       check_failed
    391          
    392          	switch (CaptureChannel)
   \                     ??PWM_GetCaptureValue_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD002             BEQ.N    ??PWM_GetCaptureValue_2
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD002             BEQ.N    ??PWM_GetCaptureValue_3
   \   00000036   0xE003             B.N      ??PWM_GetCaptureValue_4
    393          	{
    394          	case 0:
    395          		return PWMx->CR0;
   \                     ??PWM_GetCaptureValue_2: (+1)
   \   00000038   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003A   0xE002             B.N      ??PWM_GetCaptureValue_5
    396          		break;
    397          
    398          	case 1:
    399          		return PWMx->CR1;
   \                     ??PWM_GetCaptureValue_3: (+1)
   \   0000003C   0x6B20             LDR      R0,[R4, #+48]
   \   0000003E   0xE000             B.N      ??PWM_GetCaptureValue_5
    400          		break;
    401          
    402          	default:
    403          		return (0);
   \                     ??PWM_GetCaptureValue_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetCaptureValue_5: (+1)
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    404          		break;
    405          	}
    406          }
    407          
    408          
    409          /********************************************************************//**
    410           * @brief 		Update value for each PWM channel with update type option
    411           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    412           * @param[in]	MatchChannel Match channel
    413           * @param[in]	MatchValue Match value
    414           * @param[in]	UpdateType Type of Update, should be:
    415           * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
    416           * 					this channel immediately
    417           * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
    418           * 					this channel on next reset by a PWM Match event.
    419           * @return		None
    420           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          void PWM_MatchUpdate(LPC_PWM_TypeDef *PWMx, uint8_t MatchChannel, \
    422          					uint32_t MatchValue, uint8_t UpdateType)
    423          {
   \                     PWM_MatchUpdate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    424          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   0000000A   0x....             LDR.N    R0,??DataTable13  ;; 0x40018000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??PWM_MatchUpdate_0
   \   00000010   0xF44F 0x71D4      MOV      R1,#+424
   \   00000014   0x....             LDR.N    R0,??DataTable13_1
   \   00000016   0x.... 0x....      BL       check_failed
    425          	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(MatchChannel));
   \                     ??PWM_MatchUpdate_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D07             CMP      R5,#+7
   \   0000001E   0xDB04             BLT.N    ??PWM_MatchUpdate_1
   \   00000020   0xF240 0x11A9      MOVW     R1,#+425
   \   00000024   0x....             LDR.N    R0,??DataTable13_1
   \   00000026   0x.... 0x....      BL       check_failed
    426          	CHECK_PARAM(PARAM_PWM_MATCH_UPDATE(UpdateType));
   \                     ??PWM_MatchUpdate_1: (+1)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD007             BEQ.N    ??PWM_MatchUpdate_2
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2F01             CMP      R7,#+1
   \   00000034   0xD004             BEQ.N    ??PWM_MatchUpdate_2
   \   00000036   0xF44F 0x71D5      MOV      R1,#+426
   \   0000003A   0x....             LDR.N    R0,??DataTable13_1
   \   0000003C   0x.... 0x....      BL       check_failed
    427          
    428          	switch (MatchChannel)
   \                     ??PWM_MatchUpdate_2: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD009             BEQ.N    ??PWM_MatchUpdate_3
   \   00000046   0x2D02             CMP      R5,#+2
   \   00000048   0xD00B             BEQ.N    ??PWM_MatchUpdate_4
   \   0000004A   0xD308             BCC.N    ??PWM_MatchUpdate_5
   \   0000004C   0x2D04             CMP      R5,#+4
   \   0000004E   0xD00C             BEQ.N    ??PWM_MatchUpdate_6
   \   00000050   0xD309             BCC.N    ??PWM_MatchUpdate_7
   \   00000052   0x2D06             CMP      R5,#+6
   \   00000054   0xD00D             BEQ.N    ??PWM_MatchUpdate_8
   \   00000056   0xD30A             BCC.N    ??PWM_MatchUpdate_9
   \   00000058   0xE00C             B.N      ??PWM_MatchUpdate_10
    429          	{
    430          	case 0:
    431          		PWMx->MR0 = MatchValue;
   \                     ??PWM_MatchUpdate_3: (+1)
   \   0000005A   0x61A6             STR      R6,[R4, #+24]
    432          		break;
   \   0000005C   0xE00A             B.N      ??PWM_MatchUpdate_10
    433          
    434          	case 1:
    435          		PWMx->MR1 = MatchValue;
   \                     ??PWM_MatchUpdate_5: (+1)
   \   0000005E   0x61E6             STR      R6,[R4, #+28]
    436          		break;
   \   00000060   0xE008             B.N      ??PWM_MatchUpdate_10
    437          
    438          	case 2:
    439          		PWMx->MR2 = MatchValue;
   \                     ??PWM_MatchUpdate_4: (+1)
   \   00000062   0x6226             STR      R6,[R4, #+32]
    440          		break;
   \   00000064   0xE006             B.N      ??PWM_MatchUpdate_10
    441          
    442          	case 3:
    443          		PWMx->MR3 = MatchValue;
   \                     ??PWM_MatchUpdate_7: (+1)
   \   00000066   0x6266             STR      R6,[R4, #+36]
    444          		break;
   \   00000068   0xE004             B.N      ??PWM_MatchUpdate_10
    445          
    446          	case 4:
    447          		PWMx->MR4 = MatchValue;
   \                     ??PWM_MatchUpdate_6: (+1)
   \   0000006A   0x6426             STR      R6,[R4, #+64]
    448          		break;
   \   0000006C   0xE002             B.N      ??PWM_MatchUpdate_10
    449          
    450          	case 5:
    451          		PWMx->MR5 = MatchValue;
   \                     ??PWM_MatchUpdate_9: (+1)
   \   0000006E   0x6466             STR      R6,[R4, #+68]
    452          		break;
   \   00000070   0xE000             B.N      ??PWM_MatchUpdate_10
    453          
    454          	case 6:
    455          		PWMx->MR6 = MatchValue;
   \                     ??PWM_MatchUpdate_8: (+1)
   \   00000072   0x64A6             STR      R6,[R4, #+72]
    456          		break;
    457          	}
    458          
    459          	// Write Latch register
    460          	PWMx->LER |= PWM_LER_EN_MATCHn_LATCH(MatchChannel);
   \                     ??PWM_MatchUpdate_10: (+1)
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D07             CMP      R5,#+7
   \   00000078   0xDA02             BGE.N    ??PWM_MatchUpdate_11
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x40A8             LSLS     R0,R0,R5
   \   0000007E   0xE000             B.N      ??PWM_MatchUpdate_12
   \                     ??PWM_MatchUpdate_11: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??PWM_MatchUpdate_12: (+1)
   \   00000082   0x6D21             LDR      R1,[R4, #+80]
   \   00000084   0x4308             ORRS     R0,R0,R1
   \   00000086   0x6520             STR      R0,[R4, #+80]
    461          
    462          	// In case of update now
    463          	if (UpdateType == PWM_MATCH_UPDATE_NOW)
   \   00000088   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008A   0x2F00             CMP      R7,#+0
   \   0000008C   0xD107             BNE.N    ??PWM_MatchUpdate_13
    464          	{
    465          		PWMx->TCR |= PWM_TCR_COUNTER_RESET;
   \   0000008E   0x6860             LDR      R0,[R4, #+4]
   \   00000090   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000094   0x6060             STR      R0,[R4, #+4]
    466          		PWMx->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   0000009C   0x6060             STR      R0,[R4, #+4]
    467          	}
    468          }
   \                     ??PWM_MatchUpdate_13: (+1)
   \   0000009E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    469          
    470          
    471          /********************************************************************//**
    472           * @brief 		Configure Edge mode for each PWM channel
    473           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    474           * @param[in]	PWMChannel PWM channel, should be in range from 2 to 6
    475           * @param[in]	ModeOption PWM mode option, should be:
    476           * 				- PWM_CHANNEL_SINGLE_EDGE: Single Edge mode
    477           * 				- PWM_CHANNEL_DUAL_EDGE: Dual Edge mode
    478           * @return 		None
    479           * Note: PWM Channel 1 can not be selected for mode option
    480           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    481          void PWM_ChannelConfig(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption)
    482          {
   \                     PWM_ChannelConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    483          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ChannelConfig_0
   \   0000000E   0xF240 0x11E3      MOVW     R1,#+483
   \   00000012   0x....             LDR.N    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
    484          	CHECK_PARAM(PARAM_PWM1_EDGE_MODE_CHANNEL(PWMChannel));
   \                     ??PWM_ChannelConfig_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDB02             BLT.N    ??PWM_ChannelConfig_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D07             CMP      R5,#+7
   \   00000022   0xDB04             BLT.N    ??PWM_ChannelConfig_2
   \                     ??PWM_ChannelConfig_1: (+1)
   \   00000024   0xF44F 0x71F2      MOV      R1,#+484
   \   00000028   0x....             LDR.N    R0,??DataTable13_1
   \   0000002A   0x.... 0x....      BL       check_failed
    485          	CHECK_PARAM(PARAM_PWM_CHANNEL_EDGE(ModeOption));
   \                     ??PWM_ChannelConfig_2: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD007             BEQ.N    ??PWM_ChannelConfig_3
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD004             BEQ.N    ??PWM_ChannelConfig_3
   \   0000003A   0xF240 0x11E5      MOVW     R1,#+485
   \   0000003E   0x....             LDR.N    R0,??DataTable13_1
   \   00000040   0x.... 0x....      BL       check_failed
    486          
    487          	// Single edge mode
    488          	if (ModeOption == PWM_CHANNEL_SINGLE_EDGE)
   \                     ??PWM_ChannelConfig_3: (+1)
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD110             BNE.N    ??PWM_ChannelConfig_4
    489          	{
    490          		PWMx->PCR &= (~PWM_PCR_PWMSELn(PWMChannel)) & PWM_PCR_BITMASK;
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xDA01             BGE.N    ??PWM_ChannelConfig_5
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE001             B.N      ??PWM_ChannelConfig_6
   \                     ??PWM_ChannelConfig_5: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x40A8             LSLS     R0,R0,R5
   \                     ??PWM_ChannelConfig_6: (+1)
   \   0000005C   0x6CE1             LDR      R1,[R4, #+76]
   \   0000005E   0xF647 0x627C      MOVW     R2,#+32380
   \   00000062   0xEA32 0x0000      BICS     R0,R2,R0
   \   00000066   0x4008             ANDS     R0,R0,R1
   \   00000068   0x64E0             STR      R0,[R4, #+76]
   \   0000006A   0xE00B             B.N      ??PWM_ChannelConfig_7
    491          	}
    492          	// Double edge mode
    493          	else if (PWM_CHANNEL_DUAL_EDGE)
    494          	{
    495          		PWMx->PCR |= PWM_PCR_PWMSELn(PWMChannel);
   \                     ??PWM_ChannelConfig_4: (+1)
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xDA01             BGE.N    ??PWM_ChannelConfig_8
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE001             B.N      ??PWM_ChannelConfig_9
   \                     ??PWM_ChannelConfig_8: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x40A8             LSLS     R0,R0,R5
   \                     ??PWM_ChannelConfig_9: (+1)
   \   0000007E   0x6CE1             LDR      R1,[R4, #+76]
   \   00000080   0x4308             ORRS     R0,R0,R1
   \   00000082   0x64E0             STR      R0,[R4, #+76]
    496          	}
    497          }
   \                     ??PWM_ChannelConfig_7: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    498          
    499          
    500          
    501          /********************************************************************//**
    502           * @brief 		Enable/Disable PWM channel output
    503           * @param[in]	PWMx	PWM peripheral selected, should be PWM1
    504           * @param[in]	PWMChannel PWM channel, should be in range from 1 to 6
    505           * @param[in]	NewState New State of this function, should be:
    506           * 				- ENABLE: Enable this PWM channel output
    507           * 				- DISABLE: Disable this PWM channel output
    508           * @return		None
    509           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    510          void PWM_ChannelCmd(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState)
    511          {
   \                     PWM_ChannelCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    512          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ChannelCmd_0
   \   0000000E   0xF44F 0x7100      MOV      R1,#+512
   \   00000012   0x....             LDR.N    R0,??DataTable13_1
   \   00000014   0x.... 0x....      BL       check_failed
    513          	CHECK_PARAM(PARAM_PWM1_CHANNEL(PWMChannel));
   \                     ??PWM_ChannelCmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD002             BEQ.N    ??PWM_ChannelCmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D07             CMP      R5,#+7
   \   00000022   0xDB04             BLT.N    ??PWM_ChannelCmd_2
   \                     ??PWM_ChannelCmd_1: (+1)
   \   00000024   0xF240 0x2101      MOVW     R1,#+513
   \   00000028   0x....             LDR.N    R0,??DataTable13_1
   \   0000002A   0x.... 0x....      BL       check_failed
    514          
    515          	if (NewState == ENABLE)
   \                     ??PWM_ChannelCmd_2: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD10E             BNE.N    ??PWM_ChannelCmd_3
    516          	{
    517          		PWMx->PCR |= PWM_PCR_PWMENAn(PWMChannel);
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xDA01             BGE.N    ??PWM_ChannelCmd_4
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE003             B.N      ??PWM_ChannelCmd_5
   \                     ??PWM_ChannelCmd_4: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF115 0x0108      ADDS     R1,R5,#+8
   \   00000048   0x4088             LSLS     R0,R0,R1
   \                     ??PWM_ChannelCmd_5: (+1)
   \   0000004A   0x6CE1             LDR      R1,[R4, #+76]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x64E0             STR      R0,[R4, #+76]
   \   00000050   0xE011             B.N      ??PWM_ChannelCmd_6
    518          	}
    519          	else
    520          	{
    521          		PWMx->PCR &= (~PWM_PCR_PWMENAn(PWMChannel)) & PWM_PCR_BITMASK;
   \                     ??PWM_ChannelCmd_3: (+1)
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDA01             BGE.N    ??PWM_ChannelCmd_7
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??PWM_ChannelCmd_8
   \                     ??PWM_ChannelCmd_7: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF115 0x0108      ADDS     R1,R5,#+8
   \   00000066   0x4088             LSLS     R0,R0,R1
   \                     ??PWM_ChannelCmd_8: (+1)
   \   00000068   0x6CE1             LDR      R1,[R4, #+76]
   \   0000006A   0xF647 0x627C      MOVW     R2,#+32380
   \   0000006E   0xEA32 0x0000      BICS     R0,R2,R0
   \   00000072   0x4008             ANDS     R0,R0,R1
   \   00000074   0x64E0             STR      R0,[R4, #+76]
    522          	}
    523          }
   \                     ??PWM_ChannelCmd_6: (+1)
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40018000         DC32     0x40018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x70          DC8 5FH, 70H, 77H, 6DH, 2EH, 63H, 0
   \              0x77 0x6D    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
    524          
    525          /**
    526           * @}
    527           */
    528          
    529          #endif /* _PWM */
    530          
    531          /**
    532           * @}
    533           */
    534          
    535          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   PWM_ChannelCmd
        16   -> check_failed
      16   PWM_ChannelConfig
        16   -> check_failed
      16   PWM_ClearIntPending
        16   -> check_failed
      16   PWM_Cmd
        16   -> check_failed
      16   PWM_ConfigCapture
        16   -> check_failed
      16   PWM_ConfigMatch
        16   -> check_failed
      16   PWM_ConfigStructInit
        16   -> check_failed
      16   PWM_CounterCmd
        16   -> check_failed
       8   PWM_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      16   PWM_GetCaptureValue
        16   -> check_failed
      16   PWM_GetIntStatus
        16   -> check_failed
      32   PWM_Init
        32   -> CLKPWR_ConfigPPWR
        32   -> CLKPWR_GetPCLK
        32   -> CLKPWR_SetPCLKDiv
        32   -> check_failed
        32 __aeabi_uldivmod
      24   PWM_MatchUpdate
        24   -> check_failed
       8   PWM_ResetCounter
         8   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
     152  ?_0
     120  PWM_ChannelCmd
     134  PWM_ChannelConfig
      80  PWM_ClearIntPending
      72  PWM_Cmd
     318  PWM_ConfigCapture
     324  PWM_ConfigMatch
      64  PWM_ConfigStructInit
      74  PWM_CounterCmd
      44  PWM_DeInit
      68  PWM_GetCaptureValue
      92  PWM_GetIntStatus
     294  PWM_Init
     160  PWM_MatchUpdate
      42  PWM_ResetCounter

 
   152 bytes in section .rodata
 1 898 bytes in section .text
 
 1 898 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: 2
