###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:07
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_qei.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_qei.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_qei.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_qei.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_qei.c
      1          /**
      2           * @file	: lpc17xx_qei.c
      3           * @brief	: Contains all functions support for QEI firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 26. May. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup QEI
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_qei.h"
     27          #include "lpc17xx_clkpwr.h"
     28          
     29          
     30          /* If this source file built with example, the LPC17xx FW library configuration
     31           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     32           * otherwise the default FW library configuration file must be included instead
     33           */
     34          #ifdef __BUILD_WITH_EXAMPLE__
     35          #include "lpc17xx_libcfg.h"
     36          #else
     37          #include "lpc17xx_libcfg_default.h"
     38          #endif /* __BUILD_WITH_EXAMPLE__ */
     39          
     40          
     41          #ifdef _QEI
     42          
     43          /* Private Types -------------------------------------------------------------- */
     44          /** @defgroup QEI_Private_Types
     45           * @{
     46           */
     47          
     48          /**
     49           * @brief QEI configuration union type definition
     50           */
     51          typedef union {
     52          	QEI_CFG_Type bmQEIConfig;
     53          	uint32_t ulQEIConfig;
     54          } QEI_CFGOPT_Type;
     55          
     56          /**
     57           * @}
     58           */
     59          
     60          
     61          /* Public Functions ----------------------------------------------------------- */
     62          /** @addtogroup QEI_Public_Functions
     63           * @{
     64           */
     65          
     66          /*********************************************************************//**
     67           * @brief		Resets value for each type of QEI value, such as velocity,
     68           * 				counter, position, etc..
     69           * @param[in]	QEIx			QEI peripheral, should be QEI
     70           * @param[in]	ulResetType		QEI Reset Type, should be one of the following:
     71           * 								- QEI_RESET_POS: Reset Position Counter
     72           * 								- QEI_RESET_POSOnIDX: Reset Position Counter on Index signal
     73           * 								- QEI_RESET_VEL: Reset Velocity
     74           * 								- QEI_RESET_IDX: Reset Index Counter
     75           * @return		None
     76           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     77          void QEI_Reset(LPC_QEI_TypeDef *QEIx, uint32_t ulResetType)
     78          {
   \                     QEI_Reset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     79          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_Reset_0
   \   0000000E   0x214F             MOVS     R1,#+79
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
     80          	CHECK_PARAM(PARAM_QEI_RESET(ulResetType));
   \                     ??QEI_Reset_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD00A             BEQ.N    ??QEI_Reset_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD008             BEQ.N    ??QEI_Reset_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD006             BEQ.N    ??QEI_Reset_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD004             BEQ.N    ??QEI_Reset_1
   \   00000028   0x2150             MOVS     R1,#+80
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000002E   0x.... 0x....      BL       check_failed
     81          
     82          	QEIx->QEICON = ulResetType;
   \                     ??QEI_Reset_1: (+1)
   \   00000032   0x6025             STR      R5,[R4, #+0]
     83          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     84          
     85          /*********************************************************************//**
     86           * @brief		Initializes the QEI peripheral according to the specified
     87          *               parameters in the QEI_ConfigStruct.
     88           * @param[in]	QEIx				QEI peripheral, should be QEI
     89           * @param[in]	QEI_ConfigStruct	Pointer to a QEI_CFG_Type structure
     90          *                    that contains the configuration information for the
     91          *                    specified QEI peripheral
     92           * @return		None
     93           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     94          void QEI_Init(LPC_QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct)
     95          {
   \                     QEI_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     96          
     97          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_Init_0
   \   0000000E   0x2161             MOVS     R1,#+97
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
     98          	CHECK_PARAM(PARAM_QEI_DIRINV(QEI_ConfigStruct->DirectionInvert));
   \                     ??QEI_Init_0: (+1)
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0x7829             LDRB     R1,[R5, #+0]
   \   00000020   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000024   0xF091 0x0101      EORS     R1,R1,#0x1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD004             BEQ.N    ??QEI_Init_1
   \   0000002E   0x2162             MOVS     R1,#+98
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000034   0x.... 0x....      BL       check_failed
     99          	CHECK_PARAM(PARAM_QEI_SIGNALMODE(QEI_ConfigStruct->SignalMode));
   \                     ??QEI_Init_1: (+1)
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000003E   0x07C0             LSLS     R0,R0,#+31
   \   00000040   0xD509             BPL.N    ??QEI_Init_2
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000048   0x07C0             LSLS     R0,R0,#+31
   \   0000004A   0xD404             BMI.N    ??QEI_Init_2
   \   0000004C   0x2163             MOVS     R1,#+99
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000052   0x.... 0x....      BL       check_failed
    100          	CHECK_PARAM(PARAM_QEI_CAPMODE(QEI_ConfigStruct->CaptureMode));
   \                     ??QEI_Init_2: (+1)
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD509             BPL.N    ??QEI_Init_3
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000066   0x07C0             LSLS     R0,R0,#+31
   \   00000068   0xD404             BMI.N    ??QEI_Init_3
   \   0000006A   0x2164             MOVS     R1,#+100
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000070   0x.... 0x....      BL       check_failed
    101          	CHECK_PARAM(PARAM_QEI_INVINX(QEI_ConfigStruct->InvertIndex));
   \                     ??QEI_Init_3: (+1)
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000007A   0x07C0             LSLS     R0,R0,#+31
   \   0000007C   0xD509             BPL.N    ??QEI_Init_4
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000084   0x07C0             LSLS     R0,R0,#+31
   \   00000086   0xD404             BMI.N    ??QEI_Init_4
   \   00000088   0x2165             MOVS     R1,#+101
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000008E   0x.... 0x....      BL       check_failed
    102          
    103          	/* Set up clock and power for QEI module */
    104          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, ENABLE);
   \                     ??QEI_Init_4: (+1)
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000098   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    105          
    106          	/* As default, peripheral clock for QEI module
    107          	 * is set to FCCLK / 2 */
    108          	CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_QEI, CLKPWR_PCLKSEL_CCLK_DIV_1);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x2020             MOVS     R0,#+32
   \   000000A0   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
    109          
    110          	// Reset all remaining value in QEI peripheral
    111          	QEIx->QEICON = QEI_CON_RESP | QEI_CON_RESV | QEI_CON_RESI;
   \   000000A4   0x200D             MOVS     R0,#+13
   \   000000A6   0x6020             STR      R0,[R4, #+0]
    112          	QEIx->QEIMAXPOS = 0x00;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x6120             STR      R0,[R4, #+16]
    113          	QEIx->CMPOS0 = 0x00;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x6160             STR      R0,[R4, #+20]
    114          	QEIx->CMPOS1 = 0x00;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x61A0             STR      R0,[R4, #+24]
    115          	QEIx->CMPOS2 = 0x00;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x61E0             STR      R0,[R4, #+28]
    116          	QEIx->INXCMP = 0x00;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x6260             STR      R0,[R4, #+36]
    117          	QEIx->QEILOAD = 0x00;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x62A0             STR      R0,[R4, #+40]
    118          	QEIx->VELCOMP = 0x00;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x63A0             STR      R0,[R4, #+56]
    119          	QEIx->FILTER = 0x00;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x63E0             STR      R0,[R4, #+60]
    120          	// Disable all Interrupt
    121          	QEIx->QEIIEC = QEI_IECLR_BITMASK;
   \   000000C8   0xF641 0x70FF      MOVW     R0,#+8191
   \   000000CC   0xF8C4 0x0FD8      STR      R0,[R4, #+4056]
    122          	// Clear all Interrupt pending
    123          	QEIx->QEICLR = QEI_INTCLR_BITMASK;
   \   000000D0   0xF641 0x70FF      MOVW     R0,#+8191
   \   000000D4   0xF8C4 0x0FE8      STR      R0,[R4, #+4072]
    124          	// Set QEI configuration value corresponding to its setting up value
    125          	QEIx->QEICONF = ((QEI_CFGOPT_Type *)QEI_ConfigStruct)->ulQEIConfig;
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x60A0             STR      R0,[R4, #+8]
    126          }
   \   000000DC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    127          
    128          
    129          /*********************************************************************//**
    130           * @brief		De-initializes the QEI peripheral registers to their
    131          *                  default reset values.
    132           * @param[in]	QEIx				QEI peripheral, should be QEI
    133           * @return 		None
    134           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          void QEI_DeInit(LPC_QEI_TypeDef *QEIx)
    136          {
   \                     QEI_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    137          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_DeInit_0
   \   0000000C   0x2189             MOVS     R1,#+137
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    138          
    139          	/* Turn off clock and power for QEI module */
    140          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, DISABLE);
   \                     ??QEI_DeInit_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000001C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    141          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    142          
    143          
    144          /*****************************************************************************//**
    145          * @brief		Fills each QIE_InitStruct member with its default value:
    146          * 				- DirectionInvert = QEI_DIRINV_NONE
    147          * 				- SignalMode = QEI_SIGNALMODE_QUAD
    148          * 				- CaptureMode = QEI_CAPMODE_4X
    149          * 				- InvertIndex = QEI_INVINX_NONE
    150          * @param[in]	QIE_InitStruct Pointer to a QEI_CFG_Type structure
    151          *                    which will be initialized.
    152          * @return		None
    153          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    154          void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct)
    155          {
    156          	QIE_InitStruct->CaptureMode = QEI_CAPMODE_4X;
   \                     QEI_ConfigStructInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000006   0x6001             STR      R1,[R0, #+0]
    157          	QIE_InitStruct->DirectionInvert = QEI_DIRINV_NONE;
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0849             LSRS     R1,R1,#+1
   \   0000000C   0x0049             LSLS     R1,R1,#+1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    158          	QIE_InitStruct->InvertIndex = QEI_INVINX_NONE;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF031 0x0108      BICS     R1,R1,#0x8
   \   00000016   0x6001             STR      R1,[R0, #+0]
    159          	QIE_InitStruct->SignalMode = QEI_SIGNALMODE_QUAD;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF031 0x0102      BICS     R1,R1,#0x2
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    160          }
   \   00000020   0x4770             BX       LR               ;; return
    161          
    162          
    163          /*********************************************************************//**
    164           * @brief		Check whether if specified flag status is set or not
    165           * @param[in]	QEIx		QEI peripheral, should be QEI
    166           * @param[in]	ulFlagType	Status Flag Type, should be one of the following:
    167           * 							- QEI_STATUS_DIR: Direction Status
    168           * @return		New Status of this status flag (SET or RESET)
    169           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    170          FlagStatus QEI_GetStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulFlagType)
    171          {
   \                     QEI_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    172          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_GetStatus_0
   \   0000000E   0x21AC             MOVS     R1,#+172
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    173          	CHECK_PARAM(PARAM_QEI_STATUS(ulFlagType));
   \                     ??QEI_GetStatus_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD004             BEQ.N    ??QEI_GetStatus_1
   \   0000001C   0x21AD             MOVS     R1,#+173
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000022   0x.... 0x....      BL       check_failed
    174          	return ((QEIx->QEISTAT & ulFlagType) ? SET : RESET);
   \                     ??QEI_GetStatus_1: (+1)
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x4228             TST      R0,R5
   \   0000002A   0xD001             BEQ.N    ??QEI_GetStatus_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??QEI_GetStatus_3
   \                     ??QEI_GetStatus_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??QEI_GetStatus_3: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    175          }
    176          
    177          /*********************************************************************//**
    178           * @brief		Get current position value in QEI peripheral
    179           * @param[in]	QEIx		QEI peripheral, should be QEI
    180           * @return		Current position value of QEI peripheral
    181           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          uint32_t QEI_GetPosition(LPC_QEI_TypeDef *QEIx)
    183          {
   \                     QEI_GetPosition: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    184          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_GetPosition_0
   \   0000000C   0x21B8             MOVS     R1,#+184
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    185          	return (QEIx->QEIPOS);
   \                     ??QEI_GetPosition_0: (+1)
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    186          }
    187          
    188          /*********************************************************************//**
    189           * @brief		Set max position value for QEI peripheral
    190           * @param[in]	QEIx		QEI peripheral, should be QEI
    191           * @param[in]	ulMaxPos	Max position value to set
    192           * @return		None
    193           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          void QEI_SetMaxPosition(LPC_QEI_TypeDef *QEIx, uint32_t ulMaxPos)
    195          {
   \                     QEI_SetMaxPosition: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    196          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_SetMaxPosition_0
   \   0000000E   0x21C4             MOVS     R1,#+196
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    197          	QEIx->QEIMAXPOS = ulMaxPos;
   \                     ??QEI_SetMaxPosition_0: (+1)
   \   00000018   0x6125             STR      R5,[R4, #+16]
    198          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    199          
    200          /*********************************************************************//**
    201           * @brief		Set position compare value for QEI peripheral
    202           * @param[in]	QEIx		QEI peripheral, should be QEI
    203           * @param[in]	bPosCompCh	Compare Position channel, should be:
    204           * 							- QEI_COMPPOS_CH_0: QEI compare position channel 0
    205           * 							- QEI_COMPPOS_CH_1: QEI compare position channel 1
    206           * 							- QEI_COMPPOS_CH_2: QEI compare position channel 2
    207           * @param[in]	ulPosComp	Compare Position value to set
    208           * @return		None
    209           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    210          void QEI_SetPositionComp(LPC_QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp)
    211          {
   \                     QEI_SetPositionComp: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    212          	uint32_t *tmp;
    213          
    214          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD003             BEQ.N    ??QEI_SetPositionComp_0
   \   00000010   0x21D6             MOVS     R1,#+214
   \   00000012   0x....             LDR.N    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    215          	CHECK_PARAM(PARAM_QEI_COMPPOS_CH(bPosCompCh));
   \                     ??QEI_SetPositionComp_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD009             BEQ.N    ??QEI_SetPositionComp_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD006             BEQ.N    ??QEI_SetPositionComp_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD003             BEQ.N    ??QEI_SetPositionComp_1
   \   0000002A   0x21D7             MOVS     R1,#+215
   \   0000002C   0x....             LDR.N    R0,??DataTable18_1
   \   0000002E   0x.... 0x....      BL       check_failed
    216          	tmp = (uint32_t *) (&(QEIx->CMPOS0) + bPosCompCh * 4);
   \                     ??QEI_SetPositionComp_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x0128             LSLS     R0,R5,#+4
   \   00000036   0x4420             ADD      R0,R4,R0
   \   00000038   0x3014             ADDS     R0,R0,#+20
   \   0000003A   0x0007             MOVS     R7,R0
    217          	*tmp = ulPosComp;
   \   0000003C   0x603E             STR      R6,[R7, #+0]
    218          
    219          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    220          
    221          /*********************************************************************//**
    222           * @brief		Get current index counter of QEI peripheral
    223           * @param[in]	QEIx		QEI peripheral, should be QEI
    224           * @return		Current value of QEI index counter
    225           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          uint32_t QEI_GetIndex(LPC_QEI_TypeDef *QEIx)
    227          {
   \                     QEI_GetIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    228          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD003             BEQ.N    ??QEI_GetIndex_0
   \   0000000A   0x21E4             MOVS     R1,#+228
   \   0000000C   0x....             LDR.N    R0,??DataTable18_1
   \   0000000E   0x.... 0x....      BL       check_failed
    229          	return (QEIx->INXCNT);
   \                     ??QEI_GetIndex_0: (+1)
   \   00000012   0x6A20             LDR      R0,[R4, #+32]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    230          }
    231          
    232          /*********************************************************************//**
    233           * @brief		Set value for index compare in QEI peripheral
    234           * @param[in]	QEIx		QEI peripheral, should be QEI
    235           * @param[in]	ulIndexComp		Compare Index Value to set
    236           * @return		None
    237           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    238          void QEI_SetIndexComp(LPC_QEI_TypeDef *QEIx, uint32_t ulIndexComp)
    239          {
   \                     QEI_SetIndexComp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    240          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD003             BEQ.N    ??QEI_SetIndexComp_0
   \   0000000C   0x21F0             MOVS     R1,#+240
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    241          	QEIx->INXCMP = ulIndexComp;
   \                     ??QEI_SetIndexComp_0: (+1)
   \   00000014   0x6265             STR      R5,[R4, #+36]
    242          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    243          
    244          /*********************************************************************//**
    245           * @brief		Set timer reload value for QEI peripheral. When the velocity timer is
    246           * 				over-flow, the value that set for Timer Reload register will be loaded
    247           * 				into the velocity timer for next period. The calculated velocity in RPM
    248           * 				therefore will be affect by this value.
    249           * @param[in]	QEIx			QEI peripheral, should be QEI
    250           * @param[in]	QEIReloadStruct	QEI reload structure
    251           * @return		None
    252           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          void QEI_SetTimerReload(LPC_QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct)
    254          {
   \                     QEI_SetTimerReload: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
    255          	uint64_t pclk;
    256          
    257          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4286             CMP      R6,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetTimerReload_0
   \   0000000C   0xF240 0x1101      MOVW     R1,#+257
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    258          	CHECK_PARAM(PARAM_QEI_TIMERRELOAD(QEIReloadStruct->ReloadOption));
   \                     ??QEI_SetTimerReload_0: (+1)
   \   00000016   0x7838             LDRB     R0,[R7, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??QEI_SetTimerReload_1
   \   0000001C   0x7838             LDRB     R0,[R7, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD004             BEQ.N    ??QEI_SetTimerReload_1
   \   00000022   0xF44F 0x7181      MOV      R1,#+258
   \   00000026   0x....             LDR.N    R0,??DataTable18_1
   \   00000028   0x.... 0x....      BL       check_failed
    259          
    260          	if (QEIReloadStruct->ReloadOption == QEI_TIMERRELOAD_TICKVAL) {
   \                     ??QEI_SetTimerReload_1: (+1)
   \   0000002C   0x7838             LDRB     R0,[R7, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??QEI_SetTimerReload_2
    261          		QEIx->QEILOAD = QEIReloadStruct->ReloadValue - 1;
   \   00000032   0x6878             LDR      R0,[R7, #+4]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x62B0             STR      R0,[R6, #+40]
   \   00000038   0xE012             B.N      ??QEI_SetTimerReload_3
    262          	} else {
    263          		pclk = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
   \                     ??QEI_SetTimerReload_2: (+1)
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x0004             MOVS     R4,R0
   \   00000044   0x000D             MOVS     R5,R1
    264          		pclk = (pclk /(1000000/QEIReloadStruct->ReloadValue)) - 1;
   \   00000046   0x....             LDR.N    R0,??DataTable18_2  ;; 0xf4240
   \   00000048   0x6879             LDR      R1,[R7, #+4]
   \   0000004A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000058   0x1E44             SUBS     R4,R0,#+1
   \   0000005A   0xF171 0x0500      SBCS     R5,R1,#+0
    265          		QEIx->QEILOAD = (uint32_t)pclk;
   \   0000005E   0x62B4             STR      R4,[R6, #+40]
    266          	}
    267          }
   \                     ??QEI_SetTimerReload_3: (+1)
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    268          
    269          /*********************************************************************//**
    270           * @brief		Get current timer counter in QEI peripheral
    271           * @param[in]	QEIx			QEI peripheral, should be QEI
    272           * @return		Current timer counter in QEI peripheral
    273           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          uint32_t QEI_GetTimer(LPC_QEI_TypeDef *QEIx)
    275          {
   \                     QEI_GetTimer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    276          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetTimer_0
   \   0000000A   0xF44F 0x718A      MOV      R1,#+276
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    277          	return (QEIx->QEITIME);
   \                     ??QEI_GetTimer_0: (+1)
   \   00000014   0x6AE0             LDR      R0,[R4, #+44]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    278          }
    279          
    280          /*********************************************************************//**
    281           * @brief		Get current velocity pulse counter in current time period
    282           * @param[in]	QEIx			QEI peripheral, should be QEI
    283           * @return		Current velocity pulse counter value
    284           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          uint32_t QEI_GetVelocity(LPC_QEI_TypeDef *QEIx)
    286          {
   \                     QEI_GetVelocity: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    287          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetVelocity_0
   \   0000000A   0xF240 0x111F      MOVW     R1,#+287
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    288          	return (QEIx->QEIVEL);
   \                     ??QEI_GetVelocity_0: (+1)
   \   00000014   0x6B20             LDR      R0,[R4, #+48]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    289          }
    290          
    291          /*********************************************************************//**
    292           * @brief		Get the most recently measured velocity of the QEI. When
    293           * 				the Velocity timer in QEI is over-flow, the current velocity
    294           * 				value will be loaded into Velocity Capture register.
    295           * @param[in]	QEIx			QEI peripheral, should be QEI
    296           * @return		The most recently measured velocity value
    297           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    298          uint32_t QEI_GetVelocityCap(LPC_QEI_TypeDef *QEIx)
    299          {
   \                     QEI_GetVelocityCap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    300          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetVelocityCap_0
   \   0000000A   0xF44F 0x7196      MOV      R1,#+300
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    301          	return (QEIx->QEICAP);
   \                     ??QEI_GetVelocityCap_0: (+1)
   \   00000014   0x6B60             LDR      R0,[R4, #+52]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    302          }
    303          
    304          /*********************************************************************//**
    305           * @brief		Set Velocity Compare value for QEI peripheral
    306           * @param[in]	QEIx			QEI peripheral, should be QEI
    307           * @param[in]	ulVelComp		Compare Velocity value to set
    308           * @return		None
    309           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          void QEI_SetVelocityComp(LPC_QEI_TypeDef *QEIx, uint32_t ulVelComp)
    311          {
   \                     QEI_SetVelocityComp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    312          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetVelocityComp_0
   \   0000000C   0xF44F 0x719C      MOV      R1,#+312
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    313          	QEIx->VELCOMP = ulVelComp;
   \                     ??QEI_SetVelocityComp_0: (+1)
   \   00000016   0x63A5             STR      R5,[R4, #+56]
    314          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    315          
    316          /*********************************************************************//**
    317           * @brief		Set value of sampling count for the digital filter in
    318           * 				QEI peripheral
    319           * @param[in]	QEIx			QEI peripheral, should be QEI
    320           * @param[in]	ulSamplingPulse	Value of sampling count to set
    321           * @return		None
    322           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    323          void QEI_SetDigiFilter(LPC_QEI_TypeDef *QEIx, uint32_t ulSamplingPulse)
    324          {
   \                     QEI_SetDigiFilter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    325          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetDigiFilter_0
   \   0000000C   0xF240 0x1145      MOVW     R1,#+325
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    326          	QEIx->FILTER = ulSamplingPulse;
   \                     ??QEI_SetDigiFilter_0: (+1)
   \   00000016   0x63E5             STR      R5,[R4, #+60]
    327          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    328          
    329          /*********************************************************************//**
    330           * @brief		Check whether if specified interrupt flag status in QEI
    331           * 				peripheral is set or not
    332           * @param[in]	QEIx			QEI peripheral, should be QEI
    333           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    334          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    335          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    336          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    337          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    338          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    339          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    340          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    341          														current position interrupt
    342          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    343          														current position interrupt
    344          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    345          														current position interrupt
    346          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    347          														index count interrupt
    348          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    349          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    350          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    351           * @return		New State of specified interrupt flag status (SET or RESET)
    352           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          FlagStatus QEI_GetIntStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    354          {
   \                     QEI_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    355          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_GetIntStatus_0
   \   0000000C   0xF240 0x1163      MOVW     R1,#+355
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    356          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_GetIntStatus_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_GetIntStatus_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_GetIntStatus_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_GetIntStatus_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_GetIntStatus_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_GetIntStatus_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_GetIntStatus_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_GetIntStatus_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_GetIntStatus_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_GetIntStatus_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_GetIntStatus_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_GetIntStatus_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_GetIntStatus_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_GetIntStatus_1
   \   00000054   0xF44F 0x71B2      MOV      R1,#+356
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    357          
    358          	return((QEIx->QEIINTSTAT & ulIntType) ? SET : RESET);
   \                     ??QEI_GetIntStatus_1: (+1)
   \   0000005E   0xF8D4 0x0FE0      LDR      R0,[R4, #+4064]
   \   00000062   0x4228             TST      R0,R5
   \   00000064   0xD001             BEQ.N    ??QEI_GetIntStatus_2
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE000             B.N      ??QEI_GetIntStatus_3
   \                     ??QEI_GetIntStatus_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??QEI_GetIntStatus_3: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    359          }
    360          
    361          /*********************************************************************//**
    362           * @brief		Enable/Disable specified interrupt in QEI peripheral
    363           * @param[in]	QEIx			QEI peripheral, should be QEI
    364           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    365           * 								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    366           *								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    367           *								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    368           * 								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    369           *  							- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    370           * 								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    371           *								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    372           *														current position interrupt
    373           *								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    374           *														current position interrupt
    375           *								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    376           *														current position interrupt
    377           *								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    378           *														index count interrupt
    379           *								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    380           *								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    381           *								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    382           * @param[in]	NewState		New function state, should be:
    383           *								- DISABLE
    384           *								- ENABLE
    385           * @return		None
    386           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          void QEI_IntCmd(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState)
    388          {
   \                     QEI_IntCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    389          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_IntCmd_0
   \   0000000E   0xF240 0x1185      MOVW     R1,#+389
   \   00000012   0x....             LDR.N    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    390          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntCmd_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD021             BEQ.N    ??QEI_IntCmd_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD01F             BEQ.N    ??QEI_IntCmd_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD01D             BEQ.N    ??QEI_IntCmd_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD01B             BEQ.N    ??QEI_IntCmd_1
   \   00000028   0x2D10             CMP      R5,#+16
   \   0000002A   0xD019             BEQ.N    ??QEI_IntCmd_1
   \   0000002C   0x2D20             CMP      R5,#+32
   \   0000002E   0xD017             BEQ.N    ??QEI_IntCmd_1
   \   00000030   0x2D40             CMP      R5,#+64
   \   00000032   0xD015             BEQ.N    ??QEI_IntCmd_1
   \   00000034   0x2D80             CMP      R5,#+128
   \   00000036   0xD013             BEQ.N    ??QEI_IntCmd_1
   \   00000038   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003C   0xD010             BEQ.N    ??QEI_IntCmd_1
   \   0000003E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000042   0xD00D             BEQ.N    ??QEI_IntCmd_1
   \   00000044   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000048   0xD00A             BEQ.N    ??QEI_IntCmd_1
   \   0000004A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004E   0xD007             BEQ.N    ??QEI_IntCmd_1
   \   00000050   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000054   0xD004             BEQ.N    ??QEI_IntCmd_1
   \   00000056   0xF44F 0x71C3      MOV      R1,#+390
   \   0000005A   0x....             LDR.N    R0,??DataTable18_1
   \   0000005C   0x.... 0x....      BL       check_failed
    391          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??QEI_IntCmd_1: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD007             BEQ.N    ??QEI_IntCmd_2
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E01             CMP      R6,#+1
   \   0000006A   0xD004             BEQ.N    ??QEI_IntCmd_2
   \   0000006C   0xF240 0x1187      MOVW     R1,#+391
   \   00000070   0x....             LDR.N    R0,??DataTable18_1
   \   00000072   0x.... 0x....      BL       check_failed
    392          
    393          	if (NewState == ENABLE) {
   \                     ??QEI_IntCmd_2: (+1)
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E01             CMP      R6,#+1
   \   0000007A   0xD102             BNE.N    ??QEI_IntCmd_3
    394          		QEIx->QEIIES = ulIntType;
   \   0000007C   0xF8C4 0x5FDC      STR      R5,[R4, #+4060]
   \   00000080   0xE001             B.N      ??QEI_IntCmd_4
    395          	} else {
    396          		QEIx->QEIIEC = ulIntType;
   \                     ??QEI_IntCmd_3: (+1)
   \   00000082   0xF8C4 0x5FD8      STR      R5,[R4, #+4056]
    397          	}
    398          }
   \                     ??QEI_IntCmd_4: (+1)
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
    399          
    400          
    401          /*********************************************************************//**
    402           * @brief		Sets (forces) specified interrupt in QEI peripheral
    403           * @param[in]	QEIx			QEI peripheral, should be QEI
    404           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    405          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    406          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    407          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    408          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    409          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    410          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    411          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    412          														current position interrupt
    413          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    414          														current position interrupt
    415          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    416          														current position interrupt
    417          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    418          														index count interrupt
    419          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    420          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    421          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    422           * @return		None
    423           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    424          void QEI_IntSet(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    425          {
   \                     QEI_IntSet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    426          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_IntSet_0
   \   0000000C   0xF44F 0x71D5      MOV      R1,#+426
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    427          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntSet_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_IntSet_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_IntSet_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_IntSet_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_IntSet_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_IntSet_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_IntSet_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_IntSet_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_IntSet_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_IntSet_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_IntSet_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_IntSet_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_IntSet_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_IntSet_1
   \   00000054   0xF240 0x11AB      MOVW     R1,#+427
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    428          
    429          	QEIx->QEISET = ulIntType;
   \                     ??QEI_IntSet_1: (+1)
   \   0000005E   0xF8C4 0x5FEC      STR      R5,[R4, #+4076]
    430          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    431          
    432          /*********************************************************************//**
    433           * @brief		Clear (force) specified interrupt (pending) in QEI peripheral
    434           * @param[in]	QEIx			QEI peripheral, should be QEI
    435           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    436          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    437          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    438          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    439          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    440          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    441          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    442          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    443          														current position interrupt
    444          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    445          														current position interrupt
    446          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    447          														current position interrupt
    448          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    449          														index count interrupt
    450          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    451          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    452          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    453           * @return		None
    454           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    455          void QEI_IntClear(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    456          {
   \                     QEI_IntClear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    457          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_IntClear_0
   \   0000000C   0xF240 0x11C9      MOVW     R1,#+457
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    458          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntClear_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_IntClear_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_IntClear_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_IntClear_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_IntClear_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_IntClear_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_IntClear_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_IntClear_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_IntClear_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_IntClear_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_IntClear_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_IntClear_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_IntClear_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_IntClear_1
   \   00000054   0xF44F 0x71E5      MOV      R1,#+458
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    459          
    460          	QEIx->QEICLR = ulIntType;
   \                     ??QEI_IntClear_1: (+1)
   \   0000005E   0xF8C4 0x5FE8      STR      R5,[R4, #+4072]
    461          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    462          
    463          
    464          /*********************************************************************//**
    465           * @brief		Calculates the actual velocity in RPM passed via velocity
    466           * 				capture value and Pulse Per Round (of the encoder) value
    467           * 				parameter input.
    468           * @param[in]	QEIx			QEI peripheral, should be QEI
    469           * @param[in]	ulVelCapValue	Velocity capture input value that can
    470           * 								be got from QEI_GetVelocityCap() function
    471           * @param[in]	ulPPR			Pulse per round of encoder
    472           * @return		The actual value of velocity in RPM (Round per minute)
    473           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    474          uint32_t QEI_CalculateRPM(LPC_QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR)
    475          {
   \                     QEI_CalculateRPM: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
    476          	uint64_t rpm, clock, Load, edges;
    477          
    478          	// Get current Clock rate for timer input
    479          	clock = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
    480          	// Get Timer load value (velocity capture period)
    481          	Load  = (uint64_t)(QEIx->QEILOAD + 1);
   \   00000016   0x9806             LDR      R0,[SP, #+24]
   \   00000018   0x6A80             LDR      R0,[R0, #+40]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
    482          	// Get Edge
    483          	edges = (uint64_t)((QEIx->QEICONF & QEI_CONF_CAPMODE) ? 4 : 2);
   \   00000022   0x9806             LDR      R0,[SP, #+24]
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0x0740             LSLS     R0,R0,#+29
   \   00000028   0xD502             BPL.N    ??QEI_CalculateRPM_0
   \   0000002A   0x2404             MOVS     R4,#+4
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0xE001             B.N      ??QEI_CalculateRPM_1
   \                     ??QEI_CalculateRPM_0: (+1)
   \   00000030   0x2402             MOVS     R4,#+2
   \   00000032   0x2500             MOVS     R5,#+0
    484          	// Calculate RPM
    485          	rpm = ((clock * ulVelCapValue * 60) / (Load * ulPPR * edges));
   \                     ??QEI_CalculateRPM_1: (+1)
   \   00000034   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   00000038   0x2700             MOVS     R7,#+0
   \   0000003A   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \   0000003E   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \   00000042   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \   00000046   0xF05F 0x0A3C      MOVS     R10,#+60
   \   0000004A   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000004E   0xFBAA 0x0102      UMULL    R0,R1,R10,R2
   \   00000052   0xFB0A 0x1103      MLA      R1,R10,R3,R1
   \   00000056   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0x468B             MOV      R11,R1
   \   0000005E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000062   0xF05F 0x0900      MOVS     R9,#+0
   \   00000066   0xFBA8 0x2300      UMULL    R2,R3,R8,R0
   \   0000006A   0xFB08 0x3301      MLA      R3,R8,R1,R3
   \   0000006E   0xFB09 0x3300      MLA      R3,R9,R0,R3
   \   00000072   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000076   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   0000007A   0xFB05 0x1102      MLA      R1,R5,R2,R1
   \   0000007E   0x0002             MOVS     R2,R0
   \   00000080   0x000B             MOVS     R3,R1
   \   00000082   0x4650             MOV      R0,R10
   \   00000084   0x4659             MOV      R1,R11
   \   00000086   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000008A   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
    486          
    487          	return (uint32_t)(rpm);
   \   0000008E   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   00000092   0xB007             ADD      SP,SP,#+28
   \   00000094   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    488          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x400BC000         DC32     0x400bc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x71          DC8 5FH, 71H, 65H, 69H, 2EH, 63H, 0
   \              0x65 0x69    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
    489          
    490          
    491          /**
    492           * @}
    493           */
    494          
    495          #endif /* _QEI */
    496          
    497          /**
    498           * @}
    499           */
    500          
    501          /* --------------------------------- End Of File ------------------------------ */
    502          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   QEI_CalculateRPM
        64   -> CLKPWR_GetPCLK
        64 __aeabi_uldivmod
       0   QEI_ConfigStructInit
       8   QEI_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
       8   QEI_GetIndex
         8   -> check_failed
      16   QEI_GetIntStatus
        16   -> check_failed
       8   QEI_GetPosition
         8   -> check_failed
      16   QEI_GetStatus
        16   -> check_failed
       8   QEI_GetTimer
         8   -> check_failed
       8   QEI_GetVelocity
         8   -> check_failed
       8   QEI_GetVelocityCap
         8   -> check_failed
      16   QEI_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> CLKPWR_SetPCLKDiv
        16   -> check_failed
      16   QEI_IntClear
        16   -> check_failed
      16   QEI_IntCmd
        16   -> check_failed
      16   QEI_IntSet
        16   -> check_failed
      16   QEI_Reset
        16   -> check_failed
      16   QEI_SetDigiFilter
        16   -> check_failed
      16   QEI_SetIndexComp
        16   -> check_failed
      16   QEI_SetMaxPosition
        16   -> check_failed
      24   QEI_SetPositionComp
        24   -> check_failed
      24   QEI_SetTimerReload
        24   -> CLKPWR_GetPCLK
        24   -> check_failed
        24 __aeabi_uldivmod
      16   QEI_SetVelocityComp
        16   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
     152  ?_0
     152  QEI_CalculateRPM
      34  QEI_ConfigStructInit
      34  QEI_DeInit
      22  QEI_GetIndex
     112  QEI_GetIntStatus
      26  QEI_GetPosition
      54  QEI_GetStatus
      24  QEI_GetTimer
      24  QEI_GetVelocity
      24  QEI_GetVelocityCap
     222  QEI_Init
     100  QEI_IntClear
     136  QEI_IntCmd
     100  QEI_IntSet
      54  QEI_Reset
      26  QEI_SetDigiFilter
      24  QEI_SetIndexComp
      28  QEI_SetMaxPosition
      64  QEI_SetPositionComp
      98  QEI_SetTimerReload
      26  QEI_SetVelocityComp

 
   152 bytes in section .rodata
 1 396 bytes in section .text
 
 1 396 bytes of CODE  memory
   152 bytes of CONST memory

Errors: none
Warnings: none
