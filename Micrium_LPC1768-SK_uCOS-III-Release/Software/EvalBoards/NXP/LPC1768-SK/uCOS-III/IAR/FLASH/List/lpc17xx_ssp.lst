###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_ssp.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_ssp.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_ssp.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_ssp.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_ssp.c
      1          /**
      2           * @file	: lpc17xx_ssp.c
      3           * @brief	: Contains all functions support for SSP firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 9. April. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup SSP
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_ssp.h"
     27          #include "lpc17xx_clkpwr.h"
     28          
     29          
     30          /* If this source file built with example, the LPC17xx FW library configuration
     31           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     32           * otherwise the default FW library configuration file must be included instead
     33           */
     34          #ifdef __BUILD_WITH_EXAMPLE__
     35          #include "lpc17xx_libcfg.h"
     36          #else
     37          #include "lpc17xx_libcfg_default.h"
     38          #endif /* __BUILD_WITH_EXAMPLE__ */
     39          
     40          
     41          #ifdef _SSP
     42          
     43          /* Private Types -------------------------------------------------------------- */
     44          /** @defgroup SSP_Private_Types
     45           * @{
     46           */
     47          
     48          /** @brief SSP device configuration structure type */
     49          typedef struct
     50          {
     51          	int32_t 	dataword;				/* Current data word: 0 - 8 bit; 1 - 16 bit */
     52          	uint32_t    txrx_setup; 			/* Transmission setup */
     53          	void		(*inthandler)(LPC_SSP_TypeDef *SSPx);   	/* Transmission interrupt handler */
     54          } SSP_CFG_T;
     55          
     56          /**
     57           * @}
     58           */
     59          
     60          /* Private Variables ---------------------------------------------------------- */
     61          /* SSP configuration data */

   \                                 In section .bss, align 4
     62          static SSP_CFG_T sspdat[2];
   \                     sspdat:
   \   00000000                      DS8 24
     63          
     64          
     65          /* Private Functions ---------------------------------------------------------- */
     66          /** @defgroup SSP_Private_Functions
     67           * @{
     68           */
     69          
     70          /**
     71           * @brief Convert from SSP peripheral to number
     72           */

   \                                 In section .text, align 2, keep-with-next
     73          static int32_t SSP_getNum(LPC_SSP_TypeDef *SSPx){
   \                     SSP_getNum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     74          	if (SSPx == LPC_SSP0) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??SSP_getNum_0
     75          		return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE007             B.N      ??SSP_getNum_1
     76          	} else if (SSPx == LPC_SSP1) {
   \                     ??SSP_getNum_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD101             BNE.N    ??SSP_getNum_2
     77          		return (1);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE001             B.N      ??SSP_getNum_1
     78          	}
     79          	return (-1);
   \                     ??SSP_getNum_2: (+1)
   \   0000001A   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??SSP_getNum_1: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
     80          }
     81          
     82          
     83          /*********************************************************************//**
     84           * @brief 		Standard Private SSP Interrupt handler
     85           * @param		SSPx: SSP peripheral definition, should be
     86           * 					  SSP0 or SSP1.
     87           * @return 		None
     88           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          void SSP_IntHandler(LPC_SSP_TypeDef *SSPx)
     90          {
   \                     SSP_IntHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
     91          	SSP_DATA_SETUP_Type *xf_setup;
     92              uint16_t tmp;
     93              int32_t sspnum;
     94          
     95              // Disable interrupt
     96              SSPx->IMSC = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6160             STR      R0,[R4, #+20]
     97          
     98              sspnum = SSP_getNum(SSPx);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       SSP_getNum
   \   0000000E   0x0007             MOVS     R7,R0
     99              xf_setup = (SSP_DATA_SETUP_Type *)sspdat[sspnum].txrx_setup;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000014   0x210C             MOVS     R1,#+12
   \   00000016   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000001A   0x4408             ADD      R0,R0,R1
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x0005             MOVS     R5,R0
    100          
    101              // save status
    102              tmp = SSPx->RIS;
   \   00000020   0x69A0             LDR      R0,[R4, #+24]
   \   00000022   0x0006             MOVS     R6,R0
    103              xf_setup->status = tmp;
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x616E             STR      R6,[R5, #+20]
    104          
    105              // Check overrun error
    106              if (tmp & SSP_RIS_ROR){
   \   00000028   0x07F0             LSLS     R0,R6,#+31
   \   0000002A   0xD50B             BPL.N    ??SSP_IntHandler_0
    107              	// Clear interrupt
    108              	SSPx->ICR = SSP_RIS_ROR;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x6220             STR      R0,[R4, #+32]
    109              	// update status
    110              	xf_setup->status |= SSP_STAT_ERROR;
   \   00000030   0x6968             LDR      R0,[R5, #+20]
   \   00000032   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000036   0x6168             STR      R0,[R5, #+20]
    111              	// Callback
    112              	if (xf_setup->callback != NULL){
   \   00000038   0x69A8             LDR      R0,[R5, #+24]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD001             BEQ.N    ??SSP_IntHandler_1
    113              		xf_setup->callback();
   \   0000003E   0x69A8             LDR      R0,[R5, #+24]
   \   00000040   0x4780             BLX      R0
    114              	}
    115              	return;
   \                     ??SSP_IntHandler_1: (+1)
   \   00000042   0xE0CA             B.N      ??SSP_IntHandler_2
    116              }
    117          
    118              if ((xf_setup->tx_cnt != xf_setup->length) || (xf_setup->rx_cnt != xf_setup->length)){
   \                     ??SSP_IntHandler_0: (+1)
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x6929             LDR      R1,[R5, #+16]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD104             BNE.N    ??SSP_IntHandler_3
   \   0000004C   0x68E8             LDR      R0,[R5, #+12]
   \   0000004E   0x6929             LDR      R1,[R5, #+16]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xF000 0x80AF      BEQ.W    ??SSP_IntHandler_4
    119              	/* check if RX FIFO contains data */
    120          		while ((SSPx->SR & SSP_SR_RNE) && (xf_setup->rx_cnt != xf_setup->length)){
   \                     ??SSP_IntHandler_3: (+1)
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x0740             LSLS     R0,R0,#+29
   \   0000005A   0xD52B             BPL.N    ??SSP_IntHandler_5
   \   0000005C   0x68E8             LDR      R0,[R5, #+12]
   \   0000005E   0x6929             LDR      R1,[R5, #+16]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD027             BEQ.N    ??SSP_IntHandler_5
    121          			// Read data from SSP data
    122          			tmp = SSP_ReceiveData(SSPx);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       SSP_ReceiveData
   \   0000006A   0x0006             MOVS     R6,R0
    123          
    124          			// Store data to destination
    125          			if (xf_setup->rx_data != NULL)
   \   0000006C   0x68A8             LDR      R0,[R5, #+8]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD010             BEQ.N    ??SSP_IntHandler_6
    126          			{
    127          				if (sspdat[sspnum].dataword == 0){
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000076   0x210C             MOVS     R1,#+12
   \   00000078   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000007C   0x5840             LDR      R0,[R0, R1]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD104             BNE.N    ??SSP_IntHandler_7
    128          					*(uint8_t *)((uint32_t)xf_setup->rx_data + xf_setup->rx_cnt) = (uint8_t) tmp;
   \   00000082   0x68A8             LDR      R0,[R5, #+8]
   \   00000084   0x68E9             LDR      R1,[R5, #+12]
   \   00000086   0x1808             ADDS     R0,R1,R0
   \   00000088   0x7006             STRB     R6,[R0, #+0]
   \   0000008A   0xE003             B.N      ??SSP_IntHandler_6
    129          				} else {
    130          					*(uint16_t *)((uint32_t)xf_setup->rx_data + xf_setup->rx_cnt) = (uint16_t) tmp;
   \                     ??SSP_IntHandler_7: (+1)
   \   0000008C   0x68A8             LDR      R0,[R5, #+8]
   \   0000008E   0x68E9             LDR      R1,[R5, #+12]
   \   00000090   0x1808             ADDS     R0,R1,R0
   \   00000092   0x8006             STRH     R6,[R0, #+0]
    131          				}
    132          			}
    133          			// Increase counter
    134          			if (sspdat[sspnum].dataword == 0){
   \                     ??SSP_IntHandler_6: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000098   0x210C             MOVS     R1,#+12
   \   0000009A   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000009E   0x5840             LDR      R0,[R0, R1]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD103             BNE.N    ??SSP_IntHandler_8
    135          				xf_setup->rx_cnt++;
   \   000000A4   0x68E8             LDR      R0,[R5, #+12]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x60E8             STR      R0,[R5, #+12]
   \   000000AA   0xE7D4             B.N      ??SSP_IntHandler_3
    136          			} else {
    137          				xf_setup->rx_cnt += 2;
   \                     ??SSP_IntHandler_8: (+1)
   \   000000AC   0x68E8             LDR      R0,[R5, #+12]
   \   000000AE   0x1C80             ADDS     R0,R0,#+2
   \   000000B0   0x60E8             STR      R0,[R5, #+12]
   \   000000B2   0xE7D0             B.N      ??SSP_IntHandler_3
    138          			}
    139          		}
    140          
    141          		while ((SSPx->SR & SSP_SR_TNF) && (xf_setup->tx_cnt != xf_setup->length)){
   \                     ??SSP_IntHandler_5: (+1)
   \   000000B4   0x68E0             LDR      R0,[R4, #+12]
   \   000000B6   0x0780             LSLS     R0,R0,#+30
   \   000000B8   0xD57C             BPL.N    ??SSP_IntHandler_4
   \   000000BA   0x6868             LDR      R0,[R5, #+4]
   \   000000BC   0x6929             LDR      R1,[R5, #+16]
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD078             BEQ.N    ??SSP_IntHandler_4
    142          			// Write data to buffer
    143          			if(xf_setup->tx_data == NULL){
   \   000000C2   0x6828             LDR      R0,[R5, #+0]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD118             BNE.N    ??SSP_IntHandler_9
    144          				if (sspdat[sspnum].dataword == 0){
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   000000CC   0x210C             MOVS     R1,#+12
   \   000000CE   0xFB01 0xF107      MUL      R1,R1,R7
   \   000000D2   0x5840             LDR      R0,[R0, R1]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD107             BNE.N    ??SSP_IntHandler_10
    145          					SSP_SendData(SSPx, 0xFF);
   \   000000D8   0x21FF             MOVS     R1,#+255
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       SSP_SendData
    146          					xf_setup->tx_cnt++;
   \   000000E0   0x6868             LDR      R0,[R5, #+4]
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x6068             STR      R0,[R5, #+4]
   \   000000E6   0xE028             B.N      ??SSP_IntHandler_11
    147          				} else {
    148          					SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_IntHandler_10: (+1)
   \   000000E8   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       SSP_SendData
    149          					xf_setup->tx_cnt += 2;
   \   000000F2   0x6868             LDR      R0,[R5, #+4]
   \   000000F4   0x1C80             ADDS     R0,R0,#+2
   \   000000F6   0x6068             STR      R0,[R5, #+4]
   \   000000F8   0xE01F             B.N      ??SSP_IntHandler_11
    150          				}
    151          			} else {
    152          				if (sspdat[sspnum].dataword == 0){
   \                     ??SSP_IntHandler_9: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   000000FE   0x210C             MOVS     R1,#+12
   \   00000100   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000104   0x5840             LDR      R0,[R0, R1]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD10C             BNE.N    ??SSP_IntHandler_12
    153          					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)xf_setup->tx_data + xf_setup->tx_cnt)));
   \   0000010A   0x6828             LDR      R0,[R5, #+0]
   \   0000010C   0x6869             LDR      R1,[R5, #+4]
   \   0000010E   0x1808             ADDS     R0,R1,R0
   \   00000110   0x7801             LDRB     R1,[R0, #+0]
   \   00000112   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000114   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x.... 0x....      BL       SSP_SendData
    154          					xf_setup->tx_cnt++;
   \   0000011C   0x6868             LDR      R0,[R5, #+4]
   \   0000011E   0x1C40             ADDS     R0,R0,#+1
   \   00000120   0x6068             STR      R0,[R5, #+4]
   \   00000122   0xE00A             B.N      ??SSP_IntHandler_11
    155          				} else {
    156          					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)xf_setup->tx_data + xf_setup->tx_cnt)));
   \                     ??SSP_IntHandler_12: (+1)
   \   00000124   0x6828             LDR      R0,[R5, #+0]
   \   00000126   0x6869             LDR      R1,[R5, #+4]
   \   00000128   0x1808             ADDS     R0,R1,R0
   \   0000012A   0x8801             LDRH     R1,[R0, #+0]
   \   0000012C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0x.... 0x....      BL       SSP_SendData
    157          					xf_setup->tx_cnt += 2;
   \   00000134   0x6868             LDR      R0,[R5, #+4]
   \   00000136   0x1C80             ADDS     R0,R0,#+2
   \   00000138   0x6068             STR      R0,[R5, #+4]
    158          				}
    159          			}
    160          
    161          		    // Check overrun error
    162          		    if ((tmp = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_IntHandler_11: (+1)
   \   0000013A   0x69A0             LDR      R0,[R4, #+24]
   \   0000013C   0x0006             MOVS     R6,R0
   \   0000013E   0x07F0             LSLS     R0,R6,#+31
   \   00000140   0xD509             BPL.N    ??SSP_IntHandler_13
    163          		    	// update status
    164          		    	xf_setup->status |= SSP_STAT_ERROR;
   \   00000142   0x6968             LDR      R0,[R5, #+20]
   \   00000144   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000148   0x6168             STR      R0,[R5, #+20]
    165          		    	// Callback
    166          		    	if (xf_setup->callback != NULL){
   \   0000014A   0x69A8             LDR      R0,[R5, #+24]
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD001             BEQ.N    ??SSP_IntHandler_14
    167          		    		xf_setup->callback();
   \   00000150   0x69A8             LDR      R0,[R5, #+24]
   \   00000152   0x4780             BLX      R0
    168          		    	}
    169          		    	return;
   \                     ??SSP_IntHandler_14: (+1)
   \   00000154   0xE041             B.N      ??SSP_IntHandler_2
    170          		    }
    171          
    172          			// Check for any data available in RX FIFO
    173          			while ((SSPx->SR & SSP_SR_RNE) && (xf_setup->rx_cnt != xf_setup->length)){
   \                     ??SSP_IntHandler_13: (+1)
   \   00000156   0x68E0             LDR      R0,[R4, #+12]
   \   00000158   0x0740             LSLS     R0,R0,#+29
   \   0000015A   0xD5AB             BPL.N    ??SSP_IntHandler_5
   \   0000015C   0x68E8             LDR      R0,[R5, #+12]
   \   0000015E   0x6929             LDR      R1,[R5, #+16]
   \   00000160   0x4288             CMP      R0,R1
   \   00000162   0xD0A7             BEQ.N    ??SSP_IntHandler_5
    174          				// Read data from SSP data
    175          				tmp = SSP_ReceiveData(SSPx);
   \   00000164   0x0020             MOVS     R0,R4
   \   00000166   0x.... 0x....      BL       SSP_ReceiveData
   \   0000016A   0x0006             MOVS     R6,R0
    176          
    177          				// Store data to destination
    178          				if (xf_setup->rx_data != NULL)
   \   0000016C   0x68A8             LDR      R0,[R5, #+8]
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD010             BEQ.N    ??SSP_IntHandler_15
    179          				{
    180          					if (sspdat[sspnum].dataword == 0){
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000176   0x210C             MOVS     R1,#+12
   \   00000178   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000017C   0x5840             LDR      R0,[R0, R1]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD104             BNE.N    ??SSP_IntHandler_16
    181          						*(uint8_t *)((uint32_t)xf_setup->rx_data + xf_setup->rx_cnt) = (uint8_t) tmp;
   \   00000182   0x68A8             LDR      R0,[R5, #+8]
   \   00000184   0x68E9             LDR      R1,[R5, #+12]
   \   00000186   0x1808             ADDS     R0,R1,R0
   \   00000188   0x7006             STRB     R6,[R0, #+0]
   \   0000018A   0xE003             B.N      ??SSP_IntHandler_15
    182          					} else {
    183          						*(uint16_t *)((uint32_t)xf_setup->rx_data + xf_setup->rx_cnt) = (uint16_t) tmp;
   \                     ??SSP_IntHandler_16: (+1)
   \   0000018C   0x68A8             LDR      R0,[R5, #+8]
   \   0000018E   0x68E9             LDR      R1,[R5, #+12]
   \   00000190   0x1808             ADDS     R0,R1,R0
   \   00000192   0x8006             STRH     R6,[R0, #+0]
    184          					}
    185          				}
    186          				// Increase counter
    187          				if (sspdat[sspnum].dataword == 0){
   \                     ??SSP_IntHandler_15: (+1)
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000198   0x210C             MOVS     R1,#+12
   \   0000019A   0xFB01 0xF107      MUL      R1,R1,R7
   \   0000019E   0x5840             LDR      R0,[R0, R1]
   \   000001A0   0x2800             CMP      R0,#+0
   \   000001A2   0xD103             BNE.N    ??SSP_IntHandler_17
    188          					xf_setup->rx_cnt++;
   \   000001A4   0x68E8             LDR      R0,[R5, #+12]
   \   000001A6   0x1C40             ADDS     R0,R0,#+1
   \   000001A8   0x60E8             STR      R0,[R5, #+12]
   \   000001AA   0xE7D4             B.N      ??SSP_IntHandler_13
    189          				} else {
    190          					xf_setup->rx_cnt += 2;
   \                     ??SSP_IntHandler_17: (+1)
   \   000001AC   0x68E8             LDR      R0,[R5, #+12]
   \   000001AE   0x1C80             ADDS     R0,R0,#+2
   \   000001B0   0x60E8             STR      R0,[R5, #+12]
   \   000001B2   0xE7D0             B.N      ??SSP_IntHandler_13
    191          				}
    192          			}
    193          		}
    194              }
    195          
    196          	// If there more data to sent or receive
    197          	if ((xf_setup->rx_cnt != xf_setup->length) || (xf_setup->tx_cnt != xf_setup->length)){
   \                     ??SSP_IntHandler_4: (+1)
   \   000001B4   0x68E8             LDR      R0,[R5, #+12]
   \   000001B6   0x6929             LDR      R1,[R5, #+16]
   \   000001B8   0x4288             CMP      R0,R1
   \   000001BA   0xD103             BNE.N    ??SSP_IntHandler_18
   \   000001BC   0x6868             LDR      R0,[R5, #+4]
   \   000001BE   0x6929             LDR      R1,[R5, #+16]
   \   000001C0   0x4288             CMP      R0,R1
   \   000001C2   0xD002             BEQ.N    ??SSP_IntHandler_19
    198          		// Enable all interrupt
    199          		SSPx->IMSC = SSP_IMSC_BITMASK;
   \                     ??SSP_IntHandler_18: (+1)
   \   000001C4   0x200F             MOVS     R0,#+15
   \   000001C6   0x6160             STR      R0,[R4, #+20]
   \   000001C8   0xE007             B.N      ??SSP_IntHandler_20
    200          	} else {
    201          		// Save status
    202          		xf_setup->status = SSP_STAT_DONE;
   \                     ??SSP_IntHandler_19: (+1)
   \   000001CA   0xF44F 0x7080      MOV      R0,#+256
   \   000001CE   0x6168             STR      R0,[R5, #+20]
    203          		// Callback
    204          		if (xf_setup->callback != NULL){
   \   000001D0   0x69A8             LDR      R0,[R5, #+24]
   \   000001D2   0x2800             CMP      R0,#+0
   \   000001D4   0xD001             BEQ.N    ??SSP_IntHandler_20
    205          			xf_setup->callback();
   \   000001D6   0x69A8             LDR      R0,[R5, #+24]
   \   000001D8   0x4780             BLX      R0
    206          		}
    207          	}
    208          }
   \                     ??SSP_IntHandler_20: (+1)
   \                     ??SSP_IntHandler_2: (+1)
   \   000001DA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    209          
    210          /**
    211           * @}
    212           */
    213          
    214          
    215          /* Public Functions ----------------------------------------------------------- */
    216          /** @addtogroup SSP_Public_Functions
    217           * @{
    218           */
    219          
    220          /*********************************************************************//**
    221           * @brief 		Setup clock rate for SSP device
    222           * @param[in] 	SSPx	SSP peripheral definition, should be
    223           * 						SSP0 or SSP1.
    224           * @param[in]	target_clock : clock of SSP (Hz)
    225           * @return 		None
    226           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    227          void SSP_SetClock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock)
    228          {
   \                     SSP_SetClock: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    229              uint32_t prescale, cr0_div, cmp_clk, ssp_clk;
    230          
    231              CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??SSP_SetClock_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??SSP_SetClock_0
   \   00000018   0x21E7             MOVS     R1,#+231
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    232          
    233              /* The SSP clock is derived from the (main system oscillator / 2),
    234                 so compute the best divider from that clock */
    235              if (SSPx == LPC_SSP0){
   \                     ??SSP_SetClock_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD104             BNE.N    ??SSP_SetClock_1
    236              	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP0);
   \   0000002A   0x202A             MOVS     R0,#+42
   \   0000002C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0xE009             B.N      ??SSP_SetClock_2
    237              } else if (SSPx == LPC_SSP1) {
   \                     ??SSP_SetClock_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD104             BNE.N    ??SSP_SetClock_3
    238              	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP1);
   \   0000003C   0x2014             MOVS     R0,#+20
   \   0000003E   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000042   0x4681             MOV      R9,R0
   \   00000044   0xE000             B.N      ??SSP_SetClock_2
    239              } else {
    240              	return;
   \                     ??SSP_SetClock_3: (+1)
   \   00000046   0xE022             B.N      ??SSP_SetClock_4
    241              }
    242          
    243          	/* Find closest divider to get at or under the target frequency.
    244          	   Use smallest prescale possible and rely on the divider to get
    245          	   the closest target frequency */
    246          	cr0_div = 0;
   \                     ??SSP_SetClock_2: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0007             MOVS     R7,R0
    247          	cmp_clk = 0xFFFFFFFF;
   \   0000004C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000050   0x4680             MOV      R8,R0
    248          	prescale = 2;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x0006             MOVS     R6,R0
    249          	while (cmp_clk > target_clock)
   \                     ??SSP_SetClock_5: (+1)
   \   00000056   0x4545             CMP      R5,R8
   \   00000058   0xD20D             BCS.N    ??SSP_SetClock_6
    250          	{
    251          		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
   \   0000005A   0x1C78             ADDS     R0,R7,#+1
   \   0000005C   0x4370             MULS     R0,R6,R0
   \   0000005E   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000062   0x4680             MOV      R8,R0
    252          		if (cmp_clk > target_clock)
   \   00000064   0x4545             CMP      R5,R8
   \   00000066   0xD2F6             BCS.N    ??SSP_SetClock_5
    253          		{
    254          			cr0_div++;
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
    255          			if (cr0_div > 0xFF)
   \   0000006A   0x2FFF             CMP      R7,#+255
   \   0000006C   0xD9F3             BLS.N    ??SSP_SetClock_5
    256          			{
    257          				cr0_div = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0007             MOVS     R7,R0
    258          				prescale += 2;
   \   00000072   0x1CB6             ADDS     R6,R6,#+2
   \   00000074   0xE7EF             B.N      ??SSP_SetClock_5
    259          			}
    260          		}
    261          	}
    262          
    263              /* Write computed prescaler and divider back to register */
    264              SSPx->CR0 &= (~SSP_CR0_SCR(0xFF)) & SSP_CR0_BITMASK;
   \                     ??SSP_SetClock_6: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   0000007C   0x6020             STR      R0,[R4, #+0]
    265              SSPx->CR0 |= (SSP_CR0_SCR(cr0_div)) & SSP_CR0_BITMASK;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x0239             LSLS     R1,R7,#+8
   \   00000082   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x6020             STR      R0,[R4, #+0]
    266              SSPx->CPSR = prescale & SSP_CPSR_BITMASK;
   \   00000088   0xF006 0x00FF      AND      R0,R6,#0xFF
   \   0000008C   0x6120             STR      R0,[R4, #+16]
    267          }
   \                     ??SSP_SetClock_4: (+1)
   \   0000008E   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    268          
    269          
    270          /*********************************************************************//**
    271           * @brief		De-initializes the SSPx peripheral registers to their
    272          *                  default reset values.
    273           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    274           * @return 		None
    275           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          void SSP_DeInit(LPC_SSP_TypeDef* SSPx)
    277          {
   \                     SSP_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    278          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??SSP_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??SSP_DeInit_0
   \   00000014   0xF44F 0x718B      MOV      R1,#+278
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001C   0x.... 0x....      BL       check_failed
    279          
    280          	if (SSPx == LPC_SSP0){
   \                     ??SSP_DeInit_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD105             BNE.N    ??SSP_DeInit_1
    281          		/* Set up clock and power for SSP0 module */
    282          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, DISABLE);
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000002E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000032   0xE008             B.N      ??SSP_DeInit_2
    283          	} else if (SSPx == LPC_SSP1) {
   \                     ??SSP_DeInit_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD104             BNE.N    ??SSP_DeInit_2
    284          		/* Set up clock and power for SSP1 module */
    285          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, DISABLE);
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000042   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    286          	}
    287          }
   \                     ??SSP_DeInit_2: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    288          
    289          
    290          
    291          /********************************************************************//**
    292           * @brief		Initializes the SSPx peripheral according to the specified
    293          *               parameters in the SSP_ConfigStruct.
    294           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    295           * @param[in]	SSP_ConfigStruct Pointer to a SSP_CFG_Type structure
    296          *                    that contains the configuration information for the
    297          *                    specified SSP peripheral.
    298           * @return 		None
    299           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    300          void SSP_Init(LPC_SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct)
    301          {
   \                     SSP_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    302          	uint32_t tmp;
    303          
    304          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_Init_0
   \   00000016   0xF44F 0x7198      MOV      R1,#+304
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    305          
    306          	if(SSPx == LPC_SSP0) {
   \                     ??SSP_Init_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD105             BNE.N    ??SSP_Init_1
    307          		/* Set up clock and power for SSP0 module */
    308          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, ENABLE);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000030   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000034   0xE00A             B.N      ??SSP_Init_2
    309          	} else if(SSPx == LPC_SSP1) {
   \                     ??SSP_Init_1: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD105             BNE.N    ??SSP_Init_3
    310          		/* Set up clock and power for SSP1 module */
    311          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, ENABLE);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF44F 0x6080      MOV      R0,#+1024
   \   00000044   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000048   0xE000             B.N      ??SSP_Init_2
    312          	} else {
    313          		return;
   \                     ??SSP_Init_3: (+1)
   \   0000004A   0xE028             B.N      ??SSP_Init_4
    314          	}
    315          
    316          	/* Configure SSP, interrupt is disable, LoopBack mode is disable,
    317          	 * SSP is disable, Slave output is disable as default
    318          	 */
    319          	tmp = ((SSP_ConfigStruct->CPHA) | (SSP_ConfigStruct->CPOL) \
    320          		| (SSP_ConfigStruct->FrameFormat) | (SSP_ConfigStruct->Databit))
    321          		& SSP_CR0_BITMASK;
   \                     ??SSP_Init_2: (+1)
   \   0000004C   0x6868             LDR      R0,[R5, #+4]
   \   0000004E   0x68A9             LDR      R1,[R5, #+8]
   \   00000050   0x4308             ORRS     R0,R1,R0
   \   00000052   0x6929             LDR      R1,[R5, #+16]
   \   00000054   0x4308             ORRS     R0,R1,R0
   \   00000056   0x6829             LDR      R1,[R5, #+0]
   \   00000058   0x4308             ORRS     R0,R1,R0
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0x0006             MOVS     R6,R0
    322          	// write back to SSP control register
    323          	SSPx->CR0 = tmp;
   \   0000005E   0x6026             STR      R6,[R4, #+0]
    324          	tmp = SSP_getNum(SSPx);
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x.... 0x....      BL       SSP_getNum
   \   00000066   0x0006             MOVS     R6,R0
    325          	if (SSP_ConfigStruct->Databit > SSP_DATABIT_8){
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x2808             CMP      R0,#+8
   \   0000006C   0xD307             BCC.N    ??SSP_Init_5
    326          		sspdat[tmp].dataword = 1;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000074   0x220C             MOVS     R2,#+12
   \   00000076   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000007A   0x5088             STR      R0,[R1, R2]
   \   0000007C   0xE006             B.N      ??SSP_Init_6
    327          	} else {
    328          		sspdat[tmp].dataword = 0;
   \                     ??SSP_Init_5: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000084   0x220C             MOVS     R2,#+12
   \   00000086   0xFB02 0xF206      MUL      R2,R2,R6
   \   0000008A   0x5088             STR      R0,[R1, R2]
    329          	}
    330          
    331          	tmp = SSP_ConfigStruct->Mode & SSP_CR1_BITMASK;
   \                     ??SSP_Init_6: (+1)
   \   0000008C   0x7B28             LDRB     R0,[R5, #+12]
   \   0000008E   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000092   0x0006             MOVS     R6,R0
    332          	// Write back to CR1
    333          	SSPx->CR1 = tmp;
   \   00000094   0x6066             STR      R6,[R4, #+4]
    334          
    335          	// Set clock rate for SSP peripheral
    336          	SSP_SetClock(SSPx, SSP_ConfigStruct->ClockRate);
   \   00000096   0x6969             LDR      R1,[R5, #+20]
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       SSP_SetClock
    337          }
   \                     ??SSP_Init_4: (+1)
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
    338          
    339          
    340          
    341          /*****************************************************************************//**
    342          * @brief		Fills each SSP_InitStruct member with its default value:
    343          * 				- CPHA = SSP_CPHA_FIRST
    344          * 				- CPOL = SSP_CPOL_HI
    345          * 				- ClockRate = 1000000
    346          * 				- Databit = SSP_DATABIT_8
    347          * 				- Mode = SSP_MASTER_MODE
    348          * 				- FrameFormat = SSP_FRAME_SSP
    349          * @param[in]	SSP_InitStruct Pointer to a SSP_CFG_Type structure
    350          *                    which will be initialized.
    351          * @return		None
    352          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct)
    354          {
    355          	SSP_InitStruct->CPHA = SSP_CPHA_FIRST;
   \                     SSP_ConfigStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6041             STR      R1,[R0, #+4]
    356          	SSP_InitStruct->CPOL = SSP_CPOL_HI;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6081             STR      R1,[R0, #+8]
    357          	SSP_InitStruct->ClockRate = 1000000;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable19_4  ;; 0xf4240
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    358          	SSP_InitStruct->Databit = SSP_DATABIT_8;
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x6001             STR      R1,[R0, #+0]
    359          	SSP_InitStruct->Mode = SSP_MASTER_MODE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    360          	SSP_InitStruct->FrameFormat = SSP_FRAME_SPI;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6101             STR      R1,[R0, #+16]
    361          }
   \   0000001A   0x4770             BX       LR               ;; return
    362          
    363          
    364          /*********************************************************************//**
    365           * @brief		Enable or disable SSP peripheral's operation
    366           * @param[in]	SSPx	SSP peripheral, should be SSP0 or SSP1
    367           * @param[in]	NewState New State of SSPx peripheral's operation
    368           * @return 		none
    369           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    370          void SSP_Cmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    371          {
   \                     SSP_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    372          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_Cmd_0
   \   00000016   0xF44F 0x71BA      MOV      R1,#+372
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    373          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_Cmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SSP_Cmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SSP_Cmd_1
   \   0000002E   0xF240 0x1175      MOVW     R1,#+373
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000036   0x.... 0x....      BL       check_failed
    374          
    375          	if (NewState == ENABLE)
   \                     ??SSP_Cmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD104             BNE.N    ??SSP_Cmd_2
    376          	{
    377          		SSPx->CR1 |= SSP_CR1_SSP_EN;
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000046   0x6060             STR      R0,[R4, #+4]
   \   00000048   0xE003             B.N      ??SSP_Cmd_3
    378          	}
    379          	else
    380          	{
    381          		SSPx->CR1 &= (~SSP_CR1_SSP_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_Cmd_2: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0xF010 0x000D      ANDS     R0,R0,#0xD
   \   00000050   0x6060             STR      R0,[R4, #+4]
    382          	}
    383          }
   \                     ??SSP_Cmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    384          
    385          
    386          
    387          /*********************************************************************//**
    388           * @brief		Enable or disable Loop Back mode function in SSP peripheral
    389           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    390           * @param[in]	NewState	New State of Loop Back mode, should be:
    391           * 							- ENABLE: Enable this function
    392           * 							- DISABLE: Disable this function
    393           * @return 		None
    394           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    395          void SSP_LoopBackCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    396          {
   \                     SSP_LoopBackCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    397          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_LoopBackCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_LoopBackCmd_0
   \   00000016   0xF240 0x118D      MOVW     R1,#+397
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    398          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_LoopBackCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SSP_LoopBackCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SSP_LoopBackCmd_1
   \   0000002E   0xF44F 0x71C7      MOV      R1,#+398
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000036   0x.... 0x....      BL       check_failed
    399          
    400          	if (NewState == ENABLE)
   \                     ??SSP_LoopBackCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD104             BNE.N    ??SSP_LoopBackCmd_2
    401          	{
    402          		SSPx->CR1 |= SSP_CR1_LBM_EN;
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x6060             STR      R0,[R4, #+4]
   \   00000048   0xE003             B.N      ??SSP_LoopBackCmd_3
    403          	}
    404          	else
    405          	{
    406          		SSPx->CR1 &= (~SSP_CR1_LBM_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_LoopBackCmd_2: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0xF010 0x000E      ANDS     R0,R0,#0xE
   \   00000050   0x6060             STR      R0,[R4, #+4]
    407          	}
    408          }
   \                     ??SSP_LoopBackCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    409          
    410          
    411          
    412          /*********************************************************************//**
    413           * @brief		Enable or disable Slave Output function in SSP peripheral
    414           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    415           * @param[in]	NewState	New State of Slave Output function, should be:
    416           * 							- ENABLE: Slave Output in normal operation
    417           * 							- DISABLE: Slave Output is disabled. This blocks
    418           * 							SSP controller from driving the transmit data
    419           * 							line (MISO)
    420           * Note: 		This function is available when SSP peripheral in Slave mode
    421           * @return 		None
    422           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    423          void SSP_SlaveOutputCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    424          {
   \                     SSP_SlaveOutputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    425          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_SlaveOutputCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_SlaveOutputCmd_0
   \   00000016   0xF240 0x11A9      MOVW     R1,#+425
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    426          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_SlaveOutputCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SSP_SlaveOutputCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SSP_SlaveOutputCmd_1
   \   0000002E   0xF44F 0x71D5      MOV      R1,#+426
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   00000036   0x.... 0x....      BL       check_failed
    427          
    428          	if (NewState == ENABLE)
   \                     ??SSP_SlaveOutputCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD104             BNE.N    ??SSP_SlaveOutputCmd_2
    429          	{
    430          		SSPx->CR1 &= (~SSP_CR1_SO_DISABLE) & SSP_CR1_BITMASK;
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000046   0x6060             STR      R0,[R4, #+4]
   \   00000048   0xE003             B.N      ??SSP_SlaveOutputCmd_3
    431          	}
    432          	else
    433          	{
    434          		SSPx->CR1 |= SSP_CR1_SO_DISABLE;
   \                     ??SSP_SlaveOutputCmd_2: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000050   0x6060             STR      R0,[R4, #+4]
    435          	}
    436          }
   \                     ??SSP_SlaveOutputCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    437          
    438          
    439          
    440          /*********************************************************************//**
    441           * @brief		Transmit a single data through SSPx peripheral
    442           * @param[in]	SSPx	SSP peripheral selected, should be SSP
    443           * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
    444           * 						this depend on SSP data bit number configured)
    445           * @return 		none
    446           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    447          void SSP_SendData(LPC_SSP_TypeDef* SSPx, uint16_t Data)
    448          {
   \                     SSP_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    449          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_SendData_0
   \   00000016   0xF240 0x11C1      MOVW     R1,#+449
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001E   0x.... 0x....      BL       check_failed
    450          
    451          	SSPx->DR = SSP_DR_BITMASK(Data);
   \                     ??SSP_SendData_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x60A5             STR      R5,[R4, #+8]
    452          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    453          
    454          
    455          
    456          /*********************************************************************//**
    457           * @brief		Receive a single data from SSPx peripheral
    458           * @param[in]	SSPx	SSP peripheral selected, should be SSP
    459           * @return 		Data received (16-bit long)
    460           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    461          uint16_t SSP_ReceiveData(LPC_SSP_TypeDef* SSPx)
    462          {
   \                     SSP_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    463          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??SSP_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??SSP_ReceiveData_0
   \   00000014   0xF240 0x11CF      MOVW     R1,#+463
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000001C   0x.... 0x....      BL       check_failed
    464          
    465          	return ((uint16_t) (SSP_DR_BITMASK(SSPx->DR)));
   \                     ??SSP_ReceiveData_0: (+1)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    466          }
    467          
    468          /*********************************************************************//**
    469           * @brief 		SSP Read write data function
    470           * @param[in]	SSPx 	Pointer to SSP peripheral, should be SSP0 or SSP1
    471           * @param[in]	dataCfg	Pointer to a SSP_DATA_SETUP_Type structure that
    472           * 						contains specified information about transmit
    473           * 						data configuration.
    474           * @param[in]	xfType	Transfer type, should be:
    475           * 						- SSP_TRANSFER_POLLING: Polling mode
    476           * 						- SSP_TRANSFER_INTERRUPT: Interrupt mode
    477           * @return 		Actual Data length has been transferred in polling mode.
    478           * 				In interrupt mode, always return (0)
    479           * 				Return (-1) if error.
    480           * Note: This function can be used in both master and slave mode.
    481           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    482          int32_t SSP_ReadWrite (LPC_SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
    483          						SSP_TRANSFER_Type xfType)
    484          {
   \                     SSP_ReadWrite: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x468B             MOV      R11,R1
    485          	uint8_t *rdata8;
    486              uint8_t *wdata8;
    487          	uint16_t *rdata16;
    488              uint16_t *wdata16;
    489              uint32_t stat;
    490              uint32_t tmp;
    491              int32_t sspnum;
    492              int32_t dataword;
    493          
    494              dataCfg->rx_cnt = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8CB 0x000C      STR      R0,[R11, #+12]
    495              dataCfg->tx_cnt = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8CB 0x0004      STR      R0,[R11, #+4]
    496              dataCfg->status = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF8CB 0x0014      STR      R0,[R11, #+20]
    497          
    498          
    499          	/* Clear all remaining data in RX FIFO */
    500          	while (SSPx->SR & SSP_SR_RNE){
   \                     ??SSP_ReadWrite_0: (+1)
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x0740             LSLS     R0,R0,#+29
   \   0000001E   0xD504             BPL.N    ??SSP_ReadWrite_1
    501          		tmp = (uint32_t) SSP_ReceiveData(SSPx);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       SSP_ReceiveData
   \   00000026   0x0005             MOVS     R5,R0
   \   00000028   0xE7F7             B.N      ??SSP_ReadWrite_0
    502          	}
    503          
    504          	// Clear status
    505          	SSPx->ICR = SSP_ICR_BITMASK;
   \                     ??SSP_ReadWrite_1: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x6220             STR      R0,[R4, #+32]
    506          
    507          	sspnum = SSP_getNum(SSPx);
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       SSP_getNum
   \   00000034   0x0006             MOVS     R6,R0
    508          	dataword = sspdat[sspnum].dataword;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   0000003A   0x210C             MOVS     R1,#+12
   \   0000003C   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000040   0x5840             LDR      R0,[R0, R1]
   \   00000042   0x9000             STR      R0,[SP, #+0]
    509          
    510          	// Polling mode ----------------------------------------------------------------------
    511          	if (xfType == SSP_TRANSFER_POLLING){
   \   00000044   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xF040 0x80A8      BNE.W    ??SSP_ReadWrite_2
    512          		if (dataword == 0){
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD106             BNE.N    ??SSP_ReadWrite_3
    513          			rdata8 = (uint8_t *)dataCfg->rx_data;
   \   00000054   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000058   0x4681             MOV      R9,R0
    514          			wdata8 = (uint8_t *)dataCfg->tx_data;
   \   0000005A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005E   0x0007             MOVS     R7,R0
   \   00000060   0xE005             B.N      ??SSP_ReadWrite_4
    515          		} else {
    516          			rdata16 = (uint16_t *)dataCfg->rx_data;
   \                     ??SSP_ReadWrite_3: (+1)
   \   00000062   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000066   0x4682             MOV      R10,R0
    517          			wdata16 = (uint16_t *)dataCfg->tx_data;
   \   00000068   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000006C   0x4680             MOV      R8,R0
    518          		}
    519          		while ((dataCfg->tx_cnt != dataCfg->length) || (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_4: (+1)
   \   0000006E   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000072   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD105             BNE.N    ??SSP_ReadWrite_5
   \   0000007A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000007E   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD077             BEQ.N    ??SSP_ReadWrite_6
    520          			if ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_5: (+1)
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0x0780             LSLS     R0,R0,#+30
   \   0000008A   0xD53C             BPL.N    ??SSP_ReadWrite_7
   \   0000008C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000090   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD036             BEQ.N    ??SSP_ReadWrite_7
    521          				// Write data to buffer
    522          				if(dataCfg->tx_data == NULL){
   \   00000098   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD117             BNE.N    ??SSP_ReadWrite_8
    523          					if (dataword == 0){
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD109             BNE.N    ??SSP_ReadWrite_9
    524          						SSP_SendData(SSPx, 0xFF);
   \   000000A6   0x21FF             MOVS     R1,#+255
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       SSP_SendData
    525          						dataCfg->tx_cnt++;
   \   000000AE   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000B8   0xE025             B.N      ??SSP_ReadWrite_7
    526          					} else {
    527          						SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_9: (+1)
   \   000000BA   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       SSP_SendData
    528          						dataCfg->tx_cnt += 2;
   \   000000C4   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000C8   0x1C80             ADDS     R0,R0,#+2
   \   000000CA   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000CE   0xE01A             B.N      ??SSP_ReadWrite_7
    529          					}
    530          				} else {
    531          					if (dataword == 0){
   \                     ??SSP_ReadWrite_8: (+1)
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD10B             BNE.N    ??SSP_ReadWrite_10
    532          						SSP_SendData(SSPx, *wdata8);
   \   000000D6   0x7839             LDRB     R1,[R7, #+0]
   \   000000D8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       SSP_SendData
    533          						wdata8++;
   \   000000E0   0x1C7F             ADDS     R7,R7,#+1
    534          						dataCfg->tx_cnt++;
   \   000000E2   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
   \   000000E8   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000EC   0xE00B             B.N      ??SSP_ReadWrite_7
    535          					} else {
    536          						SSP_SendData(SSPx, *wdata16);
   \                     ??SSP_ReadWrite_10: (+1)
   \   000000EE   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       SSP_SendData
    537          						wdata16++;
   \   000000F8   0xF118 0x0802      ADDS     R8,R8,#+2
    538          						dataCfg->tx_cnt += 2;
   \   000000FC   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000100   0x1C80             ADDS     R0,R0,#+2
   \   00000102   0xF8CB 0x0004      STR      R0,[R11, #+4]
    539          					}
    540          				}
    541          			}
    542          
    543          			// Check overrun error
    544          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_7: (+1)
   \   00000106   0x69A0             LDR      R0,[R4, #+24]
   \   00000108   0x9001             STR      R0,[SP, #+4]
   \   0000010A   0x07C0             LSLS     R0,R0,#+31
   \   0000010C   0xD507             BPL.N    ??SSP_ReadWrite_11
    545          				// save status and return
    546          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   0000010E   0x9801             LDR      R0,[SP, #+4]
   \   00000110   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000114   0xF8CB 0x0014      STR      R0,[R11, #+20]
    547          				return (-1);
   \   00000118   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000011C   0xE102             B.N      ??SSP_ReadWrite_12
    548          			}
    549          
    550          			// Check for any data available in RX FIFO
    551          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_11: (+1)
   \   0000011E   0x68E0             LDR      R0,[R4, #+12]
   \   00000120   0x0740             LSLS     R0,R0,#+29
   \   00000122   0xD5A4             BPL.N    ??SSP_ReadWrite_4
   \   00000124   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000128   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000012C   0x4288             CMP      R0,R1
   \   0000012E   0xD09E             BEQ.N    ??SSP_ReadWrite_4
    552          				// Read data from SSP data
    553          				tmp = SSP_ReceiveData(SSPx);
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x.... 0x....      BL       SSP_ReceiveData
   \   00000136   0x0005             MOVS     R5,R0
    554          
    555          				// Store data to destination
    556          				if (dataCfg->rx_data != NULL)
   \   00000138   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD00B             BEQ.N    ??SSP_ReadWrite_13
    557          				{
    558          					if (dataword == 0){
   \   00000140   0x9800             LDR      R0,[SP, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD104             BNE.N    ??SSP_ReadWrite_14
    559          						*(rdata8) = (uint8_t) tmp;
   \   00000146   0xF889 0x5000      STRB     R5,[R9, #+0]
    560          						rdata8++;
   \   0000014A   0xF119 0x0901      ADDS     R9,R9,#+1
   \   0000014E   0xE003             B.N      ??SSP_ReadWrite_13
    561          					} else {
    562          						*(rdata16) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_14: (+1)
   \   00000150   0xF8AA 0x5000      STRH     R5,[R10, #+0]
    563          						rdata16++;
   \   00000154   0xF11A 0x0A02      ADDS     R10,R10,#+2
    564          					}
    565          				}
    566          				// Increase counter
    567          				if (dataword == 0){
   \                     ??SSP_ReadWrite_13: (+1)
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD105             BNE.N    ??SSP_ReadWrite_15
    568          					dataCfg->rx_cnt++;
   \   0000015E   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000162   0x1C40             ADDS     R0,R0,#+1
   \   00000164   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000168   0xE7D9             B.N      ??SSP_ReadWrite_11
    569          				} else {
    570          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_15: (+1)
   \   0000016A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000016E   0x1C80             ADDS     R0,R0,#+2
   \   00000170   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000174   0xE7D3             B.N      ??SSP_ReadWrite_11
    571          				}
    572          			}
    573          		}
    574          
    575          		// save status
    576          		dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_6: (+1)
   \   00000176   0xF44F 0x7080      MOV      R0,#+256
   \   0000017A   0xF8CB 0x0014      STR      R0,[R11, #+20]
    577          
    578          		if (dataCfg->tx_data != NULL){
   \   0000017E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD002             BEQ.N    ??SSP_ReadWrite_16
    579          			return dataCfg->tx_cnt;
   \   00000186   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   0000018A   0xE0CB             B.N      ??SSP_ReadWrite_12
    580          		} else if (dataCfg->rx_data != NULL){
   \                     ??SSP_ReadWrite_16: (+1)
   \   0000018C   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xD002             BEQ.N    ??SSP_ReadWrite_17
    581          			return dataCfg->rx_cnt;
   \   00000194   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000198   0xE0C4             B.N      ??SSP_ReadWrite_12
    582          		} else {
    583          			return (0);
   \                     ??SSP_ReadWrite_17: (+1)
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0xE0C2             B.N      ??SSP_ReadWrite_12
    584          		}
    585          	}
    586          
    587          	// Interrupt mode ----------------------------------------------------------------------
    588          	else if (xfType == SSP_TRANSFER_INTERRUPT){
   \                     ??SSP_ReadWrite_2: (+1)
   \   0000019E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000001A2   0x2801             CMP      R0,#+1
   \   000001A4   0xF040 0x80BC      BNE.W    ??SSP_ReadWrite_18
    589          		sspdat[sspnum].inthandler = SSP_IntHandler;
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable19_5
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   000001B0   0x220C             MOVS     R2,#+12
   \   000001B2   0xFB02 0xF206      MUL      R2,R2,R6
   \   000001B6   0x4411             ADD      R1,R1,R2
   \   000001B8   0x6088             STR      R0,[R1, #+8]
    590          		sspdat[sspnum].txrx_setup = (uint32_t)dataCfg;
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   000001BE   0x210C             MOVS     R1,#+12
   \   000001C0   0xFB01 0xF106      MUL      R1,R1,R6
   \   000001C4   0x4408             ADD      R0,R0,R1
   \   000001C6   0xF8C0 0xB004      STR      R11,[R0, #+4]
    591          
    592          		while ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_19: (+1)
   \   000001CA   0x68E0             LDR      R0,[R4, #+12]
   \   000001CC   0x0780             LSLS     R0,R0,#+30
   \   000001CE   0xF140 0x8092      BPL.W    ??SSP_ReadWrite_20
   \   000001D2   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001D6   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000001DA   0x4288             CMP      R0,R1
   \   000001DC   0xF000 0x808B      BEQ.W    ??SSP_ReadWrite_20
    593          			// Write data to buffer
    594          			if(dataCfg->tx_data == NULL){
   \   000001E0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD11B             BNE.N    ??SSP_ReadWrite_21
    595          				if (sspdat[sspnum].dataword == 0){
   \   000001E8   0x....             LDR.N    R0,??DataTable19_2
   \   000001EA   0x210C             MOVS     R1,#+12
   \   000001EC   0xFB01 0xF106      MUL      R1,R1,R6
   \   000001F0   0x5840             LDR      R0,[R0, R1]
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xD109             BNE.N    ??SSP_ReadWrite_22
    596          					SSP_SendData(SSPx, 0xFF);
   \   000001F6   0x21FF             MOVS     R1,#+255
   \   000001F8   0x0020             MOVS     R0,R4
   \   000001FA   0x.... 0x....      BL       SSP_SendData
    597          					dataCfg->tx_cnt++;
   \   000001FE   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000202   0x1C40             ADDS     R0,R0,#+1
   \   00000204   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   00000208   0xE031             B.N      ??SSP_ReadWrite_23
    598          				} else {
    599          					SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_22: (+1)
   \   0000020A   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000020E   0x0020             MOVS     R0,R4
   \   00000210   0x.... 0x....      BL       SSP_SendData
    600          					dataCfg->tx_cnt += 2;
   \   00000214   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000218   0x1C80             ADDS     R0,R0,#+2
   \   0000021A   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   0000021E   0xE026             B.N      ??SSP_ReadWrite_23
    601          				}
    602          			} else {
    603          				if (sspdat[sspnum].dataword == 0){
   \                     ??SSP_ReadWrite_21: (+1)
   \   00000220   0x....             LDR.N    R0,??DataTable19_2
   \   00000222   0x210C             MOVS     R1,#+12
   \   00000224   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000228   0x5840             LDR      R0,[R0, R1]
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD110             BNE.N    ??SSP_ReadWrite_24
    604          					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \   0000022E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000232   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   00000236   0x1808             ADDS     R0,R1,R0
   \   00000238   0x7801             LDRB     R1,[R0, #+0]
   \   0000023A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000023C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000023E   0x0020             MOVS     R0,R4
   \   00000240   0x.... 0x....      BL       SSP_SendData
    605          					dataCfg->tx_cnt++;
   \   00000244   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000248   0x1C40             ADDS     R0,R0,#+1
   \   0000024A   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   0000024E   0xE00E             B.N      ??SSP_ReadWrite_23
    606          				} else {
    607          					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \                     ??SSP_ReadWrite_24: (+1)
   \   00000250   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000254   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   00000258   0x1808             ADDS     R0,R1,R0
   \   0000025A   0x8801             LDRH     R1,[R0, #+0]
   \   0000025C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000025E   0x0020             MOVS     R0,R4
   \   00000260   0x.... 0x....      BL       SSP_SendData
    608          					dataCfg->tx_cnt += 2;
   \   00000264   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000268   0x1C80             ADDS     R0,R0,#+2
   \   0000026A   0xF8CB 0x0004      STR      R0,[R11, #+4]
    609          				}
    610          			}
    611          
    612          			// Check error
    613          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_23: (+1)
   \   0000026E   0x69A0             LDR      R0,[R4, #+24]
   \   00000270   0x9001             STR      R0,[SP, #+4]
   \   00000272   0x07C0             LSLS     R0,R0,#+31
   \   00000274   0xD507             BPL.N    ??SSP_ReadWrite_25
    614          				// save status and return
    615          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   00000276   0x9801             LDR      R0,[SP, #+4]
   \   00000278   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000027C   0xF8CB 0x0014      STR      R0,[R11, #+20]
    616          				return (-1);
   \   00000280   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000284   0xE04E             B.N      ??SSP_ReadWrite_12
    617          			}
    618          
    619          			// Check for any data available in RX FIFO
    620          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_25: (+1)
   \   00000286   0x68E0             LDR      R0,[R4, #+12]
   \   00000288   0x0740             LSLS     R0,R0,#+29
   \   0000028A   0xD59E             BPL.N    ??SSP_ReadWrite_19
   \   0000028C   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000290   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000294   0x4288             CMP      R0,R1
   \   00000296   0xD098             BEQ.N    ??SSP_ReadWrite_19
    621          				// Read data from SSP data
    622          				tmp = SSP_ReceiveData(SSPx);
   \   00000298   0x0020             MOVS     R0,R4
   \   0000029A   0x.... 0x....      BL       SSP_ReceiveData
   \   0000029E   0x0005             MOVS     R5,R0
    623          
    624          				// Store data to destination
    625          				if (dataCfg->rx_data != NULL)
   \   000002A0   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000002A4   0x2800             CMP      R0,#+0
   \   000002A6   0xD013             BEQ.N    ??SSP_ReadWrite_26
    626          				{
    627          					if (sspdat[sspnum].dataword == 0){
   \   000002A8   0x....             LDR.N    R0,??DataTable19_2
   \   000002AA   0x210C             MOVS     R1,#+12
   \   000002AC   0xFB01 0xF106      MUL      R1,R1,R6
   \   000002B0   0x5840             LDR      R0,[R0, R1]
   \   000002B2   0x2800             CMP      R0,#+0
   \   000002B4   0xD106             BNE.N    ??SSP_ReadWrite_27
    628          						*(uint8_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint8_t) tmp;
   \   000002B6   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000002BA   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   000002BE   0x1808             ADDS     R0,R1,R0
   \   000002C0   0x7005             STRB     R5,[R0, #+0]
   \   000002C2   0xE005             B.N      ??SSP_ReadWrite_26
    629          					} else {
    630          						*(uint16_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_27: (+1)
   \   000002C4   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000002C8   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   000002CC   0x1808             ADDS     R0,R1,R0
   \   000002CE   0x8005             STRH     R5,[R0, #+0]
    631          					}
    632          				}
    633          				// Increase counter
    634          				if (sspdat[sspnum].dataword == 0){
   \                     ??SSP_ReadWrite_26: (+1)
   \   000002D0   0x....             LDR.N    R0,??DataTable19_2
   \   000002D2   0x210C             MOVS     R1,#+12
   \   000002D4   0xFB01 0xF106      MUL      R1,R1,R6
   \   000002D8   0x5840             LDR      R0,[R0, R1]
   \   000002DA   0x2800             CMP      R0,#+0
   \   000002DC   0xD105             BNE.N    ??SSP_ReadWrite_28
    635          					dataCfg->rx_cnt++;
   \   000002DE   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   000002E2   0x1C40             ADDS     R0,R0,#+1
   \   000002E4   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   000002E8   0xE7CD             B.N      ??SSP_ReadWrite_25
    636          				} else {
    637          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_28: (+1)
   \   000002EA   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   000002EE   0x1C80             ADDS     R0,R0,#+2
   \   000002F0   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   000002F4   0xE7C7             B.N      ??SSP_ReadWrite_25
    638          				}
    639          			}
    640          		}
    641          
    642          		// If there more data to sent or receive
    643          		if ((dataCfg->rx_cnt != dataCfg->length) || (dataCfg->tx_cnt != dataCfg->length)){
   \                     ??SSP_ReadWrite_20: (+1)
   \   000002F6   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   000002FA   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000002FE   0x4288             CMP      R0,R1
   \   00000300   0xD105             BNE.N    ??SSP_ReadWrite_29
   \   00000302   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000306   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000030A   0x4288             CMP      R0,R1
   \   0000030C   0xD002             BEQ.N    ??SSP_ReadWrite_30
    644          			// Enable all interrupt
    645          			SSPx->IMSC = SSP_IMSC_BITMASK;
   \                     ??SSP_ReadWrite_29: (+1)
   \   0000030E   0x200F             MOVS     R0,#+15
   \   00000310   0x6160             STR      R0,[R4, #+20]
   \   00000312   0xE003             B.N      ??SSP_ReadWrite_31
    646          		} else {
    647          			// Save status
    648          			dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_30: (+1)
   \   00000314   0xF44F 0x7080      MOV      R0,#+256
   \   00000318   0xF8CB 0x0014      STR      R0,[R11, #+20]
    649          		}
    650          		return (0);
   \                     ??SSP_ReadWrite_31: (+1)
   \   0000031C   0x2000             MOVS     R0,#+0
   \   0000031E   0xE001             B.N      ??SSP_ReadWrite_12
    651          	}
    652          
    653          	return (-1);
   \                     ??SSP_ReadWrite_18: (+1)
   \   00000320   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??SSP_ReadWrite_12: (+1)
   \   00000324   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    654          }
    655          
    656          /*********************************************************************//**
    657           * @brief		Checks whether the specified SSP status flag is set or not
    658           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    659           * @param[in]	FlagType	Type of flag to check status, should be one
    660           * 							of following:
    661           *							- SSP_STAT_TXFIFO_EMPTY: TX FIFO is empty
    662           *							- SSP_STAT_TXFIFO_NOTFULL: TX FIFO is not full
    663           *							- SSP_STAT_RXFIFO_NOTEMPTY: RX FIFO is not empty
    664           *							- SSP_STAT_RXFIFO_FULL: RX FIFO is full
    665           *							- SSP_STAT_BUSY: SSP peripheral is busy
    666           * @return		New State of specified SSP status flag
    667           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    668          FlagStatus SSP_GetStatus(LPC_SSP_TypeDef* SSPx, uint32_t FlagType)
    669          {
   \                     SSP_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    670          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetStatus_0
   \   00000012   0xF240 0x219E      MOVW     R1,#+670
   \   00000016   0x....             LDR.N    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       check_failed
    671          	CHECK_PARAM(PARAM_SSP_STAT(FlagType));
   \                     ??SSP_GetStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00C             BEQ.N    ??SSP_GetStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD00A             BEQ.N    ??SSP_GetStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD008             BEQ.N    ??SSP_GetStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD006             BEQ.N    ??SSP_GetStatus_1
   \   0000002C   0x2D10             CMP      R5,#+16
   \   0000002E   0xD004             BEQ.N    ??SSP_GetStatus_1
   \   00000030   0xF240 0x219F      MOVW     R1,#+671
   \   00000034   0x....             LDR.N    R0,??DataTable19_3
   \   00000036   0x.... 0x....      BL       check_failed
    672          
    673          	return ((SSPx->SR & FlagType) ? SET : RESET);
   \                     ??SSP_GetStatus_1: (+1)
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x4228             TST      R0,R5
   \   0000003E   0xD001             BEQ.N    ??SSP_GetStatus_2
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??SSP_GetStatus_3
   \                     ??SSP_GetStatus_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetStatus_3: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    674          }
    675          
    676          
    677          
    678          /*********************************************************************//**
    679           * @brief		Enable or disable specified interrupt type in SSP peripheral
    680           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    681           * @param[in]	IntType	Interrupt type in SSP peripheral, should be:
    682           * 				- SSP_INTCFG_ROR: Receive Overrun interrupt
    683           * 				- SSP_INTCFG_RT: Receive Time out interrupt
    684           * 				- SSP_INTCFG_RX: RX FIFO is at least half full interrupt
    685           * 				- SSP_INTCFG_TX: TX FIFO is at least half empty interrupt
    686           * @param[in]	NewState New State of specified interrupt type, should be:
    687           * 				- ENABLE: Enable this interrupt type
    688           * 				- DISABLE: Disable this interrupt type
    689           * @return		None
    690           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    691          void SSP_IntConfig(LPC_SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState)
    692          {
   \                     SSP_IntConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    693          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SSP_IntConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_IntConfig_0
   \   00000014   0xF240 0x21B5      MOVW     R1,#+693
   \   00000018   0x....             LDR.N    R0,??DataTable19_3
   \   0000001A   0x.... 0x....      BL       check_failed
    694          	CHECK_PARAM(PARAM_SSP_INTCFG(IntType));
   \                     ??SSP_IntConfig_0: (+1)
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD00A             BEQ.N    ??SSP_IntConfig_1
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD008             BEQ.N    ??SSP_IntConfig_1
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xD006             BEQ.N    ??SSP_IntConfig_1
   \   0000002A   0x2D08             CMP      R5,#+8
   \   0000002C   0xD004             BEQ.N    ??SSP_IntConfig_1
   \   0000002E   0xF240 0x21B6      MOVW     R1,#+694
   \   00000032   0x....             LDR.N    R0,??DataTable19_3
   \   00000034   0x.... 0x....      BL       check_failed
    695          
    696          	if (NewState == ENABLE)
   \                     ??SSP_IntConfig_1: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E01             CMP      R6,#+1
   \   0000003C   0xD103             BNE.N    ??SSP_IntConfig_2
    697          	{
    698          		SSPx->IMSC |= IntType;
   \   0000003E   0x6960             LDR      R0,[R4, #+20]
   \   00000040   0x4328             ORRS     R0,R5,R0
   \   00000042   0x6160             STR      R0,[R4, #+20]
   \   00000044   0xE005             B.N      ??SSP_IntConfig_3
    699          	}
    700          	else
    701          	{
    702          		SSPx->IMSC &= (~IntType) & SSP_IMSC_BITMASK;
   \                     ??SSP_IntConfig_2: (+1)
   \   00000046   0x6960             LDR      R0,[R4, #+20]
   \   00000048   0x43E9             MVNS     R1,R5
   \   0000004A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000004E   0x4008             ANDS     R0,R1,R0
   \   00000050   0x6160             STR      R0,[R4, #+20]
    703          	}
    704          }
   \                     ??SSP_IntConfig_3: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    705          
    706          
    707          /*********************************************************************//**
    708           * @brief	Check whether the specified Raw interrupt status flag is
    709           * 			set or not
    710           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    711           * @param[in]	RawIntType	Raw Interrupt Type, should be:
    712           * 				- SSP_INTSTAT_RAW_ROR: Receive Overrun interrupt
    713           * 				- SSP_INTSTAT_RAW_RT: Receive Time out interrupt
    714           * 				- SSP_INTSTAT_RAW_RX: RX FIFO is at least half full interrupt
    715           * 				- SSP_INTSTAT_RAW_TX: TX FIFO is at least half empty interrupt
    716           * @return	New State of specified Raw interrupt status flag in SSP peripheral
    717           * Note: Enabling/Disabling specified interrupt in SSP peripheral does not
    718           * 		effect to Raw Interrupt Status flag.
    719           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    720          IntStatus SSP_GetRawIntStatus(LPC_SSP_TypeDef *SSPx, uint32_t RawIntType)
    721          {
   \                     SSP_GetRawIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    722          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetRawIntStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetRawIntStatus_0
   \   00000012   0xF240 0x21D2      MOVW     R1,#+722
   \   00000016   0x....             LDR.N    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       check_failed
    723          	CHECK_PARAM(PARAM_SSP_INTSTAT_RAW(RawIntType));
   \                     ??SSP_GetRawIntStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00A             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD008             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD006             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD004             BEQ.N    ??SSP_GetRawIntStatus_1
   \   0000002C   0xF240 0x21D3      MOVW     R1,#+723
   \   00000030   0x....             LDR.N    R0,??DataTable19_3
   \   00000032   0x.... 0x....      BL       check_failed
    724          
    725          	return ((SSPx->RIS & RawIntType) ? SET : RESET);
   \                     ??SSP_GetRawIntStatus_1: (+1)
   \   00000036   0x69A0             LDR      R0,[R4, #+24]
   \   00000038   0x4228             TST      R0,R5
   \   0000003A   0xD001             BEQ.N    ??SSP_GetRawIntStatus_2
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??SSP_GetRawIntStatus_3
   \                     ??SSP_GetRawIntStatus_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetRawIntStatus_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    726          }
    727          
    728          
    729          /*********************************************************************//**
    730           * @brief	Check whether the specified interrupt status flag is
    731           * 			set or not
    732           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    733           * @param[in]	IntType	Raw Interrupt Type, should be:
    734           * 				- SSP_INTSTAT_ROR: Receive Overrun interrupt
    735           * 				- SSP_INTSTAT_RT: Receive Time out interrupt
    736           * 				- SSP_INTSTAT_RX: RX FIFO is at least half full interrupt
    737           * 				- SSP_INTSTAT_TX: TX FIFO is at least half empty interrupt
    738           * @return	New State of specified interrupt status flag in SSP peripheral
    739           * Note: Enabling/Disabling specified interrupt in SSP peripheral effects
    740           * 			to Interrupt Status flag.
    741           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    742          IntStatus SSP_GetIntStatus (LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    743          {
   \                     SSP_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    744          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetIntStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetIntStatus_0
   \   00000012   0xF44F 0x713A      MOV      R1,#+744
   \   00000016   0x....             LDR.N    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       check_failed
    745          	CHECK_PARAM(PARAM_SSP_INTSTAT(IntType));
   \                     ??SSP_GetIntStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00A             BEQ.N    ??SSP_GetIntStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD008             BEQ.N    ??SSP_GetIntStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD006             BEQ.N    ??SSP_GetIntStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD004             BEQ.N    ??SSP_GetIntStatus_1
   \   0000002C   0xF240 0x21E9      MOVW     R1,#+745
   \   00000030   0x....             LDR.N    R0,??DataTable19_3
   \   00000032   0x.... 0x....      BL       check_failed
    746          
    747          	return ((SSPx->MIS & IntType) ? SET :RESET);
   \                     ??SSP_GetIntStatus_1: (+1)
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x4228             TST      R0,R5
   \   0000003A   0xD001             BEQ.N    ??SSP_GetIntStatus_2
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??SSP_GetIntStatus_3
   \                     ??SSP_GetIntStatus_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetIntStatus_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    748          }
    749          
    750          
    751          
    752          /*********************************************************************//**
    753           * @brief				Clear specified interrupt pending in SSP peripheral
    754           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    755           * @param[in]	IntType	Interrupt pending to clear, should be:
    756           * 						- SSP_INTCLR_ROR: clears the "frame was received when
    757           * 						RxFIFO was full" interrupt.
    758           * 						- SSP_INTCLR_RT: clears the "Rx FIFO was not empty and
    759           * 						has not been read for a timeout period" interrupt.
    760           * @return		None
    761           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    762          void SSP_ClearIntPending(LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    763          {
   \                     SSP_ClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    764          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_ClearIntPending_0
   \   0000000C   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_ClearIntPending_0
   \   00000012   0xF44F 0x713F      MOV      R1,#+764
   \   00000016   0x....             LDR.N    R0,??DataTable19_3
   \   00000018   0x.... 0x....      BL       check_failed
    765          	CHECK_PARAM(PARAM_SSP_INTCLR(IntType));
   \                     ??SSP_ClearIntPending_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD006             BEQ.N    ??SSP_ClearIntPending_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD004             BEQ.N    ??SSP_ClearIntPending_1
   \   00000024   0xF240 0x21FD      MOVW     R1,#+765
   \   00000028   0x....             LDR.N    R0,??DataTable19_3
   \   0000002A   0x.... 0x....      BL       check_failed
    766          
    767          	SSPx->ICR = IntType;
   \                     ??SSP_ClearIntPending_1: (+1)
   \   0000002E   0x6225             STR      R5,[R4, #+32]
    768          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    769          
    770          /*********************************************************************//**
    771           * @brief				Enable/Disable DMA function for SSP peripheral
    772           * @param[in]	SSPx	SSP peripheral selected, should be SSP0 or SSP1
    773           * @param[in]	DMAMode	Type of DMA, should be:
    774           * 						- SSP_DMA_TX: DMA for the transmit FIFO
    775           * 						- SSP_DMA_RX: DMA for the Receive FIFO
    776           * @param[in]	NewState	New State of DMA function on SSP peripheral,
    777           * 						should be:
    778           * 						- ENALBE: Enable this function
    779           * 						- DISABLE: Disable this function
    780           * @return		None
    781           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    782          void SSP_DMACmd(LPC_SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState)
    783          {
   \                     SSP_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    784          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SSP_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_DMACmd_0
   \   00000014   0xF44F 0x7144      MOV      R1,#+784
   \   00000018   0x....             LDR.N    R0,??DataTable19_3
   \   0000001A   0x.... 0x....      BL       check_failed
    785          	CHECK_PARAM(PARAM_SSP_DMA(DMAMode));
   \                     ??SSP_DMACmd_0: (+1)
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD006             BEQ.N    ??SSP_DMACmd_1
   \   00000022   0x2D02             CMP      R5,#+2
   \   00000024   0xD004             BEQ.N    ??SSP_DMACmd_1
   \   00000026   0xF240 0x3111      MOVW     R1,#+785
   \   0000002A   0x....             LDR.N    R0,??DataTable19_3
   \   0000002C   0x.... 0x....      BL       check_failed
    786          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_DMACmd_1: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD007             BEQ.N    ??SSP_DMACmd_2
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD004             BEQ.N    ??SSP_DMACmd_2
   \   0000003C   0xF240 0x3112      MOVW     R1,#+786
   \   00000040   0x....             LDR.N    R0,??DataTable19_3
   \   00000042   0x.... 0x....      BL       check_failed
    787          
    788          	if (NewState == ENABLE)
   \                     ??SSP_DMACmd_2: (+1)
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD103             BNE.N    ??SSP_DMACmd_3
    789          	{
    790          		SSPx->DMACR |= DMAMode;
   \   0000004C   0x6A60             LDR      R0,[R4, #+36]
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x6260             STR      R0,[R4, #+36]
   \   00000052   0xE005             B.N      ??SSP_DMACmd_4
    791          	}
    792          	else
    793          	{
    794          		SSPx->DMACR &= (~DMAMode) & SSP_DMA_BITMASK;
   \                     ??SSP_DMACmd_3: (+1)
   \   00000054   0x6A60             LDR      R0,[R4, #+36]
   \   00000056   0x43E9             MVNS     R1,R5
   \   00000058   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x6260             STR      R0,[R4, #+36]
    795          	}
    796          }
   \                     ??SSP_DMACmd_4: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    797          
    798          /**
    799           * @brief		Standard SSP0 Interrupt handler
    800           * @param[in] 	None
    801           * @return		None
    802           */

   \                                 In section .text, align 2, keep-with-next
    803          void SSP0_StdIntHandler(void)
    804          {
   \                     SSP0_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    805          	// Call relevant handler
    806          	sspdat[0].inthandler(LPC_SSP0);
   \   00000002   0x....             LDR.N    R0,??DataTable19  ;; 0x40088000
   \   00000004   0x....             LDR.N    R1,??DataTable19_2
   \   00000006   0x6889             LDR      R1,[R1, #+8]
   \   00000008   0x4788             BLX      R1
    807          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    808          
    809          /**
    810           * @brief		Standard SSP1 Interrupt handler
    811           * @param[in] 	None
    812           * @return		None
    813           */

   \                                 In section .text, align 2, keep-with-next
    814          void SSP1_StdIntHandler(void)
    815          {
   \                     SSP1_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    816          	// Call relevant handler
    817          	sspdat[1].inthandler(LPC_SSP1);
   \   00000002   0x....             LDR.N    R0,??DataTable19_1  ;; 0x40030000
   \   00000004   0x....             LDR.N    R1,??DataTable19_2
   \   00000006   0x6949             LDR      R1,[R1, #+20]
   \   00000008   0x4788             BLX      R1
    818          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40088000         DC32     0x40088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x40030000         DC32     0x40030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     sspdat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     SSP_IntHandler

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x73          DC8 5FH, 73H, 73H, 70H, 2EH, 63H, 0
   \              0x73 0x70    
   \              0x2E 0x63    
   \              0x00         
   \   00000097   0x00               DC8 0
    819          
    820          /**
    821           * @}
    822           */
    823          
    824          #endif /* _SSP */
    825          
    826          /**
    827           * @}
    828           */
    829          
    830          /* --------------------------------- End Of File ------------------------------ */
    831          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SSP0_StdIntHandler
         8   -- Indirect call
       8   SSP1_StdIntHandler
         8   -- Indirect call
      16   SSP_ClearIntPending
        16   -> check_failed
      16   SSP_Cmd
        16   -> check_failed
       0   SSP_ConfigStructInit
      16   SSP_DMACmd
        16   -> check_failed
       8   SSP_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      16   SSP_GetIntStatus
        16   -> check_failed
      16   SSP_GetRawIntStatus
        16   -> check_failed
      16   SSP_GetStatus
        16   -> check_failed
      16   SSP_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> SSP_SetClock
        16   -> SSP_getNum
        16   -> check_failed
      16   SSP_IntConfig
        16   -> check_failed
      24   SSP_IntHandler
        24   -- Indirect call
        24   -> SSP_ReceiveData
        24   -> SSP_SendData
        24   -> SSP_getNum
      16   SSP_LoopBackCmd
        16   -> check_failed
      48   SSP_ReadWrite
        48   -> SSP_ReceiveData
        48   -> SSP_SendData
        48   -> SSP_getNum
       8   SSP_ReceiveData
         8   -> check_failed
      16   SSP_SendData
        16   -> check_failed
      32   SSP_SetClock
        32   -> CLKPWR_GetPCLK
        32   -> check_failed
      16   SSP_SlaveOutputCmd
        16   -> check_failed
       0   SSP_getNum


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
     152  ?_0
      12  SSP0_StdIntHandler
      12  SSP1_StdIntHandler
      50  SSP_ClearIntPending
      84  SSP_Cmd
      28  SSP_ConfigStructInit
      98  SSP_DMACmd
      72  SSP_DeInit
      70  SSP_GetIntStatus
      70  SSP_GetRawIntStatus
      74  SSP_GetStatus
     160  SSP_Init
      84  SSP_IntConfig
     476  SSP_IntHandler
      84  SSP_LoopBackCmd
     808  SSP_ReadWrite
      38  SSP_ReceiveData
      40  SSP_SendData
     146  SSP_SetClock
      84  SSP_SlaveOutputCmd
      32  SSP_getNum
      24  sspdat

 
    24 bytes in section .bss
   152 bytes in section .rodata
 2 546 bytes in section .text
 
 2 546 bytes of CODE  memory
   152 bytes of CONST memory
    24 bytes of DATA  memory

Errors: none
Warnings: none
