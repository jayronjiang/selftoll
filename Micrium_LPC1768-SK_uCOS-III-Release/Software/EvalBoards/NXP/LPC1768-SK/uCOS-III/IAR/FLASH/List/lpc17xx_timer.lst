###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_timer.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_timer.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_timer.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_timer.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_timer.c
      1          /**
      2           * @file	: lpc17xx_timer.c
      3           * @brief	: Contains all functions support for Timer firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 14. April. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup TIM
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_timer.h"
     27          #include "lpc17xx_clkpwr.h"
     28          #include "lpc17xx_pinsel.h"
     29          
     30          /* If this source file built with example, the LPC17xx FW library configuration
     31           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     32           * otherwise the default FW library configuration file must be included instead
     33           */
     34          #ifdef __BUILD_WITH_EXAMPLE__
     35          #include "lpc17xx_libcfg.h"
     36          #else
     37          #include "lpc17xx_libcfg_default.h"
     38          #endif /* __BUILD_WITH_EXAMPLE__ */
     39          
     40          #ifdef _TIM
     41          
     42          /* Private Functions ---------------------------------------------------------- */
     43          /** @defgroup TIM_Private_Functions
     44           * @{
     45           */
     46          
     47          uint32_t TIM_GetPClock (uint32_t timernum);
     48          uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec);
     49          uint32_t TIM_ConverPtrToTimeNum (LPC_TIM_TypeDef *TIMx);
     50          
     51          
     52          /*********************************************************************//**
     53           * @brief 		Get peripheral clock of each timer controller
     54           * @param[in]	timernum Timer number
     55           * @return 		Peripheral clock of timer
     56           **********************************************************************/
     57          

   \                                 In section .text, align 2, keep-with-next
     58          uint32_t TIM_GetPClock (uint32_t timernum)
     59          {
   \                     TIM_GetPClock: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     60          	uint32_t clkdlycnt;
     61          	switch (timernum)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ.N    ??TIM_GetPClock_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD00D             BEQ.N    ??TIM_GetPClock_1
   \   0000000C   0xD307             BCC.N    ??TIM_GetPClock_2
   \   0000000E   0x2C03             CMP      R4,#+3
   \   00000010   0xD00F             BEQ.N    ??TIM_GetPClock_3
   \   00000012   0xE012             B.N      ??TIM_GetPClock_4
     62          	{
     63          	case 0:
     64          		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER0);
   \                     ??TIM_GetPClock_0: (+1)
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000001A   0x0005             MOVS     R5,R0
     65          		break;
   \   0000001C   0xE00D             B.N      ??TIM_GetPClock_4
     66          
     67          	case 1:
     68          		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER1);
   \                     ??TIM_GetPClock_2: (+1)
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000024   0x0005             MOVS     R5,R0
     69          		break;
   \   00000026   0xE008             B.N      ??TIM_GetPClock_4
     70          
     71          	case 2:
     72          		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER2);
   \                     ??TIM_GetPClock_1: (+1)
   \   00000028   0x202C             MOVS     R0,#+44
   \   0000002A   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000002E   0x0005             MOVS     R5,R0
     73          		break;
   \   00000030   0xE003             B.N      ??TIM_GetPClock_4
     74          
     75          	case 3:
     76          		clkdlycnt = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_TIMER3);
   \                     ??TIM_GetPClock_3: (+1)
   \   00000032   0x202E             MOVS     R0,#+46
   \   00000034   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000038   0x0005             MOVS     R5,R0
     77          		break;
     78          	}
     79          	return clkdlycnt;
   \                     ??TIM_GetPClock_4: (+1)
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     80          }
     81          
     82          
     83          /*********************************************************************//**
     84           * @brief 		Convert a time to a timer count value
     85           * @param[in]	timernum Timer number
     86           * @param[in]	usec Time in microseconds
     87           * @return 		The number of required clock ticks to give the time delay
     88           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          uint32_t TIM_ConverUSecToVal (uint32_t timernum, uint32_t usec)
     90          {
   \                     TIM_ConverUSecToVal: (+1)
   \   00000000   0xE92D 0x4370      PUSH     {R4-R6,R8,R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x4688             MOV      R8,R1
     91          	uint64_t clkdlycnt;
     92          
     93          	// Get Pclock of timer
     94          	clkdlycnt = (uint64_t) TIM_GetPClock (timernum);
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x.... 0x....      BL       TIM_GetPClock
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0004             MOVS     R4,R0
   \   00000012   0x000D             MOVS     R5,R1
     95          
     96          	clkdlycnt = (clkdlycnt * usec) / 1000000;
   \   00000014   0xF05F 0x0900      MOVS     R9,#+0
   \   00000018   0xFBA8 0x0104      UMULL    R0,R1,R8,R4
   \   0000001C   0xFB08 0x1105      MLA      R1,R8,R5,R1
   \   00000020   0xFB09 0x1104      MLA      R1,R9,R4,R1
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable12  ;; 0xf4240
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000002E   0x0004             MOVS     R4,R0
   \   00000030   0x000D             MOVS     R5,R1
     97          	return (uint32_t) clkdlycnt;
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xE8BD 0x8370      POP      {R4-R6,R8,R9,PC}  ;; return
     98          }
     99          
    100          
    101          /*********************************************************************//**
    102           * @brief 		Convert a timer register pointer to a timer number
    103           * @param[in]	TIMx Pointer to a timer register set
    104           * @return 		The timer number (0 to 3) or -1 if register pointer is bad
    105           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          uint32_t TIM_ConverPtrToTimeNum (LPC_TIM_TypeDef *TIMx)
    107          {
   \                     TIM_ConverPtrToTimeNum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    108          	uint32_t tnum = -1;
   \   00000002   0xF05F 0x30FF      MOVS     R0,#-1
    109          
    110          	if (TIMx == LPC_TIM0)
   \   00000006   0xF1B1 0x2F40      CMP      R1,#+1073758208
   \   0000000A   0xD102             BNE.N    ??TIM_ConverPtrToTimeNum_0
    111          	{
    112          		tnum = 0;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xE013             B.N      ??TIM_ConverPtrToTimeNum_1
    113          	}
    114          	else if (TIMx == LPC_TIM1)
   \                     ??TIM_ConverPtrToTimeNum_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable12_1  ;; 0x40008000
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD102             BNE.N    ??TIM_ConverPtrToTimeNum_2
    115          	{
    116          		tnum = 1;
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0xE00C             B.N      ??TIM_ConverPtrToTimeNum_1
    117          	}
    118          	else if (TIMx == LPC_TIM2)
   \                     ??TIM_ConverPtrToTimeNum_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable12_2  ;; 0x40090000
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD102             BNE.N    ??TIM_ConverPtrToTimeNum_3
    119          	{
    120          		tnum = 2;
   \   00000028   0x2202             MOVS     R2,#+2
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xE005             B.N      ??TIM_ConverPtrToTimeNum_1
    121          	}
    122          	else if (TIMx == LPC_TIM3)
   \                     ??TIM_ConverPtrToTimeNum_3: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable12_3  ;; 0x40094000
   \   00000032   0x4291             CMP      R1,R2
   \   00000034   0xD101             BNE.N    ??TIM_ConverPtrToTimeNum_1
    123          	{
    124          		tnum = 3;
   \   00000036   0x2203             MOVS     R2,#+3
   \   00000038   0x0010             MOVS     R0,R2
    125          	}
    126          
    127          	return tnum;
   \                     ??TIM_ConverPtrToTimeNum_1: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
    128          }
    129          
    130          /**
    131           * @}
    132           */
    133          
    134          
    135          /* Public Functions ----------------------------------------------------------- */
    136          /** @addtogroup TIM_Public_Functions
    137           * @{
    138           */
    139          
    140          /*********************************************************************//**
    141           * @brief 		Get Interrupt Status
    142           * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
    143           * @param[in]	IntFlag
    144           * @return 		FlagStatus
    145           * 				- SET : interrupt
    146           * 				- RESET : no interrupt
    147           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          FlagStatus TIM_GetIntStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
    149          {
   \                     TIM_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    150          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD010             BEQ.N    ??TIM_GetIntStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00C             BEQ.N    ??TIM_GetIntStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??TIM_GetIntStatus_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40094000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD004             BEQ.N    ??TIM_GetIntStatus_0
   \   00000024   0x2196             MOVS     R1,#+150
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   0000002A   0x.... 0x....      BL       check_failed
    151          	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
   \                     ??TIM_GetIntStatus_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD013             BEQ.N    ??TIM_GetIntStatus_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD010             BEQ.N    ??TIM_GetIntStatus_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD00D             BEQ.N    ??TIM_GetIntStatus_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD00A             BEQ.N    ??TIM_GetIntStatus_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D04             CMP      R5,#+4
   \   0000004A   0xD007             BEQ.N    ??TIM_GetIntStatus_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D05             CMP      R5,#+5
   \   00000050   0xD004             BEQ.N    ??TIM_GetIntStatus_1
   \   00000052   0x2197             MOVS     R1,#+151
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000058   0x.... 0x....      BL       check_failed
    152          	uint8_t temp = (TIMx->IR)& TIM_IR_CLR(IntFlag);
   \                     ??TIM_GetIntStatus_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x40A9             LSLS     R1,R1,R5
   \   00000062   0x4001             ANDS     R1,R1,R0
    153          	if (temp)
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0xD001             BEQ.N    ??TIM_GetIntStatus_2
    154          		return SET;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE000             B.N      ??TIM_GetIntStatus_3
    155          
    156          	return RESET;
   \                     ??TIM_GetIntStatus_2: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??TIM_GetIntStatus_3: (+1)
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    157          
    158          }
    159          /*********************************************************************//**
    160           * @brief 		Get Capture Interrupt Status
    161           * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
    162           * @param[in]	IntFlag
    163           * @return 		FlagStatus
    164           * 				- SET : interrupt
    165           * 				- RESET : no interrupt
    166           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          FlagStatus TIM_GetIntCaptureStatus(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
    168          {
   \                     TIM_GetIntCaptureStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    169          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD010             BEQ.N    ??TIM_GetIntCaptureStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00C             BEQ.N    ??TIM_GetIntCaptureStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??TIM_GetIntCaptureStatus_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40094000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD004             BEQ.N    ??TIM_GetIntCaptureStatus_0
   \   00000024   0x21A9             MOVS     R1,#+169
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   0000002A   0x.... 0x....      BL       check_failed
    170          	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
   \                     ??TIM_GetIntCaptureStatus_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD013             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD010             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD00D             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD00A             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D04             CMP      R5,#+4
   \   0000004A   0xD007             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D05             CMP      R5,#+5
   \   00000050   0xD004             BEQ.N    ??TIM_GetIntCaptureStatus_1
   \   00000052   0x21AA             MOVS     R1,#+170
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000058   0x.... 0x....      BL       check_failed
    171          	uint8_t temp = (TIMx->IR) & (1<<(4+IntFlag));
   \                     ??TIM_GetIntCaptureStatus_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x1D2A             ADDS     R2,R5,#+4
   \   00000062   0x4091             LSLS     R1,R1,R2
   \   00000064   0x4001             ANDS     R1,R1,R0
    172          	if(temp)
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0xD001             BEQ.N    ??TIM_GetIntCaptureStatus_2
    173          		return SET;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE000             B.N      ??TIM_GetIntCaptureStatus_3
    174          	return RESET;
   \                     ??TIM_GetIntCaptureStatus_2: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??TIM_GetIntCaptureStatus_3: (+1)
   \   00000072   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    175          }
    176          /*********************************************************************//**
    177           * @brief 		Clear Interrupt pending
    178           * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
    179           * @param[in]	IntFlag should be in TIM_INT_TYPE enum
    180           * @return 		None
    181           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          void TIM_ClearIntPending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
    183          {
   \                     TIM_ClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD010             BEQ.N    ??TIM_ClearIntPending_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00C             BEQ.N    ??TIM_ClearIntPending_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??TIM_ClearIntPending_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40094000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD004             BEQ.N    ??TIM_ClearIntPending_0
   \   00000024   0x21B8             MOVS     R1,#+184
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   0000002A   0x.... 0x....      BL       check_failed
    185          	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
   \                     ??TIM_ClearIntPending_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD013             BEQ.N    ??TIM_ClearIntPending_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD010             BEQ.N    ??TIM_ClearIntPending_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD00D             BEQ.N    ??TIM_ClearIntPending_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD00A             BEQ.N    ??TIM_ClearIntPending_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D04             CMP      R5,#+4
   \   0000004A   0xD007             BEQ.N    ??TIM_ClearIntPending_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D05             CMP      R5,#+5
   \   00000050   0xD004             BEQ.N    ??TIM_ClearIntPending_1
   \   00000052   0x21B9             MOVS     R1,#+185
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000058   0x.... 0x....      BL       check_failed
    186          	TIMx->IR |= TIM_IR_CLR(IntFlag);
   \                     ??TIM_ClearIntPending_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x40A9             LSLS     R1,R1,R5
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x6020             STR      R0,[R4, #+0]
    187          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    188          
    189          /*********************************************************************//**
    190           * @brief 		Clear Capture Interrupt pending
    191           * @param[in]	TIMx Timer selection, should be TIM0, TIM1, TIM2, TIM3
    192           * @param[in]	IntFlag should be in TIM_INT_TYPE enum
    193           * @return 		None
    194           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    195          void TIM_ClearIntCapturePending(LPC_TIM_TypeDef *TIMx, uint8_t IntFlag)
    196          {
   \                     TIM_ClearIntCapturePending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    197          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD010             BEQ.N    ??TIM_ClearIntCapturePending_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00C             BEQ.N    ??TIM_ClearIntCapturePending_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??TIM_ClearIntCapturePending_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40094000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD004             BEQ.N    ??TIM_ClearIntCapturePending_0
   \   00000024   0x21C5             MOVS     R1,#+197
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   0000002A   0x.... 0x....      BL       check_failed
    198          	CHECK_PARAM(PARAM_TIM_INT_TYPE(IntFlag));
   \                     ??TIM_ClearIntCapturePending_0: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD013             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD010             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D02             CMP      R5,#+2
   \   0000003E   0xD00D             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D03             CMP      R5,#+3
   \   00000044   0xD00A             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D04             CMP      R5,#+4
   \   0000004A   0xD007             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D05             CMP      R5,#+5
   \   00000050   0xD004             BEQ.N    ??TIM_ClearIntCapturePending_1
   \   00000052   0x21C6             MOVS     R1,#+198
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000058   0x.... 0x....      BL       check_failed
    199          	TIMx->IR |= (1<<(4+IntFlag));
   \                     ??TIM_ClearIntCapturePending_1: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x1D2A             ADDS     R2,R5,#+4
   \   00000062   0x4091             LSLS     R1,R1,R2
   \   00000064   0x4308             ORRS     R0,R1,R0
   \   00000066   0x6020             STR      R0,[R4, #+0]
    200          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    201          
    202          /*********************************************************************//**
    203          * @brief 		Configuration for Timer at initial time
    204          * @param[in] 	TimerCounterMode Should be :
    205          * 					- PrescaleOption = TC_PRESCALE_USVAL,
    206          * 					- PrescaleValue = 1
    207          * 				Counter mode with
    208          * 					- Caption channel 0
    209          * @param[in] 	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type or
    210          * 				TIM_COUNTERCFG_Type
    211          * @return 		None
    212           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          void TIM_ConfigStructInit(uint8_t TimerCounterMode, void *TIM_ConfigStruct)
    214          {
    215          	if (TimerCounterMode == TIM_TIMER_MODE )
   \                     TIM_ConfigStructInit: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD104             BNE.N    ??TIM_ConfigStructInit_0
    216          	{
    217          		TIM_TIMERCFG_Type * pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
    218          		pTimeCfg->PrescaleOption = TIM_PRESCALE_USVAL;
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x700A             STRB     R2,[R1, #+0]
    219          		pTimeCfg->PrescaleValue = 1;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   \   0000000E   0xE001             B.N      ??TIM_ConfigStructInit_1
    220          	}
    221          	else
    222          	{
    223          		TIM_COUNTERCFG_Type * pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
    224          		pCounterCfg->CountInputSelect = TIM_COUNTER_INCAP0;
   \                     ??TIM_ConfigStructInit_0: (+1)
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x704A             STRB     R2,[R1, #+1]
    225          
    226          	}
    227          }
   \                     ??TIM_ConfigStructInit_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    228          
    229          /*********************************************************************//**
    230           * @brief 		Initial Timer/Counter device
    231           * 				 	Set Clock frequency for Timer
    232           * 					Set initial configuration for Timer
    233           * @param[in]	TIMx  Timer selection, should be TIM0, TIM1, TIM2, TIM3
    234           * @param[in]	TimerCounterMode TIM_MODE_OPT
    235           * @param[in]	TIM_ConfigStruct pointer to TIM_TIMERCFG_Type
    236           * 				that contains the configuration information for the
    237           *                    specified Timer peripheral.
    238           * @return 		None
    239           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    240          void TIM_Init(LPC_TIM_TypeDef *TIMx, uint8_t TimerCounterMode, void *TIM_ConfigStruct)
    241          {
   \                     TIM_Init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    242          	TIM_TIMERCFG_Type *pTimeCfg;
    243          	TIM_COUNTERCFG_Type *pCounterCfg;
    244          	uint32_t timer;
    245          
    246          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   0000000A   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000E   0xD010             BEQ.N    ??TIM_Init_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00C             BEQ.N    ??TIM_Init_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD008             BEQ.N    ??TIM_Init_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40094000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD004             BEQ.N    ??TIM_Init_0
   \   00000028   0x21F6             MOVS     R1,#+246
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   0000002E   0x.... 0x....      BL       check_failed
    247          	CHECK_PARAM(PARAM_TIM_MODE_OPT(TimerCounterMode));
   \                     ??TIM_Init_0: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00D             BEQ.N    ??TIM_Init_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD00A             BEQ.N    ??TIM_Init_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D01             CMP      R5,#+1
   \   00000042   0xD007             BEQ.N    ??TIM_Init_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD004             BEQ.N    ??TIM_Init_1
   \   0000004A   0x21F7             MOVS     R1,#+247
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   00000050   0x.... 0x....      BL       check_failed
    248          
    249          	timer = TIM_ConverPtrToTimeNum(TIMx) ;
   \                     ??TIM_Init_1: (+1)
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       TIM_ConverPtrToTimeNum
   \   0000005A   0x4681             MOV      R9,R0
    250          	//set power
    251          	if (TIMx== LPC_TIM0)
   \   0000005C   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000060   0xD108             BNE.N    ??TIM_Init_2
    252          	{
    253          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, ENABLE);
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    254          		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER0, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   00000072   0xE026             B.N      ??TIM_Init_3
    255          	}
    256          	else if (TIMx== LPC_TIM1)
   \                     ??TIM_Init_2: (+1)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40008000
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD108             BNE.N    ??TIM_Init_4
    257          	{
    258          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, ENABLE);
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x2004             MOVS     R0,#+4
   \   00000080   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    259          		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER1, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   0000008C   0xE019             B.N      ??TIM_Init_3
    260          
    261          	}
    262          
    263          	else if (TIMx== LPC_TIM2)
   \                     ??TIM_Init_4: (+1)
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40090000
   \   00000092   0x4284             CMP      R4,R0
   \   00000094   0xD109             BNE.N    ??TIM_Init_5
    264          	{
    265          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, ENABLE);
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000009C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    266          		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER2, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x202C             MOVS     R0,#+44
   \   000000A4   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   000000A8   0xE00B             B.N      ??TIM_Init_3
    267          	}
    268          	else if (TIMx== LPC_TIM3)
   \                     ??TIM_Init_5: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   000000AC   0x4284             CMP      R4,R0
   \   000000AE   0xD108             BNE.N    ??TIM_Init_3
    269          	{
    270          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM3, ENABLE);
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000B6   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    271          		CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_TIMER3, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x202E             MOVS     R0,#+46
   \   000000BE   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
    272          
    273          	}
    274          
    275          	TIMx->CCR &= ~TIM_CTCR_MODE_MASK;
   \                     ??TIM_Init_3: (+1)
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0x0880             LSRS     R0,R0,#+2
   \   000000C6   0x0080             LSLS     R0,R0,#+2
   \   000000C8   0x62A0             STR      R0,[R4, #+40]
    276          	TIMx->CCR |= TIM_TIMER_MODE;
   \   000000CA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000CC   0x62A0             STR      R0,[R4, #+40]
    277          
    278          	TIMx->TC =0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x60A0             STR      R0,[R4, #+8]
    279          	TIMx->PC =0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x6120             STR      R0,[R4, #+16]
    280          	TIMx->PR =0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x60E0             STR      R0,[R4, #+12]
    281          	if (TimerCounterMode == TIM_TIMER_MODE )
   \   000000DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DC   0x2D00             CMP      R5,#+0
   \   000000DE   0xD110             BNE.N    ??TIM_Init_6
    282          	{
    283          		pTimeCfg = (TIM_TIMERCFG_Type *)TIM_ConfigStruct;
   \   000000E0   0x0037             MOVS     R7,R6
    284          		if (pTimeCfg->PrescaleOption  == TIM_PRESCALE_TICKVAL)
   \   000000E2   0x7838             LDRB     R0,[R7, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD103             BNE.N    ??TIM_Init_7
    285          		{
    286          			TIMx->PR   = pTimeCfg->PrescaleValue -1  ;
   \   000000E8   0x6878             LDR      R0,[R7, #+4]
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   \   000000EC   0x60E0             STR      R0,[R4, #+12]
   \   000000EE   0xE015             B.N      ??TIM_Init_8
    287          		}
    288          		else
    289          		{
    290          			TIMx->PR   = TIM_ConverUSecToVal (TIM_ConverPtrToTimeNum(TIMx),pTimeCfg->PrescaleValue)-1;
   \                     ??TIM_Init_7: (+1)
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x.... 0x....      BL       TIM_ConverPtrToTimeNum
   \   000000F6   0x6879             LDR      R1,[R7, #+4]
   \   000000F8   0x.... 0x....      BL       TIM_ConverUSecToVal
   \   000000FC   0x1E40             SUBS     R0,R0,#+1
   \   000000FE   0x60E0             STR      R0,[R4, #+12]
   \   00000100   0xE00C             B.N      ??TIM_Init_8
    291          		}
    292          	}
    293          	else
    294          	{
    295          
    296          		pCounterCfg = (TIM_COUNTERCFG_Type *)TIM_ConfigStruct;
   \                     ??TIM_Init_6: (+1)
   \   00000102   0x46B0             MOV      R8,R6
    297          		TIMx->CCR  &= ~TIM_CTCR_INPUT_MASK;
   \   00000104   0x6AA0             LDR      R0,[R4, #+40]
   \   00000106   0xF030 0x000C      BICS     R0,R0,#0xC
   \   0000010A   0x62A0             STR      R0,[R4, #+40]
    298          		if (pCounterCfg->CountInputSelect == TIM_COUNTER_INCAP1)
   \   0000010C   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   00000110   0x2801             CMP      R0,#+1
   \   00000112   0xD103             BNE.N    ??TIM_Init_8
    299          			TIMx->CCR |= _BIT(2);
   \   00000114   0x6AA0             LDR      R0,[R4, #+40]
   \   00000116   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000011A   0x62A0             STR      R0,[R4, #+40]
    300          	}
    301          
    302          	// Clear interrupt pending
    303          	TIMx->IR = 0xFFFFFFFF;
   \                     ??TIM_Init_8: (+1)
   \   0000011C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000120   0x6020             STR      R0,[R4, #+0]
    304          
    305          }
   \   00000122   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    306          
    307          /*********************************************************************//**
    308           * @brief 		Close Timer/Counter device
    309           * @param[in]	TIMx  Pointer to timer device
    310           * @return 		None
    311           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          void TIM_DeInit (LPC_TIM_TypeDef *TIMx)
    313          {
   \                     TIM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    314          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000004   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000008   0xD00D             BEQ.N    ??TIM_DeInit_0
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??TIM_DeInit_0
   \   00000010   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??TIM_DeInit_0
   \   00000016   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??TIM_DeInit_0
   \   0000001C   0xF44F 0x719D      MOV      R1,#+314
   \   00000020   0x....             LDR.N    R0,??DataTable12_4
   \   00000022   0x.... 0x....      BL       check_failed
    315          	// Disable timer/counter
    316          	TIMx->TCR = 0x00;
   \                     ??TIM_DeInit_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x6060             STR      R0,[R4, #+4]
    317          
    318          	// Disable power
    319          	if (TIMx== LPC_TIM0)
   \   0000002A   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000002E   0xD104             BNE.N    ??TIM_DeInit_1
    320          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM0, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000038   0xE018             B.N      ??TIM_DeInit_2
    321          
    322          	else if (TIMx== LPC_TIM1)
   \                     ??TIM_DeInit_1: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD104             BNE.N    ??TIM_DeInit_3
    323          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM1, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000048   0xE010             B.N      ??TIM_DeInit_2
    324          
    325          	else if (TIMx== LPC_TIM2)
   \                     ??TIM_DeInit_3: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD105             BNE.N    ??TIM_DeInit_4
    326          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000056   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   0000005A   0xE007             B.N      ??TIM_DeInit_2
    327          
    328          	else if (TIMx== LPC_TIM3)
   \                     ??TIM_DeInit_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD104             BNE.N    ??TIM_DeInit_2
    329          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCTIM2, DISABLE);
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000068   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    330          
    331          }
   \                     ??TIM_DeInit_2: (+1)
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    332          
    333          /*********************************************************************//**
    334           * @brief	 	Start/Stop Timer/Counter device
    335           * @param[in]	TIMx Pointer to timer device
    336           * @param[in]	NewState
    337           * 				-	ENABLE  : set timer enable
    338           * 				-	DISABLE : disable timer
    339           * @return 		None
    340           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    341          void TIM_Cmd(LPC_TIM_TypeDef *TIMx, FunctionalState NewState)
    342          {
   \                     TIM_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    343          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD00D             BEQ.N    ??TIM_Cmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_Cmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_Cmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_Cmd_0
   \   0000001E   0xF240 0x1157      MOVW     R1,#+343
   \   00000022   0x....             LDR.N    R0,??DataTable12_4
   \   00000024   0x.... 0x....      BL       check_failed
    344          	if (NewState == ENABLE)
   \                     ??TIM_Cmd_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD104             BNE.N    ??TIM_Cmd_1
    345          	{
    346          		TIMx->TCR	|=  TIM_ENABLE;
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000034   0x6060             STR      R0,[R4, #+4]
   \   00000036   0xE003             B.N      ??TIM_Cmd_2
    347          	}
    348          	else
    349          	{
    350          		TIMx->TCR &= ~TIM_ENABLE;
   \                     ??TIM_Cmd_1: (+1)
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0x0840             LSRS     R0,R0,#+1
   \   0000003C   0x0040             LSLS     R0,R0,#+1
   \   0000003E   0x6060             STR      R0,[R4, #+4]
    351          	}
    352          }
   \                     ??TIM_Cmd_2: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    353          
    354          /*********************************************************************//**
    355           * @brief 		Reset Timer/Counter device,
    356           * 					Make TC and PC are synchronously reset on the next
    357           * 					positive edge of PCLK
    358           * @param[in]	TIMx Pointer to timer device
    359           * @return 		None
    360           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    361          void TIM_ResetCounter(LPC_TIM_TypeDef *TIMx)
    362          {
   \                     TIM_ResetCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    363          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000004   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000008   0xD00D             BEQ.N    ??TIM_ResetCounter_0
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00A             BEQ.N    ??TIM_ResetCounter_0
   \   00000010   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD007             BEQ.N    ??TIM_ResetCounter_0
   \   00000016   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??TIM_ResetCounter_0
   \   0000001C   0xF240 0x116B      MOVW     R1,#+363
   \   00000020   0x....             LDR.N    R0,??DataTable12_4
   \   00000022   0x.... 0x....      BL       check_failed
    364          	TIMx->TCR |= TIM_RESET;
   \                     ??TIM_ResetCounter_0: (+1)
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    365          	TIMx->TCR &= ~TIM_RESET;
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000034   0x6060             STR      R0,[R4, #+4]
    366          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    367          
    368          /*********************************************************************//**
    369           * @brief 		Configuration for Match register
    370           * @param[in]	TIMx Pointer to timer device
    371           * @param[in]   TIM_MatchConfigStruct Pointer to TIM_MATCHCFG_Type
    372           * 					- MatchChannel : choose channel 0 or 1
    373           * 					- IntOnMatch	 : if SET, interrupt will be generated when MRxx match
    374           * 									the value in TC
    375           * 					- StopOnMatch	 : if SET, TC and PC will be stopped whenM Rxx match
    376           * 									the value in TC
    377           * 					- ResetOnMatch : if SET, Reset on MR0 when MRxx match
    378           * 									the value in TC
    379           * 					-ExtMatchOutputType: Select output for external match
    380           * 						 +	 0:	Do nothing for external output pin if match
    381           *						 +   1:	Force external output pin to low if match
    382           *						 + 	 2: Force external output pin to high if match
    383           *						 + 	 3: Toggle external output pin if match
    384           *					MatchValue: Set the value to be compared with TC value
    385           * @return 		None
    386           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    387          void TIM_ConfigMatch(LPC_TIM_TypeDef *TIMx, TIM_MATCHCFG_Type *TIM_MatchConfigStruct)
    388          {
   \                     TIM_ConfigMatch: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    389          	uint32_t timer;
    390          
    391          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD00D             BEQ.N    ??TIM_ConfigMatch_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_ConfigMatch_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_ConfigMatch_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_ConfigMatch_0
   \   0000001E   0xF240 0x1187      MOVW     R1,#+391
   \   00000022   0x....             LDR.N    R0,??DataTable12_4
   \   00000024   0x.... 0x....      BL       check_failed
    392          	CHECK_PARAM(PARAM_TIM_EXTMATCH_OPT(TIM_MatchConfigStruct->ExtMatchOutputType));
   \                     ??TIM_ConfigMatch_0: (+1)
   \   00000028   0x7928             LDRB     R0,[R5, #+4]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??TIM_ConfigMatch_1
   \   0000002E   0x7928             LDRB     R0,[R5, #+4]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD00A             BEQ.N    ??TIM_ConfigMatch_1
   \   00000034   0x7928             LDRB     R0,[R5, #+4]
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD007             BEQ.N    ??TIM_ConfigMatch_1
   \   0000003A   0x7928             LDRB     R0,[R5, #+4]
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD004             BEQ.N    ??TIM_ConfigMatch_1
   \   00000040   0xF44F 0x71C4      MOV      R1,#+392
   \   00000044   0x....             LDR.N    R0,??DataTable12_4
   \   00000046   0x.... 0x....      BL       check_failed
    393          
    394          	timer = TIM_ConverPtrToTimeNum(TIMx) ;
   \                     ??TIM_ConfigMatch_1: (+1)
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       TIM_ConverPtrToTimeNum
   \   00000050   0x0006             MOVS     R6,R0
    395          	switch(TIM_MatchConfigStruct->MatchChannel)
   \   00000052   0x7828             LDRB     R0,[R5, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD002             BEQ.N    ??TIM_ConfigMatch_2
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD003             BEQ.N    ??TIM_ConfigMatch_3
   \   0000005C   0xE004             B.N      ??TIM_ConfigMatch_4
    396          	{
    397          	case 0:
    398          		TIMx->MR0 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_2: (+1)
   \   0000005E   0x68A8             LDR      R0,[R5, #+8]
   \   00000060   0x61A0             STR      R0,[R4, #+24]
    399          		break;
   \   00000062   0xE001             B.N      ??TIM_ConfigMatch_4
    400          	case 1:
    401          		TIMx->MR1 = TIM_MatchConfigStruct->MatchValue;
   \                     ??TIM_ConfigMatch_3: (+1)
   \   00000064   0x68A8             LDR      R0,[R5, #+8]
   \   00000066   0x61E0             STR      R0,[R4, #+28]
    402          		break;
    403          	}
    404          	//interrupt on MRn
    405          	TIMx->MCR &=~TIM_MCR_CHANNEL_MASKBIT(TIM_MatchConfigStruct->MatchChannel);
   \                     ??TIM_ConfigMatch_4: (+1)
   \   00000068   0x6960             LDR      R0,[R4, #+20]
   \   0000006A   0x2107             MOVS     R1,#+7
   \   0000006C   0xF995 0x2000      LDRSB    R2,[R5, #+0]
   \   00000070   0x4091             LSLS     R1,R1,R2
   \   00000072   0x4388             BICS     R0,R0,R1
   \   00000074   0x6160             STR      R0,[R4, #+20]
    406          
    407          	if (TIM_MatchConfigStruct->IntOnMatch)
   \   00000076   0x7868             LDRB     R0,[R5, #+1]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD007             BEQ.N    ??TIM_ConfigMatch_5
    408          		TIMx->MCR |= TIM_INT_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   0000007C   0x6960             LDR      R0,[R4, #+20]
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x782A             LDRB     R2,[R5, #+0]
   \   00000082   0x2303             MOVS     R3,#+3
   \   00000084   0x435A             MULS     R2,R3,R2
   \   00000086   0x4091             LSLS     R1,R1,R2
   \   00000088   0x4308             ORRS     R0,R1,R0
   \   0000008A   0x6160             STR      R0,[R4, #+20]
    409          
    410          	//reset on MRn
    411          	if (TIM_MatchConfigStruct->ResetOnMatch)
   \                     ??TIM_ConfigMatch_5: (+1)
   \   0000008C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD008             BEQ.N    ??TIM_ConfigMatch_6
    412          		TIMx->MCR |= TIM_RESET_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   00000092   0x6960             LDR      R0,[R4, #+20]
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0x782A             LDRB     R2,[R5, #+0]
   \   00000098   0x2303             MOVS     R3,#+3
   \   0000009A   0x435A             MULS     R2,R3,R2
   \   0000009C   0x1C52             ADDS     R2,R2,#+1
   \   0000009E   0x4091             LSLS     R1,R1,R2
   \   000000A0   0x4308             ORRS     R0,R1,R0
   \   000000A2   0x6160             STR      R0,[R4, #+20]
    413          
    414          	//stop on MRn
    415          	if (TIM_MatchConfigStruct->StopOnMatch)
   \                     ??TIM_ConfigMatch_6: (+1)
   \   000000A4   0x78A8             LDRB     R0,[R5, #+2]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD008             BEQ.N    ??TIM_ConfigMatch_7
    416          		TIMx->MCR |= TIM_STOP_ON_MATCH(TIM_MatchConfigStruct->MatchChannel);
   \   000000AA   0x6960             LDR      R0,[R4, #+20]
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x782A             LDRB     R2,[R5, #+0]
   \   000000B0   0x2303             MOVS     R3,#+3
   \   000000B2   0x435A             MULS     R2,R3,R2
   \   000000B4   0x1C92             ADDS     R2,R2,#+2
   \   000000B6   0x4091             LSLS     R1,R1,R2
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x6160             STR      R0,[R4, #+20]
    417          //	TIMx->MCR = 0x02;
    418          
    419          	// match output type
    420          
    421          	TIMx->EMR 	&= ~TIM_EM_MASK(TIM_MatchConfigStruct->MatchChannel);
   \                     ??TIM_ConfigMatch_7: (+1)
   \   000000BC   0x6BE0             LDR      R0,[R4, #+60]
   \   000000BE   0x2103             MOVS     R1,#+3
   \   000000C0   0x782A             LDRB     R2,[R5, #+0]
   \   000000C2   0x0052             LSLS     R2,R2,#+1
   \   000000C4   0x1D12             ADDS     R2,R2,#+4
   \   000000C6   0x4091             LSLS     R1,R1,R2
   \   000000C8   0x4388             BICS     R0,R0,R1
   \   000000CA   0x63E0             STR      R0,[R4, #+60]
    422          	TIMx->EMR    = TIM_EM_SET(TIM_MatchConfigStruct->MatchChannel,TIM_MatchConfigStruct->ExtMatchOutputType);
   \   000000CC   0x7928             LDRB     R0,[R5, #+4]
   \   000000CE   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   000000D2   0x7829             LDRB     R1,[R5, #+0]
   \   000000D4   0x0049             LSLS     R1,R1,#+1
   \   000000D6   0x1D09             ADDS     R1,R1,#+4
   \   000000D8   0x4088             LSLS     R0,R0,R1
   \   000000DA   0x63E0             STR      R0,[R4, #+60]
    423          }
   \   000000DC   0xBD70             POP      {R4-R6,PC}       ;; return
    424          /*********************************************************************//**
    425           * @brief 		Configuration for Capture register
    426           * @param[in]	TIMx Pointer to timer device
    427           * 					- CaptureChannel: set the channel to capture data
    428           * 					- RisingEdge    : if SET, Capture at rising edge
    429           * 					- FallingEdge	: if SET, Capture at falling edge
    430           * 					- IntOnCaption  : if SET, Capture generate interrupt
    431           * @param[in]   TIM_CaptureConfigStruct	Pointer to TIM_CAPTURECFG_Type
    432           * @return 		None
    433           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    434          void TIM_ConfigCapture(LPC_TIM_TypeDef *TIMx, TIM_CAPTURECFG_Type *TIM_CaptureConfigStruct)
    435          {
   \                     TIM_ConfigCapture: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    436          	uint32_t timer;
    437          
    438          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD00D             BEQ.N    ??TIM_ConfigCapture_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_ConfigCapture_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_ConfigCapture_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_ConfigCapture_0
   \   0000001E   0xF44F 0x71DB      MOV      R1,#+438
   \   00000022   0x....             LDR.N    R0,??DataTable12_4
   \   00000024   0x.... 0x....      BL       check_failed
    439          	timer = TIM_ConverPtrToTimeNum(TIMx) ;
   \                     ??TIM_ConfigCapture_0: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       TIM_ConverPtrToTimeNum
   \   0000002E   0x0006             MOVS     R6,R0
    440          	TIMx->CCR &= ~TIM_CCR_CHANNEL_MASKBIT(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000030   0x6AA0             LDR      R0,[R4, #+40]
   \   00000032   0x2107             MOVS     R1,#+7
   \   00000034   0xF995 0x2000      LDRSB    R2,[R5, #+0]
   \   00000038   0x4091             LSLS     R1,R1,R2
   \   0000003A   0x4388             BICS     R0,R0,R1
   \   0000003C   0x62A0             STR      R0,[R4, #+40]
    441          
    442          	if (TIM_CaptureConfigStruct->RisingEdge)
   \   0000003E   0x7868             LDRB     R0,[R5, #+1]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD007             BEQ.N    ??TIM_ConfigCapture_1
    443          		TIMx->CCR |= TIM_CAP_RISING(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000044   0x6AA0             LDR      R0,[R4, #+40]
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x782A             LDRB     R2,[R5, #+0]
   \   0000004A   0x2303             MOVS     R3,#+3
   \   0000004C   0x435A             MULS     R2,R3,R2
   \   0000004E   0x4091             LSLS     R1,R1,R2
   \   00000050   0x4308             ORRS     R0,R1,R0
   \   00000052   0x62A0             STR      R0,[R4, #+40]
    444          
    445          	if (TIM_CaptureConfigStruct->FallingEdge)
   \                     ??TIM_ConfigCapture_1: (+1)
   \   00000054   0x78A8             LDRB     R0,[R5, #+2]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD008             BEQ.N    ??TIM_ConfigCapture_2
    446          		TIMx->CCR |= TIM_CAP_FALLING(TIM_CaptureConfigStruct->CaptureChannel);
   \   0000005A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x782A             LDRB     R2,[R5, #+0]
   \   00000060   0x2303             MOVS     R3,#+3
   \   00000062   0x435A             MULS     R2,R3,R2
   \   00000064   0x1C52             ADDS     R2,R2,#+1
   \   00000066   0x4091             LSLS     R1,R1,R2
   \   00000068   0x4308             ORRS     R0,R1,R0
   \   0000006A   0x62A0             STR      R0,[R4, #+40]
    447          
    448          	if (TIM_CaptureConfigStruct->IntOnCaption)
   \                     ??TIM_ConfigCapture_2: (+1)
   \   0000006C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD008             BEQ.N    ??TIM_ConfigCapture_3
    449          		TIMx->CCR |= TIM_INT_ON_CAP(TIM_CaptureConfigStruct->CaptureChannel);
   \   00000072   0x6AA0             LDR      R0,[R4, #+40]
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0x782A             LDRB     R2,[R5, #+0]
   \   00000078   0x2303             MOVS     R3,#+3
   \   0000007A   0x435A             MULS     R2,R3,R2
   \   0000007C   0x1C92             ADDS     R2,R2,#+2
   \   0000007E   0x4091             LSLS     R1,R1,R2
   \   00000080   0x4308             ORRS     R0,R1,R0
   \   00000082   0x62A0             STR      R0,[R4, #+40]
    450          }
   \                     ??TIM_ConfigCapture_3: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    451          
    452          /*********************************************************************//**
    453           * @brief 		Read value of capture register in timer/counter device
    454           * @param[in]	TIMx Pointer to timer/counter device
    455           * @param[in]	CaptureChannel: capture channel number
    456           * @return 		Value of capture register
    457           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    458          uint32_t TIM_GetCaptureValue(LPC_TIM_TypeDef *TIMx, uint8_t CaptureChannel)
    459          {
   \                     TIM_GetCaptureValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    460          	CHECK_PARAM(PARAM_TIMx(TIMx));
   \   00000006   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   0000000A   0xD00D             BEQ.N    ??TIM_GetCaptureValue_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40008000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00A             BEQ.N    ??TIM_GetCaptureValue_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40090000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD007             BEQ.N    ??TIM_GetCaptureValue_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40094000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??TIM_GetCaptureValue_0
   \   0000001E   0xF44F 0x71E6      MOV      R1,#+460
   \   00000022   0x....             LDR.N    R0,??DataTable12_4
   \   00000024   0x.... 0x....      BL       check_failed
    461          	CHECK_PARAM(PARAM_TIM_COUNTER_INPUT_OPT(CaptureChannel));
   \                     ??TIM_GetCaptureValue_0: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??TIM_GetCaptureValue_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD004             BEQ.N    ??TIM_GetCaptureValue_1
   \   00000034   0xF240 0x11CD      MOVW     R1,#+461
   \   00000038   0x....             LDR.N    R0,??DataTable12_4
   \   0000003A   0x.... 0x....      BL       check_failed
    462          
    463          	if(CaptureChannel==0)
   \                     ??TIM_GetCaptureValue_1: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD101             BNE.N    ??TIM_GetCaptureValue_2
    464          		return TIMx->CR0;
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0xE000             B.N      ??TIM_GetCaptureValue_3
    465          	else
    466          		return TIMx->CR1;
   \                     ??TIM_GetCaptureValue_2: (+1)
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \                     ??TIM_GetCaptureValue_3: (+1)
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    467          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x74          DC8 5FH, 74H, 69H, 6DH, 65H, 72H, 2EH, 63H
   \              0x69 0x6D    
   \              0x65 0x72    
   \              0x2E 0x63    
   \   00000098   0x00               DC8 0
   \   00000099   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    468          
    469          /**
    470           * @}
    471           */
    472          
    473          #endif /* _TIMER */
    474          
    475          /**
    476           * @}
    477           */
    478          
    479          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TIM_ClearIntCapturePending
        16   -> check_failed
      16   TIM_ClearIntPending
        16   -> check_failed
      16   TIM_Cmd
        16   -> check_failed
      16   TIM_ConfigCapture
        16   -> TIM_ConverPtrToTimeNum
        16   -> check_failed
      16   TIM_ConfigMatch
        16   -> TIM_ConverPtrToTimeNum
        16   -> check_failed
       0   TIM_ConfigStructInit
       0   TIM_ConverPtrToTimeNum
      24   TIM_ConverUSecToVal
        24   -> TIM_GetPClock
        24 __aeabi_uldivmod
       8   TIM_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      16   TIM_GetCaptureValue
        16   -> check_failed
      16   TIM_GetIntCaptureStatus
        16   -> check_failed
      16   TIM_GetIntStatus
        16   -> check_failed
      16   TIM_GetPClock
        16   -> CLKPWR_GetPCLK
      32   TIM_Init
        32   -> CLKPWR_ConfigPPWR
        32   -> CLKPWR_SetPCLKDiv
        32   -> TIM_ConverPtrToTimeNum
        32   -> TIM_ConverUSecToVal
        32   -> check_failed
       8   TIM_ResetCounter
         8   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
     156  ?_0
     106  TIM_ClearIntCapturePending
     104  TIM_ClearIntPending
      66  TIM_Cmd
     134  TIM_ConfigCapture
     222  TIM_ConfigMatch
      22  TIM_ConfigStructInit
      60  TIM_ConverPtrToTimeNum
      56  TIM_ConverUSecToVal
     110  TIM_DeInit
      76  TIM_GetCaptureValue
     116  TIM_GetIntCaptureStatus
     114  TIM_GetIntStatus
      62  TIM_GetPClock
     294  TIM_Init
      56  TIM_ResetCounter

 
   156 bytes in section .rodata
 1 618 bytes in section .text
 
 1 618 bytes of CODE  memory
   156 bytes of CONST memory

Errors: none
Warnings: 3
