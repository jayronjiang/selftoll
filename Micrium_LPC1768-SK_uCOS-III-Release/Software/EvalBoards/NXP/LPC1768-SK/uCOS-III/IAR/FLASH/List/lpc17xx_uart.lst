###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:08
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_uart.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_uart.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_uart.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_uart.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\source\lpc17xx_uart.c
      1          /**
      2           * @file	: lpc17xx_uart.c
      3           * @brief	: Contains all functions support for UART firmware library on LPC17xx
      4           * @version	: 1.0
      5           * @date	: 18. Mar. 2009
      6           * @author	: HieuNguyen
      7           **************************************************************************
      8           * Software that is described herein is for illustrative purposes only
      9           * which provides customers with programming information regarding the
     10           * products. This software is supplied "AS IS" without any warranties.
     11           * NXP Semiconductors assumes no responsibility or liability for the
     12           * use of the software, conveys no license or title under any patent,
     13           * copyright, or mask work right to the product. NXP Semiconductors
     14           * reserves the right to make changes in the software without
     15           * notification. NXP Semiconductors also make no representation or
     16           * warranty that such application will be suitable for the specified
     17           * use without further testing or modification.
     18           **********************************************************************/
     19          
     20          /* Peripheral group ----------------------------------------------------------- */
     21          /** @addtogroup UART
     22           * @{
     23           */
     24          
     25          /* Includes ------------------------------------------------------------------- */
     26          #include "lpc17xx_uart.h"
     27          #include "lpc17xx_clkpwr.h"
     28          
     29          /* If this source file built with example, the LPC17xx FW library configuration
     30           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     31           * otherwise the default FW library configuration file must be included instead
     32           */
     33          #ifdef __BUILD_WITH_EXAMPLE__
     34          #include "lpc17xx_libcfg.h"
     35          #else
     36          #include "lpc17xx_libcfg_default.h"
     37          #endif /* __BUILD_WITH_EXAMPLE__ */
     38          
     39          
     40          #ifdef _UART
     41          
     42          /* Private Types -------------------------------------------------------------- */
     43          /** @defgroup UART_Private_Types
     44           * @{
     45           */
     46          
     47          /**
     48           * @brief UART call-back function type definitions
     49           */
     50          typedef struct {
     51          	fnTxCbs_Type *pfnTxCbs; 	// Transmit callback
     52          	fnRxCbs_Type *pfnRxCbs;		// Receive callback
     53          	fnABCbs_Type *pfnABCbs;		// Auto-Baudrate callback
     54          	fnErrCbs_Type *pfnErrCbs;	// Error callback
     55          } UART_CBS_Type;
     56          
     57          /**
     58           * @}
     59           */
     60          
     61          
     62          /* Private Variables ---------------------------------------------------------- */
     63          /** @defgroup UART_Private_Variables
     64           * @{
     65           */
     66          
     67          
     68          /** Call-back function pointer data */

   \                                 In section .bss, align 4
     69          UART_CBS_Type uartCbsDat[4] = {
   \                     uartCbsDat:
   \   00000000                      DS8 64
     70          		{NULL, NULL, NULL, NULL},
     71          		{NULL, NULL, NULL, NULL},
     72          		{NULL, NULL, NULL, NULL},
     73          		{NULL, NULL, NULL, NULL},
     74          };
     75          
     76          /** UART1 modem status interrupt callback pointer data */

   \                                 In section .bss, align 4
     77          fnModemCbs_Type *pfnModemCbs = NULL;
   \                     pfnModemCbs:
   \   00000000                      DS8 4
     78          
     79          /**
     80           * @}
     81           */
     82          
     83          
     84          /* Private Functions ---------------------------------------------------------- */
     85          /** @defgroup UART_Private_Functions
     86           * @{
     87           */
     88          
     89          /**
     90           * @brief		Get UART number due to UART peripheral pointer
     91           * @param[in]	UARTx	UART pointer
     92           * @return		UART number
     93           */

   \                                 In section .text, align 2, keep-with-next
     94          uint8_t getUartNum(LPC_UART_TypeDef *UARTx) {
   \                     getUartNum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     95          	if (UARTx == LPC_UART0) return (0);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??getUartNum_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE00C             B.N      ??getUartNum_1
     96          	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1) return (1);
   \                     ??getUartNum_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD101             BNE.N    ??getUartNum_2
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE006             B.N      ??getUartNum_1
     97          	else if (UARTx == LPC_UART2) return (2);
   \                     ??getUartNum_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD101             BNE.N    ??getUartNum_3
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE000             B.N      ??getUartNum_1
     98          	else return (3);
   \                     ??getUartNum_3: (+1)
   \   00000026   0x2003             MOVS     R0,#+3
   \                     ??getUartNum_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
     99          }
    100          
    101          /*********************************************************************//**
    102           * @brief		Determines best dividers to get a target clock rate
    103           * @param[in]	UARTx	Pointer to selected UART peripheral, should be
    104           * 						UART0, UART1, UART2 or UART3.
    105           * @param[in]	baudrate Desired UART baud rate.
    106           * @return 		Error status.
    107           **********************************************************************/
    108          

   \                                 In section .text, align 2, keep-with-next
    109          Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate)
    110          {
   \                     uart_set_divisors: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    111          	Status errorStatus = ERROR;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0014      STRB     R0,[SP, #+20]
    112          
    113          	uint32_t uClk;
    114          	uint32_t calcBaudrate = 0;
   \   00000010   0x2600             MOVS     R6,#+0
    115          	uint32_t temp = 0;
   \   00000012   0x2700             MOVS     R7,#+0
    116          
    117          	uint32_t mulFracDiv, dividerAddFracDiv;
    118          	uint32_t diviser = 0 ;
   \   00000014   0xF05F 0x0B00      MOVS     R11,#+0
    119          	uint32_t mulFracDivOptimal = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x9004             STR      R0,[SP, #+16]
    120          	uint32_t dividerAddOptimal = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9003             STR      R0,[SP, #+12]
    121          	uint32_t diviserOptimal = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9001             STR      R0,[SP, #+4]
    122          
    123          	uint32_t relativeError = 0;
   \   00000024   0xF05F 0x0A00      MOVS     R10,#+0
    124          	uint32_t relativeOptimalError = 100000;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x186a0
   \   0000002C   0x9002             STR      R0,[SP, #+8]
    125          
    126          	/* get UART block clock */
    127          	if (UARTx == LPC_UART0)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD104             BNE.N    ??uart_set_divisors_0
    128          	{
    129          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART0);
   \   00000036   0x2006             MOVS     R0,#+6
   \   00000038   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0xE019             B.N      ??uart_set_divisors_1
    130          	}
    131          	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1)
   \                     ??uart_set_divisors_0: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD104             BNE.N    ??uart_set_divisors_2
    132          	{
    133          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART1);
   \   00000048   0x2008             MOVS     R0,#+8
   \   0000004A   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0xE010             B.N      ??uart_set_divisors_1
    134          	}
    135          	else if (UARTx == LPC_UART2)
   \                     ??uart_set_divisors_2: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD104             BNE.N    ??uart_set_divisors_3
    136          	{
    137          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART2);
   \   0000005A   0x2030             MOVS     R0,#+48
   \   0000005C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000060   0x9000             STR      R0,[SP, #+0]
   \   00000062   0xE007             B.N      ??uart_set_divisors_1
    138          	}
    139          	else if (UARTx == LPC_UART3)
   \                     ??uart_set_divisors_3: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD103             BNE.N    ??uart_set_divisors_1
    140          	{
    141          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART3);
   \   0000006C   0x2032             MOVS     R0,#+50
   \   0000006E   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000072   0x9000             STR      R0,[SP, #+0]
    142          	}
    143          
    144          
    145          	uClk = uClk >> 4; /* div by 16 */
   \                     ??uart_set_divisors_1: (+1)
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x0900             LSRS     R0,R0,#+4
   \   00000078   0x9000             STR      R0,[SP, #+0]
    146          	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
    147          	* The formula is :
    148          	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
    149          	* It involves floating point calculations. That's the reason the formulae are adjusted with
    150          	* Multiply and divide method.*/
    151          	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
    152          	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
    153          	for (mulFracDiv = 1 ; mulFracDiv <= 15 ;mulFracDiv++)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x4680             MOV      R8,R0
   \                     ??uart_set_divisors_4: (+1)
   \   0000007E   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000082   0xD23F             BCS.N    ??uart_set_divisors_5
    154          	{
    155          	for (dividerAddFracDiv = 0 ; dividerAddFracDiv <= 15 ;dividerAddFracDiv++)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x4681             MOV      R9,R0
   \                     ??uart_set_divisors_6: (+1)
   \   00000088   0xF1B9 0x0F10      CMP      R9,#+16
   \   0000008C   0xD234             BCS.N    ??uart_set_divisors_7
    156          	{
    157          	  temp = (mulFracDiv * uClk) / ((mulFracDiv + dividerAddFracDiv));
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0xFB00 0xF008      MUL      R0,R0,R8
   \   00000094   0xEB19 0x0108      ADDS     R1,R9,R8
   \   00000098   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000009C   0x0007             MOVS     R7,R0
    158          
    159          	  diviser = temp / baudrate;
   \   0000009E   0xFBB7 0xF0F5      UDIV     R0,R7,R5
   \   000000A2   0x4683             MOV      R11,R0
    160          	  if ((temp % baudrate) > (baudrate / 2))
   \   000000A4   0xFBB7 0xF0F5      UDIV     R0,R7,R5
   \   000000A8   0xFB05 0x7010      MLS      R0,R5,R0,R7
   \   000000AC   0x0869             LSRS     R1,R5,#+1
   \   000000AE   0x4281             CMP      R1,R0
   \   000000B0   0xD201             BCS.N    ??uart_set_divisors_8
    161          		diviser++;
   \   000000B2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    162          
    163          	  if (diviser > 2 && diviser < 65536)
   \                     ??uart_set_divisors_8: (+1)
   \   000000B6   0xF1BB 0x0F03      CMP      R11,#+3
   \   000000BA   0xD31A             BCC.N    ??uart_set_divisors_9
   \   000000BC   0xF5BB 0x3F80      CMP      R11,#+65536
   \   000000C0   0xD217             BCS.N    ??uart_set_divisors_9
    164          	  {
    165          		calcBaudrate = temp / diviser;
   \   000000C2   0xFBB7 0xF0FB      UDIV     R0,R7,R11
   \   000000C6   0x0006             MOVS     R6,R0
    166          
    167          		if (calcBaudrate <= baudrate)
   \   000000C8   0x42B5             CMP      R5,R6
   \   000000CA   0xD302             BCC.N    ??uart_set_divisors_10
    168          		  relativeError = baudrate - calcBaudrate;
   \   000000CC   0x1BA8             SUBS     R0,R5,R6
   \   000000CE   0x4682             MOV      R10,R0
   \   000000D0   0xE001             B.N      ??uart_set_divisors_11
    169          		else
    170          		  relativeError = calcBaudrate - baudrate;
   \                     ??uart_set_divisors_10: (+1)
   \   000000D2   0x1B70             SUBS     R0,R6,R5
   \   000000D4   0x4682             MOV      R10,R0
    171          
    172          		if ((relativeError < relativeOptimalError))
   \                     ??uart_set_divisors_11: (+1)
   \   000000D6   0x9802             LDR      R0,[SP, #+8]
   \   000000D8   0x4582             CMP      R10,R0
   \   000000DA   0xD20A             BCS.N    ??uart_set_divisors_9
    173          		{
    174          		  mulFracDivOptimal = mulFracDiv ;
   \   000000DC   0xF8CD 0x8010      STR      R8,[SP, #+16]
    175          		  dividerAddOptimal = dividerAddFracDiv;
   \   000000E0   0xF8CD 0x900C      STR      R9,[SP, #+12]
    176          		  diviserOptimal = diviser;
   \   000000E4   0xF8CD 0xB004      STR      R11,[SP, #+4]
    177          		  relativeOptimalError = relativeError;
   \   000000E8   0xF8CD 0xA008      STR      R10,[SP, #+8]
    178          		  if (relativeError == 0)
   \   000000EC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000F0   0xD002             BEQ.N    ??uart_set_divisors_7
    179          			break;
    180          		}
    181          	  } /* End of if */
    182          	} /* end of inner for loop */
   \                     ??uart_set_divisors_9: (+1)
   \   000000F2   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000F6   0xE7C7             B.N      ??uart_set_divisors_6
    183          	if (relativeError == 0)
   \                     ??uart_set_divisors_7: (+1)
   \   000000F8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000FC   0xD002             BEQ.N    ??uart_set_divisors_5
    184          	  break;
    185          	} /* end of outer for loop  */
   \                     ??uart_set_divisors_12: (+1)
   \   000000FE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000102   0xE7BC             B.N      ??uart_set_divisors_4
    186          
    187          	if (relativeOptimalError < ((baudrate * UART_ACCEPTED_BAUDRATE_ERROR)/100))
   \                     ??uart_set_divisors_5: (+1)
   \   00000104   0x2003             MOVS     R0,#+3
   \   00000106   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000010A   0x2164             MOVS     R1,#+100
   \   0000010C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000110   0x9902             LDR      R1,[SP, #+8]
   \   00000112   0x4281             CMP      R1,R0
   \   00000114   0xD232             BCS.N    ??uart_set_divisors_13
    188          	{
    189          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   0000011A   0x4284             CMP      R4,R0
   \   0000011C   0xD116             BNE.N    ??uart_set_divisors_14
    190          		{
    191          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   0000011E   0x7B20             LDRB     R0,[R4, #+12]
   \   00000120   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000124   0x7320             STRB     R0,[R4, #+12]
    192          			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
   \   00000126   0x9801             LDR      R0,[SP, #+4]
   \   00000128   0x0A00             LSRS     R0,R0,#+8
   \   0000012A   0x7120             STRB     R0,[R4, #+4]
    193          			((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
   \   0000012C   0x9801             LDR      R0,[SP, #+4]
   \   0000012E   0x7020             STRB     R0,[R4, #+0]
    194          			/* Then reset DLAB bit */
    195          			((LPC_UART1_TypeDef *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   00000130   0x7B20             LDRB     R0,[R4, #+12]
   \   00000132   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000136   0x7320             STRB     R0,[R4, #+12]
    196          			((LPC_UART1_TypeDef *)UARTx)->FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
    197          					| UART_FDR_DIVADDVAL(dividerAddOptimal)) & UART_FDR_BITMASK;
   \   00000138   0x9804             LDR      R0,[SP, #+16]
   \   0000013A   0x9903             LDR      R1,[SP, #+12]
   \   0000013C   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000140   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   00000144   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000148   0x62A0             STR      R0,[R4, #+40]
   \   0000014A   0xE014             B.N      ??uart_set_divisors_15
    198          		}
    199          		else
    200          		{
    201          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \                     ??uart_set_divisors_14: (+1)
   \   0000014C   0x7B20             LDRB     R0,[R4, #+12]
   \   0000014E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000152   0x7320             STRB     R0,[R4, #+12]
    202          			UARTx->/*DLIER.*/DLM = UART_LOAD_DLM(diviserOptimal);
   \   00000154   0x9801             LDR      R0,[SP, #+4]
   \   00000156   0x0A00             LSRS     R0,R0,#+8
   \   00000158   0x7120             STRB     R0,[R4, #+4]
    203          			UARTx->/*RBTHDLR.*/DLL = UART_LOAD_DLL(diviserOptimal);
   \   0000015A   0x9801             LDR      R0,[SP, #+4]
   \   0000015C   0x7020             STRB     R0,[R4, #+0]
    204          			/* Then reset DLAB bit */
    205          			UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   0000015E   0x7B20             LDRB     R0,[R4, #+12]
   \   00000160   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000164   0x7320             STRB     R0,[R4, #+12]
    206          			UARTx->FDR = (UART_FDR_MULVAL(mulFracDivOptimal) \
    207          					| UART_FDR_DIVADDVAL(dividerAddOptimal)) & UART_FDR_BITMASK;
   \   00000166   0x9804             LDR      R0,[SP, #+16]
   \   00000168   0x9903             LDR      R1,[SP, #+12]
   \   0000016A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   0000016E   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   00000172   0xF884 0x0028      STRB     R0,[R4, #+40]
    208          		}
    209          		errorStatus = SUCCESS;
   \                     ??uart_set_divisors_15: (+1)
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xF88D 0x0014      STRB     R0,[SP, #+20]
    210          	}
    211          
    212          	return errorStatus;
   \                     ??uart_set_divisors_13: (+1)
   \   0000017C   0xF89D 0x0014      LDRB     R0,[SP, #+20]
   \   00000180   0xB007             ADD      SP,SP,#+28
   \   00000182   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    213          }
    214          
    215          /*********************************************************************//**
    216           * @brief		General UART interrupt handler and router
    217           * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
    218           * @return		None
    219           *
    220           * Note:
    221           * - Handles transmit, receive, and status interrupts for the UART.
    222           * Based on the interrupt status, routes the interrupt to the
    223           * respective call-back to be handled by the user application using
    224           * this driver.
    225           * - If callback is not installed, corresponding interrupt will be disabled
    226           * - All these interrupt source below will be checked:
    227           *   		- Transmit Holding Register Empty.
    228           * 			- Received Data Available and Character Time Out.
    229           * 			- Receive Line Status (not implemented)
    230           * 			- End of auto-baud interrupt (not implemented)
    231           * 			- Auto-Baudrate Time-Out interrupt (not implemented)
    232           * 			- Modem Status interrupt (UART0 Modem functionality)
    233           * 			- CTS signal transition interrupt (UART0 Modem functionality)
    234           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          void UART_GenIntHandler(LPC_UART_TypeDef *UARTx)
    236          {
   \                     UART_GenIntHandler: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    237          	uint8_t pUart, modemsts;
    238          	uint32_t intsrc, tmp, tmp1;
    239          
    240          	pUart = getUartNum(UARTx);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       getUartNum
   \   0000000C   0x0005             MOVS     R5,R0
    241          
    242          	/* Determine the interrupt source */
    243          	intsrc = UARTx->IIR;
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0x0007             MOVS     R7,R0
    244          	tmp = intsrc & UART_IIR_INTID_MASK;
   \   00000012   0xF017 0x000E      ANDS     R0,R7,#0xE
   \   00000016   0x4680             MOV      R8,R0
    245          
    246          	/*
    247          	 * In case of using UART1 with full modem,
    248          	 * interrupt ID = 0 that means modem status interrupt has been detected
    249          	 */
    250          	if (pUart == 1) {
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD11A             BNE.N    ??UART_GenIntHandler_0
    251          		if (tmp == 0){
   \   0000001E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000022   0xD117             BNE.N    ??UART_GenIntHandler_0
    252          			// Check Modem status
    253          			modemsts = LPC_UART1->MSR & UART1_MSR_BITMASK;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40010018
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x0006             MOVS     R6,R0
    254          			// Call modem status call-back
    255          			if (pfnModemCbs != NULL){
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??UART_GenIntHandler_1
    256          				pfnModemCbs(modemsts);
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable18_1
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x4788             BLX      R1
   \   00000042   0xE007             B.N      ??UART_GenIntHandler_0
    257          			}
    258          			// disable modem status interrupt and CTS status change interrupt
    259          			// if its callback is not installed
    260          			else {
    261          				LPC_UART1->IER &= ~(UART1_IER_MSINT_EN | UART1_IER_CTSINT_EN);
   \                     ??UART_GenIntHandler_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x40010004
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x0088      BICS     R0,R0,#0x88
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable18_2  ;; 0x40010004
   \   00000052   0x6008             STR      R0,[R1, #+0]
    262          			}
    263          		}
    264          	}
    265          
    266          	// Receive Line Status
    267          	if (tmp == UART_IIR_INTID_RLS){
   \                     ??UART_GenIntHandler_0: (+1)
   \   00000054   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000058   0xD11C             BNE.N    ??UART_GenIntHandler_2
    268          		// Check line status
    269          		tmp1 = UARTx->LSR;
   \   0000005A   0x7D20             LDRB     R0,[R4, #+20]
   \   0000005C   0x4681             MOV      R9,R0
    270          		// Mask out the Receive Ready and Transmit Holding empty status
    271          		tmp1 &= (UART_LSR_OE | UART_LSR_PE | UART_LSR_FE \
    272          				| UART_LSR_BI | UART_LSR_RXFE);
   \   0000005E   0xF019 0x099E      ANDS     R9,R9,#0x9E
    273          		// If any error exist
    274          		if (tmp1) {
   \   00000062   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000066   0xD015             BEQ.N    ??UART_GenIntHandler_2
    275          			// Call Call-back function with error input value
    276          			if (uartCbsDat[pUart].pfnErrCbs != NULL) {
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0x0129             LSLS     R1,R5,#+4
   \   00000070   0x4408             ADD      R0,R0,R1
   \   00000072   0x68C0             LDR      R0,[R0, #+12]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD009             BEQ.N    ??UART_GenIntHandler_3
    277          				uartCbsDat[pUart].pfnErrCbs(tmp1);
   \   00000078   0x4648             MOV      R0,R9
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x012A             LSLS     R2,R5,#+4
   \   00000084   0x4411             ADD      R1,R1,R2
   \   00000086   0x68C9             LDR      R1,[R1, #+12]
   \   00000088   0x4788             BLX      R1
   \   0000008A   0xE003             B.N      ??UART_GenIntHandler_2
    278          			}
    279          			// Disable interrupt if its call-back is not install
    280          			else {
    281          				UARTx->IER &= ~(UART_IER_RLSINT_EN);
   \                     ??UART_GenIntHandler_3: (+1)
   \   0000008C   0x6860             LDR      R0,[R4, #+4]
   \   0000008E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000092   0x6060             STR      R0,[R4, #+4]
    282          			}
    283          		}
    284          	}
    285          
    286          	// Receive Data Available or Character time-out
    287          	if ((tmp == UART_IIR_INTID_RDA) || (tmp == UART_IIR_INTID_CTI)){
   \                     ??UART_GenIntHandler_2: (+1)
   \   00000094   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000098   0xD002             BEQ.N    ??UART_GenIntHandler_4
   \   0000009A   0xF1B8 0x0F0C      CMP      R8,#+12
   \   0000009E   0xD113             BNE.N    ??UART_GenIntHandler_5
    288          		// Call Rx call back function
    289          		if (uartCbsDat[pUart].pfnRxCbs != NULL) {
   \                     ??UART_GenIntHandler_4: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x0129             LSLS     R1,R5,#+4
   \   000000A8   0x4408             ADD      R0,R0,R1
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD007             BEQ.N    ??UART_GenIntHandler_6
    290          			uartCbsDat[pUart].pfnRxCbs();
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B6   0x0129             LSLS     R1,R5,#+4
   \   000000B8   0x4408             ADD      R0,R0,R1
   \   000000BA   0x6840             LDR      R0,[R0, #+4]
   \   000000BC   0x4780             BLX      R0
   \   000000BE   0xE003             B.N      ??UART_GenIntHandler_5
    291          		}
    292          		// Disable interrupt if its call-back is not install
    293          		else {
    294          			UARTx->IER &= ~(UART_IER_RBRINT_EN);
   \                     ??UART_GenIntHandler_6: (+1)
   \   000000C0   0x6860             LDR      R0,[R4, #+4]
   \   000000C2   0x0840             LSRS     R0,R0,#+1
   \   000000C4   0x0040             LSLS     R0,R0,#+1
   \   000000C6   0x6060             STR      R0,[R4, #+4]
    295          		}
    296          	}
    297          
    298          	// Transmit Holding Empty
    299          	if (tmp == UART_IIR_INTID_THRE){
   \                     ??UART_GenIntHandler_5: (+1)
   \   000000C8   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000CC   0xD111             BNE.N    ??UART_GenIntHandler_7
    300          		// Call Tx call back function
    301          		if (uartCbsDat[pUart].pfnTxCbs != NULL) {
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x0129             LSLS     R1,R5,#+4
   \   000000D6   0x5840             LDR      R0,[R0, R1]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD006             BEQ.N    ??UART_GenIntHandler_8
    302          			uartCbsDat[pUart].pfnTxCbs();
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000000E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E2   0x0129             LSLS     R1,R5,#+4
   \   000000E4   0x5840             LDR      R0,[R0, R1]
   \   000000E6   0x4780             BLX      R0
   \   000000E8   0xE003             B.N      ??UART_GenIntHandler_7
    303          		}
    304          		// Disable interrupt if its call-back is not install
    305          		else {
    306          			UARTx->IER &= ~(UART_IER_THREINT_EN);
   \                     ??UART_GenIntHandler_8: (+1)
   \   000000EA   0x6860             LDR      R0,[R4, #+4]
   \   000000EC   0xF030 0x0002      BICS     R0,R0,#0x2
   \   000000F0   0x6060             STR      R0,[R4, #+4]
    307          		}
    308          	}
    309          
    310          	intsrc &= (UART_IIR_ABEO_INT | UART_IIR_ABTO_INT);
   \                     ??UART_GenIntHandler_7: (+1)
   \   000000F2   0xF417 0x7740      ANDS     R7,R7,#0x300
    311          	// Check if End of auto-baudrate interrupt or Auto baudrate time out
    312          	if (intsrc){
   \   000000F6   0x2F00             CMP      R7,#+0
   \   000000F8   0xD024             BEQ.N    ??UART_GenIntHandler_9
    313          		// Clear interrupt pending
    314          		UARTx->ACR |= ((intsrc & UART_IIR_ABEO_INT) ? UART_ACR_ABEOINT_CLR : 0) \
    315          						| ((intsrc & UART_IIR_ABTO_INT) ? UART_ACR_ABTOINT_CLR : 0);
   \   000000FA   0x05F8             LSLS     R0,R7,#+23
   \   000000FC   0xD502             BPL.N    ??UART_GenIntHandler_10
   \   000000FE   0xF44F 0x7080      MOV      R0,#+256
   \   00000102   0xE000             B.N      ??UART_GenIntHandler_11
   \                     ??UART_GenIntHandler_10: (+1)
   \   00000104   0x2000             MOVS     R0,#+0
   \                     ??UART_GenIntHandler_11: (+1)
   \   00000106   0x05B9             LSLS     R1,R7,#+22
   \   00000108   0xD502             BPL.N    ??UART_GenIntHandler_12
   \   0000010A   0xF44F 0x7100      MOV      R1,#+512
   \   0000010E   0xE000             B.N      ??UART_GenIntHandler_13
   \                     ??UART_GenIntHandler_12: (+1)
   \   00000110   0x2100             MOVS     R1,#+0
   \                     ??UART_GenIntHandler_13: (+1)
   \   00000112   0x6A22             LDR      R2,[R4, #+32]
   \   00000114   0x4308             ORRS     R0,R1,R0
   \   00000116   0x4310             ORRS     R0,R0,R2
   \   00000118   0x6220             STR      R0,[R4, #+32]
    316          		if (uartCbsDat[pUart].pfnABCbs != NULL) {
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0x0129             LSLS     R1,R5,#+4
   \   00000122   0x4408             ADD      R0,R0,R1
   \   00000124   0x6880             LDR      R0,[R0, #+8]
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD008             BEQ.N    ??UART_GenIntHandler_14
    317          			uartCbsDat[pUart].pfnABCbs(intsrc);
   \   0000012A   0x0038             MOVS     R0,R7
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000130   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000132   0x012A             LSLS     R2,R5,#+4
   \   00000134   0x4411             ADD      R1,R1,R2
   \   00000136   0x6889             LDR      R1,[R1, #+8]
   \   00000138   0x4788             BLX      R1
   \   0000013A   0xE003             B.N      ??UART_GenIntHandler_9
    318          		} else {
    319          			// Disable End of AB interrupt
    320          			UARTx->IER &= ~(UART_IER_ABEOINT_EN | UART_IER_ABTOINT_EN);
   \                     ??UART_GenIntHandler_14: (+1)
   \   0000013C   0x6860             LDR      R0,[R4, #+4]
   \   0000013E   0xF430 0x7040      BICS     R0,R0,#0x300
   \   00000142   0x6060             STR      R0,[R4, #+4]
    321          		}
    322          	}
    323          }
   \                     ??UART_GenIntHandler_9: (+1)
   \   00000144   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    324          
    325          /**
    326           * @}
    327           */
    328          
    329          
    330          /* Public Functions ----------------------------------------------------------- */
    331          /** @addtogroup UART_Public_Functions
    332           * @{
    333           */
    334          
    335          /*********************************************************************//**
    336           * @brief		De-initializes the UARTx peripheral registers to their
    337          *                  default reset values.
    338           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    339           * 						UART2 or UART3.
    340           * @return 		None
    341           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    342          void UART_DeInit(LPC_UART_TypeDef* UARTx)
    343          {
   \                     UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    344          	// For debug mode
    345          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_DeInit_0
   \   00000024   0xF240 0x1159      MOVW     R1,#+345
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002C   0x.... 0x....      BL       check_failed
    346          
    347          	UART_TxCmd(UARTx, DISABLE);
   \                     ??UART_DeInit_0: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_TxCmd
    348          
    349          #ifdef _UART0
    350          	if (UARTx == LPC_UART0)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD103             BNE.N    ??UART_DeInit_1
    351          	{
    352          		/* Set up clock and power for UART module */
    353          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    354          	}
    355          #endif
    356          
    357          #ifdef _UART1
    358          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_DeInit_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD103             BNE.N    ??UART_DeInit_2
    359          	{
    360          		/* Set up clock and power for UART module */
    361          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2010             MOVS     R0,#+16
   \   00000054   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    362          	}
    363          #endif
    364          
    365          #ifdef _UART2
    366          	if (UARTx == LPC_UART2)
   \                     ??UART_DeInit_2: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD104             BNE.N    ??UART_DeInit_3
    367          	{
    368          		/* Set up clock and power for UART module */
    369          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000066   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    370          	}
    371          #endif
    372          
    373          #ifdef _UART3
    374          	if (UARTx == LPC_UART3)
   \                     ??UART_DeInit_3: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD104             BNE.N    ??UART_DeInit_4
    375          	{
    376          		/* Set up clock and power for UART module */
    377          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000078   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    378          	}
    379          #endif
    380          }
   \                     ??UART_DeInit_4: (+1)
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    381          
    382          /********************************************************************//**
    383           * @brief		Initializes the UARTx peripheral according to the specified
    384          *               parameters in the UART_ConfigStruct.
    385           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    386           * 						UART2 or UART3.
    387           * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
    388          *                    that contains the configuration information for the
    389          *                    specified UART peripheral.
    390           * @return 		None
    391           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    392          void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
    393          {
   \                     UART_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    394          	uint32_t tmp;
    395          
    396          	// For debug mode
    397          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??UART_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??UART_Init_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??UART_Init_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??UART_Init_0
   \   00000026   0xF240 0x118D      MOVW     R1,#+397
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002E   0x.... 0x....      BL       check_failed
    398          	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct->Databits));
   \                     ??UART_Init_0: (+1)
   \   00000032   0x7968             LDRB     R0,[R5, #+5]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00E             BEQ.N    ??UART_Init_1
   \   00000038   0x7968             LDRB     R0,[R5, #+5]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD00B             BEQ.N    ??UART_Init_1
   \   0000003E   0x7968             LDRB     R0,[R5, #+5]
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD008             BEQ.N    ??UART_Init_1
   \   00000044   0x7968             LDRB     R0,[R5, #+5]
   \   00000046   0x2803             CMP      R0,#+3
   \   00000048   0xD005             BEQ.N    ??UART_Init_1
   \   0000004A   0xF44F 0x71C7      MOV      R1,#+398
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000052   0x.... 0x....      BL       check_failed
    399          	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct->Stopbits));
   \                     ??UART_Init_1: (+1)
   \   00000056   0x79A8             LDRB     R0,[R5, #+6]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD008             BEQ.N    ??UART_Init_2
   \   0000005C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD005             BEQ.N    ??UART_Init_2
   \   00000062   0xF240 0x118F      MOVW     R1,#+399
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000006A   0x.... 0x....      BL       check_failed
    400          	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct->Parity));
   \                     ??UART_Init_2: (+1)
   \   0000006E   0x7928             LDRB     R0,[R5, #+4]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD011             BEQ.N    ??UART_Init_3
   \   00000074   0x7928             LDRB     R0,[R5, #+4]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD00E             BEQ.N    ??UART_Init_3
   \   0000007A   0x7928             LDRB     R0,[R5, #+4]
   \   0000007C   0x2802             CMP      R0,#+2
   \   0000007E   0xD00B             BEQ.N    ??UART_Init_3
   \   00000080   0x7928             LDRB     R0,[R5, #+4]
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD008             BEQ.N    ??UART_Init_3
   \   00000086   0x7928             LDRB     R0,[R5, #+4]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0xD005             BEQ.N    ??UART_Init_3
   \   0000008C   0xF44F 0x71C8      MOV      R1,#+400
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000094   0x.... 0x....      BL       check_failed
    401          
    402          #ifdef _UART0
    403          	if(UARTx == LPC_UART0)
   \                     ??UART_Init_3: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   0000009C   0x4284             CMP      R4,R0
   \   0000009E   0xD103             BNE.N    ??UART_Init_4
    404          	{
    405          		/* Set up clock and power for UART module */
    406          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x2008             MOVS     R0,#+8
   \   000000A4   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    407          	}
    408          #endif
    409          
    410          #ifdef _UART1
    411          	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_Init_4: (+1)
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   000000AC   0x4284             CMP      R4,R0
   \   000000AE   0xD103             BNE.N    ??UART_Init_5
    412          	{
    413          		/* Set up clock and power for UART module */
    414          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0x2010             MOVS     R0,#+16
   \   000000B4   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    415          	}
    416          #endif
    417          
    418          #ifdef _UART2
    419          	if(UARTx == LPC_UART2)
   \                     ??UART_Init_5: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   000000BC   0x4284             CMP      R4,R0
   \   000000BE   0xD104             BNE.N    ??UART_Init_6
    420          	{
    421          		/* Set up clock and power for UART module */
    422          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000000C6   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    423          	}
    424          #endif
    425          
    426          #ifdef _UART3
    427          	if(UARTx == LPC_UART3)
   \                     ??UART_Init_6: (+1)
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   000000CE   0x4284             CMP      R4,R0
   \   000000D0   0xD104             BNE.N    ??UART_Init_7
    428          	{
    429          		/* Set up clock and power for UART module */
    430          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0xF05F 0x7000      MOVS     R0,#+33554432
   \   000000D8   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    431          	}
    432          #endif
    433          
    434          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_Init_7: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD128             BNE.N    ??UART_Init_8
    435          	{
    436          		/* FIFOs are empty */
    437          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
    438          				| UART_FCR_RX_RS | UART_FCR_TX_RS);
   \   000000E4   0x2007             MOVS     R0,#+7
   \   000000E6   0x7220             STRB     R0,[R4, #+8]
    439          		// Disable FIFO
    440          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x7220             STRB     R0,[R4, #+8]
    441          
    442          		// Dummy reading
    443          		while (((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_RDR)
   \                     ??UART_Init_9: (+1)
   \   000000EC   0x7D20             LDRB     R0,[R4, #+20]
   \   000000EE   0x07C0             LSLS     R0,R0,#+31
   \   000000F0   0xD502             BPL.N    ??UART_Init_10
    444          		{
    445          			tmp = ((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR;
   \   000000F2   0x7820             LDRB     R0,[R4, #+0]
   \   000000F4   0x0006             MOVS     R6,R0
   \   000000F6   0xE7F9             B.N      ??UART_Init_9
    446          		}
    447          
    448          		((LPC_UART1_TypeDef *)UARTx)->TER = UART_TER_TXEN;
   \                     ??UART_Init_10: (+1)
   \   000000F8   0x2080             MOVS     R0,#+128
   \   000000FA   0xF884 0x0030      STRB     R0,[R4, #+48]
    449          		// Wait for current transmit complete
    450          		while (!(((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_THRE));
   \                     ??UART_Init_11: (+1)
   \   000000FE   0x7D20             LDRB     R0,[R4, #+20]
   \   00000100   0x0680             LSLS     R0,R0,#+26
   \   00000102   0xD5FC             BPL.N    ??UART_Init_11
    451          		// Disable Tx
    452          		((LPC_UART1_TypeDef *)UARTx)->TER = 0;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0030      STRB     R0,[R4, #+48]
    453          
    454          		// Disable interrupt
    455          		((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6060             STR      R0,[R4, #+4]
    456          		// Set LCR to default state
    457          		((LPC_UART1_TypeDef *)UARTx)->LCR = 0;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x7320             STRB     R0,[R4, #+12]
    458          		// Set ACR to default state
    459          		((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x6220             STR      R0,[R4, #+32]
    460          		// Set Modem Control to default state
    461          		((LPC_UART1_TypeDef *)UARTx)->MCR = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x7420             STRB     R0,[R4, #+16]
    462          		// Set RS485 control to default state
    463          		((LPC_UART1_TypeDef *)UARTx)->RS485CTRL = 0;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF884 0x004C      STRB     R0,[R4, #+76]
    464          		// Set RS485 delay timer to default state
    465          		((LPC_UART1_TypeDef *)UARTx)->RS485DLY = 0;
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF884 0x0054      STRB     R0,[R4, #+84]
    466          		// Set RS485 addr match to default state
    467          		((LPC_UART1_TypeDef *)UARTx)->ADRMATCH = 0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF884 0x0050      STRB     R0,[R4, #+80]
    468          		//Dummy Reading to Clear Status
    469          		tmp = ((LPC_UART1_TypeDef *)UARTx)->MSR;
   \   0000012C   0x7E20             LDRB     R0,[R4, #+24]
   \   0000012E   0x0006             MOVS     R6,R0
    470          		tmp = ((LPC_UART1_TypeDef *)UARTx)->LSR;
   \   00000130   0x7D20             LDRB     R0,[R4, #+20]
   \   00000132   0x0006             MOVS     R6,R0
   \   00000134   0xE01A             B.N      ??UART_Init_12
    471          	}
    472          	else
    473          	{
    474          		/* FIFOs are empty */
    475          		UARTx->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
   \                     ??UART_Init_8: (+1)
   \   00000136   0x2007             MOVS     R0,#+7
   \   00000138   0x7220             STRB     R0,[R4, #+8]
    476          		// Disable FIFO
    477          		UARTx->/*IIFCR.*/FCR = 0;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x7220             STRB     R0,[R4, #+8]
    478          
    479          		// Dummy reading
    480          		while (UARTx->LSR & UART_LSR_RDR)
   \                     ??UART_Init_13: (+1)
   \   0000013E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000140   0x07C0             LSLS     R0,R0,#+31
   \   00000142   0xD502             BPL.N    ??UART_Init_14
    481          		{
    482          			tmp = UARTx->/*RBTHDLR.*/RBR;
   \   00000144   0x7820             LDRB     R0,[R4, #+0]
   \   00000146   0x0006             MOVS     R6,R0
   \   00000148   0xE7F9             B.N      ??UART_Init_13
    483          		}
    484          
    485          		UARTx->TER = UART_TER_TXEN;
   \                     ??UART_Init_14: (+1)
   \   0000014A   0x2080             MOVS     R0,#+128
   \   0000014C   0xF884 0x0030      STRB     R0,[R4, #+48]
    486          		// Wait for current transmit complete
    487          		while (!(UARTx->LSR & UART_LSR_THRE));
   \                     ??UART_Init_15: (+1)
   \   00000150   0x7D20             LDRB     R0,[R4, #+20]
   \   00000152   0x0680             LSLS     R0,R0,#+26
   \   00000154   0xD5FC             BPL.N    ??UART_Init_15
    488          		// Disable Tx
    489          		UARTx->TER = 0;
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF884 0x0030      STRB     R0,[R4, #+48]
    490          
    491          		// Disable interrupt
    492          		UARTx->/*DLIER.*/IER = 0;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x6060             STR      R0,[R4, #+4]
    493          		// Set LCR to default state
    494          		UARTx->LCR = 0;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x7320             STRB     R0,[R4, #+12]
    495          		// Set ACR to default state
    496          		UARTx->ACR = 0;
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x6220             STR      R0,[R4, #+32]
    497          		// Dummy reading
    498          		tmp = UARTx->LSR;
   \   00000168   0x7D20             LDRB     R0,[R4, #+20]
   \   0000016A   0x0006             MOVS     R6,R0
    499          	}
    500          
    501          	if (UARTx == LPC_UART3)
   \                     ??UART_Init_12: (+1)
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000170   0x4284             CMP      R4,R0
   \   00000172   0xD102             BNE.N    ??UART_Init_16
    502          	{
    503          		// Set IrDA to default state
    504          		UARTx->ICR = 0;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF884 0x0024      STRB     R0,[R4, #+36]
    505          	}
    506          
    507          	// Set Line Control register ----------------------------
    508          
    509          	uart_set_divisors(UARTx, (UART_ConfigStruct->Baud_rate));
   \                     ??UART_Init_16: (+1)
   \   0000017A   0x6829             LDR      R1,[R5, #+0]
   \   0000017C   0x0020             MOVS     R0,R4
   \   0000017E   0x.... 0x....      BL       uart_set_divisors
    510          
    511          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   00000186   0x4284             CMP      R4,R0
   \   00000188   0xD104             BNE.N    ??UART_Init_17
    512          	{
    513          		tmp = (((LPC_UART1_TypeDef *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
    514          				& UART_LCR_BITMASK;
   \   0000018A   0x7B20             LDRB     R0,[R4, #+12]
   \   0000018C   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000190   0x0006             MOVS     R6,R0
   \   00000192   0xE003             B.N      ??UART_Init_18
    515          	}
    516          	else
    517          	{
    518          		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
   \                     ??UART_Init_17: (+1)
   \   00000194   0x7B20             LDRB     R0,[R4, #+12]
   \   00000196   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   0000019A   0x0006             MOVS     R6,R0
    519          	}
    520          
    521          	switch (UART_ConfigStruct->Databits){
   \                     ??UART_Init_18: (+1)
   \   0000019C   0x7968             LDRB     R0,[R5, #+5]
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD003             BEQ.N    ??UART_Init_19
   \   000001A2   0x2802             CMP      R0,#+2
   \   000001A4   0xD005             BEQ.N    ??UART_Init_20
   \   000001A6   0xD301             BCC.N    ??UART_Init_21
   \   000001A8   0xE006             B.N      ??UART_Init_22
    522          	case UART_DATABIT_5:
    523          		tmp |= UART_LCR_WLEN5;
    524          		break;
   \                     ??UART_Init_19: (+1)
   \   000001AA   0xE007             B.N      ??UART_Init_23
    525          	case UART_DATABIT_6:
    526          		tmp |= UART_LCR_WLEN6;
   \                     ??UART_Init_21: (+1)
   \   000001AC   0xF056 0x0601      ORRS     R6,R6,#0x1
    527          		break;
   \   000001B0   0xE004             B.N      ??UART_Init_23
    528          	case UART_DATABIT_7:
    529          		tmp |= UART_LCR_WLEN7;
   \                     ??UART_Init_20: (+1)
   \   000001B2   0xF056 0x0602      ORRS     R6,R6,#0x2
    530          		break;
   \   000001B6   0xE001             B.N      ??UART_Init_23
    531          	case UART_DATABIT_8:
    532          	default:
    533          		tmp |= UART_LCR_WLEN8;
   \                     ??UART_Init_22: (+1)
   \   000001B8   0xF056 0x0603      ORRS     R6,R6,#0x3
    534          		break;
    535          	}
    536          
    537          	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
   \                     ??UART_Init_23: (+1)
   \   000001BC   0x7928             LDRB     R0,[R5, #+4]
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD015             BEQ.N    ??UART_Init_24
    538          	{
    539          		// Do nothing...
    540          	}
    541          	else
    542          	{
    543          		tmp |= UART_LCR_PARITY_EN;
   \   000001C2   0xF056 0x0608      ORRS     R6,R6,#0x8
    544          		switch (UART_ConfigStruct->Parity)
   \   000001C6   0x7928             LDRB     R0,[R5, #+4]
   \   000001C8   0x2801             CMP      R0,#+1
   \   000001CA   0xD006             BEQ.N    ??UART_Init_25
   \   000001CC   0xD30F             BCC.N    ??UART_Init_26
   \   000001CE   0x2803             CMP      R0,#+3
   \   000001D0   0xD007             BEQ.N    ??UART_Init_27
   \   000001D2   0xD303             BCC.N    ??UART_Init_28
   \   000001D4   0x2804             CMP      R0,#+4
   \   000001D6   0xD007             BEQ.N    ??UART_Init_29
   \   000001D8   0xE009             B.N      ??UART_Init_26
    545          		{
    546          		case UART_PARITY_ODD:
    547          			tmp |= UART_LCR_PARITY_ODD;
    548          			break;
   \                     ??UART_Init_25: (+1)
   \   000001DA   0xE008             B.N      ??UART_Init_24
    549          
    550          		case UART_PARITY_EVEN:
    551          			tmp |= UART_LCR_PARITY_EVEN;
   \                     ??UART_Init_28: (+1)
   \   000001DC   0xF056 0x0610      ORRS     R6,R6,#0x10
    552          			break;
   \   000001E0   0xE005             B.N      ??UART_Init_24
    553          
    554          		case UART_PARITY_SP_1:
    555          			tmp |= UART_LCR_PARITY_F_1;
   \                     ??UART_Init_27: (+1)
   \   000001E2   0xF056 0x0620      ORRS     R6,R6,#0x20
    556          			break;
   \   000001E6   0xE002             B.N      ??UART_Init_24
    557          
    558          		case UART_PARITY_SP_0:
    559          			tmp |= UART_LCR_PARITY_F_0;
   \                     ??UART_Init_29: (+1)
   \   000001E8   0xF056 0x0630      ORRS     R6,R6,#0x30
    560          			break;
   \   000001EC   0xE7FF             B.N      ??UART_Init_24
    561          		default:
    562          			break;
    563          		}
    564          	}
    565          
    566          	switch (UART_ConfigStruct->Stopbits){
   \                     ??UART_Init_26: (+1)
   \                     ??UART_Init_24: (+1)
   \   000001EE   0x79A8             LDRB     R0,[R5, #+6]
   \   000001F0   0x2801             CMP      R0,#+1
   \   000001F2   0xD102             BNE.N    ??UART_Init_30
    567          	case UART_STOPBIT_2:
    568          		tmp |= UART_LCR_STOPBIT_SEL;
   \   000001F4   0xF056 0x0604      ORRS     R6,R6,#0x4
    569          		break;
   \   000001F8   0xE7FF             B.N      ??UART_Init_31
    570          	case UART_STOPBIT_1:
    571          	default:
    572          		// Do no thing
    573          		break;
    574          	}
    575          
    576          
    577          	// Write back to LCR, configure FIFO and Disable Tx
    578          	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
   \                     ??UART_Init_30: (+1)
   \                     ??UART_Init_31: (+1)
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable14_1  ;; 0x40010000
   \   000001FE   0x4284             CMP      R4,R0
   \   00000200   0xD101             BNE.N    ??UART_Init_32
    579          	{
    580          		((LPC_UART1_TypeDef *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \   00000202   0x7326             STRB     R6,[R4, #+12]
   \   00000204   0xE000             B.N      ??UART_Init_33
    581          	}
    582          	else
    583          	{
    584          		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \                     ??UART_Init_32: (+1)
   \   00000206   0x7326             STRB     R6,[R4, #+12]
    585          	}
    586          }
   \                     ??UART_Init_33: (+1)
   \   00000208   0xBD70             POP      {R4-R6,PC}       ;; return
    587          
    588          
    589          /*****************************************************************************//**
    590          * @brief		Fills each UART_InitStruct member with its default value:
    591          * 				9600 bps
    592          * 				8-bit data
    593          * 				1 Stopbit
    594          * 				None Parity
    595          * @param[in]	UART_InitStruct Pointer to a UART_CFG_Type structure
    596          *                    which will be initialized.
    597          * @return		None
    598          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    599          void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
    600          {
    601          	UART_InitStruct->Baud_rate = 9600;
   \                     UART_ConfigStructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    602          	UART_InitStruct->Databits = UART_DATABIT_8;
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    603          	UART_InitStruct->Parity = UART_PARITY_NONE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7101             STRB     R1,[R0, #+4]
    604          	UART_InitStruct->Stopbits = UART_STOPBIT_1;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7181             STRB     R1,[R0, #+6]
    605          }
   \   00000012   0x4770             BX       LR               ;; return
    606          
    607          
    608          /*********************************************************************//**
    609           * @brief		Transmit a single data through UART peripheral
    610           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    611           * 						UART2 or UART3.
    612           * @param[in]	Data	Data to transmit (must be 8-bit long)
    613           * @return none
    614           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    615          void UART_SendData(LPC_UART_TypeDef* UARTx, uint8_t Data)
    616          {
   \                     UART_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    617          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??UART_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??UART_SendData_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??UART_SendData_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??UART_SendData_0
   \   00000026   0xF240 0x2169      MOVW     R1,#+617
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002E   0x.... 0x....      BL       check_failed
    618          
    619          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_SendData_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD101             BNE.N    ??UART_SendData_1
    620          	{
    621          		((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
   \   0000003A   0x7025             STRB     R5,[R4, #+0]
   \   0000003C   0xE000             B.N      ??UART_SendData_2
    622          	}
    623          	else
    624          	{
    625          		UARTx->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
   \                     ??UART_SendData_1: (+1)
   \   0000003E   0x7025             STRB     R5,[R4, #+0]
    626          	}
    627          
    628          }
   \                     ??UART_SendData_2: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    629          
    630          
    631          /*********************************************************************//**
    632           * @brief		Receive a single data from UART peripheral
    633           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    634           * 						UART2 or UART3.
    635           * @return 		Data received
    636           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    637          uint8_t UART_ReceiveData(LPC_UART_TypeDef* UARTx)
    638          {
   \                     UART_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    639          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_ReceiveData_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_ReceiveData_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_ReceiveData_0
   \   00000024   0xF240 0x217F      MOVW     R1,#+639
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002C   0x.... 0x....      BL       check_failed
    640          
    641          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ReceiveData_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD101             BNE.N    ??UART_ReceiveData_1
    642          	{
    643          		return (((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0xE000             B.N      ??UART_ReceiveData_2
    644          	}
    645          	else
    646          	{
    647          		return (UARTx->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
   \                     ??UART_ReceiveData_1: (+1)
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \                     ??UART_ReceiveData_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    648          	}
    649          }
    650          
    651          
    652          /*********************************************************************//**
    653           * @brief		Force BREAK character on UART line, output pin UARTx TXD is
    654          				forced to logic 0.
    655           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    656           * 						UART2 or UART3.
    657           * @return none
    658           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    659          void UART_ForceBreak(LPC_UART_TypeDef* UARTx)
    660          {
   \                     UART_ForceBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    661          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_ForceBreak_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_ForceBreak_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_ForceBreak_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_ForceBreak_0
   \   00000024   0xF240 0x2195      MOVW     R1,#+661
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002C   0x.... 0x....      BL       check_failed
    662          
    663          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ForceBreak_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD104             BNE.N    ??UART_ForceBreak_1
    664          	{
    665          		((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_BREAK_EN;
   \   00000038   0x7B20             LDRB     R0,[R4, #+12]
   \   0000003A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003E   0x7320             STRB     R0,[R4, #+12]
   \   00000040   0xE003             B.N      ??UART_ForceBreak_2
    666          	}
    667          	else
    668          	{
    669          		UARTx->LCR |= UART_LCR_BREAK_EN;
   \                     ??UART_ForceBreak_1: (+1)
   \   00000042   0x7B20             LDRB     R0,[R4, #+12]
   \   00000044   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000048   0x7320             STRB     R0,[R4, #+12]
    670          	}
    671          }
   \                     ??UART_ForceBreak_2: (+1)
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    672          
    673          
    674          #ifdef _UART3
    675          
    676          /*********************************************************************//**
    677           * @brief		Enable or disable inverting serial input function of IrDA
    678           * 				on UART peripheral.
    679           * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
    680           * @param[in]	NewState New state of inverting serial input, should be:
    681           * 				- ENABLE: Enable this function.
    682           * 				- DISABLE: Disable this function.
    683           * @return none
    684           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
    686          {
   \                     UART_IrDAInvtInputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    687          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??UART_IrDAInvtInputCmd_0
   \   0000000E   0xF240 0x21AF      MOVW     R1,#+687
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000016   0x.... 0x....      BL       check_failed
    688          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IrDAInvtInputCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??UART_IrDAInvtInputCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??UART_IrDAInvtInputCmd_1
   \   00000026   0xF44F 0x712C      MOV      R1,#+688
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002E   0x.... 0x....      BL       check_failed
    689          
    690          	if (NewState == ENABLE)
   \                     ??UART_IrDAInvtInputCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD106             BNE.N    ??UART_IrDAInvtInputCmd_2
    691          	{
    692          		UARTx->ICR |= UART_ICR_IRDAINV;
   \   00000038   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000003C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000040   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   00000044   0xE008             B.N      ??UART_IrDAInvtInputCmd_3
    693          	}
    694          	else if (NewState == DISABLE)
   \                     ??UART_IrDAInvtInputCmd_2: (+1)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD105             BNE.N    ??UART_IrDAInvtInputCmd_3
    695          	{
    696          		UARTx->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
   \   0000004C   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000050   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   00000054   0xF884 0x0024      STRB     R0,[R4, #+36]
    697          	}
    698          }
   \                     ??UART_IrDAInvtInputCmd_3: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    699          
    700          
    701          /*********************************************************************//**
    702           * @brief		Enable or disable IrDA function on UART peripheral.
    703           * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
    704           * @param[in]	NewState New state of IrDA function, should be:
    705           * 				- ENABLE: Enable this function.
    706           * 				- DISABLE: Disable this function.
    707           * @return none
    708           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    709          void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
    710          {
   \                     UART_IrDACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    711          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??UART_IrDACmd_0
   \   0000000E   0xF240 0x21C7      MOVW     R1,#+711
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000016   0x.... 0x....      BL       check_failed
    712          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IrDACmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??UART_IrDACmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??UART_IrDACmd_1
   \   00000026   0xF44F 0x7132      MOV      R1,#+712
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002E   0x.... 0x....      BL       check_failed
    713          
    714          	if (NewState == ENABLE)
   \                     ??UART_IrDACmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD106             BNE.N    ??UART_IrDACmd_2
    715          	{
    716          		UARTx->ICR |= UART_ICR_IRDAEN;
   \   00000038   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000003C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000040   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   00000044   0xE005             B.N      ??UART_IrDACmd_3
    717          	}
    718          	else
    719          	{
    720          		UARTx->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
   \                     ??UART_IrDACmd_2: (+1)
   \   00000046   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000004A   0xF010 0x003E      ANDS     R0,R0,#0x3E
   \   0000004E   0xF884 0x0024      STRB     R0,[R4, #+36]
    721          	}
    722          }
   \                     ??UART_IrDACmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    723          
    724          
    725          /*********************************************************************//**
    726           * @brief		Configure Pulse divider for IrDA function on UART peripheral.
    727           * @param[in]	UARTx UART peripheral selected, should be UART3 (only)
    728           * @param[in]	PulseDiv Pulse Divider value from Peripheral clock,
    729           * 				should be one of the following:
    730          				- UART_IrDA_PULSEDIV2 	: Pulse width = 2 * Tpclk
    731          				- UART_IrDA_PULSEDIV4 	: Pulse width = 4 * Tpclk
    732          				- UART_IrDA_PULSEDIV8 	: Pulse width = 8 * Tpclk
    733          				- UART_IrDA_PULSEDIV16 	: Pulse width = 16 * Tpclk
    734          				- UART_IrDA_PULSEDIV32 	: Pulse width = 32 * Tpclk
    735          				- UART_IrDA_PULSEDIV64 	: Pulse width = 64 * Tpclk
    736          				- UART_IrDA_PULSEDIV128 : Pulse width = 128 * Tpclk
    737          				- UART_IrDA_PULSEDIV256 : Pulse width = 256 * Tpclk
    738          
    739           * @return none
    740           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    741          void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
    742          {
   \                     UART_IrDAPulseDivConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    743          	uint32_t tmp, tmp1;
    744          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??UART_IrDAPulseDivConfig_0
   \   0000000E   0xF44F 0x713A      MOV      R1,#+744
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000016   0x.... 0x....      BL       check_failed
    745          	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
   \                     ??UART_IrDAPulseDivConfig_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD01A             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD017             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D02             CMP      R5,#+2
   \   0000002A   0xD014             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D03             CMP      R5,#+3
   \   00000030   0xD011             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D04             CMP      R5,#+4
   \   00000036   0xD00E             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D05             CMP      R5,#+5
   \   0000003C   0xD00B             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D06             CMP      R5,#+6
   \   00000042   0xD008             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D07             CMP      R5,#+7
   \   00000048   0xD005             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000004A   0xF240 0x21E9      MOVW     R1,#+745
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000052   0x.... 0x....      BL       check_failed
    746          
    747          	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
   \                     ??UART_IrDAPulseDivConfig_1: (+1)
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x00E8             LSLS     R0,R5,#+3
   \   0000005A   0xF010 0x0038      ANDS     R0,R0,#0x38
   \   0000005E   0x0007             MOVS     R7,R0
    748          	tmp = UARTx->ICR & (~UART_ICR_PULSEDIV(7));
   \   00000060   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000064   0xF030 0x0038      BICS     R0,R0,#0x38
   \   00000068   0x0006             MOVS     R6,R0
    749          	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
   \   0000006A   0xF057 0x0004      ORRS     R0,R7,#0x4
   \   0000006E   0x4306             ORRS     R6,R0,R6
    750          	UARTx->ICR = tmp & UART_ICR_BITMASK;
   \   00000070   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   00000074   0xF884 0x0024      STRB     R0,[R4, #+36]
    751          }
   \   00000078   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    752          
    753          #endif
    754          
    755          
    756          /********************************************************************//**
    757           * @brief 		Enable or disable specified UART interrupt.
    758           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    759           * 						UART2 or UART3.
    760           * @param[in]	UARTIntCfg	Specifies the interrupt flag,
    761           * 				should be one of the following:
    762          				- UART_INTCFG_RBR 	:  RBR Interrupt enable
    763          				- UART_INTCFG_THRE 	:  THR Interrupt enable
    764          				- UART_INTCFG_RLS 	:  RX line status interrupt enable
    765          				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
    766          				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
    767          				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
    768          				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
    769           * @param[in]	NewState New state of specified UART interrupt type,
    770           * 				should be:
    771           * 				- ENALBE: Enable this UART interrupt type.
    772          * 				- DISALBE: Disable this UART interrupt type.
    773           * @return 		None
    774           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    775          void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
    776          {
   \                     UART_IntConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    777          	uint32_t tmp;
    778          
    779          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x4000c000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD011             BEQ.N    ??UART_IntConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??UART_IntConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40098000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD009             BEQ.N    ??UART_IntConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x4009c000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD005             BEQ.N    ??UART_IntConfig_0
   \   00000028   0xF240 0x310B      MOVW     R1,#+779
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000030   0x.... 0x....      BL       check_failed
    780          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IntConfig_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD008             BEQ.N    ??UART_IntConfig_1
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD005             BEQ.N    ??UART_IntConfig_1
   \   00000040   0xF44F 0x7143      MOV      R1,#+780
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000048   0x.... 0x....      BL       check_failed
    781          
    782          	switch(UARTIntCfg){
   \                     ??UART_IntConfig_1: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD009             BEQ.N    ??UART_IntConfig_2
   \   00000052   0x2D02             CMP      R5,#+2
   \   00000054   0xD00D             BEQ.N    ??UART_IntConfig_3
   \   00000056   0xD309             BCC.N    ??UART_IntConfig_4
   \   00000058   0x2D04             CMP      R5,#+4
   \   0000005A   0xD010             BEQ.N    ??UART_IntConfig_5
   \   0000005C   0xD30C             BCC.N    ??UART_IntConfig_6
   \   0000005E   0x2D06             CMP      R5,#+6
   \   00000060   0xD014             BEQ.N    ??UART_IntConfig_7
   \   00000062   0xD30F             BCC.N    ??UART_IntConfig_8
   \   00000064   0xE015             B.N      ??UART_IntConfig_9
    783          		case UART_INTCFG_RBR:
    784          			tmp = UART_IER_RBRINT_EN;
   \                     ??UART_IntConfig_2: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x0007             MOVS     R7,R0
    785          			break;
   \   0000006A   0xE012             B.N      ??UART_IntConfig_9
    786          		case UART_INTCFG_THRE:
    787          			tmp = UART_IER_THREINT_EN;
   \                     ??UART_IntConfig_4: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x0007             MOVS     R7,R0
    788          			break;
   \   00000070   0xE00F             B.N      ??UART_IntConfig_9
    789          		case UART_INTCFG_RLS:
    790          			tmp = UART_IER_RLSINT_EN;
   \                     ??UART_IntConfig_3: (+1)
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x0007             MOVS     R7,R0
    791          			break;
   \   00000076   0xE00C             B.N      ??UART_IntConfig_9
    792          		case UART1_INTCFG_MS:
    793          			tmp = UART1_IER_MSINT_EN;
   \                     ??UART_IntConfig_6: (+1)
   \   00000078   0x2008             MOVS     R0,#+8
   \   0000007A   0x0007             MOVS     R7,R0
    794          			break;
   \   0000007C   0xE009             B.N      ??UART_IntConfig_9
    795          		case UART1_INTCFG_CTS:
    796          			tmp = UART1_IER_CTSINT_EN;
   \                     ??UART_IntConfig_5: (+1)
   \   0000007E   0x2080             MOVS     R0,#+128
   \   00000080   0x0007             MOVS     R7,R0
    797          			break;
   \   00000082   0xE006             B.N      ??UART_IntConfig_9
    798          		case UART_INTCFG_ABEO:
    799          			tmp = UART_IER_ABEOINT_EN;
   \                     ??UART_IntConfig_8: (+1)
   \   00000084   0xF44F 0x7080      MOV      R0,#+256
   \   00000088   0x0007             MOVS     R7,R0
    800          			break;
   \   0000008A   0xE002             B.N      ??UART_IntConfig_9
    801          		case UART_INTCFG_ABTO:
    802          			tmp = UART_IER_ABTOINT_EN;
   \                     ??UART_IntConfig_7: (+1)
   \   0000008C   0xF44F 0x7000      MOV      R0,#+512
   \   00000090   0x0007             MOVS     R7,R0
    803          			break;
    804          	}
    805          
    806          	if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART_IntConfig_9: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD11B             BNE.N    ??UART_IntConfig_10
    807          	{
    808          		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D00             CMP      R5,#+0
   \   0000009E   0xD02D             BEQ.N    ??UART_IntConfig_11
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D01             CMP      R5,#+1
   \   000000A4   0xD02A             BEQ.N    ??UART_IntConfig_11
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D02             CMP      R5,#+2
   \   000000AA   0xD027             BEQ.N    ??UART_IntConfig_11
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D05             CMP      R5,#+5
   \   000000B0   0xD024             BEQ.N    ??UART_IntConfig_11
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D06             CMP      R5,#+6
   \   000000B6   0xD021             BEQ.N    ??UART_IntConfig_11
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D03             CMP      R5,#+3
   \   000000BC   0xD01E             BEQ.N    ??UART_IntConfig_11
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D04             CMP      R5,#+4
   \   000000C2   0xD01B             BEQ.N    ??UART_IntConfig_11
   \   000000C4   0xF44F 0x714A      MOV      R1,#+808
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   000000CC   0x.... 0x....      BL       check_failed
   \   000000D0   0xE014             B.N      ??UART_IntConfig_11
    809          	}
    810          	else
    811          	{
    812          		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
   \                     ??UART_IntConfig_10: (+1)
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD011             BEQ.N    ??UART_IntConfig_11
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0x2D01             CMP      R5,#+1
   \   000000DC   0xD00E             BEQ.N    ??UART_IntConfig_11
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0x2D02             CMP      R5,#+2
   \   000000E2   0xD00B             BEQ.N    ??UART_IntConfig_11
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0x2D05             CMP      R5,#+5
   \   000000E8   0xD008             BEQ.N    ??UART_IntConfig_11
   \   000000EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EC   0x2D06             CMP      R5,#+6
   \   000000EE   0xD005             BEQ.N    ??UART_IntConfig_11
   \   000000F0   0xF44F 0x714B      MOV      R1,#+812
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   000000F8   0x.... 0x....      BL       check_failed
    813          	}
    814          
    815          	if (NewState == ENABLE)
   \                     ??UART_IntConfig_11: (+1)
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x2E01             CMP      R6,#+1
   \   00000100   0xD10B             BNE.N    ??UART_IntConfig_12
    816          	{
    817          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000106   0x4284             CMP      R4,R0
   \   00000108   0xD103             BNE.N    ??UART_IntConfig_13
    818          		{
    819          			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER |= tmp;
   \   0000010A   0x6860             LDR      R0,[R4, #+4]
   \   0000010C   0x4338             ORRS     R0,R7,R0
   \   0000010E   0x6060             STR      R0,[R4, #+4]
   \   00000110   0xE014             B.N      ??UART_IntConfig_14
    820          		}
    821          		else
    822          		{
    823          			UARTx->/*DLIER.*/IER |= tmp;
   \                     ??UART_IntConfig_13: (+1)
   \   00000112   0x6860             LDR      R0,[R4, #+4]
   \   00000114   0x4338             ORRS     R0,R7,R0
   \   00000116   0x6060             STR      R0,[R4, #+4]
   \   00000118   0xE010             B.N      ??UART_IntConfig_14
    824          		}
    825          	}
    826          	else
    827          	{
    828          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART_IntConfig_12: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD106             BNE.N    ??UART_IntConfig_15
    829          		{
    830          			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER &= (~tmp) & UART1_IER_BITMASK;
   \   00000122   0x6860             LDR      R0,[R4, #+4]
   \   00000124   0xF240 0x318F      MOVW     R1,#+911
   \   00000128   0x43B9             BICS     R1,R1,R7
   \   0000012A   0x4008             ANDS     R0,R1,R0
   \   0000012C   0x6060             STR      R0,[R4, #+4]
   \   0000012E   0xE005             B.N      ??UART_IntConfig_14
    831          		}
    832          		else
    833          		{
    834          			UARTx->/*DLIER.*/IER &= (~tmp) & UART_IER_BITMASK;
   \                     ??UART_IntConfig_15: (+1)
   \   00000130   0x6860             LDR      R0,[R4, #+4]
   \   00000132   0xF240 0x3107      MOVW     R1,#+775
   \   00000136   0x43B9             BICS     R1,R1,R7
   \   00000138   0x4008             ANDS     R0,R1,R0
   \   0000013A   0x6060             STR      R0,[R4, #+4]
    835          		}
    836          	}
    837          }
   \                     ??UART_IntConfig_14: (+1)
   \   0000013C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    838          
    839          
    840          /********************************************************************//**
    841           * @brief 		Get current value of Line Status register in UART peripheral.
    842           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    843           * 						UART2 or UART3.
    844           * @return		Current value of Line Status register in UART peripheral.
    845           * Note:	The return value of this function must be ANDed with each member in
    846           * 			UART_LS_Type enumeration to determine current flag status
    847           * 			corresponding to each Line status type. Because some flags in
    848           * 			Line Status register will be cleared after reading, the next reading
    849           * 			Line Status register could not be correct. So this function used to
    850           * 			read Line status register in one time only, then the return value
    851           * 			used to check all flags.
    852           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    853          uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx)
    854          {
   \                     UART_GetLineStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    855          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x....             LDR.N    R0,??DataTable14  ;; 0x4000c000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00E             BEQ.N    ??UART_GetLineStatus_0
   \   0000000A   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40010000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00B             BEQ.N    ??UART_GetLineStatus_0
   \   00000010   0x....             LDR.N    R0,??DataTable15  ;; 0x40098000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD008             BEQ.N    ??UART_GetLineStatus_0
   \   00000016   0x....             LDR.N    R0,??DataTable15_2  ;; 0x4009c000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??UART_GetLineStatus_0
   \   0000001C   0xF240 0x3157      MOVW     R1,#+855
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000024   0x.... 0x....      BL       check_failed
    856          
    857          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_GetLineStatus_0: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40010000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD104             BNE.N    ??UART_GetLineStatus_1
    858          	{
    859          		return ((((LPC_UART1_TypeDef *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40010014
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE000             B.N      ??UART_GetLineStatus_2
    860          	}
    861          	else
    862          	{
    863          		return ((UARTx->LSR) & UART_LSR_BITMASK);
   \                     ??UART_GetLineStatus_1: (+1)
   \   00000038   0x7D20             LDRB     R0,[R4, #+20]
   \                     ??UART_GetLineStatus_2: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    864          	}
    865          }
    866          
    867          /*********************************************************************//**
    868           * @brief		Check whether if UART is busy or not
    869           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    870           * 						UART2 or UART3.
    871           * @return		RESET if UART is not busy, otherwise return SET.
    872           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    873          FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx)
    874          {
   \                     UART_CheckBusy: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    875          	if (UARTx->LSR & UART_LSR_TEMT){
   \   00000002   0x7D08             LDRB     R0,[R1, #+20]
   \   00000004   0x0640             LSLS     R0,R0,#+25
   \   00000006   0xD501             BPL.N    ??UART_CheckBusy_0
    876          		return RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE000             B.N      ??UART_CheckBusy_1
    877          	} else {
    878          		return SET;
   \                     ??UART_CheckBusy_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \                     ??UART_CheckBusy_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    879          	}
    880          }
    881          
    882          
    883          /*********************************************************************//**
    884           * @brief		Configure FIFO function on selected UART peripheral
    885           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    886           * 						UART2 or UART3.
    887           * @param[in]	FIFOCfg	Pointer to a UART_FIFO_CFG_Type Structure that
    888           * 						contains specified information about FIFO configuration
    889           * @return 		none
    890           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    891          void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
    892          {
   \                     UART_FIFOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    893          	uint8_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    894          
    895          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable14  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00F             BEQ.N    ??UART_FIFOConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00B             BEQ.N    ??UART_FIFOConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??UART_FIFOConfig_0
   \   0000001C   0x....             LDR.N    R0,??DataTable15_2  ;; 0x4009c000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??UART_FIFOConfig_0
   \   00000022   0xF240 0x317F      MOVW     R1,#+895
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002A   0x.... 0x....      BL       check_failed
    896          	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg->FIFO_Level));
   \                     ??UART_FIFOConfig_0: (+1)
   \   0000002E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00E             BEQ.N    ??UART_FIFOConfig_1
   \   00000034   0x78E8             LDRB     R0,[R5, #+3]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD00B             BEQ.N    ??UART_FIFOConfig_1
   \   0000003A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD008             BEQ.N    ??UART_FIFOConfig_1
   \   00000040   0x78E8             LDRB     R0,[R5, #+3]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xD005             BEQ.N    ??UART_FIFOConfig_1
   \   00000046   0xF44F 0x7160      MOV      R1,#+896
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000004E   0x.... 0x....      BL       check_failed
    897          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_DMAMode));
   \                     ??UART_FIFOConfig_1: (+1)
   \   00000052   0x78A8             LDRB     R0,[R5, #+2]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD008             BEQ.N    ??UART_FIFOConfig_2
   \   00000058   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD005             BEQ.N    ??UART_FIFOConfig_2
   \   0000005E   0xF240 0x3181      MOVW     R1,#+897
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000066   0x.... 0x....      BL       check_failed
    898          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetRxBuf));
   \                     ??UART_FIFOConfig_2: (+1)
   \   0000006A   0x7828             LDRB     R0,[R5, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD008             BEQ.N    ??UART_FIFOConfig_3
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD005             BEQ.N    ??UART_FIFOConfig_3
   \   00000076   0xF240 0x3182      MOVW     R1,#+898
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000007E   0x.... 0x....      BL       check_failed
    899          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetTxBuf));
   \                     ??UART_FIFOConfig_3: (+1)
   \   00000082   0x7868             LDRB     R0,[R5, #+1]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD008             BEQ.N    ??UART_FIFOConfig_4
   \   00000088   0x7868             LDRB     R0,[R5, #+1]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD005             BEQ.N    ??UART_FIFOConfig_4
   \   0000008E   0xF240 0x3183      MOVW     R1,#+899
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000096   0x.... 0x....      BL       check_failed
    900          
    901          	tmp |= UART_FCR_FIFO_EN;
   \                     ??UART_FIFOConfig_4: (+1)
   \   0000009A   0xF056 0x0601      ORRS     R6,R6,#0x1
    902          	switch (FIFOCfg->FIFO_Level){
   \   0000009E   0x78E8             LDRB     R0,[R5, #+3]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD003             BEQ.N    ??UART_FIFOConfig_5
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD005             BEQ.N    ??UART_FIFOConfig_6
   \   000000A8   0xD301             BCC.N    ??UART_FIFOConfig_7
   \   000000AA   0xE006             B.N      ??UART_FIFOConfig_8
    903          	case UART_FIFO_TRGLEV0:
    904          		tmp |= UART_FCR_TRG_LEV0;
    905          		break;
   \                     ??UART_FIFOConfig_5: (+1)
   \   000000AC   0xE007             B.N      ??UART_FIFOConfig_9
    906          	case UART_FIFO_TRGLEV1:
    907          		tmp |= UART_FCR_TRG_LEV1;
   \                     ??UART_FIFOConfig_7: (+1)
   \   000000AE   0xF056 0x0640      ORRS     R6,R6,#0x40
    908          		break;
   \   000000B2   0xE004             B.N      ??UART_FIFOConfig_9
    909          	case UART_FIFO_TRGLEV2:
    910          		tmp |= UART_FCR_TRG_LEV2;
   \                     ??UART_FIFOConfig_6: (+1)
   \   000000B4   0xF056 0x0680      ORRS     R6,R6,#0x80
    911          		break;
   \   000000B8   0xE001             B.N      ??UART_FIFOConfig_9
    912          	case UART_FIFO_TRGLEV3:
    913          	default:
    914          		tmp |= UART_FCR_TRG_LEV3;
   \                     ??UART_FIFOConfig_8: (+1)
   \   000000BA   0xF056 0x06C0      ORRS     R6,R6,#0xC0
    915          		break;
    916          	}
    917          
    918          	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
   \                     ??UART_FIFOConfig_9: (+1)
   \   000000BE   0x7868             LDRB     R0,[R5, #+1]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD101             BNE.N    ??UART_FIFOConfig_10
    919          	{
    920          		tmp |= UART_FCR_TX_RS;
   \   000000C4   0xF056 0x0604      ORRS     R6,R6,#0x4
    921          	}
    922          	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
   \                     ??UART_FIFOConfig_10: (+1)
   \   000000C8   0x7828             LDRB     R0,[R5, #+0]
   \   000000CA   0x2801             CMP      R0,#+1
   \   000000CC   0xD101             BNE.N    ??UART_FIFOConfig_11
    923          	{
    924          		tmp |= UART_FCR_RX_RS;
   \   000000CE   0xF056 0x0602      ORRS     R6,R6,#0x2
    925          	}
    926          	if (FIFOCfg->FIFO_DMAMode == ENABLE)
   \                     ??UART_FIFOConfig_11: (+1)
   \   000000D2   0x78A8             LDRB     R0,[R5, #+2]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD101             BNE.N    ??UART_FIFOConfig_12
    927          	{
    928          		tmp |= UART_FCR_DMAMODE_SEL;
   \   000000D8   0xF056 0x0608      ORRS     R6,R6,#0x8
    929          	}
    930          
    931          
    932          	//write to FIFO control register
    933          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_FIFOConfig_12: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD103             BNE.N    ??UART_FIFOConfig_13
    934          	{
    935          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
   \   000000E4   0xF016 0x00CF      ANDS     R0,R6,#0xCF
   \   000000E8   0x7220             STRB     R0,[R4, #+8]
   \   000000EA   0xE002             B.N      ??UART_FIFOConfig_14
    936          	}
    937          	else
    938          	{
    939          		UARTx->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
   \                     ??UART_FIFOConfig_13: (+1)
   \   000000EC   0xF016 0x00CF      ANDS     R0,R6,#0xCF
   \   000000F0   0x7220             STRB     R0,[R4, #+8]
    940          	}
    941          
    942          }
   \                     ??UART_FIFOConfig_14: (+1)
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
    943          
    944          
    945          /*****************************************************************************//**
    946          * @brief		Fills each UART_FIFOInitStruct member with its default value:
    947          * 				- FIFO_DMAMode = DISABLE
    948          * 				- FIFO_Level = UART_FIFO_TRGLEV0
    949          * 				- FIFO_ResetRxBuf = ENABLE
    950          * 				- FIFO_ResetTxBuf = ENABLE
    951          * 				- FIFO_State = ENABLE
    952          
    953          * @param[in]	UART_FIFOInitStruct Pointer to a UART_FIFO_CFG_Type structure
    954          *                    which will be initialized.
    955          * @return		None
    956          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    957          void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
    958          {
    959          	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
   \                     UART_FIFOConfigStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7081             STRB     R1,[R0, #+2]
    960          	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x70C1             STRB     R1,[R0, #+3]
    961          	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    962          	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
    963          }
   \   00000010   0x4770             BX       LR               ;; return
    964          
    965          
    966          /*********************************************************************//**
    967           * @brief		Start/Stop Auto Baudrate activity
    968           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
    969           * 						UART2 or UART3.
    970           * @param[in]	ABConfigStruct	A pointer to UART_AB_CFG_Type structure that
    971           * 								contains specified information about UART
    972           * 								auto baudrate configuration
    973           * @param[in]	NewState New State of Auto baudrate activity, should be:
    974           * 				- ENABLE: Start this activity
    975           *				- DISABLE: Stop this activity
    976           * Note:		Auto-baudrate mode enable bit will be cleared once this mode
    977           * 				completed.
    978           * @return 		none
    979           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    980          void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
    981          				FunctionalState NewState)
    982          {
   \                     UART_ABCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    983          	uint32_t tmp;
    984          
    985          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable14  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00F             BEQ.N    ??UART_ABCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00B             BEQ.N    ??UART_ABCmd_0
   \   00000016   0x....             LDR.N    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??UART_ABCmd_0
   \   0000001C   0x....             LDR.N    R0,??DataTable15_2  ;; 0x4009c000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??UART_ABCmd_0
   \   00000022   0xF240 0x31D9      MOVW     R1,#+985
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000002A   0x.... 0x....      BL       check_failed
    986          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_ABCmd_0: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD008             BEQ.N    ??UART_ABCmd_1
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD005             BEQ.N    ??UART_ABCmd_1
   \   0000003A   0xF240 0x31DA      MOVW     R1,#+986
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000042   0x.... 0x....      BL       check_failed
    987          
    988          	tmp = 0;
   \                     ??UART_ABCmd_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0007             MOVS     R7,R0
    989          	if (NewState == ENABLE) {
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2E01             CMP      R6,#+1
   \   0000004E   0xD109             BNE.N    ??UART_ABCmd_2
    990          		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1){
   \   00000050   0x7828             LDRB     R0,[R5, #+0]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD101             BNE.N    ??UART_ABCmd_3
    991          			tmp |= UART_ACR_MODE;
   \   00000056   0xF057 0x0702      ORRS     R7,R7,#0x2
    992          		}
    993          		if (ABConfigStruct->AutoRestart == ENABLE){
   \                     ??UART_ABCmd_3: (+1)
   \   0000005A   0x7868             LDRB     R0,[R5, #+1]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD101             BNE.N    ??UART_ABCmd_2
    994          			tmp |= UART_ACR_AUTO_RESTART;
   \   00000060   0xF057 0x0704      ORRS     R7,R7,#0x4
    995          		}
    996          	}
    997          
    998          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ABCmd_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD117             BNE.N    ??UART_ABCmd_4
    999          	{
   1000          		if (NewState == ENABLE)
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E01             CMP      R6,#+1
   \   00000070   0xD111             BNE.N    ??UART_ABCmd_5
   1001          		{
   1002          			// Clear DLL and DLM value
   1003          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   00000072   0x7B20             LDRB     R0,[R4, #+12]
   \   00000074   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000078   0x7320             STRB     R0,[R4, #+12]
   1004          			((LPC_UART1_TypeDef *)UARTx)->DLL = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7020             STRB     R0,[R4, #+0]
   1005          			((LPC_UART1_TypeDef *)UARTx)->DLM = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7120             STRB     R0,[R4, #+4]
   1006          			((LPC_UART1_TypeDef *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
   \   00000082   0x7B20             LDRB     R0,[R4, #+12]
   \   00000084   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000088   0x7320             STRB     R0,[R4, #+12]
   1007          			// FDR value must be reset to default value
   1008          			((LPC_UART1_TypeDef *)UARTx)->FDR = 0x10;
   \   0000008A   0x2010             MOVS     R0,#+16
   \   0000008C   0x62A0             STR      R0,[R4, #+40]
   1009          			((LPC_UART1_TypeDef *)UARTx)->ACR = UART_ACR_START | tmp;
   \   0000008E   0xF057 0x0001      ORRS     R0,R7,#0x1
   \   00000092   0x6220             STR      R0,[R4, #+32]
   \   00000094   0xE01A             B.N      ??UART_ABCmd_6
   1010          		}
   1011          		else
   1012          		{
   1013          			((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
   \                     ??UART_ABCmd_5: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x6220             STR      R0,[R4, #+32]
   \   0000009A   0xE017             B.N      ??UART_ABCmd_6
   1014          		}
   1015          	}
   1016          	else
   1017          	{
   1018          		if (NewState == ENABLE)
   \                     ??UART_ABCmd_4: (+1)
   \   0000009C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009E   0x2E01             CMP      R6,#+1
   \   000000A0   0xD112             BNE.N    ??UART_ABCmd_7
   1019          		{
   1020          			// Clear DLL and DLM value
   1021          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \   000000A2   0x7B20             LDRB     R0,[R4, #+12]
   \   000000A4   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A8   0x7320             STRB     R0,[R4, #+12]
   1022          			UARTx->DLL = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7020             STRB     R0,[R4, #+0]
   1023          			UARTx->DLM = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x7120             STRB     R0,[R4, #+4]
   1024          			UARTx->LCR &= ~UART_LCR_DLAB_EN;
   \   000000B2   0x7B20             LDRB     R0,[R4, #+12]
   \   000000B4   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000B8   0x7320             STRB     R0,[R4, #+12]
   1025          			// FDR value must be reset to default value
   1026          			UARTx->FDR = 0x10;
   \   000000BA   0x2010             MOVS     R0,#+16
   \   000000BC   0xF884 0x0028      STRB     R0,[R4, #+40]
   1027          			UARTx->ACR = UART_ACR_START | tmp;
   \   000000C0   0xF057 0x0001      ORRS     R0,R7,#0x1
   \   000000C4   0x6220             STR      R0,[R4, #+32]
   \   000000C6   0xE001             B.N      ??UART_ABCmd_6
   1028          		}
   1029          		else
   1030          		{
   1031          			UARTx->ACR = 0;
   \                     ??UART_ABCmd_7: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x6220             STR      R0,[R4, #+32]
   1032          		}
   1033          	}
   1034          }
   \                     ??UART_ABCmd_6: (+1)
   \   000000CC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1035          
   1036          
   1037          /*********************************************************************//**
   1038           * @brief		Enable/Disable transmission on UART TxD pin
   1039           * @param[in]	UARTx	UART peripheral selected, should be UART0, UART1,
   1040           * 						UART2 or UART3.
   1041           * @param[in]	NewState New State of Tx transmission function, should be:
   1042           * 				- ENABLE: Enable this function
   1043          				- DISABLE: Disable this function
   1044           * @return none
   1045           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1046          void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
   1047          {
   \                     UART_TxCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1048          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_2  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00E             BEQ.N    ??UART_TxCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00A             BEQ.N    ??UART_TxCmd_0
   \   00000016   0x....             LDR.N    R0,??DataTable15  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD007             BEQ.N    ??UART_TxCmd_0
   \   0000001C   0x....             LDR.N    R0,??DataTable15_2  ;; 0x4009c000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??UART_TxCmd_0
   \   00000022   0xF44F 0x6183      MOV      R1,#+1048
   \   00000026   0x....             LDR.N    R0,??DataTable19_1
   \   00000028   0x.... 0x....      BL       check_failed
   1049          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_TxCmd_0: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD007             BEQ.N    ??UART_TxCmd_1
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD004             BEQ.N    ??UART_TxCmd_1
   \   00000038   0xF240 0x4119      MOVW     R1,#+1049
   \   0000003C   0x....             LDR.N    R0,??DataTable19_1
   \   0000003E   0x.... 0x....      BL       check_failed
   1050          
   1051          	if (NewState == ENABLE)
   \                     ??UART_TxCmd_1: (+1)
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D01             CMP      R5,#+1
   \   00000046   0xD111             BNE.N    ??UART_TxCmd_2
   1052          	{
   1053          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD106             BNE.N    ??UART_TxCmd_3
   1054          		{
   1055          			((LPC_UART1_TypeDef *)UARTx)->TER |= UART_TER_TXEN;
   \   00000050   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000054   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000058   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   0000005C   0xE015             B.N      ??UART_TxCmd_4
   1056          		}
   1057          		else
   1058          		{
   1059          			UARTx->TER |= UART_TER_TXEN;
   \                     ??UART_TxCmd_3: (+1)
   \   0000005E   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000062   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000066   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   0000006A   0xE00E             B.N      ??UART_TxCmd_4
   1060          		}
   1061          	}
   1062          	else
   1063          	{
   1064          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_TxCmd_2: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD105             BNE.N    ??UART_TxCmd_5
   1065          		{
   1066          			((LPC_UART1_TypeDef *)UARTx)->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \   00000074   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   0000007E   0xE004             B.N      ??UART_TxCmd_4
   1067          		}
   1068          		else
   1069          		{
   1070          			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \                     ??UART_TxCmd_5: (+1)
   \   00000080   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF884 0x0030      STRB     R0,[R4, #+48]
   1071          		}
   1072          	}
   1073          }
   \                     ??UART_TxCmd_4: (+1)
   \   0000008A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1074          
   1075          #ifdef _UART1
   1076          
   1077          /*********************************************************************//**
   1078           * @brief		Force pin DTR/RTS corresponding to given state (Full modem mode)
   1079           * @param[in]	UARTx	UART1 (only)
   1080           * @param[in]	Pin	Pin that NewState will be applied to, should be:
   1081           * 				- UART1_MODEM_PIN_DTR: DTR pin.
   1082           * 				- UART1_MODEM_PIN_RTS: RTS pin.
   1083           * @param[in]	NewState New State of DTR/RTS pin, should be:
   1084           * 				- INACTIVE: Force the pin to inactive signal.
   1085          				- ACTIVE: Force the pin to active signal.
   1086           * @return none
   1087           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1088          void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
   1089          							UART1_SignalState NewState)
   1090          {
   \                     UART_FullModemForcePinState: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1091          	uint8_t tmp = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1092          
   1093          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??UART_FullModemForcePinState_0
   \   00000012   0xF240 0x4145      MOVW     R1,#+1093
   \   00000016   0x....             LDR.N    R0,??DataTable19_1
   \   00000018   0x.... 0x....      BL       check_failed
   1094          	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
   \                     ??UART_FullModemForcePinState_0: (+1)
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??UART_FullModemForcePinState_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xD004             BEQ.N    ??UART_FullModemForcePinState_1
   \   00000028   0xF240 0x4146      MOVW     R1,#+1094
   \   0000002C   0x....             LDR.N    R0,??DataTable19_1
   \   0000002E   0x.... 0x....      BL       check_failed
   1095          	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
   \                     ??UART_FullModemForcePinState_1: (+1)
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD007             BEQ.N    ??UART_FullModemForcePinState_2
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E01             CMP      R6,#+1
   \   0000003C   0xD004             BEQ.N    ??UART_FullModemForcePinState_2
   \   0000003E   0xF240 0x4147      MOVW     R1,#+1095
   \   00000042   0x....             LDR.N    R0,??DataTable19_1
   \   00000044   0x.... 0x....      BL       check_failed
   1096          
   1097          	switch (Pin){
   \                     ??UART_FullModemForcePinState_2: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD002             BEQ.N    ??UART_FullModemForcePinState_3
   \   0000004E   0x2D01             CMP      R5,#+1
   \   00000050   0xD003             BEQ.N    ??UART_FullModemForcePinState_4
   \   00000052   0xE005             B.N      ??UART_FullModemForcePinState_5
   1098          	case UART1_MODEM_PIN_DTR:
   1099          		tmp = UART1_MCR_DTR_CTRL;
   \                     ??UART_FullModemForcePinState_3: (+1)
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x0007             MOVS     R7,R0
   1100          		break;
   \   00000058   0xE002             B.N      ??UART_FullModemForcePinState_6
   1101          	case UART1_MODEM_PIN_RTS:
   1102          		tmp = UART1_MCR_RTS_CTRL;
   \                     ??UART_FullModemForcePinState_4: (+1)
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x0007             MOVS     R7,R0
   1103          		break;
   \   0000005E   0xE7FF             B.N      ??UART_FullModemForcePinState_6
   1104          	default:
   1105          		break;
   1106          	}
   1107          
   1108          	if (NewState == ACTIVE){
   \                     ??UART_FullModemForcePinState_5: (+1)
   \                     ??UART_FullModemForcePinState_6: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E01             CMP      R6,#+1
   \   00000064   0xD103             BNE.N    ??UART_FullModemForcePinState_7
   1109          		UARTx->MCR |= tmp;
   \   00000066   0x7C20             LDRB     R0,[R4, #+16]
   \   00000068   0x4338             ORRS     R0,R7,R0
   \   0000006A   0x7420             STRB     R0,[R4, #+16]
   \   0000006C   0xE005             B.N      ??UART_FullModemForcePinState_8
   1110          	} else {
   1111          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemForcePinState_7: (+1)
   \   0000006E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000070   0x43F9             MVNS     R1,R7
   \   00000072   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000076   0x4008             ANDS     R0,R1,R0
   \   00000078   0x7420             STRB     R0,[R4, #+16]
   1112          	}
   1113          }
   \                     ??UART_FullModemForcePinState_8: (+1)
   \   0000007A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1114          
   1115          
   1116          /*********************************************************************//**
   1117           * @brief		Configure Full Modem mode for UART peripheral
   1118           * @param[in]	UARTx	UART1 (only)
   1119           * @param[in]	Mode Full Modem mode, should be:
   1120           * 				- UART1_MODEM_MODE_LOOPBACK: Loop back mode.
   1121           * 				- UART1_MODEM_MODE_AUTO_RTS: Auto-RTS mode.
   1122           * 				- UART1_MODEM_MODE_AUTO_CTS: Auto-CTS mode.
   1123           * @param[in]	NewState New State of this mode, should be:
   1124           * 				- ENABLE: Enable this mode.
   1125          				- DISABLE: Disable this mode.
   1126           * @return none
   1127           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1128          void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
   1129          							FunctionalState NewState)
   1130          {
   \                     UART_FullModemConfigMode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1131          	uint8_t tmp;
   1132          
   1133          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??UART_FullModemConfigMode_0
   \   00000010   0xF240 0x416D      MOVW     R1,#+1133
   \   00000014   0x....             LDR.N    R0,??DataTable19_1
   \   00000016   0x.... 0x....      BL       check_failed
   1134          	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
   \                     ??UART_FullModemConfigMode_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD00A             BEQ.N    ??UART_FullModemConfigMode_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD007             BEQ.N    ??UART_FullModemConfigMode_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D02             CMP      R5,#+2
   \   0000002A   0xD004             BEQ.N    ??UART_FullModemConfigMode_1
   \   0000002C   0xF240 0x416E      MOVW     R1,#+1134
   \   00000030   0x....             LDR.N    R0,??DataTable19_1
   \   00000032   0x.... 0x....      BL       check_failed
   1135          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_FullModemConfigMode_1: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD007             BEQ.N    ??UART_FullModemConfigMode_2
   \   0000003C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003E   0x2E01             CMP      R6,#+1
   \   00000040   0xD004             BEQ.N    ??UART_FullModemConfigMode_2
   \   00000042   0xF240 0x416F      MOVW     R1,#+1135
   \   00000046   0x....             LDR.N    R0,??DataTable19_1
   \   00000048   0x.... 0x....      BL       check_failed
   1136          
   1137          	switch(Mode){
   \                     ??UART_FullModemConfigMode_2: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD003             BEQ.N    ??UART_FullModemConfigMode_3
   \   00000052   0x2D02             CMP      R5,#+2
   \   00000054   0xD007             BEQ.N    ??UART_FullModemConfigMode_4
   \   00000056   0xD303             BCC.N    ??UART_FullModemConfigMode_5
   \   00000058   0xE008             B.N      ??UART_FullModemConfigMode_6
   1138          	case UART1_MODEM_MODE_LOOPBACK:
   1139          		tmp = UART1_MCR_LOOPB_EN;
   \                     ??UART_FullModemConfigMode_3: (+1)
   \   0000005A   0x2010             MOVS     R0,#+16
   \   0000005C   0x0007             MOVS     R7,R0
   1140          		break;
   \   0000005E   0xE005             B.N      ??UART_FullModemConfigMode_7
   1141          	case UART1_MODEM_MODE_AUTO_RTS:
   1142          		tmp = UART1_MCR_AUTO_RTS_EN;
   \                     ??UART_FullModemConfigMode_5: (+1)
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x0007             MOVS     R7,R0
   1143          		break;
   \   00000064   0xE002             B.N      ??UART_FullModemConfigMode_7
   1144          	case UART1_MODEM_MODE_AUTO_CTS:
   1145          		tmp = UART1_MCR_AUTO_CTS_EN;
   \                     ??UART_FullModemConfigMode_4: (+1)
   \   00000066   0x2080             MOVS     R0,#+128
   \   00000068   0x0007             MOVS     R7,R0
   1146          		break;
   \   0000006A   0xE7FF             B.N      ??UART_FullModemConfigMode_7
   1147          	default:
   1148          		break;
   1149          	}
   1150          
   1151          	if (NewState == ENABLE)
   \                     ??UART_FullModemConfigMode_6: (+1)
   \                     ??UART_FullModemConfigMode_7: (+1)
   \   0000006C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006E   0x2E01             CMP      R6,#+1
   \   00000070   0xD103             BNE.N    ??UART_FullModemConfigMode_8
   1152          	{
   1153          		UARTx->MCR |= tmp;
   \   00000072   0x7C20             LDRB     R0,[R4, #+16]
   \   00000074   0x4338             ORRS     R0,R7,R0
   \   00000076   0x7420             STRB     R0,[R4, #+16]
   \   00000078   0xE005             B.N      ??UART_FullModemConfigMode_9
   1154          	}
   1155          	else
   1156          	{
   1157          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemConfigMode_8: (+1)
   \   0000007A   0x7C20             LDRB     R0,[R4, #+16]
   \   0000007C   0x43F9             MVNS     R1,R7
   \   0000007E   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000082   0x4008             ANDS     R0,R1,R0
   \   00000084   0x7420             STRB     R0,[R4, #+16]
   1158          	}
   1159          }
   \                     ??UART_FullModemConfigMode_9: (+1)
   \   00000086   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1160          
   1161          
   1162          /*********************************************************************//**
   1163           * @brief		Get current status of modem status register
   1164           * @param[in]	UARTx	UART1 (only)
   1165           * @return 		Current value of modem status register
   1166           * Note:	The return value of this function must be ANDed with each member
   1167           * 			UART_MODEM_STAT_type enumeration to determine current flag status
   1168           * 			corresponding to each modem flag status. Because some flags in
   1169           * 			modem status register will be cleared after reading, the next reading
   1170           * 			modem register could not be correct. So this function used to
   1171           * 			read modem status register in one time only, then the return value
   1172           * 			used to check all flags.
   1173           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1174          uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx)
   1175          {
   \                     UART_FullModemGetStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1176          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??UART_FullModemGetStatus_0
   \   0000000C   0xF44F 0x6193      MOV      R1,#+1176
   \   00000010   0x....             LDR.N    R0,??DataTable19_1
   \   00000012   0x.... 0x....      BL       check_failed
   1177          	return ((UARTx->MSR) & UART1_MSR_BITMASK);
   \                     ??UART_FullModemGetStatus_0: (+1)
   \   00000016   0x7E20             LDRB     R0,[R4, #+24]
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1178          }
   1179          
   1180          
   1181          /*********************************************************************//**
   1182           * @brief		Configure UART peripheral in RS485 mode according to the specified
   1183          *               parameters in the RS485ConfigStruct.
   1184           * @param[in]	UARTx	UART1 (only)
   1185           * @param[in]	RS485ConfigStruct Pointer to a UART1_RS485_CTRLCFG_Type structure
   1186          *                    that contains the configuration information for specified UART
   1187          *                    in RS485 mode.
   1188           * @return		None
   1189           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1190          void UART_RS485Config(LPC_UART1_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
   1191          {
   \                     UART_RS485Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1192          	uint32_t tmp;
   1193          
   1194          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40010000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??UART_RS485Config_0
   \   0000000E   0xF240 0x41AA      MOVW     R1,#+1194
   \   00000012   0x....             LDR.N    R0,??DataTable19_1
   \   00000014   0x.... 0x....      BL       check_failed
   1195          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoAddrDetect_State));
   \                     ??UART_RS485Config_0: (+1)
   \   00000018   0x78A8             LDRB     R0,[R5, #+2]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD007             BEQ.N    ??UART_RS485Config_1
   \   0000001E   0x78A8             LDRB     R0,[R5, #+2]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??UART_RS485Config_1
   \   00000024   0xF240 0x41AB      MOVW     R1,#+1195
   \   00000028   0x....             LDR.N    R0,??DataTable19_1
   \   0000002A   0x.... 0x....      BL       check_failed
   1196          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoDirCtrl_State));
   \                     ??UART_RS485Config_1: (+1)
   \   0000002E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD007             BEQ.N    ??UART_RS485Config_2
   \   00000034   0x78E8             LDRB     R0,[R5, #+3]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD004             BEQ.N    ??UART_RS485Config_2
   \   0000003A   0xF240 0x41AC      MOVW     R1,#+1196
   \   0000003E   0x....             LDR.N    R0,??DataTable19_1
   \   00000040   0x.... 0x....      BL       check_failed
   1197          	CHECK_PARAM(PARAM_UART1_RS485_CFG_DELAYVALUE(RS485ConfigStruct->DelayValue));
   \                     ??UART_RS485Config_2: (+1)
   \   00000044   0x79E8             LDRB     R0,[R5, #+7]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0xD104             BNE.N    ??UART_RS485Config_3
   \   0000004A   0xF240 0x41AD      MOVW     R1,#+1197
   \   0000004E   0x....             LDR.N    R0,??DataTable19_1
   \   00000050   0x.... 0x....      BL       check_failed
   1198          	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct->DirCtrlPol_Level));
   \                     ??UART_RS485Config_3: (+1)
   \   00000054   0x7968             LDRB     R0,[R5, #+5]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD007             BEQ.N    ??UART_RS485Config_4
   \   0000005A   0x7968             LDRB     R0,[R5, #+5]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD004             BEQ.N    ??UART_RS485Config_4
   \   00000060   0xF240 0x41AE      MOVW     R1,#+1198
   \   00000064   0x....             LDR.N    R0,??DataTable19_1
   \   00000066   0x.... 0x....      BL       check_failed
   1199          	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct->DirCtrlPin));
   \                     ??UART_RS485Config_4: (+1)
   \   0000006A   0x7928             LDRB     R0,[R5, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD007             BEQ.N    ??UART_RS485Config_5
   \   00000070   0x7928             LDRB     R0,[R5, #+4]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD004             BEQ.N    ??UART_RS485Config_5
   \   00000076   0xF240 0x41AF      MOVW     R1,#+1199
   \   0000007A   0x....             LDR.N    R0,??DataTable19_1
   \   0000007C   0x.... 0x....      BL       check_failed
   1200          	CHECK_PARAM(PARAM_UART1_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct->MatchAddrValue));
   \                     ??UART_RS485Config_5: (+1)
   \   00000080   0x79A8             LDRB     R0,[R5, #+6]
   \   00000082   0x28FF             CMP      R0,#+255
   \   00000084   0xD104             BNE.N    ??UART_RS485Config_6
   \   00000086   0xF44F 0x6196      MOV      R1,#+1200
   \   0000008A   0x....             LDR.N    R0,??DataTable19_1
   \   0000008C   0x.... 0x....      BL       check_failed
   1201          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->NormalMultiDropMode_State));
   \                     ??UART_RS485Config_6: (+1)
   \   00000090   0x7828             LDRB     R0,[R5, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD007             BEQ.N    ??UART_RS485Config_7
   \   00000096   0x7828             LDRB     R0,[R5, #+0]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD004             BEQ.N    ??UART_RS485Config_7
   \   0000009C   0xF240 0x41B1      MOVW     R1,#+1201
   \   000000A0   0x....             LDR.N    R0,??DataTable19_1
   \   000000A2   0x.... 0x....      BL       check_failed
   1202          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->Rx_State));
   \                     ??UART_RS485Config_7: (+1)
   \   000000A6   0x7868             LDRB     R0,[R5, #+1]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD007             BEQ.N    ??UART_RS485Config_8
   \   000000AC   0x7868             LDRB     R0,[R5, #+1]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD004             BEQ.N    ??UART_RS485Config_8
   \   000000B2   0xF240 0x41B2      MOVW     R1,#+1202
   \   000000B6   0x....             LDR.N    R0,??DataTable19_1
   \   000000B8   0x.... 0x....      BL       check_failed
   1203          
   1204          	tmp = 0;
   \                     ??UART_RS485Config_8: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x0006             MOVS     R6,R0
   1205          	// If Auto Direction Control is enabled -  This function is used in Master mode
   1206          	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
   \   000000C0   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C2   0x2801             CMP      R0,#+1
   \   000000C4   0xD10E             BNE.N    ??UART_RS485Config_9
   1207          	{
   1208          		tmp |= UART1_RS485CTRL_DCTRL_EN;
   \   000000C6   0xF056 0x0610      ORRS     R6,R6,#0x10
   1209          
   1210          		// Set polar
   1211          		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
   \   000000CA   0x7968             LDRB     R0,[R5, #+5]
   \   000000CC   0x2801             CMP      R0,#+1
   \   000000CE   0xD101             BNE.N    ??UART_RS485Config_10
   1212          		{
   1213          			tmp |= UART1_RS485CTRL_OINV_1;
   \   000000D0   0xF056 0x0620      ORRS     R6,R6,#0x20
   1214          		}
   1215          
   1216          		// Set pin according to
   1217          		if (RS485ConfigStruct->DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
   \                     ??UART_RS485Config_10: (+1)
   \   000000D4   0x7928             LDRB     R0,[R5, #+4]
   \   000000D6   0x2801             CMP      R0,#+1
   \   000000D8   0xD101             BNE.N    ??UART_RS485Config_11
   1218          		{
   1219          			tmp |= UART1_RS485CTRL_SEL_DTR;
   \   000000DA   0xF056 0x0608      ORRS     R6,R6,#0x8
   1220          		}
   1221          
   1222          		// Fill delay time
   1223          		UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART1_RS485DLY_BITMASK;
   \                     ??UART_RS485Config_11: (+1)
   \   000000DE   0x79E8             LDRB     R0,[R5, #+7]
   \   000000E0   0xF884 0x0054      STRB     R0,[R4, #+84]
   1224          	}
   1225          
   1226          	// MultiDrop mode is enable
   1227          	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
   \                     ??UART_RS485Config_9: (+1)
   \   000000E4   0x7828             LDRB     R0,[R5, #+0]
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD101             BNE.N    ??UART_RS485Config_12
   1228          	{
   1229          		tmp |= UART1_RS485CTRL_NMM_EN;
   \   000000EA   0xF056 0x0601      ORRS     R6,R6,#0x1
   1230          	}
   1231          
   1232          	// Auto Address Detect function
   1233          	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
   \                     ??UART_RS485Config_12: (+1)
   \   000000EE   0x78A8             LDRB     R0,[R5, #+2]
   \   000000F0   0x2801             CMP      R0,#+1
   \   000000F2   0xD104             BNE.N    ??UART_RS485Config_13
   1234          	{
   1235          		tmp |= UART1_RS485CTRL_AADEN;
   \   000000F4   0xF056 0x0604      ORRS     R6,R6,#0x4
   1236          		// Fill Match Address
   1237          		UARTx->ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART1_RS485ADRMATCH_BITMASK;
   \   000000F8   0x79A8             LDRB     R0,[R5, #+6]
   \   000000FA   0xF884 0x0050      STRB     R0,[R4, #+80]
   1238          	}
   1239          
   1240          
   1241          	// Receiver is disable
   1242          	if (RS485ConfigStruct->Rx_State == DISABLE)
   \                     ??UART_RS485Config_13: (+1)
   \   000000FE   0x7868             LDRB     R0,[R5, #+1]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD101             BNE.N    ??UART_RS485Config_14
   1243          	{
   1244          		tmp |= UART1_RS485CTRL_RX_DIS;
   \   00000104   0xF056 0x0602      ORRS     R6,R6,#0x2
   1245          	}
   1246          
   1247          	// write back to RS485 control register
   1248          	UARTx->RS485CTRL = tmp & UART1_RS485CTRL_BITMASK;
   \                     ??UART_RS485Config_14: (+1)
   \   00000108   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   0000010C   0xF884 0x004C      STRB     R0,[R4, #+76]
   1249          
   1250          	// Enable Parity function and leave parity in stick '0' parity as default
   1251          	UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
   \   00000110   0x7B20             LDRB     R0,[R4, #+12]
   \   00000112   0xF050 0x0038      ORRS     R0,R0,#0x38
   \   00000116   0x7320             STRB     R0,[R4, #+12]
   1252          }
   \   00000118   0xBD70             POP      {R4-R6,PC}       ;; return
   1253          
   1254          
   1255          /**
   1256           * @brief 		Enable/Disable receiver in RS485 module in UART1
   1257           * @param[in]	UARTx 		UART1 only.
   1258           * @param[in]	NewState	New State of command, should be:
   1259           * 							- ENABLE: Enable this function.
   1260           * 							- DISABLE: Disable this function.
   1261           * @return		None
   1262           */

   \                                 In section .text, align 2, keep-with-next
   1263          void UART_RS485ReceiverCmd(LPC_UART1_TypeDef *UARTx, FunctionalState NewState)
   1264          {
   1265          	if (NewState == ENABLE){
   \                     UART_RS485ReceiverCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??UART_RS485ReceiverCmd_0
   1266          		UARTx->RS485CTRL &= ~UART1_RS485CTRL_RX_DIS;
   \   00000006   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   0000000A   0xF012 0x02FD      ANDS     R2,R2,#0xFD
   \   0000000E   0xF880 0x204C      STRB     R2,[R0, #+76]
   \   00000012   0xE005             B.N      ??UART_RS485ReceiverCmd_1
   1267          	} else {
   1268          		UARTx->RS485CTRL |= UART1_RS485CTRL_RX_DIS;
   \                     ??UART_RS485ReceiverCmd_0: (+1)
   \   00000014   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   00000018   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000001C   0xF880 0x204C      STRB     R2,[R0, #+76]
   1269          	}
   1270          }
   \                     ??UART_RS485ReceiverCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1271          
   1272          
   1273          /**
   1274           * @brief 		Send data on RS485 bus with specified parity stick value (9-bit mode).
   1275           * @param[in]	UARTx 		UART1 (only).
   1276           * @param[in]	pDatFrm 	Pointer to data frame.
   1277           * @param[in]	size		Size of data.
   1278           * @param[in]	ParityStick	Parity Stick value, should be 0 or 1.
   1279           * @return		None.
   1280           */

   \                                 In section .text, align 2, keep-with-next
   1281          uint32_t UART_RS485Send(LPC_UART1_TypeDef *UARTx, uint8_t *pDatFrm, \
   1282          					uint32_t size, uint8_t ParityStick)
   1283          {
   \                     UART_RS485Send: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1284          	uint8_t tmp, save;
   1285          	uint32_t cnt;
   1286          
   1287          	if (ParityStick){
   \   0000000C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD013             BEQ.N    ??UART_RS485Send_0
   1288          		save = tmp = UARTx->LCR & UART_LCR_BITMASK;
   \   00000012   0x7B20             LDRB     R0,[R4, #+12]
   \   00000014   0x4682             MOV      R10,R0
   \   00000016   0x46D0             MOV      R8,R10
   1289          		tmp &= ~(UART_LCR_PARITY_EVEN);
   \   00000018   0xF01A 0x0AEF      ANDS     R10,R10,#0xEF
   1290          		UARTx->LCR = tmp;
   \   0000001C   0xF884 0xA00C      STRB     R10,[R4, #+12]
   1291          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0x0032             MOVS     R2,R6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       UART_Send
   \   0000002C   0x4681             MOV      R9,R0
   1292          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_1: (+1)
   \   0000002E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000030   0x0640             LSLS     R0,R0,#+25
   \   00000032   0xD5FC             BPL.N    ??UART_RS485Send_1
   1293          		UARTx->LCR = save;
   \   00000034   0xF884 0x800C      STRB     R8,[R4, #+12]
   \   00000038   0xE009             B.N      ??UART_RS485Send_2
   1294          	} else {
   1295          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \                     ??UART_RS485Send_0: (+1)
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       UART_Send
   \   00000046   0x4681             MOV      R9,R0
   1296          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_3: (+1)
   \   00000048   0x7D20             LDRB     R0,[R4, #+20]
   \   0000004A   0x0640             LSLS     R0,R0,#+25
   \   0000004C   0xD5FC             BPL.N    ??UART_RS485Send_3
   1297          	}
   1298          	return cnt;
   \                     ??UART_RS485Send_2: (+1)
   \   0000004E   0x4648             MOV      R0,R9
   \   00000050   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1299          }
   1300          
   1301          
   1302          /**
   1303           * @brief 		Send Slave address frames on RS485 bus.
   1304           * @param[in]	UARTx UART1 (only).
   1305           * @param[in]	SlvAddr Slave Address.
   1306           * @return		None.
   1307           */

   \                                 In section .text, align 2, keep-with-next
   1308          void UART_RS485SendSlvAddr(LPC_UART1_TypeDef *UARTx, uint8_t SlvAddr)
   1309          {
   \                     UART_RS485SendSlvAddr: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1310          	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA901             ADD      R1,SP,#+4
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       UART_RS485Send
   1311          }
   \   00000010   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1312          
   1313          
   1314          /**
   1315           * @brief 		Send Data frames on RS485 bus.
   1316           * @param[in]	UARTx UART1 (only).
   1317           * @param[in]	pData Pointer to data to be sent.
   1318           * @param[in]	size Size of data frame to be sent.
   1319           * @return		None.
   1320           */

   \                                 In section .text, align 2, keep-with-next
   1321          uint32_t UART_RS485SendData(LPC_UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size)
   1322          {
   \                     UART_RS485SendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1323          	return (UART_RS485Send(UARTx, pData, size, 0));
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       UART_RS485Send
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
   1324          }
   1325          
   1326          #endif /* _UART1 */
   1327          
   1328          
   1329          /* Additional driver APIs ----------------------------------------------------------------------- */
   1330          
   1331          /*********************************************************************//**
   1332           * @brief		Send a block of data via UART peripheral
   1333           * @param[in]	UARTx	Selected UART peripheral used to send data,
   1334           * 				should be UART0, UART1, UART2 or UART3.
   1335           * @param[in]	txbuf 	Pointer to Transmit buffer
   1336           * @param[in]	buflen 	Length of Transmit buffer
   1337           * @param[in] 	flag 	Flag used in  UART transfer, should be
   1338           * 						NONE_BLOCKING or BLOCKING
   1339           * @return 		Number of bytes sent.
   1340           *
   1341           * Note: when using UART in BLOCKING mode, a time-out condition is used
   1342           * via defined symbol UART_BLOCKING_TIMEOUT.
   1343           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1344          uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
   1345          		uint32_t buflen, TRANSFER_BLOCK_Type flag)
   1346          {
   \                     UART_Send: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
   1347          	uint32_t bToSend, bSent, timeOut, fifo_cnt;
   1348          	uint8_t *pChar = txbuf;
   \   0000000A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   1349          
   1350          	bToSend = buflen;
   \   0000000E   0x002F             MOVS     R7,R5
   1351          
   1352          	// blocking mode
   1353          	if (flag == BLOCKING) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD126             BNE.N    ??UART_Send_0
   1354          		bSent = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4680             MOV      R8,R0
   1355          		while (bToSend){
   \                     ??UART_Send_1: (+1)
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD03D             BEQ.N    ??UART_Send_2
   1356          			timeOut = UART_BLOCKING_TIMEOUT;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0x4681             MOV      R9,R0
   1357          			// Wait for THR empty with timeout
   1358          			while (!(UARTx->LSR & UART_LSR_THRE)) {
   \                     ??UART_Send_3: (+1)
   \   00000024   0x7D20             LDRB     R0,[R4, #+20]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD405             BMI.N    ??UART_Send_4
   1359          				if (timeOut == 0) break;
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD002             BEQ.N    ??UART_Send_4
   1360          				timeOut--;
   \                     ??UART_Send_5: (+1)
   \   00000030   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000034   0xE7F6             B.N      ??UART_Send_3
   1361          			}
   1362          			// Time out!
   1363          			if(timeOut == 0) break;
   \                     ??UART_Send_4: (+1)
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD02E             BEQ.N    ??UART_Send_2
   1364          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_6: (+1)
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x4682             MOV      R10,R0
   1365          			while (fifo_cnt && bToSend){
   \                     ??UART_Send_7: (+1)
   \   00000040   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000044   0xD0E9             BEQ.N    ??UART_Send_1
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD0E7             BEQ.N    ??UART_Send_1
   1366          				UART_SendData(UARTx, (*pChar++));
   \   0000004A   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       UART_SendData
   \   00000054   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1367          				fifo_cnt--;
   \   00000058   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   1368          				bToSend--;
   \   0000005C   0x1E7F             SUBS     R7,R7,#+1
   1369          				bSent++;
   \   0000005E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000062   0xE7ED             B.N      ??UART_Send_7
   1370          			}
   1371          		}
   1372          	}
   1373          	// None blocking mode
   1374          	else {
   1375          		bSent = 0;
   \                     ??UART_Send_0: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4680             MOV      R8,R0
   1376          		while (bToSend) {
   \                     ??UART_Send_8: (+1)
   \   00000068   0x2F00             CMP      R7,#+0
   \   0000006A   0xD016             BEQ.N    ??UART_Send_2
   1377          			if (!(UARTx->LSR & UART_LSR_THRE)){
   \   0000006C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000006E   0x0680             LSLS     R0,R0,#+26
   \   00000070   0xD513             BPL.N    ??UART_Send_2
   1378          				break;
   1379          			}
   1380          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_9: (+1)
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x4682             MOV      R10,R0
   1381          			while (fifo_cnt && bToSend) {
   \                     ??UART_Send_10: (+1)
   \   00000076   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000007A   0xD0F5             BEQ.N    ??UART_Send_8
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD0F3             BEQ.N    ??UART_Send_8
   1382          				UART_SendData(UARTx, (*pChar++));
   \   00000080   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       UART_SendData
   \   0000008A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1383          				bToSend--;
   \   0000008E   0x1E7F             SUBS     R7,R7,#+1
   1384          				fifo_cnt--;
   \   00000090   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   1385          				bSent++;
   \   00000094   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000098   0xE7ED             B.N      ??UART_Send_10
   1386          			}
   1387          		}
   1388          	}
   1389          	return bSent;
   \                     ??UART_Send_2: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1390          }
   1391          
   1392          /*********************************************************************//**
   1393           * @brief		Receive a block of data via UART peripheral
   1394           * @param[in]	UARTx	Selected UART peripheral used to send data,
   1395           * 				should be UART0, UART1, UART2 or UART3.
   1396           * @param[out]	rxbuf 	Pointer to Received buffer
   1397           * @param[in]	buflen 	Length of Received buffer
   1398           * @param[in] 	flag 	Flag mode, should be NONE_BLOCKING or BLOCKING
   1399          
   1400           * @return 		Number of bytes received
   1401           *
   1402           * Note: when using UART in BLOCKING mode, a time-out condition is used
   1403           * via defined symbol UART_BLOCKING_TIMEOUT.
   1404           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1405          uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
   1406          		uint32_t buflen, TRANSFER_BLOCK_Type flag)
   1407          {
   \                     UART_Receive: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1408          	uint32_t bToRecv, bRecv, timeOut;
   1409          	uint8_t *pChar = rxbuf;
   \   0000000C   0x46AB             MOV      R11,R5
   1410          
   1411          	bToRecv = buflen;
   \   0000000E   0x46B0             MOV      R8,R6
   1412          
   1413          	// Blocking mode
   1414          	if (flag == BLOCKING) {
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F01             CMP      R7,#+1
   \   00000014   0xD11F             BNE.N    ??UART_Receive_0
   1415          		bRecv = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4681             MOV      R9,R0
   1416          		while (bToRecv){
   \                     ??UART_Receive_1: (+1)
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD02E             BEQ.N    ??UART_Receive_2
   1417          			timeOut = UART_BLOCKING_TIMEOUT;
   \   00000020   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000024   0x4682             MOV      R10,R0
   1418          			while (!(UARTx->LSR & UART_LSR_RDR)){
   \                     ??UART_Receive_3: (+1)
   \   00000026   0x7D20             LDRB     R0,[R4, #+20]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD405             BMI.N    ??UART_Receive_4
   1419          				if (timeOut == 0) break;
   \   0000002C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000030   0xD002             BEQ.N    ??UART_Receive_4
   1420          				timeOut--;
   \                     ??UART_Receive_5: (+1)
   \   00000032   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000036   0xE7F6             B.N      ??UART_Receive_3
   1421          			}
   1422          			// Time out!
   1423          			if(timeOut == 0) break;
   \                     ??UART_Receive_4: (+1)
   \   00000038   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003C   0xD01F             BEQ.N    ??UART_Receive_2
   1424          			// Get data from the buffer
   1425          			(*pChar++) = UART_ReceiveData(UARTx);
   \                     ??UART_Receive_6: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       UART_ReceiveData
   \   00000044   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000048   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1426          			bToRecv--;
   \   0000004C   0xF1B8 0x0801      SUBS     R8,R8,#+1
   1427          			bRecv++;
   \   00000050   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000054   0xE7E1             B.N      ??UART_Receive_1
   1428          		}
   1429          	}
   1430          	// None blocking mode
   1431          	else {
   1432          		bRecv = 0;
   \                     ??UART_Receive_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4681             MOV      R9,R0
   1433          		while (bToRecv) {
   \                     ??UART_Receive_7: (+1)
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD00E             BEQ.N    ??UART_Receive_2
   1434          			if (!(UARTx->LSR & UART_LSR_RDR)) {
   \   00000060   0x7D20             LDRB     R0,[R4, #+20]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD50B             BPL.N    ??UART_Receive_2
   1435          				break;
   1436          			} else {
   1437          				(*pChar++) = UART_ReceiveData(UARTx);
   \                     ??UART_Receive_8: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       UART_ReceiveData
   \   0000006C   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1438          				bRecv++;
   \   00000074   0xF119 0x0901      ADDS     R9,R9,#+1
   1439          				bToRecv--;
   \   00000078   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000007C   0xE7ED             B.N      ??UART_Receive_7
   1440          			}
   1441          		}
   1442          	}
   1443          	return bRecv;
   \                     ??UART_Receive_2: (+1)
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1444          }
   1445          
   1446          
   1447          /*********************************************************************//**
   1448           * @brief		Setup call-back function for UART interrupt handler for each
   1449           * 				UART peripheral
   1450           * @param[in]	UARTx	Selected UART peripheral, should be UART0..3
   1451           * @param[in]	CbType	Call-back type, should be:
   1452           * 						0 - Receive Call-back
   1453           * 						1 - Transmit Call-back
   1454           * 						2 - Auto Baudrate Callback
   1455           * 						3 - Error Call-back
   1456           * 						4 - Modem Status Call-back (UART1 only)
   1457           * @param[in]	pfnCbs	Pointer to Call-back function
   1458           * @return		None
   1459           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1460          void UART_SetupCbs(LPC_UART_TypeDef *UARTx, uint8_t CbType, void *pfnCbs)
   1461          {
   \                     UART_SetupCbs: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1462          	uint8_t pUartNum;
   1463          
   1464          	pUartNum = getUartNum(UARTx);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       getUartNum
   \   0000000E   0x0007             MOVS     R7,R0
   1465          	switch(CbType){
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD006             BEQ.N    ??UART_SetupCbs_0
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xD00F             BEQ.N    ??UART_SetupCbs_1
   \   0000001A   0xD309             BCC.N    ??UART_SetupCbs_2
   \   0000001C   0x2D04             CMP      R5,#+4
   \   0000001E   0xD018             BEQ.N    ??UART_SetupCbs_3
   \   00000020   0xD311             BCC.N    ??UART_SetupCbs_4
   \   00000022   0xE019             B.N      ??UART_SetupCbs_5
   1466          	case 0:
   1467          		uartCbsDat[pUartNum].pfnRxCbs = (fnTxCbs_Type *)pfnCbs;
   \                     ??UART_SetupCbs_0: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable24_3
   \   00000026   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000028   0x0139             LSLS     R1,R7,#+4
   \   0000002A   0x4408             ADD      R0,R0,R1
   \   0000002C   0x6046             STR      R6,[R0, #+4]
   1468          		break;
   \   0000002E   0xE013             B.N      ??UART_SetupCbs_6
   1469          	case 1:
   1470          		uartCbsDat[pUartNum].pfnTxCbs = (fnRxCbs_Type *)pfnCbs;
   \                     ??UART_SetupCbs_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable24_3
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x0139             LSLS     R1,R7,#+4
   \   00000036   0x5046             STR      R6,[R0, R1]
   1471          		break;
   \   00000038   0xE00E             B.N      ??UART_SetupCbs_6
   1472          	case 2:
   1473          		uartCbsDat[pUartNum].pfnABCbs = (fnABCbs_Type *)pfnCbs;
   \                     ??UART_SetupCbs_1: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable24_3
   \   0000003C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003E   0x0139             LSLS     R1,R7,#+4
   \   00000040   0x4408             ADD      R0,R0,R1
   \   00000042   0x6086             STR      R6,[R0, #+8]
   1474          		break;
   \   00000044   0xE008             B.N      ??UART_SetupCbs_6
   1475          	case 3:
   1476          		uartCbsDat[pUartNum].pfnErrCbs = (fnErrCbs_Type *)pfnCbs;
   \                     ??UART_SetupCbs_4: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable24_3
   \   00000048   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004A   0x0139             LSLS     R1,R7,#+4
   \   0000004C   0x4408             ADD      R0,R0,R1
   \   0000004E   0x60C6             STR      R6,[R0, #+12]
   1477          		break;
   \   00000050   0xE002             B.N      ??UART_SetupCbs_6
   1478          	case 4:
   1479          		pfnModemCbs = (fnModemCbs_Type *)pfnCbs;
   \                     ??UART_SetupCbs_3: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable24_4
   \   00000054   0x6006             STR      R6,[R0, #+0]
   1480          		break;
   \   00000056   0xE7FF             B.N      ??UART_SetupCbs_6
   1481          	default:
   1482          		break;
   1483          	}
   1484          }
   \                     ??UART_SetupCbs_5: (+1)
   \                     ??UART_SetupCbs_6: (+1)
   \   00000058   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1485          
   1486          /*********************************************************************//**
   1487           * @brief		Standard UART0 interrupt handler
   1488           * @param[in]	None
   1489           * @return		None
   1490           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1491          void UART0_StdIntHandler(void)
   1492          {
   \                     UART0_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1493          	UART_GenIntHandler(LPC_UART0);
   \   00000002   0x....             LDR.N    R0,??DataTable24_2  ;; 0x4000c000
   \   00000004   0x.... 0x....      BL       UART_GenIntHandler
   1494          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1495          
   1496          /*********************************************************************//**
   1497           * @brief		Standard UART1 interrupt handler
   1498           * @param[in]	None
   1499           * @return		None
   1500           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1501          void UART1_StdIntHandler(void)
   1502          {
   \                     UART1_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1503          	UART_GenIntHandler((LPC_UART_TypeDef *)LPC_UART1);
   \   00000002   0x....             LDR.N    R0,??DataTable24  ;; 0x40010000
   \   00000004   0x.... 0x....      BL       UART_GenIntHandler
   1504          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1505          
   1506          /*********************************************************************//**
   1507           * @brief		Standard UART2 interrupt handler
   1508           * @param[in]	None
   1509           * @return		None
   1510           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1511          void UART2_StdIntHandler(void)
   1512          {
   \                     UART2_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1513          	UART_GenIntHandler(LPC_UART2);
   \   00000002   0x....             LDR.N    R0,??DataTable24_5  ;; 0x40098000
   \   00000004   0x.... 0x....      BL       UART_GenIntHandler
   1514          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   1515          
   1516          /*********************************************************************//**
   1517           * @brief		Standard UART3 interrupt handler
   1518           * @param[in]	None
   1519           * @return
   1520           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1521          void UART3_StdIntHandler(void)
   1522          {
   \                     UART3_StdIntHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1523          	UART_GenIntHandler(LPC_UART3);
   \   00000002   0x....             LDR.N    R0,??DataTable24_6  ;; 0x4009c000
   \   00000004   0x.... 0x....      BL       UART_GenIntHandler
   1524          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40010018         DC32     0x40010018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     pfnModemCbs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     uartCbsDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x40010014         DC32     0x40010014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     uartCbsDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     pfnModemCbs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x45 0x3A          DC8 45H, 3AH, 5CH, 0D0H, 0C2H, 0CFH, 0EEH, 0C4H
   \              0x5C 0xD0    
   \              0xC2 0xCF    
   \              0xEE 0xC4    
   \   00000008   0xBF 0x5C          DC8 0BFH, 5CH, 0D2H, 0C6H, 0BDH, 0BBH, 0D7H, 0CAH
   \              0xD2 0xC6    
   \              0xBD 0xBB    
   \              0xD7 0xCA    
   \   00000010   0xC1 0xCF          DC8 0C1H, 0CFH, 4CH, 48H, 54H, 5CH, 0D7H, 0D4H
   \              0x4C 0x48    
   \              0x54 0x5C    
   \              0xD7 0xD4    
   \   00000018   0xD6 0xFA          DC8 0D6H, 0FAH, 0BDH, 0C9H, 0B7H, 0D1H, 0BBH, 0FAH
   \              0xBD 0xC9    
   \              0xB7 0xD1    
   \              0xBB 0xFA    
   \   00000020   0x5C 0xC8          DC8 5CH, 0C8H, 0EDH, 0BCH, 0FEH, 5CH, 4DH, 69H
   \              0xED 0xBC    
   \              0xFE 0x5C    
   \              0x4D 0x69    
   \   00000028   0x63 0x72          DC8 63H, 72H, 69H, 75H, 6DH, 5FH, 4CH, 50H
   \              0x69 0x75    
   \              0x6D 0x5F    
   \              0x4C 0x50    
   \   00000030   0x43 0x31          DC8 43H, 31H, 37H, 36H, 38H, 2DH, 53H, 4BH
   \              0x37 0x36    
   \              0x38 0x2D    
   \              0x53 0x4B    
   \   00000038   0x5F 0x75          DC8 5FH, 75H, 43H, 4FH, 53H, 2DH, 49H, 49H
   \              0x43 0x4F    
   \              0x53 0x2D    
   \              0x49 0x49    
   \   00000040   0x49 0x2D          DC8 49H, 2DH, 52H, 65H, 6CH, 65H, 61H, 73H
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \   00000048   0x65 0x5C          DC8 65H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000050   0x72 0x65          DC8 72H, 65H, 5CH, 45H, 76H, 61H, 6CH, 42H
   \              0x5C 0x45    
   \              0x76 0x61    
   \              0x6C 0x42    
   \   00000058   0x6F 0x61          DC8 6FH, 61H, 72H, 64H, 73H, 5CH, 4EH, 58H
   \              0x72 0x64    
   \              0x73 0x5C    
   \              0x4E 0x58    
   \   00000060   0x50 0x5C          DC8 50H, 5CH, 4CH, 50H, 43H, 31H, 37H, 36H
   \              0x4C 0x50    
   \              0x43 0x31    
   \              0x37 0x36    
   \   00000068   0x38 0x2D          DC8 38H, 2DH, 53H, 4BH, 5CH, 4CH, 50H, 43H
   \              0x53 0x4B    
   \              0x5C 0x4C    
   \              0x50 0x43    
   \   00000070   0x31 0x37          DC8 31H, 37H, 58H, 58H, 43H, 4DH, 53H, 49H
   \              0x58 0x58    
   \              0x43 0x4D    
   \              0x53 0x49    
   \   00000078   0x53 0x5C          DC8 53H, 5CH, 44H, 72H, 69H, 76H, 65H, 72H
   \              0x44 0x72    
   \              0x69 0x76    
   \              0x65 0x72    
   \   00000080   0x73 0x5C          DC8 73H, 5CH, 73H, 6FH, 75H, 72H, 63H, 65H
   \              0x73 0x6F    
   \              0x75 0x72    
   \              0x63 0x65    
   \   00000088   0x5C 0x6C          DC8 5CH, 6CH, 70H, 63H, 31H, 37H, 78H, 78H
   \              0x70 0x63    
   \              0x31 0x37    
   \              0x78 0x78    
   \   00000090   0x5F 0x75          DC8 5FH, 75H, 61H, 72H, 74H, 2EH, 63H, 0
   \              0x61 0x72    
   \              0x74 0x2E    
   \              0x63 0x00    
   1525          
   1526          /**
   1527           * @}
   1528           */
   1529          
   1530          
   1531          #endif /* _UART */
   1532          
   1533          /**
   1534           * @}
   1535           */
   1536          
   1537          /* --------------------------------- End Of File ------------------------------ */
   1538          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UART0_StdIntHandler
         8   -> UART_GenIntHandler
       8   UART1_StdIntHandler
         8   -> UART_GenIntHandler
       8   UART2_StdIntHandler
         8   -> UART_GenIntHandler
       8   UART3_StdIntHandler
         8   -> UART_GenIntHandler
      24   UART_ABCmd
        24   -> check_failed
       0   UART_CheckBusy
       0   UART_ConfigStructInit
       8   UART_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> UART_TxCmd
         8   -> check_failed
      16   UART_FIFOConfig
        16   -> check_failed
       0   UART_FIFOConfigStructInit
       8   UART_ForceBreak
         8   -> check_failed
      24   UART_FullModemConfigMode
        24   -> check_failed
      24   UART_FullModemForcePinState
        24   -> check_failed
       8   UART_FullModemGetStatus
         8   -> check_failed
      32   UART_GenIntHandler
        32   -- Indirect call
        32   -> getUartNum
       8   UART_GetLineStatus
         8   -> check_failed
      16   UART_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> check_failed
        16   -> uart_set_divisors
      24   UART_IntConfig
        24   -> check_failed
      16   UART_IrDACmd
        16   -> check_failed
      16   UART_IrDAInvtInputCmd
        16   -> check_failed
      24   UART_IrDAPulseDivConfig
        24   -> check_failed
      16   UART_RS485Config
        16   -> check_failed
       0   UART_RS485ReceiverCmd
      32   UART_RS485Send
        32   -> UART_Send
      16   UART_RS485SendData
        16   -> UART_RS485Send
      16   UART_RS485SendSlvAddr
        16   -> UART_RS485Send
      40   UART_Receive
        40   -> UART_ReceiveData
       8   UART_ReceiveData
         8   -> check_failed
      40   UART_Send
        40   -> UART_SendData
      16   UART_SendData
        16   -> check_failed
      24   UART_SetupCbs
        24   -> getUartNum
      16   UART_TxCmd
        16   -> check_failed
       0   getUartNum
      64   uart_set_divisors
        64   -> CLKPWR_GetPCLK


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
     152  ?_0
      10  UART0_StdIntHandler
      10  UART1_StdIntHandler
      10  UART2_StdIntHandler
      10  UART3_StdIntHandler
     206  UART_ABCmd
      16  UART_CheckBusy
      20  UART_ConfigStructInit
     126  UART_DeInit
     244  UART_FIFOConfig
      18  UART_FIFOConfigStructInit
      76  UART_ForceBreak
     136  UART_FullModemConfigMode
     124  UART_FullModemForcePinState
      26  UART_FullModemGetStatus
     328  UART_GenIntHandler
      60  UART_GetLineStatus
     522  UART_Init
     318  UART_IntConfig
      84  UART_IrDACmd
      90  UART_IrDAInvtInputCmd
     122  UART_IrDAPulseDivConfig
     282  UART_RS485Config
      34  UART_RS485ReceiverCmd
      84  UART_RS485Send
      22  UART_RS485SendData
      18  UART_RS485SendSlvAddr
     132  UART_Receive
      64  UART_ReceiveData
     160  UART_Send
      66  UART_SendData
      90  UART_SetupCbs
     140  UART_TxCmd
      42  getUartNum
       4  pfnModemCbs
      64  uartCbsDat
     390  uart_set_divisors

 
    68 bytes in section .bss
   152 bytes in section .rodata
 4 148 bytes in section .text
 
 4 148 bytes of CODE  memory
   152 bytes of CONST memory
    68 bytes of DATA  memory

Errors: none
Warnings: none
