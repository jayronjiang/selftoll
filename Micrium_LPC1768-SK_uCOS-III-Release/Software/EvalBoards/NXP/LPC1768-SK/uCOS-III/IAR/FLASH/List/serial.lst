###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:12
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\serial.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\serial.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     SERIAL (BYTE) COMMUNICATION
      4          *
      5          *                         (c) Copyright 2007-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     SERIAL (BYTE) COMMUNICATION
     18          *
     19          * Filename      : serial.c
     20          * Version       : V2.00
     21          * Programmer(s) : FGK
     22          *********************************************************************************************************
     23          */
     24          
     25          /*
     26          *********************************************************************************************************
     27          *                                            INCLUDE FILES
     28          *********************************************************************************************************
     29          */
     30          
     31          #define    SERIAL_MODULE
     32          #include  <serial.h>
     33          #include  <serial_os.h>
     34          
     35          
     36          /*
     37          *********************************************************************************************************
     38          *                                            LOCAL DEFINES
     39          *********************************************************************************************************
     40          */
     41          
     42          #define  SERIAL_RD_STATE_CLOSED                            0u
     43          #define  SERIAL_RD_STATE_OPENED                            1u
     44          #define  SERIAL_RD_STATE_RD                                2u
     45          #define  SERIAL_RD_STATE_CHK                               3u
     46          
     47          #define  SERIAL_WR_STATE_CLOSED                            0u
     48          #define  SERIAL_WR_STATE_OPENED                            1u
     49          #define  SERIAL_WR_STATE_WR                                2u
     50          #define  SERIAL_WR_STATE_WR_BUF                            3u
     51          
     52          
     53          /*
     54          *********************************************************************************************************
     55          *                                                FLAGS
     56          *********************************************************************************************************
     57          */
     58          
     59          #define  SERIAL_STATE_NONE                                 0u
     60          #define  SERIAL_STATE_CLOSED                               1u
     61          #define  SERIAL_STATE_CLOSING                              2u
     62          #define  SERIAL_STATE_OPENED                               3u
     63          
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                        FORWARD DECLARATIONS
     68          *********************************************************************************************************
     69          */
     70          
     71          typedef  struct  serial_buf_desc  SERIAL_BUF_DESC;
     72          
     73          
     74          /*
     75          *********************************************************************************************************
     76          *                                      SERIAL CALLBACK INFO TYPE
     77          *********************************************************************************************************
     78          */
     79          
     80          typedef  struct  serial_callback_info {                         /* ---------------- RD/WR CALLBACK INFO --------------- */
     81              void        *SignalPtr;                                     /* Ptr to signal to wait.                               */
     82              CPU_INT32U   Timeout;                                       /* Timeout in milliseconds. Wait indefinitely, if 0.    */
     83              CPU_SIZE_T   Len;                                           /* Nbr of octets successfully read/written.             */
     84              SERIAL_ERR   Err;                                           /* Rtn err code.                                        */
     85          } SERIAL_CALLBACK_INFO;
     86          
     87          
     88          /*
     89          *********************************************************************************************************
     90          *                                    SERIAL BUFFER DESCRIPTOR TYPE
     91          *********************************************************************************************************
     92          */
     93          
     94          struct  serial_buf_desc {
     95              CPU_SIZE_T             Len;                                 /* Buf len.                                             */
     96              CPU_INT08U            *DataPtr;                             /* Ptr to buf data.                                     */
     97          
     98              SERIAL_CALLBACK_FNCT  *Callback;                            /* Rd/Wr complete callback.                             */
     99              void                  *CallbackArg;                         /* Rd/Wr complete context.                              */
    100              void                  *CallbackBuf;                         /* Rd/Wr complete buffer pointer.                       */
    101          
    102              SERIAL_BUF_DESC       *NextPtr;
    103              SERIAL_BUF_DESC       *PrevPtr;
    104          };
    105          
    106          
    107          /*
    108          *********************************************************************************************************
    109          *                                        SERIAL INTERFACE TYPE
    110          *
    111          * Note(s) : (1) Serial interface initialization flag set when an interface has been successfully added
    112          *               & initialized to the interface table.  Once set, this flag is never cleared since the
    113          *               removal of interfaces is currently not allowed.
    114          *********************************************************************************************************
    115          */
    116          
    117          typedef  struct  serial_if {
    118              CPU_BOOLEAN            Init;                                /* IF init status (see Note #1).                        */
    119          
    120              SERIAL_IF_NBR          Nbr;                                 /* IF nbr.                                              */
    121              CPU_INT08U             State;                               /* IF state.                                            */
    122          
    123              CPU_CHAR              *NamePtr;                             /* Ptr to dev name (cfg'd @ dev add).                   */
    124          
    125              SERIAL_DEV             Dev;                                 /* Dev             (cfg'd @ dev add).                   */
    126          
    127          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    128              MEM_POOL               TxBufPool;
    129              SERIAL_BUF_DESC       *TxBufListStart;
    130              SERIAL_BUF_DESC       *TxBufListEnd;
    131          #endif
    132          
    133                                                                          /* --------------- RD COMMUNICATION DATA -------------- */
    134              CPU_INT08U             RdState;                             /* Rd state.                                            */
    135              void                  *RdSem;                               /* Rd semaphore.                                        */
    136              SERIAL_CALLBACK_FNCT  *RdCallback;                          /* Rd complete callback.                                */
    137              void                  *RdCallbackArg;                       /* Rd complete context.                                 */
    138              void                  *RdCallbackBuf;                       /* Rd complete buffer pointer.                          */
    139          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
    140              CPU_SIZE_T             RdCallbackLen;                       /* Rd complete buffer len.                              */
    141          #endif
    142              SERIAL_BUF             RdUserBuf;                           /* Rd user buf.                                         */
    143          
    144          
    145          
    146                                                                          /* --------------- WR COMMUNICATION DATA -------------- */
    147              CPU_INT08U             WrState;                             /* Wr state.                                            */
    148              void                  *WrSem;                               /* Wr semaphore.                                        */
    149              SERIAL_CALLBACK_FNCT  *WrCallback;                          /* Wr complete callback.                                */
    150              void                  *WrCallbackArg;                       /* Wr complete context.                                 */
    151              void                  *WrCallbackBuf;                       /* Wr complete buffer pointer.                          */
    152              SERIAL_BUF             WrUserBuf;                           /* Wr user buf.                                         */
    153          
    154          
    155          
    156          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* -------------------- RD BUFFER --------------------- */
    157              CPU_BOOLEAN            RdBufEn;                             /* Indicates buf presence.                              */
    158              SERIAL_ERR             RdBufErr;                            /* Rd err (while rd'ing into rd buf).                   */
    159              SERIAL_BUF             RdBuf;                               /* Buf.                                                 */
    160          #endif
    161          
    162          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)                       /* -------------------- WR BUFFER --------------------- */
    163              CPU_BOOLEAN            WrBufEn;                             /* Indicates buf presence.                              */
    164              SERIAL_BUF             WrBuf;                               /* Buf.                                                 */
    165          #endif
    166          } SERIAL_IF;
    167          
    168          
    169          /*
    170          *********************************************************************************************************
    171          *                                            LOCAL TABLES
    172          *********************************************************************************************************
    173          */
    174          

   \                                 In section .bss, align 4
    175          static  SERIAL_IF  Serial_IF_Tbl[SERIAL_IF_NBR_TOT];
   \                     Serial_IF_Tbl:
   \   00000000                      DS8 960
    176          
    177          /*
    178          *********************************************************************************************************
    179          *                                       LOCAL GLOBAL VARIABLES
    180          *********************************************************************************************************
    181          */
    182          

   \                                 In section .bss, align 1
    183          static  SERIAL_IF_NBR  SerialIF_NbrNext;
   \                     SerialIF_NbrNext:
   \   00000000                      DS8 1
    184          
    185          
    186          /*
    187          *********************************************************************************************************
    188          *                                      LOCAL FUNCTION PROTOTYPES
    189          *********************************************************************************************************
    190          */
    191                                                                          /* Clr if.                                              */
    192          static  void              Serial_IF_Clr      (SERIAL_IF             *pif);
    193                                                                          /* Clr rd callback arg and user buf.                    */
    194          static  void              Serial_IF_RdClr    (SERIAL_IF             *pif);
    195                                                                          /* Clr wr callback arg and user buf.                    */
    196          static  void              Serial_IF_WrClr    (SERIAL_IF             *pif);
    197                                                                          /* Reset rx'er.                                         */
    198          static  void              Serial_IF_RxReset  (SERIAL_IF             *pif);
    199                                                                          /* Start rx'er.                                         */
    200          static  void              Serial_IF_RxStart  (SERIAL_IF             *pif);
    201                                                                          /* Stop  rx'er.                                         */
    202          static  void              Serial_IF_RxStop   (SERIAL_IF             *pif);
    203          
    204          
    205                                                                          /* Internal rd callback.                                */
    206          static  void              Serial_RdCallback  (SERIAL_IF_NBR          if_nbr,
    207                                                        void                  *parg,
    208                                                        void                  *pbuf,
    209                                                        CPU_SIZE_T             len,
    210                                                        SERIAL_ERR             err);
    211          
    212                                                                          /* Rd async & sync handler.                             */
    213          static  void              Serial_RdHandler   (SERIAL_IF             *pif,
    214                                                        void                  *pdest,
    215                                                        CPU_SIZE_T             len,
    216                                                        SERIAL_CALLBACK_FNCT  *phandler,
    217                                                        void                  *parg,
    218                                                        CPU_BOOLEAN            async,
    219                                                        CPU_INT32U             timeout_ms,
    220                                                        SERIAL_ERR            *perr);
    221          
    222                                                                          /* Start rd.                                            */
    223          static  void              Serial_RdStart     (SERIAL_IF             *pif,
    224                                                        void                  *pdest,
    225                                                        CPU_SIZE_T             len);
    226          
    227                                                                          /* Wait for rd end.                                     */
    228          static  CPU_SIZE_T        Serial_RdEnd       (SERIAL_IF             *pif,
    229                                                        SERIAL_CALLBACK_INFO  *pinfo,
    230                                                        SERIAL_ERR            *perr);
    231          
    232          
    233                                                                          /* Internal wr callback.                                */
    234          static  void              Serial_WrCallback  (SERIAL_IF_NBR          if_nbr,
    235                                                        void                  *parg,
    236                                                        void                  *pbuf,
    237                                                        CPU_SIZE_T             len,
    238                                                        SERIAL_ERR             err);
    239          
    240                                                                          /* Insert wr buf into tx list.                          */
    241          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    242          static  void              Serial_WrBufInsert (SERIAL_IF             *pif,
    243                                                        SERIAL_BUF_DESC       *pbuf,
    244                                                        SERIAL_ERR            *perr);
    245          #endif
    246          
    247                                                                          /* Remove wr buf from tx list.                          */
    248          static  CPU_BOOLEAN       Serial_WrBufRemove (SERIAL_IF             *pif,
    249                                                        SERIAL_BUF_DESC       *pbuf);
    250          
    251                                                                          /* Init wr buf and start tx'er.                         */
    252          static  void              Serial_WrBufTxStart(SERIAL_IF             *pif,
    253                                                        SERIAL_BUF_DESC       *pbuf,
    254                                                        SERIAL_ERR            *perr);
    255          
    256                                                                          /* Start wr.                                            */
    257          static  void              Serial_WrStart     (SERIAL_IF             *pif,
    258                                                        SERIAL_BUF_DESC       *pbuf,
    259                                                        SERIAL_ERR            *perr);
    260          
    261                                                                          /* Tx next wr buf from tx list.                         */
    262          static  void              Serial_WrNext      (SERIAL_IF             *pif);
    263          
    264                                                                          /* Wait for wr end.                                     */
    265          static  CPU_SIZE_T        Serial_WrEnd       (SERIAL_IF             *pif,
    266                                                        SERIAL_CALLBACK_INFO  *pinfo,
    267                                                        SERIAL_ERR            *perr);
    268          
    269          
    270          /*$PAGE*/
    271          /*
    272          *********************************************************************************************************
    273          *********************************************************************************************************
    274          *                                     SERIAL INTERFACE FUNCTIONS
    275          *********************************************************************************************************
    276          *********************************************************************************************************
    277          */
    278          
    279          /*
    280          *********************************************************************************************************
    281          *                                            Serial_Init()
    282          *
    283          * Description : Initialize the serial communication module:
    284          *
    285          * Argument(s) : None.
    286          *
    287          * Return(s)   : SERIAL_ERR_NONE,                    if NO errors.
    288          *
    289          *               Specific initialization error code, otherwise.
    290          *
    291          * Caller(s)   : Application.
    292          *
    293          * Note(s)     : (1) SerialInit() MUST be called ... :
    294          *
    295          *                   (a) ONLY ONCE from a product's application; ...
    296          *                   (b) (1) AFTER  product's OS has been initialized
    297          *                       (2) BEFORE product's application calls any network protocol suite function(s)
    298          *********************************************************************************************************
    299          */
    300          

   \                                 In section .text, align 2, keep-with-next
    301          SERIAL_ERR  Serial_Init (void)
    302          {
   \                     Serial_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    303              SERIAL_IF_NBR   ix;
    304              SERIAL_IF      *pif;
    305              SERIAL_ERR      ser_err;
    306          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    307              LIB_ERR         lib_err;
    308          #endif
    309          
    310          
    311                                                                          /* -------------- PERFORM SERIAL/OS INIT -------------- */
    312              SerialOS_Init(&ser_err);
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x.... 0x....      BL       SerialOS_Init
    313              if (ser_err != SERIAL_OS_ERR_NONE) {
   \   00000008   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000000C   0x283C             CMP      R0,#+60
   \   0000000E   0xD002             BEQ.N    ??Serial_Init_0
    314                  return (ser_err);
   \   00000010   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000014   0xE02C             B.N      ??Serial_Init_1
    315              }
    316          
    317                                                                          /* ----------------- INIT IF DATA TBL ----------------- */
    318                                                                          /* Clr all IF data.                                     */
    319              for (ix = SERIAL_IF_NBR_MIN; ix < SERIAL_IF_NBR_TOT; ix++) {
   \                     ??Serial_Init_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0004             MOVS     R4,R0
   \                     ??Serial_Init_2: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C04             CMP      R4,#+4
   \   0000001E   0xD222             BCS.N    ??Serial_Init_3
    320                  pif = &Serial_IF_Tbl[ix];
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x21F0             MOVS     R1,#+240
   \   00000028   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x0005             MOVS     R5,R0
    321          
    322                  Serial_IF_Clr(pif);
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       Serial_IF_Clr
    323          
    324                  pif->Nbr     = (SERIAL_IF_NBR  )ix;
   \   00000036   0x706C             STRB     R4,[R5, #+1]
    325                  pif->Init    = (CPU_BOOLEAN    )DEF_NO;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7028             STRB     R0,[R5, #+0]
    326                  pif->State   = (CPU_INT08U     )SERIAL_STATE_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x70A8             STRB     R0,[R5, #+2]
    327                  pif->NamePtr = (CPU_CHAR      *)0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6068             STR      R0,[R5, #+4]
    328          
    329                  pif->RdSem   = (void          *)0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6728             STR      R0,[R5, #+112]
    330                  pif->WrSem   = (void          *)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF8C5 0x009C      STR      R0,[R5, #+156]
    331          
    332          
    333          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    334                  Mem_PoolClr(&pif->TxBufPool, &lib_err);
   \   0000004E   0xF10D 0x0102      ADD      R1,SP,#+2
   \   00000052   0xF115 0x001C      ADDS     R0,R5,#+28
   \   00000056   0x.... 0x....      BL       Mem_PoolClr
    335          
    336                  pif->TxBufListStart = (SERIAL_BUF_DESC *)0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6668             STR      R0,[R5, #+100]
    337                  pif->TxBufListEnd   = (SERIAL_BUF_DESC *)0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x66A8             STR      R0,[R5, #+104]
    338          #endif
    339              }
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xE7D9             B.N      ??Serial_Init_2
    340          
    341              SerialIF_NbrNext = SERIAL_IF_NBR_MIN;
   \                     ??Serial_Init_3: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    342          
    343              return (SERIAL_ERR_NONE);
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??Serial_Init_1: (+1)
   \   00000070   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    344          }
    345          
    346          
    347          /*$PAGE*/
    348          /*
    349          *********************************************************************************************************
    350          *                                         Serial_DevDrvAdd()
    351          *
    352          * Description : Add a serial device driver.
    353          *
    354          * Argument(s) : pname       Pointer to name that will be used to open the device.
    355          *
    356          *               pdev_cfg    Pointer to device configuration structure.
    357          *
    358          *               rd_buf_len  Length of read buffer.
    359          *
    360          *               wr_buf_len  Length of write buffer.
    361          *
    362          *               perr        Pointer to variable that will receive the return error code from this function :
    363          *
    364          *                               SERIAL_ERR_NONE                 Serial device driver successfully added.
    365          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'pname',
    366          *                                                                   'pdev_cfg', 'pdev_cfg->Drv_API' or 
    367          *                                                                   'pdev_cfg->Dev_Cfg'.
    368          *                               SERIAL_ERR_DRV_INVALID          NULL/invalid members in 'pdev_cfg->Drv_API'.
    369          *                               SERIAL_ERR_DEV_DUP_NAME         'pname' duplicates name of existing device.
    370          *                               SERIAL_ERR_IF_NOT_AVAIL         Resource for new interface NOT available.
    371          *                               SERIAL_ERR_MEM_ALLOC            Memory could NOT be allocated for new interface
    372          *                                                                   entry or read/write buffers.
    373          *                               SERIAL_ERR_BUF_POOL_INIT        Buffer pool could NOT be initialized.
    374          *
    375          * Return(s)   : None.
    376          *
    377          * Caller(s)   : Application.
    378          *
    379          * Note(s)     : None.
    380          *********************************************************************************************************
    381          */
    382          

   \                                 In section .text, align 2, keep-with-next
    383          void  Serial_DevDrvAdd (CPU_CHAR        *pname,
    384                                  SERIAL_DEV_CFG  *pdev_cfg,
    385                                  CPU_SIZE_T       rd_buf_len,
    386                                  CPU_SIZE_T       wr_buf_len,
    387                                  SERIAL_ERR      *perr)
    388          {
   \                     Serial_DevDrvAdd: (+1)
   \   00000000   0xE92D 0x4FFC      PUSH     {R2-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x9E12             LDR      R6,[SP, #+72]
    389              SERIAL_IF      *pif;
    390              SERIAL_DEV     *pdev;
    391              SERIAL_IF_NBR   ix;
    392              CPU_INT16S      cmp;
    393              CPU_BOOLEAN     init;
    394          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED) || \
    395              (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)
    396              CPU_INT08U     *pbuf_data;
    397          #endif
    398          #if (SERIAL_CFG_RD_BUF_EN       == DEF_ENABLED) || \
    399              (SERIAL_CFG_WR_BUF_EN       == DEF_ENABLED) || \
    400              (SERIAL_CFG_TX_DESC_NBR >  0)
    401              CPU_SIZE_T      octets_reqd;
    402              LIB_ERR         lib_err;
    403          #endif
    404              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    405          
    406          
    407          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
    408              if (pname == (CPU_CHAR *)0) {
    409                 *perr = SERIAL_ERR_NULL_PTR;
    410                  return;
    411              }
    412          
    413              if (pdev_cfg == (SERIAL_DEV_CFG *)0) {
    414                 *perr = SERIAL_ERR_NULL_PTR;
    415                  return;
    416              }
    417          
    418              if (pdev_cfg->Drv_API == (SERIAL_DRV_API *)0) {
    419                 *perr = SERIAL_ERR_NULL_PTR;
    420                  return;
    421              }
    422          
    423              if ((pdev_cfg->Drv_API->Init        == (void *)0) ||        /* Validate drv API.                                    */
    424                  (pdev_cfg->Drv_API->Open        == (void *)0) ||
    425                  (pdev_cfg->Drv_API->Close       == (void *)0) ||
    426                  (pdev_cfg->Drv_API->RxStart     == (void *)0) ||
    427                  (pdev_cfg->Drv_API->RxStop      == (void *)0) ||
    428                  (pdev_cfg->Drv_API->RxOctet     == (void *)0) ||
    429                  (pdev_cfg->Drv_API->TxStart     == (void *)0) ||
    430                  (pdev_cfg->Drv_API->TxStop      == (void *)0) ||
    431                  (pdev_cfg->Drv_API->TxOctet     == (void *)0) ||
    432                  (pdev_cfg->Drv_API->ISR_Handler == (void *)0)) {
    433                  *perr = SERIAL_ERR_DRV_INVALID;
    434                   return;
    435              }
    436          #endif
    437          
    438          
    439              CPU_CRITICAL_ENTER();
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x4683             MOV      R11,R0
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStart
    440                                                                          /* ---------------------- INIT DEV -------------------- */
    441              if (SerialIF_NbrNext >= SERIAL_IF_NBR_TOT) {                /* Chk next IF nbr.                                     */
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2804             CMP      R0,#+4
   \   00000022   0xD307             BCC.N    ??Serial_DevDrvAdd_0
    442                  CPU_CRITICAL_EXIT();
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0x4658             MOV      R0,R11
   \   0000002A   0x.... 0x....      BL       CPU_SR_Restore
    443                 *perr = SERIAL_ERR_IF_NOT_AVAIL;
   \   0000002E   0x2028             MOVS     R0,#+40
   \   00000030   0x8030             STRH     R0,[R6, #+0]
    444                  return;
   \   00000032   0xE10E             B.N      ??Serial_DevDrvAdd_1
    445              }
    446          
    447              for (ix = SERIAL_IF_NBR_MIN; ix < SerialIF_NbrNext; ix++) { /* Chk if dev name dup'd.                               */
   \                     ??Serial_DevDrvAdd_0: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4681             MOV      R9,R0
   \                     ??Serial_DevDrvAdd_2: (+1)
   \   00000038   0x4648             MOV      R0,R9
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD21D             BCS.N    ??Serial_DevDrvAdd_3
    448                  pif = &Serial_IF_Tbl[ix];
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000004A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000004E   0x21F0             MOVS     R1,#+240
   \   00000050   0xFB01 0xF109      MUL      R1,R1,R9
   \   00000054   0x4408             ADD      R0,R0,R1
   \   00000056   0x0007             MOVS     R7,R0
    449                  cmp =  Str_Cmp(pif->NamePtr, pname);
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0x6878             LDR      R0,[R7, #+4]
   \   0000005C   0x.... 0x....      BL       Str_Cmp
   \   00000060   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    450                  if (cmp == 0) {
   \   00000064   0xF9BD 0x0014      LDRSH    R0,[SP, #+20]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD107             BNE.N    ??Serial_DevDrvAdd_4
    451                      CPU_CRITICAL_EXIT();
   \   0000006C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000070   0x4658             MOV      R0,R11
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    452                     *perr = SERIAL_ERR_DEV_DUP_NAME;
   \   00000076   0x201E             MOVS     R0,#+30
   \   00000078   0x8030             STRH     R0,[R6, #+0]
    453                      return;
   \   0000007A   0xE0EA             B.N      ??Serial_DevDrvAdd_1
    454                  }
    455              }
   \                     ??Serial_DevDrvAdd_4: (+1)
   \   0000007C   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000080   0xE7DA             B.N      ??Serial_DevDrvAdd_2
    456          
    457                                                                          /* --------------------- SEARCH DRV ------------------- */
    458              init = DEF_TRUE;
   \                     ??Serial_DevDrvAdd_3: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF88D 0x0010      STRB     R0,[SP, #+16]
    459              for (ix = SERIAL_IF_NBR_MIN; ix < SerialIF_NbrNext; ix++) {
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x4681             MOV      R9,R0
   \                     ??Serial_DevDrvAdd_5: (+1)
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000092   0x7809             LDRB     R1,[R1, #+0]
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD217             BCS.N    ??Serial_DevDrvAdd_6
    460                  pif = &Serial_IF_Tbl[ix];
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000009E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A2   0x21F0             MOVS     R1,#+240
   \   000000A4   0xFB01 0xF109      MUL      R1,R1,R9
   \   000000A8   0x4408             ADD      R0,R0,R1
   \   000000AA   0x0007             MOVS     R7,R0
    461          
    462                  if ((pif->Init                 == DEF_YES) &&
    463                      (pif->Dev.Dev_Cfg->Drv_API == pdev_cfg->Drv_API)) {
   \   000000AC   0x7838             LDRB     R0,[R7, #+0]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD108             BNE.N    ??Serial_DevDrvAdd_7
   \   000000B2   0x68F8             LDR      R0,[R7, #+12]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0x6869             LDR      R1,[R5, #+4]
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD103             BNE.N    ??Serial_DevDrvAdd_7
    464                      init = DEF_FALSE;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF88D 0x0010      STRB     R0,[SP, #+16]
    465                      break;
   \   000000C2   0xE002             B.N      ??Serial_DevDrvAdd_6
    466                  }
    467              }
   \                     ??Serial_DevDrvAdd_7: (+1)
   \   000000C4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000C8   0xE7E0             B.N      ??Serial_DevDrvAdd_5
    468          
    469                                                                          /* ---------------------- INIT DRV -------------------- */
    470              if (init == DEF_TRUE) {
   \                     ??Serial_DevDrvAdd_6: (+1)
   \   000000CA   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000000CE   0x2801             CMP      R0,#+1
   \   000000D0   0xD10C             BNE.N    ??Serial_DevDrvAdd_8
    471                  pdev_cfg->Drv_API->Init(perr);
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0x6869             LDR      R1,[R5, #+4]
   \   000000D6   0x6809             LDR      R1,[R1, #+0]
   \   000000D8   0x4788             BLX      R1
    472                  if (*perr != SERIAL_ERR_NONE) {
   \   000000DA   0x8830             LDRH     R0,[R6, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD005             BEQ.N    ??Serial_DevDrvAdd_8
    473                       CPU_CRITICAL_EXIT();
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x4658             MOV      R0,R11
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
    474                       return;
   \   000000EA   0xE0B2             B.N      ??Serial_DevDrvAdd_1
    475                  }
    476              }
    477          
    478              pif = &Serial_IF_Tbl[SerialIF_NbrNext];
   \                     ??Serial_DevDrvAdd_8: (+1)
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable12
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000000F4   0x7809             LDRB     R1,[R1, #+0]
   \   000000F6   0x22F0             MOVS     R2,#+240
   \   000000F8   0x4351             MULS     R1,R2,R1
   \   000000FA   0x4408             ADD      R0,R0,R1
   \   000000FC   0x0007             MOVS     R7,R0
    479          
    480          
    481          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    482              Mem_PoolCreate((MEM_POOL   *)&pif->TxBufPool,
    483                             (void       *) 0,
    484                             (CPU_SIZE_T  ) 0,
    485                             (CPU_SIZE_T  ) SERIAL_CFG_TX_DESC_NBR,
    486                             (CPU_SIZE_T  ) sizeof(SERIAL_BUF_DESC),
    487                             (CPU_SIZE_T  ) sizeof(CPU_DATA),
    488                             (CPU_SIZE_T *)&octets_reqd,
    489                             (LIB_ERR    *)&lib_err);
   \   000000FE   0xF10D 0x0012      ADD      R0,SP,#+18
   \   00000102   0x9003             STR      R0,[SP, #+12]
   \   00000104   0xA806             ADD      R0,SP,#+24
   \   00000106   0x9002             STR      R0,[SP, #+8]
   \   00000108   0x2004             MOVS     R0,#+4
   \   0000010A   0x9001             STR      R0,[SP, #+4]
   \   0000010C   0x201C             MOVS     R0,#+28
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x230A             MOVS     R3,#+10
   \   00000112   0x2200             MOVS     R2,#+0
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0xF117 0x001C      ADDS     R0,R7,#+28
   \   0000011A   0x.... 0x....      BL       Mem_PoolCreate
    490          
    491              if (lib_err != LIB_MEM_ERR_NONE) {
   \   0000011E   0xF9BD 0x0012      LDRSH    R0,[SP, #+18]
   \   00000122   0xF242 0x7110      MOVW     R1,#+10000
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD007             BEQ.N    ??Serial_DevDrvAdd_9
    492                  CPU_CRITICAL_EXIT();
   \   0000012A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000012E   0x4658             MOV      R0,R11
   \   00000130   0x.... 0x....      BL       CPU_SR_Restore
    493                 *perr = SERIAL_ERR_BUF_POOL_INIT;
   \   00000134   0x2007             MOVS     R0,#+7
   \   00000136   0x8030             STRH     R0,[R6, #+0]
    494                  return;
   \   00000138   0xE08B             B.N      ??Serial_DevDrvAdd_1
    495              }
    496          #endif
    497          
    498              pif->WrSem = SerialOS_SemCreate(1 + SERIAL_CFG_TX_DESC_NBR);
   \                     ??Serial_DevDrvAdd_9: (+1)
   \   0000013A   0x200B             MOVS     R0,#+11
   \   0000013C   0x.... 0x....      BL       SerialOS_SemCreate
   \   00000140   0xF8C7 0x009C      STR      R0,[R7, #+156]
    499              if (pif->WrSem == (void *)0) {
   \   00000144   0xF8D7 0x009C      LDR      R0,[R7, #+156]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD107             BNE.N    ??Serial_DevDrvAdd_10
    500                  CPU_CRITICAL_EXIT();
   \   0000014C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000150   0x4658             MOV      R0,R11
   \   00000152   0x.... 0x....      BL       CPU_SR_Restore
    501                 *perr = SERIAL_ERR_SIGNAL;
   \   00000156   0x2003             MOVS     R0,#+3
   \   00000158   0x8030             STRH     R0,[R6, #+0]
    502                  return;
   \   0000015A   0xE07A             B.N      ??Serial_DevDrvAdd_1
    503              }
    504          
    505              pif->RdSem = SerialOS_SemCreate(1);
   \                     ??Serial_DevDrvAdd_10: (+1)
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x.... 0x....      BL       SerialOS_SemCreate
   \   00000162   0x6738             STR      R0,[R7, #+112]
    506              if (pif->RdSem == (void *)0) {
   \   00000164   0x6F38             LDR      R0,[R7, #+112]
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD107             BNE.N    ??Serial_DevDrvAdd_11
    507                  CPU_CRITICAL_EXIT();
   \   0000016A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016E   0x4658             MOV      R0,R11
   \   00000170   0x.... 0x....      BL       CPU_SR_Restore
    508                 *perr = SERIAL_ERR_SIGNAL;
   \   00000174   0x2003             MOVS     R0,#+3
   \   00000176   0x8030             STRH     R0,[R6, #+0]
    509                  return;
   \   00000178   0xE06B             B.N      ??Serial_DevDrvAdd_1
    510              }
    511          
    512              pif->NamePtr = pname;
   \                     ??Serial_DevDrvAdd_11: (+1)
   \   0000017A   0x607C             STR      R4,[R7, #+4]
    513              SerialIF_NbrNext++;                                         /* Update IF cnt.                                       */
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0x1C40             ADDS     R0,R0,#+1
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000188   0x7008             STRB     R0,[R1, #+0]
    514          
    515              CPU_CRITICAL_EXIT();
   \   0000018A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000018E   0x4658             MOV      R0,R11
   \   00000190   0x.... 0x....      BL       CPU_SR_Restore
    516          
    517                                                                          /* ------------------- LINK DEV DESC ------------------ */
    518              pdev               = &pif->Dev;
   \   00000194   0xF117 0x0008      ADDS     R0,R7,#+8
   \   00000198   0x4680             MOV      R8,R0
    519              pdev->IF_Nbr       =  pif->Nbr;
   \   0000019A   0x7878             LDRB     R0,[R7, #+1]
   \   0000019C   0xF888 0x0000      STRB     R0,[R8, #+0]
    520              pdev->Dev_Cfg      =  pdev_cfg;
   \   000001A0   0xF8C8 0x5004      STR      R5,[R8, #+4]
    521              pdev->Drv_Data     = (void                *)0;
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0xF8C8 0x0008      STR      R0,[R8, #+8]
    522              pdev->LineDrv_API  = (SERIAL_LINE_DRV_API *)0;
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF8C8 0x000C      STR      R0,[R8, #+12]
    523              pdev->LineDrv_Data = (void                *)0;
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0xF8C8 0x0010      STR      R0,[R8, #+16]
    524          
    525             *perr = SERIAL_ERR_NONE;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x8030             STRH     R0,[R6, #+0]
    526          
    527             (void)&rd_buf_len;
   \   000001BA   0xA807             ADD      R0,SP,#+28
    528          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* -------------------- INIT RD BUF ------------------- */
    529              pif->RdBufEn = DEF_NO;
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0xF887 0x00C0      STRB     R0,[R7, #+192]
    530          
    531              if (rd_buf_len > 0) {                                       /* Alloc rd buf.                                        */
   \   000001C2   0x9807             LDR      R0,[SP, #+28]
   \   000001C4   0x2800             CMP      R0,#+0
   \   000001C6   0xD017             BEQ.N    ??Serial_DevDrvAdd_12
    532                  pbuf_data = (CPU_INT08U *)Mem_HeapAlloc((CPU_SIZE_T  ) rd_buf_len,
    533                                                          (CPU_SIZE_T  ) sizeof(CPU_ALIGN),
    534                                                          (CPU_SIZE_T *)&octets_reqd,
    535                                                          (LIB_ERR    *)&lib_err);
   \   000001C8   0xF10D 0x0312      ADD      R3,SP,#+18
   \   000001CC   0xAA06             ADD      R2,SP,#+24
   \   000001CE   0x2104             MOVS     R1,#+4
   \   000001D0   0x9807             LDR      R0,[SP, #+28]
   \   000001D2   0x.... 0x....      BL       Mem_HeapAlloc
   \   000001D6   0x4682             MOV      R10,R0
    536                  if (pbuf_data == (CPU_INT08U *)0) {
   \   000001D8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001DC   0xD102             BNE.N    ??Serial_DevDrvAdd_13
    537                     *perr = SERIAL_ERR_MEM_ALLOC;                        /* Indicate rd buf alloc failure, but continue add IF.  */
   \   000001DE   0x2009             MOVS     R0,#+9
   \   000001E0   0x8030             STRH     R0,[R6, #+0]
   \   000001E2   0xE009             B.N      ??Serial_DevDrvAdd_12
    538                  } else {
    539                      pif->RdBufEn  = DEF_YES;
   \                     ??Serial_DevDrvAdd_13: (+1)
   \   000001E4   0x2001             MOVS     R0,#+1
   \   000001E6   0xF887 0x00C0      STRB     R0,[R7, #+192]
    540                      SerialBuf_Init((SERIAL_BUF  *)&(pif->RdBuf),
    541                                     (CPU_INT08U  *)  pbuf_data,
    542                                     (CPU_SIZE_T   )  rd_buf_len,
    543                                     (CPU_BOOLEAN  )  DEF_NO);
   \   000001EA   0x2300             MOVS     R3,#+0
   \   000001EC   0x9A07             LDR      R2,[SP, #+28]
   \   000001EE   0x4651             MOV      R1,R10
   \   000001F0   0xF117 0x00C4      ADDS     R0,R7,#+196
   \   000001F4   0x.... 0x....      BL       SerialBuf_Init
    544                  }
    545              }
    546          #endif
    547          
    548          
    549             (void)&wr_buf_len;
   \                     ??Serial_DevDrvAdd_12: (+1)
   \   000001F8   0xA808             ADD      R0,SP,#+32
    550          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)                       /* -------------------- INIT WR BUF ------------------- */
    551              pif->WrBufEn = DEF_NO;
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0xF887 0x00D8      STRB     R0,[R7, #+216]
    552          
    553              if (wr_buf_len > 0) {                                       /* Alloc wr buf.                                        */
   \   00000200   0x9808             LDR      R0,[SP, #+32]
   \   00000202   0x2800             CMP      R0,#+0
   \   00000204   0xD017             BEQ.N    ??Serial_DevDrvAdd_14
    554                  pbuf_data = (CPU_INT08U *)Mem_HeapAlloc((CPU_SIZE_T  ) wr_buf_len,
    555                                                          (CPU_SIZE_T  ) sizeof(CPU_ALIGN),
    556                                                          (CPU_SIZE_T *)&octets_reqd,
    557                                                          (LIB_ERR    *)&lib_err);
   \   00000206   0xF10D 0x0312      ADD      R3,SP,#+18
   \   0000020A   0xAA06             ADD      R2,SP,#+24
   \   0000020C   0x2104             MOVS     R1,#+4
   \   0000020E   0x9808             LDR      R0,[SP, #+32]
   \   00000210   0x.... 0x....      BL       Mem_HeapAlloc
   \   00000214   0x4682             MOV      R10,R0
    558                  if (pbuf_data == (CPU_INT08U *)0) {
   \   00000216   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000021A   0xD102             BNE.N    ??Serial_DevDrvAdd_15
    559                     *perr = SERIAL_ERR_MEM_ALLOC;                        /* Indicate wr buf alloc failure, but continue add IF.  */
   \   0000021C   0x2009             MOVS     R0,#+9
   \   0000021E   0x8030             STRH     R0,[R6, #+0]
   \   00000220   0xE009             B.N      ??Serial_DevDrvAdd_14
    560                  } else {
    561                      pif->WrBufEn  = DEF_YES;
   \                     ??Serial_DevDrvAdd_15: (+1)
   \   00000222   0x2001             MOVS     R0,#+1
   \   00000224   0xF887 0x00D8      STRB     R0,[R7, #+216]
    562                      SerialBuf_Init((SERIAL_BUF  *)&(pif->WrBuf),
    563                                     (CPU_INT08U  *)  pbuf_data,
    564                                     (CPU_SIZE_T   )  wr_buf_len,
    565                                     (CPU_BOOLEAN  )  DEF_NO);
   \   00000228   0x2300             MOVS     R3,#+0
   \   0000022A   0x9A08             LDR      R2,[SP, #+32]
   \   0000022C   0x4651             MOV      R1,R10
   \   0000022E   0xF117 0x00DC      ADDS     R0,R7,#+220
   \   00000232   0x.... 0x....      BL       SerialBuf_Init
    566                  }
    567              }
    568          #endif
    569          
    570          
    571              CPU_CRITICAL_ENTER();
   \                     ??Serial_DevDrvAdd_14: (+1)
   \   00000236   0x.... 0x....      BL       CPU_SR_Save
   \   0000023A   0x4683             MOV      R11,R0
   \   0000023C   0x.... 0x....      BL       CPU_IntDisMeasStart
    572              pif->Init  = DEF_YES;
   \   00000240   0x2001             MOVS     R0,#+1
   \   00000242   0x7038             STRB     R0,[R7, #+0]
    573              pif->State = SERIAL_STATE_CLOSED;
   \   00000244   0x2001             MOVS     R0,#+1
   \   00000246   0x70B8             STRB     R0,[R7, #+2]
    574              CPU_CRITICAL_EXIT();
   \   00000248   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000024C   0x4658             MOV      R0,R11
   \   0000024E   0x.... 0x....      BL       CPU_SR_Restore
    575          }
   \                     ??Serial_DevDrvAdd_1: (+1)
   \   00000252   0xB009             ADD      SP,SP,#+36
   \   00000254   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    576          
    577          
    578          /*$PAGE*/
    579          /*
    580          *********************************************************************************************************
    581          *                                         Serial_IF_IsValid()
    582          *
    583          * Description : Validate serial interface number.
    584          *
    585          * Argument(s) : if_nbr      Serial interface number to validate.
    586          *
    587          *               perr        Pointer to variable that will receive the return error code from this function :
    588          *
    589          *                               SERIAL_ERR_NONE                 Serial interface successfully validated.
    590          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
    591          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
    592          *
    593          * Return(s)   : DEF_YES, serial interface number is valid.
    594          *
    595          *               DEF_NO,  otherwise.
    596          *
    597          * Caller(s)   : various.
    598          *
    599          * Note(s)     : None.
    600          *********************************************************************************************************
    601          */
    602          

   \                                 In section .text, align 2, keep-with-next
    603          CPU_BOOLEAN  Serial_IF_IsValid (SERIAL_IF_NBR   if_nbr,
    604                                          SERIAL_ERR     *perr)
    605          {
   \                     Serial_IF_IsValid: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    606              SERIAL_IF  *pif;
    607          
    608          
    609          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* -------------- VALIDATE SERIAL IF NBR -------------- */
    610              if (if_nbr >= SERIAL_IF_NBR_TOT) {
    611                 *perr = SERIAL_ERR_IF_INVALID_NBR;
    612                  return (DEF_NO);
    613              }
    614          #endif
    615          
    616                                                                          /* ---------------- VALIDATE SERIAL IF ---------------- */
    617              if (if_nbr >= SerialIF_NbrNext) {
   \   00000004   0x0010             MOVS     R0,R2
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable13
   \   0000000A   0x7824             LDRB     R4,[R4, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x42A0             CMP      R0,R4
   \   00000010   0xD303             BCC.N    ??Serial_IF_IsValid_0
    618                 *perr = SERIAL_ERR_IF_INVALID_NBR;
   \   00000012   0x2006             MOVS     R0,#+6
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    619                  return (DEF_NO);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE018             B.N      ??Serial_IF_IsValid_1
    620              }
    621          
    622              pif = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_IF_IsValid_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000001E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000020   0x24F0             MOVS     R4,#+240
   \   00000022   0xFB04 0xF402      MUL      R4,R4,R2
   \   00000026   0x4420             ADD      R0,R0,R4
   \   00000028   0x0003             MOVS     R3,R0
    623              if (pif->Init != DEF_YES) {
   \   0000002A   0x7818             LDRB     R0,[R3, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD003             BEQ.N    ??Serial_IF_IsValid_2
    624                 *perr = SERIAL_ERR_IF_INVALID_NBR;
   \   00000030   0x2006             MOVS     R0,#+6
   \   00000032   0x8008             STRH     R0,[R1, #+0]
    625                  return (DEF_NO);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE009             B.N      ??Serial_IF_IsValid_1
    626              }
    627          
    628              if (pif->State != SERIAL_STATE_OPENED) {
   \                     ??Serial_IF_IsValid_2: (+1)
   \   00000038   0x7898             LDRB     R0,[R3, #+2]
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD003             BEQ.N    ??Serial_IF_IsValid_3
    629                 *perr = SERIAL_ERR_IF_NOT_OPEN;
   \   0000003E   0x2029             MOVS     R0,#+41
   \   00000040   0x8008             STRH     R0,[R1, #+0]
    630                  return (DEF_NO);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE002             B.N      ??Serial_IF_IsValid_1
    631              }
    632          
    633          
    634             *perr = SERIAL_ERR_NONE;
   \                     ??Serial_IF_IsValid_3: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    635              return (DEF_YES);
   \   0000004A   0x2001             MOVS     R0,#+1
   \                     ??Serial_IF_IsValid_1: (+1)
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
    636          }
    637          
    638          
    639          /*$PAGE*/
    640          /*
    641          *********************************************************************************************************
    642          *                                         Serial_SetLineDrv()
    643          *
    644          * Description : Set serial interface line driver.
    645          *
    646          * Argument(s) : if_nbr      Serial interface number to validate.
    647          *
    648          *               pline_api   Pointer to line driver API,
    649          *                               OR
    650          *                           Pointer to NULL, if the default line driver will be used.
    651          *
    652          *               perr        Pointer to variable that will receive the return error code from this function :
    653          *
    654          *                               SERIAL_ERR_NONE                 Serial interface successfully validated.
    655          *
    656          *                                                               --- RETURNED BY Serial_IF_IsValid() : ---
    657          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
    658          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
    659          *
    660          * Return(s)   : None.
    661          *
    662          * Caller(s)   : Application.
    663          *
    664          * Note(s)     : None.
    665          *********************************************************************************************************
    666          */
    667          

   \                                 In section .text, align 2, keep-with-next
    668          void  Serial_SetLineDrv (SERIAL_IF_NBR         if_nbr,
    669                                   SERIAL_LINE_DRV_API  *pline_api,
    670                                   SERIAL_ERR           *perr)
    671          {
   \                     Serial_SetLineDrv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    672              SERIAL_IF    *pif;
    673              SERIAL_DEV   *pdev;
    674              CPU_BOOLEAN   valid;
    675              void         *pline_data;
    676              SERIAL_ERR    ser_err;
    677              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    678          
    679          
    680              if (pline_api == (SERIAL_LINE_DRV_API *)0) {                /* Dflt line drv.                                       */
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD102             BNE.N    ??Serial_SetLineDrv_0
    681                  pline_api  = (SERIAL_LINE_DRV_API *)&SerialLine_Dflt;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000016   0x0005             MOVS     R5,R0
    682              }
    683          
    684                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
    685              CPU_CRITICAL_ENTER();
   \                     ??Serial_SetLineDrv_0: (+1)
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x4683             MOV      R11,R0
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStart
    686              valid = Serial_IF_IsValid(if_nbr, perr);
   \   00000022   0x0031             MOVS     R1,R6
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       Serial_IF_IsValid
   \   0000002C   0x4681             MOV      R9,R0
    687              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   0000002E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000032   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000036   0xD005             BEQ.N    ??Serial_SetLineDrv_1
    688                  CPU_CRITICAL_EXIT();
   \   00000038   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
    689                  return;
   \   00000042   0xE041             B.N      ??Serial_SetLineDrv_2
    690              }
    691          
    692                                                                          /* ----------------- GET LINE DRV INFO ---------------- */
    693              pif  = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_SetLineDrv_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x21F0             MOVS     R1,#+240
   \   0000004C   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000050   0x4408             ADD      R0,R0,R1
   \   00000052   0x0007             MOVS     R7,R0
    694              pdev = &pif->Dev;
   \   00000054   0xF117 0x0008      ADDS     R0,R7,#+8
   \   00000058   0x4680             MOV      R8,R0
    695          
    696              pline_data = pline_api->Open(pdev, perr);                   /* 'Open' new line drv.                                 */
   \   0000005A   0x0031             MOVS     R1,R6
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x682A             LDR      R2,[R5, #+0]
   \   00000060   0x4790             BLX      R2
   \   00000062   0x4682             MOV      R10,R0
    697              if (*perr != SERIAL_ERR_NONE) {
   \   00000064   0x8830             LDRH     R0,[R6, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD005             BEQ.N    ??Serial_SetLineDrv_3
    698                  CPU_CRITICAL_EXIT();
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
    699                  return;
   \   00000074   0xE028             B.N      ??Serial_SetLineDrv_2
    700              }
    701          
    702              pdev->LineDrv_API->Close(pdev, pdev->LineDrv_Data, perr);   /* 'Close' cur line drv.                                */
   \                     ??Serial_SetLineDrv_3: (+1)
   \   00000076   0x0032             MOVS     R2,R6
   \   00000078   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0xF8D8 0x300C      LDR      R3,[R8, #+12]
   \   00000082   0x685B             LDR      R3,[R3, #+4]
   \   00000084   0x4798             BLX      R3
    703              if (*perr != SERIAL_ERR_NONE) {
   \   00000086   0x8830             LDRH     R0,[R6, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD00A             BEQ.N    ??Serial_SetLineDrv_4
    704                  pline_api->Close(pdev, pline_data, &ser_err);           /* 'Close' new line drv.                                */
   \   0000008C   0x466A             MOV      R2,SP
   \   0000008E   0x4651             MOV      R1,R10
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x686B             LDR      R3,[R5, #+4]
   \   00000094   0x4798             BLX      R3
    705                  CPU_CRITICAL_EXIT();
   \   00000096   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       CPU_SR_Restore
    706                  return;
   \   000000A0   0xE012             B.N      ??Serial_SetLineDrv_2
    707              }
    708          
    709          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* Flush rd buf.                                        */
    710              if (pif->RdBufEn == DEF_YES) {
   \                     ??Serial_SetLineDrv_4: (+1)
   \   000000A2   0xF897 0x00C0      LDRB     R0,[R7, #+192]
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD103             BNE.N    ??Serial_SetLineDrv_5
    711                  SerialBuf_Clr(&(pif->RdBuf));
   \   000000AA   0xF117 0x00C4      ADDS     R0,R7,#+196
   \   000000AE   0x.... 0x....      BL       SerialBuf_Clr
    712              }
    713          #endif
    714          
    715              pdev->LineDrv_API  = pline_api;
   \                     ??Serial_SetLineDrv_5: (+1)
   \   000000B2   0xF8C8 0x500C      STR      R5,[R8, #+12]
    716              pdev->LineDrv_Data = pline_data;
   \   000000B6   0xF8C8 0xA010      STR      R10,[R8, #+16]
    717              CPU_CRITICAL_EXIT();
   \   000000BA   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BE   0x4658             MOV      R0,R11
   \   000000C0   0x.... 0x....      BL       CPU_SR_Restore
    718          
    719             *perr = SERIAL_ERR_NONE;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x8030             STRH     R0,[R6, #+0]
    720          }
   \                     ??Serial_SetLineDrv_2: (+1)
   \   000000C8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    721          
    722          
    723          /*$PAGE*/
    724          /*
    725          *********************************************************************************************************
    726          *                                            Serial_Open()
    727          *
    728          * Description : Open a serial interface for communication.
    729          *
    730          * Argument(s) : pname       Pointer to device name.
    731          *
    732          *               pcfg        Pointer to serial port setup data.
    733          *
    734          *               perr        Pointer to variable that will receive the return error code from this function :
    735          *
    736          *                               SERIAL_ERR_NONE                 Device successfully opened.
    737          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for 'pname' or 'pcfg'.
    738          *                               SERIAL_ERR_DEV_NOT_FOUND        Device not found.
    739          *                               SERIAL_ERR_DEV_ALREADY_OPEN     Device is already open.
    740          *                               SERIAL_ERR_DRV_OPEN             Driver could NOT be open or device
    741          *                                                                   initialization NOT successful.
    742          *
    743          * Return(s)   : Interface number.
    744          *
    745          * Caller(s)   : Application.
    746          *
    747          * Note(s)     : (1) The serial interface is opened with the default line driver.
    748          *********************************************************************************************************
    749          */
    750          

   \                                 In section .text, align 2, keep-with-next
    751          SERIAL_IF_NBR  Serial_Open (CPU_CHAR       *pname,
    752                                      SERIAL_IF_CFG  *pcfg,
    753                                      SERIAL_ERR     *perr)
    754          {
   \                     Serial_Open: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    755              CPU_INT16S            cmp;
    756              SERIAL_IF_NBR         ix;
    757              CPU_BOOLEAN           found;
    758              SERIAL_IF            *pif;
    759              SERIAL_DEV           *pdev;
    760              SERIAL_LINE_DRV_API  *pline_api;
    761              void                 *pline_data;
    762              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    763          
    764          
    765          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
    766              if (pname == (CPU_CHAR *)0) {
    767                 *perr = SERIAL_ERR_NULL_PTR;
    768                  return (SERIAL_IF_NBR_NONE);
    769              }
    770          
    771              if (pcfg == (SERIAL_IF_CFG *)0) {
    772                 *perr = SERIAL_ERR_NULL_PTR;
    773                  return (SERIAL_IF_NBR_NONE);
    774              }
    775          #endif
    776          
    777                                                                          /* --------------------- FIND DEV --------------------- */
    778              pif   = (SERIAL_IF *)0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4680             MOV      R8,R0
    779              found = DEF_NO;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
    780              for (ix = SERIAL_IF_NBR_MIN; ix < SerialIF_NbrNext; ix++) {
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0007             MOVS     R7,R0
   \                     ??Serial_Open_0: (+1)
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD218             BCS.N    ??Serial_Open_1
    781                  pif = &Serial_IF_Tbl[ix];
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x21F0             MOVS     R1,#+240
   \   00000034   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000038   0x4408             ADD      R0,R0,R1
   \   0000003A   0x4680             MOV      R8,R0
    782                  cmp =  Str_Cmp(pif->NamePtr, pname);
   \   0000003C   0x0021             MOVS     R1,R4
   \   0000003E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000042   0x.... 0x....      BL       Str_Cmp
   \   00000046   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    783                  if (cmp == 0) {
   \   0000004A   0xF9BD 0x0002      LDRSH    R0,[SP, #+2]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD103             BNE.N    ??Serial_Open_2
    784                      found = DEF_YES;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    785                      break;
   \   00000058   0xE001             B.N      ??Serial_Open_1
    786                  }
    787              }
   \                     ??Serial_Open_2: (+1)
   \   0000005A   0x1C7F             ADDS     R7,R7,#+1
   \   0000005C   0xE7DF             B.N      ??Serial_Open_0
    788          
    789              if (found == DEF_NO) {                                      /* IF not found.                                        */
   \                     ??Serial_Open_1: (+1)
   \   0000005E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD103             BNE.N    ??Serial_Open_3
    790                 *perr = SERIAL_ERR_DEV_NOT_FOUND;
   \   00000066   0x201F             MOVS     R0,#+31
   \   00000068   0x8030             STRH     R0,[R6, #+0]
    791                  return (SERIAL_IF_NBR_NONE);
   \   0000006A   0x20FF             MOVS     R0,#+255
   \   0000006C   0xE06E             B.N      ??Serial_Open_4
    792              }
    793          
    794          
    795              pdev = &pif->Dev;
   \                     ??Serial_Open_3: (+1)
   \   0000006E   0xF118 0x0008      ADDS     R0,R8,#+8
   \   00000072   0x4681             MOV      R9,R0
    796          
    797                                                                          /* --------------------- OPEN DEV --------------------- */
    798              CPU_CRITICAL_ENTER();
   \   00000074   0x.... 0x....      BL       CPU_SR_Save
   \   00000078   0x4683             MOV      R11,R0
   \   0000007A   0x.... 0x....      BL       CPU_IntDisMeasStart
    799              if (pif->State != SERIAL_STATE_CLOSED) {                    /* Chk if port already open.                            */
   \   0000007E   0xF898 0x0002      LDRB     R0,[R8, #+2]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD008             BEQ.N    ??Serial_Open_5
    800                  CPU_CRITICAL_EXIT();
   \   00000086   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008A   0x4658             MOV      R0,R11
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
    801                 *perr = SERIAL_ERR_DEV_ALREADY_OPEN;
   \   00000090   0x2020             MOVS     R0,#+32
   \   00000092   0x8030             STRH     R0,[R6, #+0]
    802                  return (SERIAL_IF_NBR_NONE);
   \   00000094   0x20FF             MOVS     R0,#+255
   \   00000096   0xE059             B.N      ??Serial_Open_4
    803              }
    804          
    805              pline_api  = &SerialLine_Dflt;                              /* Dflt   line drv.                                     */
   \                     ??Serial_Open_5: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000009C   0x4682             MOV      R10,R0
    806              pline_data =  pline_api->Open(pdev, perr);                  /* 'Open' line drv.                                     */
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x4648             MOV      R0,R9
   \   000000A2   0xF8DA 0x2000      LDR      R2,[R10, #+0]
   \   000000A6   0x4790             BLX      R2
   \   000000A8   0x9001             STR      R0,[SP, #+4]
    807              if (*perr != SERIAL_ERR_NONE) {
   \   000000AA   0x8830             LDRH     R0,[R6, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD006             BEQ.N    ??Serial_Open_6
    808                  CPU_CRITICAL_EXIT();
   \   000000B0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000B4   0x4658             MOV      R0,R11
   \   000000B6   0x.... 0x....      BL       CPU_SR_Restore
    809                  return (SERIAL_IF_NBR_NONE);
   \   000000BA   0x20FF             MOVS     R0,#+255
   \   000000BC   0xE046             B.N      ??Serial_Open_4
    810              }
    811          
    812              pdev->Dev_Cfg->Drv_API->Open(pdev, pcfg, perr);             /* Open dev with drv.                                   */
   \                     ??Serial_Open_6: (+1)
   \   000000BE   0x0032             MOVS     R2,R6
   \   000000C0   0x0029             MOVS     R1,R5
   \   000000C2   0x4648             MOV      R0,R9
   \   000000C4   0xF8D9 0x3004      LDR      R3,[R9, #+4]
   \   000000C8   0x685B             LDR      R3,[R3, #+4]
   \   000000CA   0x685B             LDR      R3,[R3, #+4]
   \   000000CC   0x4798             BLX      R3
    813              if (*perr != SERIAL_ERR_NONE) {
   \   000000CE   0x8830             LDRH     R0,[R6, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD00E             BEQ.N    ??Serial_Open_7
    814                  pline_api->Close(pdev, pline_data, perr);               /* 'Close' line drv.                                    */
   \   000000D4   0x0032             MOVS     R2,R6
   \   000000D6   0x9901             LDR      R1,[SP, #+4]
   \   000000D8   0x4648             MOV      R0,R9
   \   000000DA   0xF8DA 0x3004      LDR      R3,[R10, #+4]
   \   000000DE   0x4798             BLX      R3
    815                  CPU_CRITICAL_EXIT();
   \   000000E0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E4   0x4658             MOV      R0,R11
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
    816                 *perr = SERIAL_ERR_DRV_OPEN;
   \   000000EA   0x2015             MOVS     R0,#+21
   \   000000EC   0x8030             STRH     R0,[R6, #+0]
    817                  return (SERIAL_IF_NBR_NONE);
   \   000000EE   0x20FF             MOVS     R0,#+255
   \   000000F0   0xE02C             B.N      ??Serial_Open_4
    818              }
    819          
    820              pdev->LineDrv_API  = pline_api;
   \                     ??Serial_Open_7: (+1)
   \   000000F2   0xF8C9 0xA00C      STR      R10,[R9, #+12]
    821              pdev->LineDrv_Data = pline_data;
   \   000000F6   0x9801             LDR      R0,[SP, #+4]
   \   000000F8   0xF8C9 0x0010      STR      R0,[R9, #+16]
    822          
    823          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
    824              if (pif->RdBufEn == DEF_YES) {                              /* Start rx'er (if rd buf en'd).                        */
   \   000000FC   0xF898 0x00C0      LDRB     R0,[R8, #+192]
   \   00000100   0x2801             CMP      R0,#+1
   \   00000102   0xD113             BNE.N    ??Serial_Open_8
    825                  pif->RdBufErr = SERIAL_ERR_NONE;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF8A8 0x00C2      STRH     R0,[R8, #+194]
    826                  pdev->Dev_Cfg->Drv_API->RxStart(pdev, perr);
   \   0000010A   0x0031             MOVS     R1,R6
   \   0000010C   0x4648             MOV      R0,R9
   \   0000010E   0xF8D9 0x2004      LDR      R2,[R9, #+4]
   \   00000112   0x6852             LDR      R2,[R2, #+4]
   \   00000114   0x68D2             LDR      R2,[R2, #+12]
   \   00000116   0x4790             BLX      R2
    827          
    828                  if (*perr != SERIAL_ERR_NONE) {
   \   00000118   0x8830             LDRH     R0,[R6, #+0]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD006             BEQ.N    ??Serial_Open_8
    829                      CPU_CRITICAL_EXIT();
   \   0000011E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000122   0x4658             MOV      R0,R11
   \   00000124   0x.... 0x....      BL       CPU_SR_Restore
    830                      return (SERIAL_IF_NBR_NONE);
   \   00000128   0x20FF             MOVS     R0,#+255
   \   0000012A   0xE00F             B.N      ??Serial_Open_4
    831                  }
    832              }
    833          #endif
    834          
    835              pif->RdState = SERIAL_RD_STATE_OPENED;
   \                     ??Serial_Open_8: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \   0000012E   0xF888 0x006C      STRB     R0,[R8, #+108]
    836              pif->WrState = SERIAL_WR_STATE_OPENED;
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0xF888 0x0098      STRB     R0,[R8, #+152]
    837              pif->State   = SERIAL_STATE_OPENED;
   \   00000138   0x2003             MOVS     R0,#+3
   \   0000013A   0xF888 0x0002      STRB     R0,[R8, #+2]
    838              CPU_CRITICAL_EXIT();
   \   0000013E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000142   0x4658             MOV      R0,R11
   \   00000144   0x.... 0x....      BL       CPU_SR_Restore
    839          
    840              return (pif->Nbr);
   \   00000148   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \                     ??Serial_Open_4: (+1)
   \   0000014C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    841          }
    842          
    843          
    844          /*$PAGE*/
    845          /*
    846          *********************************************************************************************************
    847          *                                           Serial_Close()
    848          *
    849          * Description : Close a serial interface.
    850          *
    851          * Argument(s) : if_nbr      Interface number.
    852          *
    853          *               perr        Pointer to variable that will receive the return error code from this function :
    854          *
    855          *                               SERIAL_ERR_NONE                 Device successfully closed.
    856          *
    857          *                                                               - RETURNED BY Serial_IF_IsValid() : -
    858          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
    859          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
    860          *
    861          * Return(s)   : None.
    862          *
    863          * Caller(s)   : Application.
    864          *
    865          * Note(s)     : None.
    866          *********************************************************************************************************
    867          */
    868          

   \                                 In section .text, align 2, keep-with-next
    869          void  Serial_Close (SERIAL_IF_NBR   if_nbr,
    870                              SERIAL_ERR     *perr)
    871          {
   \                     Serial_Close: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    872              SERIAL_IF             *pif;
    873              SERIAL_DEV            *pdev;
    874              CPU_BOOLEAN            valid;
    875              SERIAL_CALLBACK_FNCT  *rd_callback;
    876              void                  *rd_callback_arg;
    877              void                  *rd_callback_buf;
    878              SERIAL_CALLBACK_FNCT  *wr_callback;
    879              void                  *wr_callback_arg;
    880              void                  *wr_callback_buf;
    881          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    882              SERIAL_BUF_DESC       *pbuf;
    883              SERIAL_BUF_DESC       *pbuf_next;
    884              LIB_ERR                lib_err;
    885          #endif
    886              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
    887          
    888                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
    889              CPU_CRITICAL_ENTER();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Save
   \   00000012   0x4683             MOV      R11,R0
   \   00000014   0x.... 0x....      BL       CPU_IntDisMeasStart
    890              valid = Serial_IF_IsValid(if_nbr, perr);
   \   00000018   0x0029             MOVS     R1,R5
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       Serial_IF_IsValid
   \   00000022   0xF88D 0x0004      STRB     R0,[SP, #+4]
    891              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   00000026   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD005             BEQ.N    ??Serial_Close_0
    892                  CPU_CRITICAL_EXIT();
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000032   0x4658             MOV      R0,R11
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
    893                  return;
   \   00000038   0xE09E             B.N      ??Serial_Close_1
    894              }
    895          
    896              pif  = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_Close_0: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x21F0             MOVS     R1,#+240
   \   00000042   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000046   0x4408             ADD      R0,R0,R1
   \   00000048   0x0006             MOVS     R6,R0
    897              pdev = &pif->Dev;
   \   0000004A   0xF116 0x0008      ADDS     R0,R6,#+8
   \   0000004E   0x0007             MOVS     R7,R0
    898                                                                          /* ------------------- ABORT DEV I/O ------------------ */
    899              pdev->Dev_Cfg->Drv_API->RxStop(pdev, perr);                 /* Stop dev rx.                                         */
   \   00000050   0x0029             MOVS     R1,R5
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x687A             LDR      R2,[R7, #+4]
   \   00000056   0x6852             LDR      R2,[R2, #+4]
   \   00000058   0x6912             LDR      R2,[R2, #+16]
   \   0000005A   0x4790             BLX      R2
    900              pdev->Dev_Cfg->Drv_API->TxStop(pdev, perr);                 /* Stop dev tx.                                         */
   \   0000005C   0x0029             MOVS     R1,R5
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0x687A             LDR      R2,[R7, #+4]
   \   00000062   0x6852             LDR      R2,[R2, #+4]
   \   00000064   0x69D2             LDR      R2,[R2, #+28]
   \   00000066   0x4790             BLX      R2
    901          
    902                                                                          /* --------------------- CLOSE DEV -------------------- */
    903              pif->State = SERIAL_STATE_CLOSING;
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x70B0             STRB     R0,[R6, #+2]
    904              pdev->Dev_Cfg->Drv_API->Close(pdev, perr);                  /* Close dev  drv.                                      */
   \   0000006C   0x0029             MOVS     R1,R5
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x687A             LDR      R2,[R7, #+4]
   \   00000072   0x6852             LDR      R2,[R2, #+4]
   \   00000074   0x6892             LDR      R2,[R2, #+8]
   \   00000076   0x4790             BLX      R2
    905              pdev->LineDrv_API->Close(pdev, pdev->LineDrv_Data, perr);   /* Close line drv.                                      */
   \   00000078   0x002A             MOVS     R2,R5
   \   0000007A   0x6939             LDR      R1,[R7, #+16]
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0x68FB             LDR      R3,[R7, #+12]
   \   00000080   0x685B             LDR      R3,[R3, #+4]
   \   00000082   0x4798             BLX      R3
    906          
    907              rd_callback_arg = pif->RdCallbackArg;
   \   00000084   0x6FB0             LDR      R0,[R6, #+120]
   \   00000086   0x9006             STR      R0,[SP, #+24]
    908              rd_callback_buf = pif->RdCallbackBuf;
   \   00000088   0x6FF0             LDR      R0,[R6, #+124]
   \   0000008A   0x9005             STR      R0,[SP, #+20]
    909              rd_callback     = pif->RdCallback;
   \   0000008C   0x6F70             LDR      R0,[R6, #+116]
   \   0000008E   0x9002             STR      R0,[SP, #+8]
    910          
    911              wr_callback_arg = pif->WrCallbackArg;
   \   00000090   0xF8D6 0x00A4      LDR      R0,[R6, #+164]
   \   00000094   0x9004             STR      R0,[SP, #+16]
    912              wr_callback_buf = pif->WrCallbackBuf;
   \   00000096   0xF8D6 0x00A8      LDR      R0,[R6, #+168]
   \   0000009A   0x9003             STR      R0,[SP, #+12]
    913              wr_callback     = pif->WrCallback;
   \   0000009C   0xF8D6 0x00A0      LDR      R0,[R6, #+160]
   \   000000A0   0x4680             MOV      R8,R0
    914          
    915              Serial_IF_Clr(pif);                                         /* Clr IF.                                              */
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       Serial_IF_Clr
    916          
    917          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* Clr rd buf.                                          */
    918              if (pif->RdBufEn == DEF_YES) {
   \   000000A8   0xF896 0x00C0      LDRB     R0,[R6, #+192]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD103             BNE.N    ??Serial_Close_2
    919                  SerialBuf_Clr(&(pif->RdBuf));
   \   000000B0   0xF116 0x00C4      ADDS     R0,R6,#+196
   \   000000B4   0x.... 0x....      BL       SerialBuf_Clr
    920              }
    921          #endif
    922          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)                       /* Clr wr buf.                                          */
    923              if (pif->WrBufEn == DEF_YES) {
   \                     ??Serial_Close_2: (+1)
   \   000000B8   0xF896 0x00D8      LDRB     R0,[R6, #+216]
   \   000000BC   0x2801             CMP      R0,#+1
   \   000000BE   0xD103             BNE.N    ??Serial_Close_3
    924                  SerialBuf_Clr(&(pif->WrBuf));
   \   000000C0   0xF116 0x00DC      ADDS     R0,R6,#+220
   \   000000C4   0x.... 0x....      BL       SerialBuf_Clr
    925              }
    926          #endif
    927              CPU_CRITICAL_EXIT();
   \                     ??Serial_Close_3: (+1)
   \   000000C8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000CC   0x4658             MOV      R0,R11
   \   000000CE   0x.... 0x....      BL       CPU_SR_Restore
    928          
    929              SerialOS_SemDel(pif->WrSem);
   \   000000D2   0xF8D6 0x009C      LDR      R0,[R6, #+156]
   \   000000D6   0x.... 0x....      BL       SerialOS_SemDel
    930              pif->WrSem = (void *)0;
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF8C6 0x009C      STR      R0,[R6, #+156]
    931          
    932              SerialOS_SemDel(pif->RdSem);
   \   000000E0   0x6F30             LDR      R0,[R6, #+112]
   \   000000E2   0x.... 0x....      BL       SerialOS_SemDel
    933              pif->RdSem = (void *)0;
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x6730             STR      R0,[R6, #+112]
    934          
    935          
    936              if (rd_callback != (SERIAL_CALLBACK_FNCT *)0) {
   \   000000EA   0x9802             LDR      R0,[SP, #+8]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD008             BEQ.N    ??Serial_Close_4
    937                (*rd_callback)((SERIAL_IF_NBR)pif->Nbr,                   /* Call rd callback fnct.                               */
    938                               (void        *)rd_callback_arg,
    939                               (void        *)rd_callback_buf,
    940                               (CPU_SIZE_T   )0,
    941                               (SERIAL_ERR   )SERIAL_ERR_IF_CLOSING);
   \   000000F0   0x202B             MOVS     R0,#+43
   \   000000F2   0x9000             STR      R0,[SP, #+0]
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x9A05             LDR      R2,[SP, #+20]
   \   000000F8   0x9906             LDR      R1,[SP, #+24]
   \   000000FA   0x7870             LDRB     R0,[R6, #+1]
   \   000000FC   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \   00000100   0x47E0             BLX      R12
    942              }
    943          
    944          
    945              if (wr_callback != (SERIAL_CALLBACK_FNCT *)0) {
   \                     ??Serial_Close_4: (+1)
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD006             BEQ.N    ??Serial_Close_5
    946                (*wr_callback)((SERIAL_IF_NBR)pif->Nbr,                   /* Call wr callback fnct.                               */
    947                               (void        *)wr_callback_arg,
    948                               (void        *)wr_callback_buf,
    949                               (CPU_SIZE_T   )0,
    950                               (SERIAL_ERR   )SERIAL_ERR_IF_CLOSING);
   \   00000108   0x202B             MOVS     R0,#+43
   \   0000010A   0x9000             STR      R0,[SP, #+0]
   \   0000010C   0x2300             MOVS     R3,#+0
   \   0000010E   0x9A03             LDR      R2,[SP, #+12]
   \   00000110   0x9904             LDR      R1,[SP, #+16]
   \   00000112   0x7870             LDRB     R0,[R6, #+1]
   \   00000114   0x47C0             BLX      R8
    951              }
    952          
    953          
    954          #if (SERIAL_CFG_TX_DESC_NBR > 0)
    955              pif->TxBufListEnd = (SERIAL_BUF_DESC *)0;
   \                     ??Serial_Close_5: (+1)
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x66B0             STR      R0,[R6, #+104]
    956              pbuf              =  pif->TxBufListStart;                   /* Inform any pending callback.                         */
   \   0000011A   0x6E70             LDR      R0,[R6, #+100]
   \   0000011C   0x4681             MOV      R9,R0
    957              while (pbuf != (SERIAL_BUF_DESC *)0) {
   \                     ??Serial_Close_6: (+1)
   \   0000011E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000122   0xD01B             BEQ.N    ??Serial_Close_7
    958                  pbuf->Callback((SERIAL_IF_NBR)pif->Nbr,
    959                                 (void        *)pbuf->CallbackArg,
    960                                 (void        *)pbuf->CallbackBuf,
    961                                 (CPU_SIZE_T   )0,
    962                                 (SERIAL_ERR   )SERIAL_ERR_IF_CLOSING);
   \   00000124   0x202B             MOVS     R0,#+43
   \   00000126   0x9000             STR      R0,[SP, #+0]
   \   00000128   0x2300             MOVS     R3,#+0
   \   0000012A   0xF8D9 0x2010      LDR      R2,[R9, #+16]
   \   0000012E   0xF8D9 0x100C      LDR      R1,[R9, #+12]
   \   00000132   0x7870             LDRB     R0,[R6, #+1]
   \   00000134   0xF8D9 0xC008      LDR      R12,[R9, #+8]
   \   00000138   0x47E0             BLX      R12
    963          
    964                  pbuf_next          =  pbuf->NextPtr;
   \   0000013A   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   0000013E   0x4682             MOV      R10,R0
    965                  pbuf_next->PrevPtr = (SERIAL_BUF_DESC *)0;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF8CA 0x0018      STR      R0,[R10, #+24]
    966          
    967                  Mem_PoolBlkFree(&pif->TxBufPool, pbuf, &lib_err);
   \   00000146   0xF10D 0x0206      ADD      R2,SP,#+6
   \   0000014A   0x4649             MOV      R1,R9
   \   0000014C   0xF116 0x001C      ADDS     R0,R6,#+28
   \   00000150   0x.... 0x....      BL       Mem_PoolBlkFree
    968          
    969                  pbuf                = pbuf_next;
   \   00000154   0x46D1             MOV      R9,R10
    970                  pif->TxBufListStart = pbuf;
   \   00000156   0xF8C6 0x9064      STR      R9,[R6, #+100]
   \   0000015A   0xE7E0             B.N      ??Serial_Close_6
    971              }
    972          #endif
    973          
    974          
    975              CPU_CRITICAL_ENTER();
   \                     ??Serial_Close_7: (+1)
   \   0000015C   0x.... 0x....      BL       CPU_SR_Save
   \   00000160   0x4683             MOV      R11,R0
   \   00000162   0x.... 0x....      BL       CPU_IntDisMeasStart
    976              pif->State = SERIAL_STATE_CLOSED;
   \   00000166   0x2001             MOVS     R0,#+1
   \   00000168   0x70B0             STRB     R0,[R6, #+2]
    977              CPU_CRITICAL_EXIT();
   \   0000016A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000016E   0x4658             MOV      R0,R11
   \   00000170   0x.... 0x....      BL       CPU_SR_Restore
    978          
    979             *perr = SERIAL_ERR_NONE;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x8028             STRH     R0,[R5, #+0]
    980          }
   \                     ??Serial_Close_1: (+1)
   \   00000178   0xB007             ADD      SP,SP,#+28
   \   0000017A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    981          
    982          
    983          /*$PAGE*/
    984          /*
    985          *********************************************************************************************************
    986          *                                             Serial_Rd()
    987          *
    988          * Description : Read synchronously from a serial interface with an optional time-out interval.
    989          *
    990          * Argument(s) : if_nbr      Interface number.
    991          *
    992          *               pdest       Pointer to destination buffer.
    993          *
    994          *               len         Number of octets to read.
    995          *
    996          *               timeout_ms  Optional timeout period in milliseconds. If specified 0, wait indefinitely.
    997          *
    998          *               perr        Pointer to variable that will receive the return error code from this function :
    999          *
   1000          *                               SERIAL_ERR_NONE                 Device successfully read.
   1001          *                               SERIAL_ERR_SIGNAL               OS semaphore could NOT be created.
   1002          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   1003          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   1004          *
   1005          *                                                               --- RETURNED BY Serial_RdHandler() : ---
   1006          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'pdest'.
   1007          *
   1008          *                                                               ----- RETURNED BY Serial_RdEnd() : -----
   1009          *                               SERIAL_ERR_TIMEOUT              Operation timed-out.
   1010          *                               SERIAL_ERR_FAIL                 Device read failed.
   1011          *
   1012          * Return(s)   : Number of octets read.
   1013          *
   1014          * Caller(s)   : Application.
   1015          *
   1016          * Note(s)     : (1) Only ONE task/context can read from the same serial interface at a time.  If the receiver
   1017          *                   is busy when this function is called, an error will be returned.
   1018          *********************************************************************************************************
   1019          */
   1020          

   \                                 In section .text, align 2, keep-with-next
   1021          CPU_SIZE_T  Serial_Rd (SERIAL_IF_NBR   if_nbr,
   1022                                 void           *pdest,
   1023                                 CPU_SIZE_T      len,
   1024                                 CPU_INT32U      timeout_ms,
   1025                                 SERIAL_ERR     *perr)
   1026          {
   \                     Serial_Rd: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   1027              SERIAL_IF             *pif;
   1028              SERIAL_CALLBACK_INFO   rd_info;
   1029              CPU_SIZE_T             len_rd;
   1030              void                  *psignal;
   1031          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1032              CPU_BOOLEAN            valid;
   1033          #endif
   1034          
   1035          
   1036          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1037              valid = Serial_IF_IsValid(if_nbr, perr);
   1038              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   1039                  return ((CPU_SIZE_T)0);
   1040              }
   1041          #endif
   1042          
   1043              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   \   00000012   0x2E00             CMP      R6,#+0
   \   00000014   0xD104             BNE.N    ??Serial_Rd_0
   1044                 *perr = SERIAL_ERR_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1045                  return ((CPU_SIZE_T)0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE03A             B.N      ??Serial_Rd_1
   1046              }
   1047          
   1048              psignal = SerialOS_SemCreate((CPU_INT16U)0);
   \                     ??Serial_Rd_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       SerialOS_SemCreate
   \   00000026   0x4683             MOV      R11,R0
   1049              if (psignal == (void *)0) {
   \   00000028   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000002C   0xD104             BNE.N    ??Serial_Rd_2
   1050                  *perr  = SERIAL_ERR_SIGNAL;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1051                   return ((CPU_SIZE_T)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE02E             B.N      ??Serial_Rd_1
   1052              }
   1053              rd_info.SignalPtr = (void     *)psignal;
   \                     ??Serial_Rd_2: (+1)
   \   00000038   0xF8CD 0xB010      STR      R11,[SP, #+16]
   1054              rd_info.Timeout   = (CPU_INT32U)timeout_ms;
   \   0000003C   0x9705             STR      R7,[SP, #+20]
   1055              rd_info.Len       = (CPU_SIZE_T)0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x9006             STR      R0,[SP, #+24]
   1056              rd_info.Err       = (SERIAL_ERR)SERIAL_ERR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xF8AD 0x001C      STRH     R0,[SP, #+28]
   1057          
   1058              pif = &Serial_IF_Tbl[if_nbr];
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x21F0             MOVS     R1,#+240
   \   00000050   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000054   0x4408             ADD      R0,R0,R1
   \   00000056   0x4681             MOV      R9,R0
   1059          
   1060              Serial_RdHandler((SERIAL_IF            *) pif,
   1061                               (void                 *) pdest,
   1062                               (CPU_SIZE_T            ) len,
   1063                               (SERIAL_CALLBACK_FNCT *)&Serial_RdCallback,
   1064                               (void                 *)&rd_info,
   1065                               (CPU_BOOLEAN           ) DEF_NO,
   1066                               (CPU_INT32U            ) timeout_ms,
   1067                               (SERIAL_ERR           *) perr);
   \   00000058   0xF8CD 0x800C      STR      R8,[SP, #+12]
   \   0000005C   0x9702             STR      R7,[SP, #+8]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9001             STR      R0,[SP, #+4]
   \   00000062   0xA804             ADD      R0,SP,#+16
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x.... 0x....      ADR.W    R3,Serial_RdCallback
   \   0000006A   0x0032             MOVS     R2,R6
   \   0000006C   0x0029             MOVS     R1,R5
   \   0000006E   0x4648             MOV      R0,R9
   \   00000070   0x.... 0x....      BL       Serial_RdHandler
   1068          
   1069              if (*perr == SERIAL_ERR_NONE) {
   \   00000074   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD106             BNE.N    ??Serial_Rd_3
   1070                  len_rd = Serial_RdEnd(pif, &rd_info, perr);             /* Wait for rd end.                                     */
   \   0000007C   0x4642             MOV      R2,R8
   \   0000007E   0xA904             ADD      R1,SP,#+16
   \   00000080   0x4648             MOV      R0,R9
   \   00000082   0x.... 0x....      BL       Serial_RdEnd
   \   00000086   0x4682             MOV      R10,R0
   \   00000088   0xE001             B.N      ??Serial_Rd_4
   1071              } else {
   1072                  len_rd = 0;
   \                     ??Serial_Rd_3: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4682             MOV      R10,R0
   1073              }
   1074          
   1075              SerialOS_SemDel(psignal);
   \                     ??Serial_Rd_4: (+1)
   \   0000008E   0x4658             MOV      R0,R11
   \   00000090   0x.... 0x....      BL       SerialOS_SemDel
   1076              return (len_rd);
   \   00000094   0x4650             MOV      R0,R10
   \                     ??Serial_Rd_1: (+1)
   \   00000096   0xB009             ADD      SP,SP,#+36
   \   00000098   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1077          }
   1078          
   1079          
   1080          /*$PAGE*/
   1081          /*
   1082          *********************************************************************************************************
   1083          *                                          Serial_RdAsync()
   1084          *
   1085          * Description : Read asynchronously from a serial interface.
   1086          *
   1087          * Argument(s) : if_nbr      Interface number.
   1088          *
   1089          *               pdest       Pointer to destination buffer.
   1090          *
   1091          *               len         Number of octets to read.
   1092          *
   1093          *               phandler    Address of read complete callback function.
   1094          *
   1095          *               parg        Pointer to read complete callback context.
   1096          *
   1097          *               perr        Pointer to variable that will receive the return error code from this function :
   1098          *
   1099          *                               SERIAL_ERR_NONE                 Asynchronous operation successful.
   1100          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'pdest'.
   1101          *                               SERIAL_ERR_NULL_FNCT            NULL pointer passed for argument 'phandler'.
   1102          *                               SERIAL_ERR_IF_IN_USE            Serial interface is in use.
   1103          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   1104          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   1105          *
   1106          * Return(s)   : None.
   1107          *
   1108          * Caller(s)   : Application.
   1109          *
   1110          * Note(s)     : (1) Only ONE task/context can read from the same serial interface at a time.  If the receiver
   1111          *                   is busy when this function is called, an error will be returned.
   1112          *********************************************************************************************************
   1113          */
   1114          

   \                                 In section .text, align 2, keep-with-next
   1115          void  Serial_RdAsync (SERIAL_IF_NBR          if_nbr,
   1116                                void                  *pdest,
   1117                                CPU_SIZE_T             len,
   1118                                SERIAL_CALLBACK_FNCT  *phandler,
   1119                                void                  *parg,
   1120                                SERIAL_ERR            *perr)
   1121          {
   \                     Serial_RdAsync: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \   00000010   0xF8DD 0x9034      LDR      R9,[SP, #+52]
   1122              SERIAL_IF    *pif;
   1123          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1124              CPU_BOOLEAN   valid;
   1125          #endif
   1126          
   1127          
   1128          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1129              valid = Serial_IF_IsValid(if_nbr, perr);
   1130              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   1131                  return;
   1132              }
   1133          #endif
   1134          
   1135              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD103             BNE.N    ??Serial_RdAsync_0
   1136                 *perr = SERIAL_ERR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1137                  return;
   \   0000001E   0xE015             B.N      ??Serial_RdAsync_1
   1138              }
   1139          
   1140              pif = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_RdAsync_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x21F0             MOVS     R1,#+240
   \   00000028   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x4682             MOV      R10,R0
   1141          
   1142              Serial_RdHandler(pif,
   1143                               pdest,
   1144                               len,
   1145                               phandler,
   1146                               parg,
   1147                               DEF_YES,
   1148                               0,
   1149                               perr);
   \   00000030   0xF8CD 0x900C      STR      R9,[SP, #+12]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9002             STR      R0,[SP, #+8]
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x9001             STR      R0,[SP, #+4]
   \   0000003C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000040   0x003B             MOVS     R3,R7
   \   00000042   0x0032             MOVS     R2,R6
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0x.... 0x....      BL       Serial_RdHandler
   1150          }
   \                     ??Serial_RdAsync_1: (+1)
   \   0000004C   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   1151          
   1152          
   1153          /*$PAGE*/
   1154          /*
   1155          *********************************************************************************************************
   1156          *                                          Serial_WaitFor()
   1157          *
   1158          * Description : Wait for octet array to arrive on serial interface.
   1159          *
   1160          * Argument(s) : if_nbr      Interface number.
   1161          *
   1162          *               psrc        Pointer to buffer to wait for.
   1163          *
   1164          *               len         Number of octets in the buffer.
   1165          *
   1166          *               timeout_ms  Optional timeout period in milliseconds. If specified 0, wait indefinitely.
   1167          *
   1168          *               perr        Pointer to variable that will receive the return error code from this function :
   1169          *
   1170          *                               SERIAL_ERR_NONE                 Octet array arrived on serial interface.
   1171          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'psrc'.
   1172          *                               SERIAL_ERR_SIGNAL               OS semaphore could NOT be created.
   1173          *
   1174          *                                                               -- RETURNED BY Serial_IF_IsValid() : --
   1175          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   1176          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   1177          *
   1178          *                                                               ----- RETURNED BY Serial_RdEnd() : ----
   1179          *                               SERIAL_ERR_TIMEOUT              Operation timed-out.
   1180          *                               SERIAL_ERR_FAIL                 Operation failed.
   1181          *
   1182          * Return(s)   : None.
   1183          *
   1184          * Caller(s)   : Application.
   1185          *
   1186          * Note(s)     : (1) Only ONE task/context can read from the same serial interface at a time.  If the receiver
   1187          *                   is busy when this function is called, an error will be returned.
   1188          *
   1189          *               (2) This function bypasses the line driver for new incoming octets, and may use rd
   1190          *                   buf for initial comparison.
   1191          *********************************************************************************************************
   1192          */
   1193          

   \                                 In section .text, align 2, keep-with-next
   1194          void  Serial_WaitFor (SERIAL_IF_NBR   if_nbr,
   1195                                void           *psrc,
   1196                                CPU_SIZE_T      len,
   1197                                CPU_INT32U      timeout_ms,
   1198                                SERIAL_ERR     *perr)
   1199          {
   \                     Serial_WaitFor: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8040      LDR      R8,[SP, #+64]
   1200              SERIAL_CALLBACK_INFO   rd_info;
   1201              SERIAL_IF             *pif;
   1202              CPU_BOOLEAN            valid;
   1203              void                  *psignal;
   1204          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1205              CPU_BOOLEAN            cmp;
   1206              CPU_BOOLEAN            empty;
   1207              CPU_BOOLEAN            rd;
   1208              CPU_INT08U             datum;
   1209          #endif
   1210              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0B00      MOVS     R11,#+0
   1211          
   1212          
   1213          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1214              if (psrc == (void *)0) {                                    /* Validate src buf ptr.                                */
   1215                 *perr = SERIAL_ERR_NULL_PTR;
   1216                  return;
   1217              }
   1218          #endif
   1219          
   1220              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD103             BNE.N    ??Serial_WaitFor_0
   1221                 *perr = SERIAL_ERR_NONE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1222                  return;
   \   00000020   0xE0E2             B.N      ??Serial_WaitFor_1
   1223              }
   1224          
   1225                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
   1226              valid = Serial_IF_IsValid(if_nbr, perr);
   \                     ??Serial_WaitFor_0: (+1)
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       Serial_IF_IsValid
   \   0000002C   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1227              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   00000030   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xF040 0x80D7      BNE.W    ??Serial_WaitFor_1
   1228                  return;
   1229              }
   1230          
   1231              pif = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_WaitFor_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x21F0             MOVS     R1,#+240
   \   00000042   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000046   0x4408             ADD      R0,R0,R1
   \   00000048   0x4681             MOV      R9,R0
   1232              SerialOS_SemWait(pif->RdSem, 0, perr);
   \   0000004A   0x4642             MOV      R2,R8
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xF8D9 0x0070      LDR      R0,[R9, #+112]
   \   00000052   0x.... 0x....      BL       SerialOS_SemWait
   1233              if (*perr != SERIAL_OS_ERR_NONE) {
   \   00000056   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000005A   0x283C             CMP      R0,#+60
   \   0000005C   0xF040 0x80C4      BNE.W    ??Serial_WaitFor_1
   1234                   return;
   1235              }
   1236          
   1237              CPU_CRITICAL_ENTER();
   \                     ??Serial_WaitFor_3: (+1)
   \   00000060   0x.... 0x....      BL       CPU_SR_Save
   \   00000064   0x4683             MOV      R11,R0
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStart
   1238          
   1239              SerialBuf_Init((SERIAL_BUF  *)&(pif->RdUserBuf),            /* Init cmp buf.                                        */
   1240                             (CPU_INT08U  *)  psrc,
   1241                             (CPU_SIZE_T   )  len,
   1242                             (CPU_BOOLEAN  )  DEF_YES);
   \   0000006A   0x2301             MOVS     R3,#+1
   \   0000006C   0x0032             MOVS     R2,R6
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0xF119 0x0084      ADDS     R0,R9,#+132
   \   00000074   0x.... 0x....      BL       SerialBuf_Init
   1243          
   1244          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* -------------------- CHK RD BUF -------------------- */
   1245              if (pif->RdBufEn == DEF_YES) {
   \   00000078   0xF899 0x00C0      LDRB     R0,[R9, #+192]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD179             BNE.N    ??Serial_WaitFor_4
   1246                  empty = SerialBuf_IsEmpty(&(pif->RdBuf));
   \   00000080   0xF119 0x00C4      ADDS     R0,R9,#+196
   \   00000084   0x.... 0x....      BL       SerialBuf_IsEmpty
   \   00000088   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1247                  if (empty == DEF_NO) {
   \   0000008C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD164             BNE.N    ??Serial_WaitFor_5
   1248                      CPU_CRITICAL_EXIT();
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000098   0x4658             MOV      R0,R11
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
   1249                      cmp = DEF_NO;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4682             MOV      R10,R0
   1250                      do {
   1251                          CPU_CRITICAL_ENTER();
   \                     ??Serial_WaitFor_6: (+1)
   \   000000A2   0x.... 0x....      BL       CPU_SR_Save
   \   000000A6   0x4683             MOV      R11,R0
   \   000000A8   0x.... 0x....      BL       CPU_IntDisMeasStart
   1252                          rd = SerialBuf_RdOctet(&(pif->RdBuf), &datum);
   \   000000AC   0xF10D 0x0102      ADD      R1,SP,#+2
   \   000000B0   0xF119 0x00C4      ADDS     R0,R9,#+196
   \   000000B4   0x.... 0x....      BL       SerialBuf_RdOctet
   \   000000B8   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1253                          if (rd == DEF_YES) {
   \   000000BC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD110             BNE.N    ??Serial_WaitFor_7
   1254                              cmp = SerialBuf_Cmp(&(pif->RdUserBuf), datum);
   \   000000C4   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   000000C8   0xF119 0x0084      ADDS     R0,R9,#+132
   \   000000CC   0x.... 0x....      BL       SerialBuf_Cmp
   \   000000D0   0x4682             MOV      R10,R0
   1255                              if (cmp != DEF_YES) {
   \   000000D2   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D6   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000DA   0xD004             BEQ.N    ??Serial_WaitFor_7
   1256                                  CPU_CRITICAL_EXIT();
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x4658             MOV      R0,R11
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
   1257                              }
   1258                          }
   1259                      } while ((rd  == DEF_YES) &&
   1260                               (cmp != DEF_YES));
   \                     ??Serial_WaitFor_7: (+1)
   \   000000E6   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xD104             BNE.N    ??Serial_WaitFor_8
   \   000000EE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000F2   0xF1BA 0x0F01      CMP      R10,#+1
   \   000000F6   0xD1D4             BNE.N    ??Serial_WaitFor_6
   1261          
   1262                      empty = SerialBuf_IsEmpty(&(pif->RdBuf));
   \                     ??Serial_WaitFor_8: (+1)
   \   000000F8   0xF119 0x00C4      ADDS     R0,R9,#+196
   \   000000FC   0x.... 0x....      BL       SerialBuf_IsEmpty
   \   00000100   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1263                      if ((cmp   == DEF_YES) &&
   1264                         ((empty == DEF_NO)  ||
   1265                          (pif->RdBufErr == SERIAL_ERR_NONE))) {
   \   00000104   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000108   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000010C   0xD114             BNE.N    ??Serial_WaitFor_9
   \   0000010E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD003             BEQ.N    ??Serial_WaitFor_10
   \   00000116   0xF8B9 0x00C2      LDRH     R0,[R9, #+194]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD10C             BNE.N    ??Serial_WaitFor_9
   1266                              CPU_CRITICAL_EXIT();
   \                     ??Serial_WaitFor_10: (+1)
   \   0000011E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000122   0x4658             MOV      R0,R11
   \   00000124   0x.... 0x....      BL       CPU_SR_Restore
   1267                              SerialOS_SemSignal(pif->RdSem);
   \   00000128   0xF8D9 0x0070      LDR      R0,[R9, #+112]
   \   0000012C   0x.... 0x....      BL       SerialOS_SemSignal
   1268                             *perr  = SERIAL_ERR_NONE;
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1269                              return;
   \   00000136   0xE057             B.N      ??Serial_WaitFor_1
   1270                      }
   1271          
   1272                      if (pif->RdBufErr != SERIAL_ERR_NONE) {             /* Restart cmp if rd buf err.                           */
   \                     ??Serial_WaitFor_9: (+1)
   \   00000138   0xF8B9 0x00C2      LDRH     R0,[R9, #+194]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD019             BEQ.N    ??Serial_WaitFor_4
   1273                          SerialBuf_Init((SERIAL_BUF  *)&(pif->RdUserBuf),
   1274                                         (CPU_INT08U  *)  psrc,
   1275                                         (CPU_SIZE_T   )  len,
   1276                                         (CPU_BOOLEAN  )  DEF_YES);
   \   00000140   0x2301             MOVS     R3,#+1
   \   00000142   0x0032             MOVS     R2,R6
   \   00000144   0x0029             MOVS     R1,R5
   \   00000146   0xF119 0x0084      ADDS     R0,R9,#+132
   \   0000014A   0x.... 0x....      BL       SerialBuf_Init
   1277          
   1278                          pif->RdBufErr  = SERIAL_ERR_NONE;               /* Flush rd buf.                                        */
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF8A9 0x00C2      STRH     R0,[R9, #+194]
   1279                          SerialBuf_Clr(&(pif->RdBuf));
   \   00000154   0xF119 0x00C4      ADDS     R0,R9,#+196
   \   00000158   0x.... 0x....      BL       SerialBuf_Clr
   \   0000015C   0xE00A             B.N      ??Serial_WaitFor_4
   1280                      }
   1281          
   1282                  } else if (pif->RdBufErr != SERIAL_ERR_NONE) {
   \                     ??Serial_WaitFor_5: (+1)
   \   0000015E   0xF8B9 0x00C2      LDRH     R0,[R9, #+194]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD006             BEQ.N    ??Serial_WaitFor_4
   1283                      pif->RdBufErr = SERIAL_ERR_NONE;                    /* Flush rd buf.                                        */
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xF8A9 0x00C2      STRH     R0,[R9, #+194]
   1284                      SerialBuf_Clr(&(pif->RdBuf));
   \   0000016C   0xF119 0x00C4      ADDS     R0,R9,#+196
   \   00000170   0x.... 0x....      BL       SerialBuf_Clr
   1285                  }
   1286              }
   1287          #endif
   1288          
   1289          
   1290              psignal = SerialOS_SemCreate((CPU_INT16U)0);
   \                     ??Serial_WaitFor_4: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x.... 0x....      BL       SerialOS_SemCreate
   \   0000017A   0x9001             STR      R0,[SP, #+4]
   1291              if (psignal == (void *)0) {
   \   0000017C   0x9801             LDR      R0,[SP, #+4]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD10C             BNE.N    ??Serial_WaitFor_11
   1292                  CPU_CRITICAL_EXIT();
   \   00000182   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000186   0x4658             MOV      R0,R11
   \   00000188   0x.... 0x....      BL       CPU_SR_Restore
   1293                  SerialOS_SemSignal(pif->RdSem);
   \   0000018C   0xF8D9 0x0070      LDR      R0,[R9, #+112]
   \   00000190   0x.... 0x....      BL       SerialOS_SemSignal
   1294                 *perr = SERIAL_ERR_SIGNAL;
   \   00000194   0x2003             MOVS     R0,#+3
   \   00000196   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1295                  return;
   \   0000019A   0xE025             B.N      ??Serial_WaitFor_1
   1296              }
   1297              rd_info.SignalPtr = (void     *)psignal;
   \                     ??Serial_WaitFor_11: (+1)
   \   0000019C   0x9801             LDR      R0,[SP, #+4]
   \   0000019E   0x9002             STR      R0,[SP, #+8]
   1298              rd_info.Timeout   = (CPU_INT32U)timeout_ms;
   \   000001A0   0x9703             STR      R7,[SP, #+12]
   1299              rd_info.Len       = (CPU_SIZE_T)0;
   \   000001A2   0x2000             MOVS     R0,#+0
   \   000001A4   0x9004             STR      R0,[SP, #+16]
   1300              rd_info.Err       = (SERIAL_ERR)SERIAL_ERR_NONE;
   \   000001A6   0x2000             MOVS     R0,#+0
   \   000001A8   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   1301          
   1302          
   1303                                                                          /* --------------------- START RD --------------------- */
   1304              pif->RdCallback    = &Serial_RdCallback;                    /* Callback called upon completion.                     */
   \   000001AC   0x.... 0x....      ADR.W    R0,Serial_RdCallback
   \   000001B0   0xF8C9 0x0074      STR      R0,[R9, #+116]
   1305              pif->RdCallbackArg = (void *)&rd_info;                      /* Arg     passed to callback.                          */
   \   000001B4   0xA802             ADD      R0,SP,#+8
   \   000001B6   0xF8C9 0x0078      STR      R0,[R9, #+120]
   1306              pif->RdCallbackBuf =  psrc;                                 /* Buf     passed to callback.                          */
   \   000001BA   0xF8C9 0x507C      STR      R5,[R9, #+124]
   1307          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1308              pif->RdCallbackLen =  len;                                  /* Buf len passed to callback.                          */
   \   000001BE   0xF8C9 0x6080      STR      R6,[R9, #+128]
   1309          #endif
   1310              pif->RdState       =  SERIAL_RD_STATE_CHK;
   \   000001C2   0x2003             MOVS     R0,#+3
   \   000001C4   0xF889 0x006C      STRB     R0,[R9, #+108]
   1311          
   1312              Serial_IF_RxStart(pif);                                     /* Start rx'er.                                         */
   \   000001C8   0x4648             MOV      R0,R9
   \   000001CA   0x.... 0x....      BL       Serial_IF_RxStart
   1313              CPU_CRITICAL_EXIT();
   \   000001CE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001D2   0x4658             MOV      R0,R11
   \   000001D4   0x.... 0x....      BL       CPU_SR_Restore
   1314          
   1315          
   1316             (void)Serial_RdEnd(pif, &rd_info, perr);                     /* Wait for rd end.                                     */
   \   000001D8   0x4642             MOV      R2,R8
   \   000001DA   0xA902             ADD      R1,SP,#+8
   \   000001DC   0x4648             MOV      R0,R9
   \   000001DE   0x.... 0x....      BL       Serial_RdEnd
   1317              SerialOS_SemDel(psignal);
   \   000001E2   0x9801             LDR      R0,[SP, #+4]
   \   000001E4   0x.... 0x....      BL       SerialOS_SemDel
   1318          }
   \                     ??Serial_WaitFor_1: (+1)
   \   000001E8   0xB007             ADD      SP,SP,#+28
   \   000001EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1319          
   1320          
   1321          /*$PAGE*/
   1322          /*
   1323          *********************************************************************************************************
   1324          *                                             Serial_Wr()
   1325          *
   1326          * Description : Write synchronously to a serial interface with an optional time-out interval.
   1327          *
   1328          * Argument(s) : if_nbr      Interface number.
   1329          *
   1330          *               psrc        Pointer to source buffer.
   1331          *
   1332          *               len         Number of octets to write.
   1333          *
   1334          *               timeout_ms  Optional timeout period in milliseconds. If specified 0, wait indefinitely.
   1335          *
   1336          *               perr        Pointer to variable that will receive the return error code from this function :
   1337          *
   1338          *                               SERIAL_ERR_NONE                 Device successfully written.
   1339          *                               SERIAL_ERR_SIGNAL               OS semaphore could NOT be created.
   1340          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'psrc'.
   1341          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   1342          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   1343          *
   1344          *                                                               ---- RETURNED BY Serial_WrStart() : ---
   1345          *                               SERIAL_ERR_BUF_ALLOC            Buffer structure could NOT be allocated.
   1346          *
   1347          *                                                               ---- RETURNED BY Serial_WrEnd() : -----
   1348          *                               SERIAL_ERR_TIMEOUT              Operation timed-out.
   1349          *                               SERIAL_ERR_FAIL                 Device write failed.
   1350          *
   1351          * Return(s)   : Number of octets written.
   1352          *
   1353          * Caller(s)   : Application.
   1354          *
   1355          * Note(s)     : (1) Multiple tasks/contexts may write to the same serial interface at any time.
   1356          *
   1357          *               (2) A synchronous write CANNOT be requested in interrupt context.
   1358          *********************************************************************************************************
   1359          */
   1360          

   \                                 In section .text, align 2, keep-with-next
   1361          CPU_SIZE_T  Serial_Wr (SERIAL_IF_NBR   if_nbr,
   1362                                 void           *psrc,
   1363                                 CPU_SIZE_T      len,
   1364                                 CPU_INT32U      timeout_ms,
   1365                                 SERIAL_ERR     *perr)
   1366          {
   \                     Serial_Wr: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8058      LDR      R8,[SP, #+88]
   1367              SERIAL_IF             *pif;
   1368              CPU_BOOLEAN            valid;
   1369              SERIAL_CALLBACK_INFO   wr_info;
   1370              CPU_SIZE_T             len_wr;
   1371              void                  *psignal;
   1372              SERIAL_BUF_DESC        buf;
   1373              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0B00      MOVS     R11,#+0
   1374          
   1375          
   1376          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1377              if (psrc == (void *)0) {                                    /* Validate src buf ptr.                                */
   1378                 *perr = SERIAL_ERR_NULL_PTR;
   1379                  return ((CPU_SIZE_T)0);
   1380              }
   1381          #endif
   1382          
   1383          
   1384              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD104             BNE.N    ??Serial_Wr_0
   1385                 *perr = SERIAL_ERR_NONE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1386                  return ((CPU_SIZE_T)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE05F             B.N      ??Serial_Wr_1
   1387              }
   1388          
   1389              wr_info.Timeout = (CPU_INT32U)timeout_ms;
   \                     ??Serial_Wr_0: (+1)
   \   00000024   0x9703             STR      R7,[SP, #+12]
   1390              wr_info.Len     = (CPU_SIZE_T)0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9004             STR      R0,[SP, #+16]
   1391              wr_info.Err     = (SERIAL_ERR)SERIAL_ERR_NONE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8AD 0x0014      STRH     R0,[SP, #+20]
   1392          
   1393          
   1394              buf.Len         =  len;
   \   00000030   0x9606             STR      R6,[SP, #+24]
   1395              buf.DataPtr     =  psrc;
   \   00000032   0x9507             STR      R5,[SP, #+28]
   1396              buf.Callback    = &Serial_WrCallback;                       /* Callback called upon completion.                     */
   \   00000034   0x.... 0x....      ADR.W    R0,Serial_WrCallback
   \   00000038   0x9008             STR      R0,[SP, #+32]
   1397              buf.CallbackArg = &wr_info;                                 /* Argument passed to callback.                         */
   \   0000003A   0xA802             ADD      R0,SP,#+8
   \   0000003C   0x9009             STR      R0,[SP, #+36]
   1398              buf.CallbackBuf =  psrc;                                    /* Buf      passed to callback.                         */
   \   0000003E   0x950A             STR      R5,[SP, #+40]
   1399          
   1400          
   1401                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
   1402              valid = Serial_IF_IsValid(if_nbr, perr);
   \   00000040   0x4641             MOV      R1,R8
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       Serial_IF_IsValid
   \   0000004A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1403              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   0000004E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD001             BEQ.N    ??Serial_Wr_2
   1404                  return ((CPU_SIZE_T)0);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE044             B.N      ??Serial_Wr_1
   1405              }
   1406          
   1407          
   1408              pif = &Serial_IF_Tbl[if_nbr];
   \                     ??Serial_Wr_2: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable12
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0x21F0             MOVS     R1,#+240
   \   00000060   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000064   0x4408             ADD      R0,R0,R1
   \   00000066   0x4681             MOV      R9,R0
   1409          
   1410              SerialOS_SemWait(pif->WrSem, 0, perr);
   \   00000068   0x4642             MOV      R2,R8
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xF8D9 0x009C      LDR      R0,[R9, #+156]
   \   00000070   0x.... 0x....      BL       SerialOS_SemWait
   1411              if (*perr != SERIAL_OS_ERR_NONE) {
   \   00000074   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000078   0x283C             CMP      R0,#+60
   \   0000007A   0xD001             BEQ.N    ??Serial_Wr_3
   1412                   return ((CPU_SIZE_T)0);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE031             B.N      ??Serial_Wr_1
   1413              }
   1414          
   1415              psignal = SerialOS_SemCreate((CPU_INT16U)0);
   \                     ??Serial_Wr_3: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      BL       SerialOS_SemCreate
   \   00000086   0x9000             STR      R0,[SP, #+0]
   1416              if (psignal == (void *)0) {
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD108             BNE.N    ??Serial_Wr_4
   1417                  SerialOS_SemSignal(pif->WrSem);
   \   0000008E   0xF8D9 0x009C      LDR      R0,[R9, #+156]
   \   00000092   0x.... 0x....      BL       SerialOS_SemSignal
   1418                 *perr = SERIAL_ERR_SIGNAL;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1419                  return ((CPU_SIZE_T)0);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE021             B.N      ??Serial_Wr_1
   1420              }
   1421          
   1422              wr_info.SignalPtr = (void *)psignal;
   \                     ??Serial_Wr_4: (+1)
   \   000000A0   0x9800             LDR      R0,[SP, #+0]
   \   000000A2   0x9002             STR      R0,[SP, #+8]
   1423          
   1424              CPU_CRITICAL_ENTER();
   \   000000A4   0x.... 0x....      BL       CPU_SR_Save
   \   000000A8   0x4683             MOV      R11,R0
   \   000000AA   0x.... 0x....      BL       CPU_IntDisMeasStart
   1425              Serial_WrStart(pif, &buf, perr);                            /* Start wr.                                            */
   \   000000AE   0x4642             MOV      R2,R8
   \   000000B0   0xA906             ADD      R1,SP,#+24
   \   000000B2   0x4648             MOV      R0,R9
   \   000000B4   0x.... 0x....      BL       Serial_WrStart
   1426              CPU_CRITICAL_EXIT();
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x4658             MOV      R0,R11
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
   1427          
   1428              if (*perr == SERIAL_ERR_NONE) {
   \   000000C2   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD106             BNE.N    ??Serial_Wr_5
   1429                  len_wr = Serial_WrEnd(pif, &wr_info, perr);             /* Wait for wr end.                                     */
   \   000000CA   0x4642             MOV      R2,R8
   \   000000CC   0xA902             ADD      R1,SP,#+8
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0x.... 0x....      BL       Serial_WrEnd
   \   000000D4   0x4682             MOV      R10,R0
   \   000000D6   0xE001             B.N      ??Serial_Wr_6
   1430              } else{
   1431                  len_wr = 0;
   \                     ??Serial_Wr_5: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x4682             MOV      R10,R0
   1432              }
   1433          
   1434              SerialOS_SemDel(psignal);
   \                     ??Serial_Wr_6: (+1)
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x.... 0x....      BL       SerialOS_SemDel
   1435              return (len_wr);
   \   000000E2   0x4650             MOV      R0,R10
   \                     ??Serial_Wr_1: (+1)
   \   000000E4   0xB00D             ADD      SP,SP,#+52
   \   000000E6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1436          }
   1437          
   1438          
   1439          /*$PAGE*/
   1440          /*
   1441          *********************************************************************************************************
   1442          *                                          Serial_WrAsync()
   1443          *
   1444          * Description : Write asynchronously to a serial interface.
   1445          *
   1446          * Argument(s) : if_nbr      Interface number.
   1447          *
   1448          *               psrc        Pointer to source buffer.
   1449          *
   1450          *               len         Number of octets to write.
   1451          *
   1452          *               phandler    Address of write complete callback function.
   1453          *
   1454          *               parg        Pointer to write complete callback context.
   1455          *
   1456          *               perr        Pointer to variable that will receive the return error code from this function :
   1457          *
   1458          *                               SERIAL_ERR_NONE             Device successfully written.
   1459          *                               SERIAL_ERR_NULL_PTR         NULL pointer passed for argument 'psrc'.
   1460          *                               SERIAL_ERR_NULL_FNCT        NULL pointer passed for argument 'phandler'.
   1461          *                               SERIAL_ERR_IF_IN_USE        Serial interface is in use.
   1462          *
   1463          *                                                           ---- RETURNED BY Serial_IF_IsValid() : ----
   1464          *                               SERIAL_ERR_IF_INVALID_NBR   Invalid serial interface number.
   1465          *                               SERIAL_ERR_IF_NOT_OPEN      Serial interface NOT open.
   1466          *
   1467          * Return(s)   : None.
   1468          *
   1469          * Caller(s)   : Application.
   1470          *
   1471          * Note(s)     : (1) Multiple tasks/contexts may write to the same serial interface at any time.
   1472          *********************************************************************************************************
   1473          */
   1474          

   \                                 In section .text, align 2, keep-with-next
   1475          void  Serial_WrAsync (SERIAL_IF_NBR          if_nbr,
   1476                                void                  *psrc,
   1477                                CPU_SIZE_T             len,
   1478                                SERIAL_CALLBACK_FNCT  *phandler,
   1479                                void                  *parg,
   1480                                SERIAL_ERR            *perr)
   1481          {
   \                     Serial_WrAsync: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8048      LDR      R8,[SP, #+72]
   \   00000012   0xF8DD 0x904C      LDR      R9,[SP, #+76]
   1482              SERIAL_IF        *pif;
   1483              CPU_BOOLEAN       valid;
   1484              SERIAL_BUF_DESC   buf;
   1485              CPU_BOOLEAN       lock;
   1486              CPU_SR_ALLOC();
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
   1487          
   1488          
   1489          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1490              if (psrc == (void *)0) {                                    /* Validate src buf ptr.                                */
   1491                 *perr = SERIAL_ERR_NULL_PTR;
   1492                  return;
   1493              }
   1494              if (phandler == (void *)0) {                                /* Validate callback fnct ptr.                          */
   1495                 *perr = SERIAL_ERR_NULL_FNCT;
   1496                  return;
   1497              }
   1498          #endif
   1499          
   1500              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD103             BNE.N    ??Serial_WrAsync_0
   1501                 *perr = SERIAL_ERR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1502                  return;
   \   00000024   0xE03F             B.N      ??Serial_WrAsync_1
   1503              }
   1504          
   1505          
   1506              buf.Len         = len;
   \                     ??Serial_WrAsync_0: (+1)
   \   00000026   0x9601             STR      R6,[SP, #+4]
   1507              buf.DataPtr     = psrc;
   \   00000028   0x9502             STR      R5,[SP, #+8]
   1508              buf.Callback    = phandler;                                 /* Callback called upon completion.                     */
   \   0000002A   0x9703             STR      R7,[SP, #+12]
   1509              buf.CallbackArg = parg;                                     /* Argument passed to callback.                         */
   \   0000002C   0xF8CD 0x8010      STR      R8,[SP, #+16]
   1510              buf.CallbackBuf = psrc;                                     /* Buf      passed to callback.                         */
   \   00000030   0x9505             STR      R5,[SP, #+20]
   1511          
   1512          
   1513              pif = &Serial_IF_Tbl[if_nbr];
   \   00000032   0x....             LDR.N    R0,??DataTable12
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x21F0             MOVS     R1,#+240
   \   00000038   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000003C   0x4408             ADD      R0,R0,R1
   \   0000003E   0x4682             MOV      R10,R0
   1514          
   1515                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
   1516              CPU_CRITICAL_ENTER();
   \   00000040   0x.... 0x....      BL       CPU_SR_Save
   \   00000044   0x4683             MOV      R11,R0
   \   00000046   0x.... 0x....      BL       CPU_IntDisMeasStart
   1517              valid = Serial_IF_IsValid(if_nbr, perr);
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       Serial_IF_IsValid
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1518              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   00000058   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD005             BEQ.N    ??Serial_WrAsync_2
   1519                  CPU_CRITICAL_EXIT();
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x4658             MOV      R0,R11
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
   1520                  return;
   \   0000006A   0xE01C             B.N      ??Serial_WrAsync_1
   1521              }
   1522          
   1523              lock = SerialOS_SemTryLock(pif->WrSem);
   \                     ??Serial_WrAsync_2: (+1)
   \   0000006C   0xF8DA 0x009C      LDR      R0,[R10, #+156]
   \   00000070   0x.... 0x....      BL       SerialOS_SemTryLock
   \   00000074   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1524              if (lock != DEF_OK) {
   \   00000078   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD008             BEQ.N    ??Serial_WrAsync_3
   1525                  CPU_CRITICAL_EXIT();
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000084   0x4658             MOV      R0,R11
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
   1526                 *perr = SERIAL_ERR_IF_IN_USE;
   \   0000008A   0x202A             MOVS     R0,#+42
   \   0000008C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   1527                  return;
   \   00000090   0xE009             B.N      ??Serial_WrAsync_1
   1528              }
   1529          
   1530              Serial_WrStart(pif, &buf, perr);                            /* Start wr.                                            */
   \                     ??Serial_WrAsync_3: (+1)
   \   00000092   0x464A             MOV      R2,R9
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0x4650             MOV      R0,R10
   \   00000098   0x.... 0x....      BL       Serial_WrStart
   1531              CPU_CRITICAL_EXIT();
   \   0000009C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A0   0x4658             MOV      R0,R11
   \   000000A2   0x.... 0x....      BL       CPU_SR_Restore
   1532          }
   \                     ??Serial_WrAsync_1: (+1)
   \   000000A6   0xB009             ADD      SP,SP,#+36
   \   000000A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1533          
   1534          
   1535          /*$PAGE*/
   1536          /*
   1537          *********************************************************************************************************
   1538          *********************************************************************************************************
   1539          *                                     FUNCTIONS CALLED BY DRIVER
   1540          *********************************************************************************************************
   1541          *********************************************************************************************************
   1542          */
   1543          
   1544          /*
   1545          *********************************************************************************************************
   1546          *                                        SerialIF_GetDevPtr()
   1547          *
   1548          * Description : Get serial interface's device pointer.
   1549          *
   1550          * Argument(s) : if_nbr      Serial interface number to validate.
   1551          *
   1552          *               perr        Pointer to variable that will receive the return error code from this function :
   1553          *
   1554          *                               SERIAL_ERR_NONE                 Serial interface device structure successfully
   1555          *                                                                   returned.
   1556          *
   1557          *                                                               ------ RETURNED BY Serial_IF_IsValid() : -----
   1558          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   1559          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   1560          *
   1561          * Return(s)   : Pointer to serial interface device structure, if NO errors.
   1562          *               Pointer to NULL,                              otherwise.
   1563          *
   1564          * Caller(s)   : Line driver functions.
   1565          *
   1566          *               This function is an INTERNAL serial interface suite function & MUST NOT be called by
   1567          *               application function(s).
   1568          *
   1569          * Note(s)     : None.
   1570          *********************************************************************************************************
   1571          */
   1572          

   \                                 In section .text, align 2, keep-with-next
   1573          SERIAL_DEV  *SerialIF_GetDevPtr (SERIAL_IF_NBR   if_nbr,
   1574                                           SERIAL_ERR     *perr)
   1575          {
   \                     SerialIF_GetDevPtr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1576              SERIAL_IF    *pif;
   1577              SERIAL_DEV   *pdev;
   1578              CPU_BOOLEAN   valid;
   1579          
   1580                                                                          /* ------------------ VALIDATE IF NBR ----------------- */
   1581              valid = Serial_IF_IsValid(if_nbr, perr);
   \   00000008   0x0029             MOVS     R1,R5
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       Serial_IF_IsValid
   \   00000012   0x4680             MOV      R8,R0
   1582              if (valid != DEF_YES) {                                     /* Rtn err if IF not valid.                             */
   \   00000014   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000018   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000001C   0xD001             BEQ.N    ??SerialIF_GetDevPtr_0
   1583                  return ((SERIAL_DEV *)0);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE00C             B.N      ??SerialIF_GetDevPtr_1
   1584              }
   1585          
   1586                                                                          /* ----------------- GET LINE DRV INFO ---------------- */
   1587              pif  = &Serial_IF_Tbl[if_nbr];
   \                     ??SerialIF_GetDevPtr_0: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable12
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x21F0             MOVS     R1,#+240
   \   00000028   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x0006             MOVS     R6,R0
   1588              pdev = &pif->Dev;
   \   00000030   0xF116 0x0008      ADDS     R0,R6,#+8
   \   00000034   0x0007             MOVS     R7,R0
   1589             *perr =  SERIAL_ERR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8028             STRH     R0,[R5, #+0]
   1590          
   1591              return (pdev);
   \   0000003A   0x0038             MOVS     R0,R7
   \                     ??SerialIF_GetDevPtr_1: (+1)
   \   0000003C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1592          }
   1593          
   1594          
   1595          /*$PAGE*/
   1596          /*
   1597          *********************************************************************************************************
   1598          *                                            SerialIF_Rx()
   1599          *
   1600          * Description : Handle a completed read.
   1601          *
   1602          * Argument(s) : pdev        Pointer to device.
   1603          *
   1604          *               datum       Read octet.
   1605          *
   1606          * Return(s)   : None.
   1607          *
   1608          * Caller(s)   : Driver ISR Handler.
   1609          *
   1610          *               This function is an INTERNAL serial interface suite function & MUST NOT be called by
   1611          *               application function(s).
   1612          *
   1613          * Note(s)     : None.
   1614          *********************************************************************************************************
   1615          */
   1616          

   \                                 In section .text, align 2, keep-with-next
   1617          void  SerialIF_Rx (SERIAL_DEV  *pdev,
   1618                             CPU_INT08U   datum)
   1619          {
   \                     SerialIF_Rx: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0004             MOVS     R4,R0
   1620              SERIAL_IF             *pif;
   1621              SERIAL_IF_NBR          if_nbr;
   1622              SERIAL_ERR             err;
   1623              SERIAL_BUF            *pbuf;
   1624              SERIAL_CALLBACK_FNCT  *callback;
   1625              void                  *callback_arg;
   1626              void                  *callback_buf;
   1627              CPU_BOOLEAN            done;
   1628              CPU_BOOLEAN            cmp;
   1629              CPU_BOOLEAN            full;
   1630              CPU_SIZE_T             rd_len;
   1631          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1632              CPU_BOOLEAN            rd;
   1633          #endif
   1634              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
   1635          
   1636          
   1637          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1638              if (pdev == (void *)0) {                                    /* Validate dev ptr.                                    */
   1639                  return;
   1640              }
   1641          
   1642              Serial_IF_IsValid(pdev->IF_Nbr, &err);
   1643              if (err != SERIAL_ERR_NONE) {
   1644                  return;
   1645              }
   1646          #endif
   1647          
   1648          
   1649              if_nbr =  pdev->IF_Nbr;
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1650              pif    = &Serial_IF_Tbl[if_nbr];
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000018   0x22F0             MOVS     R2,#+240
   \   0000001A   0x4351             MULS     R1,R2,R1
   \   0000001C   0x4408             ADD      R0,R0,R1
   \   0000001E   0x0005             MOVS     R5,R0
   1651              done   =  DEF_NO;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0007             MOVS     R7,R0
   1652          
   1653              CPU_CRITICAL_ENTER();
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x4682             MOV      R10,R0
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStart
   1654              switch (pif->RdState) {
   \   0000002E   0xF895 0x006C      LDRB     R0,[R5, #+108]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD004             BEQ.N    ??SerialIF_Rx_0
   \   00000036   0xD31D             BCC.N    ??SerialIF_Rx_1
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD046             BEQ.N    ??SerialIF_Rx_2
   \   0000003C   0xD327             BCC.N    ??SerialIF_Rx_3
   \   0000003E   0xE019             B.N      ??SerialIF_Rx_1
   1655                  case SERIAL_RD_STATE_OPENED:                            /* -------------------- RD INTO BUF ------------------- */
   1656          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1657                       if (pif->RdBufEn == DEF_YES) {
   \                     ??SerialIF_Rx_0: (+1)
   \   00000040   0xF895 0x00C0      LDRB     R0,[R5, #+192]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD10F             BNE.N    ??SerialIF_Rx_4
   1658                           if (pif->RdBufErr == SERIAL_ERR_NONE) {        /* Wr octet.                                            */
   \   00000048   0xF8B5 0x00C2      LDRH     R0,[R5, #+194]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10B             BNE.N    ??SerialIF_Rx_4
   1659                               pdev->LineDrv_API->WrOctet(pdev,
   1660                                                        &(pif->RdBuf),
   1661                                                          datum,
   1662                                                        &(pif->RdBufErr));
   \   00000050   0xF115 0x03C2      ADDS     R3,R5,#+194
   \   00000054   0xF89D 0x2018      LDRB     R2,[SP, #+24]
   \   00000058   0xF115 0x01C4      ADDS     R1,R5,#+196
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xF8D4 0xC00C      LDR      R12,[R4, #+12]
   \   00000062   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   00000066   0x47E0             BLX      R12
   1663                           }
   1664                       }
   1665          #endif
   1666                       CPU_CRITICAL_EXIT();
   \                     ??SerialIF_Rx_4: (+1)
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006C   0x4650             MOV      R0,R10
   \   0000006E   0x.... 0x....      BL       CPU_SR_Restore
   1667                       return;
   \   00000072   0xE0AE             B.N      ??SerialIF_Rx_5
   1668          
   1669          
   1670          
   1671                  case SERIAL_RD_STATE_CLOSED:
   1672                  default:
   1673                       pdev->Dev_Cfg->Drv_API->RxStop(pdev, &err);        /* Stop rx'er.                                          */
   \                     ??SerialIF_Rx_1: (+1)
   \   00000074   0xF10D 0x0106      ADD      R1,SP,#+6
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x6862             LDR      R2,[R4, #+4]
   \   0000007C   0x6852             LDR      R2,[R2, #+4]
   \   0000007E   0x6912             LDR      R2,[R2, #+16]
   \   00000080   0x4790             BLX      R2
   1674                       CPU_CRITICAL_EXIT();
   \   00000082   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000086   0x4650             MOV      R0,R10
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
   1675                       return;
   \   0000008C   0xE0A1             B.N      ??SerialIF_Rx_5
   1676          
   1677          
   1678          
   1679                  case SERIAL_RD_STATE_RD:                                /* --------------- RD DATA INTO USER BUF -------------- */
   1680                       pbuf = &(pif->RdUserBuf);
   \                     ??SerialIF_Rx_3: (+1)
   \   0000008E   0xF115 0x0084      ADDS     R0,R5,#+132
   \   00000092   0x0006             MOVS     R6,R0
   1681                       pdev->LineDrv_API->WrOctet(pdev,                   /* Wr octet.                                            */
   1682                                                  pbuf,
   1683                                                  datum,
   1684                                                 &err);
   \   00000094   0xF10D 0x0306      ADD      R3,SP,#+6
   \   00000098   0xF89D 0x2018      LDRB     R2,[SP, #+24]
   \   0000009C   0x0031             MOVS     R1,R6
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0xF8D4 0xC00C      LDR      R12,[R4, #+12]
   \   000000A4   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   000000A8   0x47E0             BLX      R12
   1685          
   1686                       full = SerialBuf_IsFull(pbuf);
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0x.... 0x....      BL       SerialBuf_IsFull
   \   000000B0   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1687          
   1688                       if ((err  != SERIAL_ERR_NONE) ||
   1689                           (full == DEF_YES)) {
   \   000000B4   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD103             BNE.N    ??SerialIF_Rx_6
   \   000000BC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD101             BNE.N    ??SerialIF_Rx_7
   1690                           done = DEF_YES;
   \                     ??SerialIF_Rx_6: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x0007             MOVS     R7,R0
   1691                       }
   1692                       break;
   \                     ??SerialIF_Rx_7: (+1)
   \   000000C8   0xE054             B.N      ??SerialIF_Rx_8
   1693          
   1694          
   1695          
   1696                  case SERIAL_RD_STATE_CHK:                               /* ------------- CHK DATA AGAINST USER BUF ------------ */
   1697          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1698                       pbuf = &(pif->RdUserBuf);
   \                     ??SerialIF_Rx_2: (+1)
   \   000000CA   0xF115 0x0084      ADDS     R0,R5,#+132
   \   000000CE   0x0006             MOVS     R6,R0
   1699          
   1700                       if (pif->RdBufEn == DEF_YES) {
   \   000000D0   0xF895 0x00C0      LDRB     R0,[R5, #+192]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD13D             BNE.N    ??SerialIF_Rx_9
   1701                           if (pif->RdBufErr != SERIAL_ERR_NONE) {
   \   000000D8   0xF8B5 0x00C2      LDRH     R0,[R5, #+194]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD00D             BEQ.N    ??SerialIF_Rx_10
   1702                               pif->RdBufErr  = SERIAL_ERR_NONE;          /* Flush rd buf.                                        */
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xF8A5 0x00C2      STRH     R0,[R5, #+194]
   1703                               SerialBuf_Clr(&(pif->RdBuf));
   \   000000E6   0xF115 0x00C4      ADDS     R0,R5,#+196
   \   000000EA   0x.... 0x....      BL       SerialBuf_Clr
   1704                                                                          /* Restart cmp if rd buf err.                           */
   1705                               SerialBuf_Init((SERIAL_BUF  *)pbuf,
   1706                                              (CPU_INT08U  *)pif->RdCallbackBuf,
   1707                                              (CPU_SIZE_T   )pif->RdCallbackLen,
   1708                                              (CPU_BOOLEAN  )DEF_YES);
   \   000000EE   0x2301             MOVS     R3,#+1
   \   000000F0   0xF8D5 0x2080      LDR      R2,[R5, #+128]
   \   000000F4   0x6FE9             LDR      R1,[R5, #+124]
   \   000000F6   0x0030             MOVS     R0,R6
   \   000000F8   0x.... 0x....      BL       SerialBuf_Init
   1709                           }
   1710          
   1711                           pdev->LineDrv_API->WrOctet(pdev,
   1712                                                    &(pif->RdBuf),
   1713                                                      datum,
   1714                                                    &(pif->RdBufErr));
   \                     ??SerialIF_Rx_10: (+1)
   \   000000FC   0xF115 0x03C2      ADDS     R3,R5,#+194
   \   00000100   0xF89D 0x2018      LDRB     R2,[SP, #+24]
   \   00000104   0xF115 0x01C4      ADDS     R1,R5,#+196
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0xF8D4 0xC00C      LDR      R12,[R4, #+12]
   \   0000010E   0xF8DC 0xC00C      LDR      R12,[R12, #+12]
   \   00000112   0x47E0             BLX      R12
   1715          
   1716                           do {
   1717                               rd = SerialBuf_RdOctet(&(pif->RdBuf), &datum);
   \                     ??SerialIF_Rx_11: (+1)
   \   00000114   0xA906             ADD      R1,SP,#+24
   \   00000116   0xF115 0x00C4      ADDS     R0,R5,#+196
   \   0000011A   0x.... 0x....      BL       SerialBuf_RdOctet
   \   0000011E   0x4681             MOV      R9,R0
   1718                               if (rd == DEF_YES) {
   \   00000120   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000124   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000128   0xD10E             BNE.N    ??SerialIF_Rx_12
   1719                                   cmp = SerialBuf_Cmp(pbuf, datum);
   \   0000012A   0xF89D 0x1018      LDRB     R1,[SP, #+24]
   \   0000012E   0x0030             MOVS     R0,R6
   \   00000130   0x.... 0x....      BL       SerialBuf_Cmp
   \   00000134   0x4680             MOV      R8,R0
   1720                                   if (cmp == DEF_YES) {
   \   00000136   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000013A   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000013E   0xD103             BNE.N    ??SerialIF_Rx_12
   1721                                       done = DEF_YES;
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x0007             MOVS     R7,R0
   1722                                       rd   = DEF_NO;
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x4681             MOV      R9,R0
   1723                                   }
   1724                               }
   1725                           } while (rd == DEF_YES);
   \                     ??SerialIF_Rx_12: (+1)
   \   00000148   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000014C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000150   0xD110             BNE.N    ??SerialIF_Rx_13
   \   00000152   0xE7DF             B.N      ??SerialIF_Rx_11
   1726          
   1727                       } else {
   1728          
   1729                           cmp = SerialBuf_Cmp(pbuf, datum);
   \                     ??SerialIF_Rx_9: (+1)
   \   00000154   0xF89D 0x1018      LDRB     R1,[SP, #+24]
   \   00000158   0x0030             MOVS     R0,R6
   \   0000015A   0x.... 0x....      BL       SerialBuf_Cmp
   \   0000015E   0x4680             MOV      R8,R0
   1730                           if (cmp == DEF_YES) {
   \   00000160   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000164   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000168   0xD104             BNE.N    ??SerialIF_Rx_13
   1731                               done = DEF_YES;
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x0007             MOVS     R7,R0
   1732                               err  = SERIAL_ERR_NONE;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1733                           }
   1734                       }
   1735          #else
   1736                       pbuf = &(pif->RdUserBuf);
   1737                       cmp  = SerialBuf_Cmp(pbuf, datum);
   1738                       if (cmp == DEF_YES) {
   1739                           done = DEF_YES;
   1740                           err  = SERIAL_ERR_NONE;
   1741                       }
   1742          #endif
   1743                       break;
   1744              }
   1745          
   1746              if (done == DEF_YES) {
   \                     ??SerialIF_Rx_13: (+1)
   \                     ??SerialIF_Rx_8: (+1)
   \   00000174   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000176   0x2F01             CMP      R7,#+1
   \   00000178   0xD126             BNE.N    ??SerialIF_Rx_14
   1747                  rd_len        = SerialBuf_DataLen(pbuf);
   \   0000017A   0x0030             MOVS     R0,R6
   \   0000017C   0x.... 0x....      BL       SerialBuf_DataLen
   \   00000180   0x4683             MOV      R11,R0
   1748          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   1749                  rd_len       += pif->RdCallbackLen;
   \   00000182   0xF8D5 0x0080      LDR      R0,[R5, #+128]
   \   00000186   0xEB10 0x0B0B      ADDS     R11,R0,R11
   1750          #endif
   1751                  callback_arg  = pif->RdCallbackArg;
   \   0000018A   0x6FA8             LDR      R0,[R5, #+120]
   \   0000018C   0x9004             STR      R0,[SP, #+16]
   1752                  callback_buf  = pif->RdCallbackBuf;
   \   0000018E   0x6FE8             LDR      R0,[R5, #+124]
   \   00000190   0x9003             STR      R0,[SP, #+12]
   1753                  callback      = pif->RdCallback;
   \   00000192   0x6F68             LDR      R0,[R5, #+116]
   \   00000194   0x9002             STR      R0,[SP, #+8]
   1754          
   1755                  Serial_IF_RxReset(pif);
   \   00000196   0x0028             MOVS     R0,R5
   \   00000198   0x.... 0x....      BL       Serial_IF_RxReset
   1756                  SerialOS_SemSignal(pif->RdSem);
   \   0000019C   0x6F28             LDR      R0,[R5, #+112]
   \   0000019E   0x.... 0x....      BL       SerialOS_SemSignal
   1757          
   1758                  if (callback != (SERIAL_CALLBACK_FNCT *)0) {
   \   000001A2   0x9802             LDR      R0,[SP, #+8]
   \   000001A4   0x2800             CMP      R0,#+0
   \   000001A6   0xD00F             BEQ.N    ??SerialIF_Rx_14
   1759                      CPU_CRITICAL_EXIT();
   \   000001A8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001AC   0x4650             MOV      R0,R10
   \   000001AE   0x.... 0x....      BL       CPU_SR_Restore
   1760          
   1761                      (*callback)(pif->Nbr,                               /* Call callback fnct.                                  */
   1762                                  callback_arg,
   1763                                  callback_buf,
   1764                                  rd_len,
   1765                                  err);
   \   000001B2   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000001B6   0x9000             STR      R0,[SP, #+0]
   \   000001B8   0x465B             MOV      R3,R11
   \   000001BA   0x9A03             LDR      R2,[SP, #+12]
   \   000001BC   0x9904             LDR      R1,[SP, #+16]
   \   000001BE   0x7868             LDRB     R0,[R5, #+1]
   \   000001C0   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   \   000001C4   0x47E0             BLX      R12
   1766          
   1767                      return;
   \   000001C6   0xE004             B.N      ??SerialIF_Rx_5
   1768                  }
   1769              }
   1770          
   1771              CPU_CRITICAL_EXIT();
   \                     ??SerialIF_Rx_14: (+1)
   \   000001C8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000001CC   0x4650             MOV      R0,R10
   \   000001CE   0x.... 0x....      BL       CPU_SR_Restore
   1772          }
   \                     ??SerialIF_Rx_5: (+1)
   \   000001D2   0xB007             ADD      SP,SP,#+28
   \   000001D4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1773          
   1774          
   1775          /*$PAGE*/
   1776          /*
   1777          *********************************************************************************************************
   1778          *                                            SerialIF_Tx()
   1779          *
   1780          * Description : Handle a completed transmission.
   1781          *
   1782          * Argument(s) : pdev        Pointer to device.
   1783          *
   1784          * Return(s)   : None.
   1785          *
   1786          * Caller(s)   : Driver ISR Handler.
   1787          *
   1788          *               This function is an INTERNAL serial interface suite function & MUST NOT be called by
   1789          *               application function(s).
   1790          *
   1791          * Note(s)     : None.
   1792          *********************************************************************************************************
   1793          */
   1794          

   \                                 In section .text, align 2, keep-with-next
   1795          void  SerialIF_Tx (SERIAL_DEV  *pdev)
   1796          {
   \                     SerialIF_Tx: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   1797              SERIAL_IF             *pif;
   1798              SERIAL_IF_NBR          if_nbr;
   1799              SERIAL_ERR             err;
   1800              SERIAL_BUF            *pbuf;
   1801              SERIAL_CALLBACK_FNCT  *callback;
   1802              void                  *callback_arg;
   1803              void                  *callback_buf;
   1804              CPU_INT08U             datum;
   1805              CPU_SIZE_T             wr_len;
   1806              CPU_SIZE_T             data_len;
   1807              CPU_SIZE_T             buf_size;
   1808              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0B00      MOVS     R11,#+0
   1809          
   1810          
   1811          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1812              if (pdev == (void *)0) {                                    /* Validate dev ptr.                                    */
   1813                  return;
   1814              }
   1815          
   1816              Serial_IF_IsValid(pdev->IF_Nbr, &err);
   1817              if (err != SERIAL_ERR_NONE) {
   1818                  return;
   1819              }
   1820          #endif
   1821          
   1822          
   1823              if_nbr   =  pdev->IF_Nbr;
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1824              pif      = &Serial_IF_Tbl[if_nbr];
   \   00000012   0x....             LDR.N    R0,??DataTable14_1
   \   00000014   0xF89D 0x1007      LDRB     R1,[SP, #+7]
   \   00000018   0x22F0             MOVS     R2,#+240
   \   0000001A   0x4351             MULS     R1,R2,R1
   \   0000001C   0x4408             ADD      R0,R0,R1
   \   0000001E   0x0005             MOVS     R5,R0
   1825          
   1826              CPU_CRITICAL_ENTER();
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   \   00000024   0x4683             MOV      R11,R0
   \   00000026   0x.... 0x....      BL       CPU_IntDisMeasStart
   1827              switch (pif->WrState) {
   \   0000002A   0xF895 0x0098      LDRB     R0,[R5, #+152]
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD002             BEQ.N    ??SerialIF_Tx_0
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD056             BEQ.N    ??SerialIF_Tx_1
   \   00000036   0xE059             B.N      ??SerialIF_Tx_2
   1828                  case SERIAL_WR_STATE_WR:                                /* ------------------- TX NEXT OCTET ------------------ */
   1829                       pbuf = &(pif->WrUserBuf);
   \                     ??SerialIF_Tx_0: (+1)
   \   00000038   0xF115 0x00AC      ADDS     R0,R5,#+172
   \   0000003C   0x0006             MOVS     R6,R0
   1830                       pdev->LineDrv_API->RdOctet(pdev,                   /* Rd next octet.                                       */
   1831                                                  pbuf,
   1832                                                 &datum,
   1833                                                 &err);
   \   0000003E   0xAB01             ADD      R3,SP,#+4
   \   00000040   0xF10D 0x0206      ADD      R2,SP,#+6
   \   00000044   0x0031             MOVS     R1,R6
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xF8D4 0xC00C      LDR      R12,[R4, #+12]
   \   0000004C   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   00000050   0x47E0             BLX      R12
   1834          
   1835                       if (err == SERIAL_ERR_NONE) {                      /* Tx next octet.                                       */
   \   00000052   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD10D             BNE.N    ??SerialIF_Tx_3
   1836                           pdev->Dev_Cfg->Drv_API->TxOctet(pdev, datum, &err);
   \   0000005A   0xAA01             ADD      R2,SP,#+4
   \   0000005C   0xF89D 0x1006      LDRB     R1,[SP, #+6]
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0x6863             LDR      R3,[R4, #+4]
   \   00000064   0x685B             LDR      R3,[R3, #+4]
   \   00000066   0x6A1B             LDR      R3,[R3, #+32]
   \   00000068   0x4798             BLX      R3
   1837                           CPU_CRITICAL_EXIT();
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
   1838                           return;
   \   00000074   0xE045             B.N      ??SerialIF_Tx_4
   1839                       }
   1840          
   1841          
   1842                                                                          /* ------------- FINAL OCTET ALREADY WR'N ------------- */
   1843                       buf_size     = SerialBuf_Size(pbuf);
   \                     ??SerialIF_Tx_3: (+1)
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       SerialBuf_Size
   \   0000007C   0x4682             MOV      R10,R0
   1844                       data_len     = SerialBuf_DataLen(pbuf);
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x.... 0x....      BL       SerialBuf_DataLen
   \   00000084   0x4681             MOV      R9,R0
   1845                       wr_len       = buf_size - data_len;
   \   00000086   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   0000008A   0x4680             MOV      R8,R0
   1846                       callback     = pif->WrCallback;
   \   0000008C   0xF8D5 0x00A0      LDR      R0,[R5, #+160]
   \   00000090   0x0007             MOVS     R7,R0
   1847                       callback_arg = pif->WrCallbackArg;
   \   00000092   0xF8D5 0x00A4      LDR      R0,[R5, #+164]
   \   00000096   0x9003             STR      R0,[SP, #+12]
   1848                       callback_buf = pif->WrCallbackBuf;
   \   00000098   0xF8D5 0x00A8      LDR      R0,[R5, #+168]
   \   0000009C   0x9002             STR      R0,[SP, #+8]
   1849          
   1850                       Serial_IF_WrClr(pif);                              /* Clr wr info.                                         */
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0x.... 0x....      BL       Serial_IF_WrClr
   1851          
   1852                       Serial_WrNext(pif);
   \   000000A4   0x0028             MOVS     R0,R5
   \   000000A6   0x.... 0x....      BL       Serial_WrNext
   1853                       SerialOS_SemSignal(pif->WrSem);
   \   000000AA   0xF8D5 0x009C      LDR      R0,[R5, #+156]
   \   000000AE   0x.... 0x....      BL       SerialOS_SemSignal
   1854          
   1855                       if (callback != (SERIAL_CALLBACK_FNCT *)0) {
   \   000000B2   0x0038             MOVS     R0,R7
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD014             BEQ.N    ??SerialIF_Tx_5
   1856                           CPU_CRITICAL_EXIT();
   \   000000B8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000BC   0x4658             MOV      R0,R11
   \   000000BE   0x.... 0x....      BL       CPU_SR_Restore
   1857          
   1858                         (*callback)(pif->Nbr,                            /* Call callback fnct.                                  */
   1859                                     callback_arg,
   1860                                     callback_buf,
   1861                                     wr_len,
   1862                                     err == SERIAL_ERR_UNDERFLOW ? SERIAL_ERR_NONE : err);
   \   000000C2   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD101             BNE.N    ??SerialIF_Tx_6
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xE001             B.N      ??SerialIF_Tx_7
   \                     ??SerialIF_Tx_6: (+1)
   \   000000CE   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \                     ??SerialIF_Tx_7: (+1)
   \   000000D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D4   0x9000             STR      R0,[SP, #+0]
   \   000000D6   0x4643             MOV      R3,R8
   \   000000D8   0x9A02             LDR      R2,[SP, #+8]
   \   000000DA   0x9903             LDR      R1,[SP, #+12]
   \   000000DC   0x7868             LDRB     R0,[R5, #+1]
   \   000000DE   0x47B8             BLX      R7
   1863          
   1864                           return;
   \   000000E0   0xE00F             B.N      ??SerialIF_Tx_4
   1865                       }
   1866                       break;
   \                     ??SerialIF_Tx_5: (+1)
   \   000000E2   0xE009             B.N      ??SerialIF_Tx_8
   1867          
   1868          
   1869          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)
   1870                  case SERIAL_WR_STATE_WR_BUF:                            /* ------------------- TX NEXT OCTET ------------------ */
   1871                       Serial_WrNext(pif);
   \                     ??SerialIF_Tx_1: (+1)
   \   000000E4   0x0028             MOVS     R0,R5
   \   000000E6   0x.... 0x....      BL       Serial_WrNext
   1872                       break;
   \   000000EA   0xE005             B.N      ??SerialIF_Tx_8
   1873          #endif
   1874          
   1875          
   1876                  case SERIAL_WR_STATE_CLOSED:                            /* ----------------- NO WR IN PROGRESS ---------------- */
   1877                  case SERIAL_WR_STATE_OPENED:
   1878                  default:
   1879                       pdev->Dev_Cfg->Drv_API->TxStop(pdev, &err);        /* Stop tx'er.                                          */
   \                     ??SerialIF_Tx_2: (+1)
   \   000000EC   0xA901             ADD      R1,SP,#+4
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x6862             LDR      R2,[R4, #+4]
   \   000000F2   0x6852             LDR      R2,[R2, #+4]
   \   000000F4   0x69D2             LDR      R2,[R2, #+28]
   \   000000F6   0x4790             BLX      R2
   1880                       break;
   1881              }
   1882              CPU_CRITICAL_EXIT();
   \                     ??SerialIF_Tx_8: (+1)
   \   000000F8   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000FC   0x4658             MOV      R0,R11
   \   000000FE   0x.... 0x....      BL       CPU_SR_Restore
   1883          }
   \                     ??SerialIF_Tx_4: (+1)
   \   00000102   0xB005             ADD      SP,SP,#+20
   \   00000104   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1884          
   1885          
   1886          /*$PAGE*/
   1887          /*
   1888          *********************************************************************************************************
   1889          *                                         SerialIF_TxWrBuf()
   1890          *
   1891          * Description : Handle a transmit echo.
   1892          *
   1893          * Argument(s) : pdev        Pointer to device.
   1894          *
   1895          *               datum       Octet to transmit.
   1896          *
   1897          * Return(s)   : None.
   1898          *
   1899          * Caller(s)   : SerialLine_WrOctet().
   1900          *
   1901          *               This function is an INTERNAL serial interface suite function & MUST NOT be called by
   1902          *               application function(s).
   1903          *
   1904          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   1905          *********************************************************************************************************
   1906          */
   1907          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1908          void  SerialIF_TxWrBuf (SERIAL_DEV  *pdev,
   1909                                  CPU_INT08U   datum)
   1910          {
   \                     SerialIF_TxWrBuf: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1911              SERIAL_IF      *pif;
   1912              SERIAL_IF_NBR   if_nbr;
   1913              SERIAL_ERR      err;
   1914          
   1915          
   1916          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   1917              if (pdev == (void *)0) {                                    /* Validate dev ptr.                                    */
   1918                  return;
   1919              }
   1920          
   1921              Serial_IF_IsValid(pdev->IF_Nbr, &err);
   1922              if (err != SERIAL_ERR_NONE) {
   1923                  return;
   1924              }
   1925          #endif
   1926          
   1927          
   1928              if_nbr   =  pdev->IF_Nbr;
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x0007             MOVS     R7,R0
   1929              pif      = &Serial_IF_Tbl[if_nbr];
   \   0000000A   0x....             LDR.N    R0,??DataTable14_1
   \   0000000C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000E   0x21F0             MOVS     R1,#+240
   \   00000010   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000014   0x4408             ADD      R0,R0,R1
   \   00000016   0x0006             MOVS     R6,R0
   1930          
   1931              if (pif->WrBufEn == DEF_YES) {
   \   00000018   0xF896 0x00D8      LDRB     R0,[R6, #+216]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD117             BNE.N    ??SerialIF_TxWrBuf_0
   1932                  switch (pif->WrState) {
   \   00000020   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0xD003             BEQ.N    ??SerialIF_TxWrBuf_1
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD909             BLS.N    ??SerialIF_TxWrBuf_2
   \   0000002E   0xE00F             B.N      ??SerialIF_TxWrBuf_3
   1933                      case SERIAL_WR_STATE_OPENED:
   1934                                                                          /* Tx first octet.                                      */
   1935                           pdev->Dev_Cfg->Drv_API->TxOctet(pdev, datum, &err);
   \                     ??SerialIF_TxWrBuf_1: (+1)
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0x0029             MOVS     R1,R5
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x6863             LDR      R3,[R4, #+4]
   \   0000003A   0x685B             LDR      R3,[R3, #+4]
   \   0000003C   0x6A1B             LDR      R3,[R3, #+32]
   \   0000003E   0x4798             BLX      R3
   1936                           break;
   \   00000040   0xE006             B.N      ??SerialIF_TxWrBuf_0
   1937          
   1938          
   1939                      case SERIAL_WR_STATE_WR:
   1940                      case SERIAL_WR_STATE_WR_BUF:
   1941                          (void)SerialBuf_WrOctet(&(pif->WrBuf), datum);
   \                     ??SerialIF_TxWrBuf_2: (+1)
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xF116 0x00DC      ADDS     R0,R6,#+220
   \   0000004A   0x.... 0x....      BL       SerialBuf_WrOctet
   1942                           break;
   \   0000004E   0xE7FF             B.N      ??SerialIF_TxWrBuf_0
   1943          
   1944          
   1945                      default:
   1946                      case SERIAL_WR_STATE_CLOSED:
   1947                           break;
   1948                  }
   1949              }
   1950          }
   \                     ??SerialIF_TxWrBuf_3: (+1)
   \                     ??SerialIF_TxWrBuf_0: (+1)
   \   00000050   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1951          #endif
   1952          
   1953          
   1954          /*$PAGE*/
   1955          /*
   1956          *********************************************************************************************************
   1957          *********************************************************************************************************
   1958          *                                           LOCAL FUNCTIONS
   1959          *********************************************************************************************************
   1960          *********************************************************************************************************
   1961          */
   1962          
   1963          /*
   1964          *********************************************************************************************************
   1965          *                                           Serial_IF_Clr()
   1966          *
   1967          * Description : Clear interface.
   1968          *
   1969          * Argument(s) : pif         Pointer to interface.
   1970          *
   1971          * Return(s)   : None.
   1972          *
   1973          * Caller(s)   : Serial_Init(),
   1974          *               Serial_Close().
   1975          *
   1976          * Note(s)     : None.
   1977          *********************************************************************************************************
   1978          */
   1979          

   \                                 In section .text, align 2, keep-with-next
   1980          static  void  Serial_IF_Clr (SERIAL_IF  *pif)
   1981          {
   \                     Serial_IF_Clr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1982              pif->RdState = SERIAL_RD_STATE_CLOSED;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x006C      STRB     R0,[R4, #+108]
   1983              Serial_IF_RdClr(pif);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       Serial_IF_RdClr
   1984          
   1985              pif->WrState = SERIAL_WR_STATE_CLOSED;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF884 0x0098      STRB     R0,[R4, #+152]
   1986              Serial_IF_WrClr(pif);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       Serial_IF_WrClr
   1987          
   1988              pif->Dev.Dev_Cfg      = (SERIAL_DEV_CFG      *)0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x60E0             STR      R0,[R4, #+12]
   1989              pif->Dev.Drv_Data     = (void                *)0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6120             STR      R0,[R4, #+16]
   1990              pif->Dev.LineDrv_API  = (SERIAL_LINE_DRV_API *)0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6160             STR      R0,[R4, #+20]
   1991              pif->Dev.LineDrv_Data = (void                *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61A0             STR      R0,[R4, #+24]
   1992          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   1993          
   1994          
   1995          /*$PAGE*/
   1996          /*
   1997          *********************************************************************************************************
   1998          *                                           Serial_IF_RdClr()
   1999          *
   2000          * Description : Clear read callback arguments and user buffer.
   2001          *
   2002          * Argument(s) : pif         Pointer to interface.
   2003          *
   2004          * Return(s)   : None.
   2005          *
   2006          * Caller(s)   : Serial_IF_Clr(),
   2007          *               Serial_IF_RxReset().
   2008          *
   2009          * Note(s)     : None.
   2010          *********************************************************************************************************
   2011          */
   2012          

   \                                 In section .text, align 2, keep-with-next
   2013          static  void  Serial_IF_RdClr (SERIAL_IF  *pif)
   2014          {
   \                     Serial_IF_RdClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2015              pif->RdCallback    = (SERIAL_CALLBACK_FNCT *)0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6760             STR      R0,[R4, #+116]
   2016              pif->RdCallbackArg = (void                 *)0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x67A0             STR      R0,[R4, #+120]
   2017              pif->RdCallbackBuf = (void                 *)0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x67E0             STR      R0,[R4, #+124]
   2018          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2019              pif->RdCallbackLen = (CPU_SIZE_T            )0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8C4 0x0080      STR      R0,[R4, #+128]
   2020          #endif
   2021              SerialBuf_Clr(&(pif->RdUserBuf));
   \   00000016   0xF114 0x0084      ADDS     R0,R4,#+132
   \   0000001A   0x.... 0x....      BL       SerialBuf_Clr
   2022          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   2023          
   2024          
   2025          /*$PAGE*/
   2026          /*
   2027          *********************************************************************************************************
   2028          *                                           Serial_IF_WrClr()
   2029          *
   2030          * Description : Clear write callback arguments and user buffer.
   2031          *
   2032          * Argument(s) : pif         Pointer to interface.
   2033          *
   2034          * Return(s)   : None.
   2035          *
   2036          * Caller(s)   : Serial_IF_Clr(),
   2037          *               Serial_IF_Tx().
   2038          *
   2039          * Note(s)     : None.
   2040          *********************************************************************************************************
   2041          */
   2042          

   \                                 In section .text, align 2, keep-with-next
   2043          static  void  Serial_IF_WrClr (SERIAL_IF  *pif)
   2044          {
   \                     Serial_IF_WrClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2045              pif->WrCallback    = (SERIAL_CALLBACK_FNCT *)0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8C4 0x00A0      STR      R0,[R4, #+160]
   2046              pif->WrCallbackArg = (void                 *)0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8C4 0x00A4      STR      R0,[R4, #+164]
   2047              pif->WrCallbackBuf = (void                 *)0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8C4 0x00A8      STR      R0,[R4, #+168]
   2048              SerialBuf_Clr(&(pif->WrUserBuf));
   \   00000016   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   0000001A   0x.... 0x....      BL       SerialBuf_Clr
   2049          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   2050          
   2051          
   2052          /*$PAGE*/
   2053          /*
   2054          *********************************************************************************************************
   2055          *                                         Serial_IF_RxReset()
   2056          *
   2057          * Description : Reset receiver.
   2058          *
   2059          * Argument(s) : pif         Pointer to interface.
   2060          *
   2061          * Return(s)   : None.
   2062          *
   2063          * Caller(s)   : Serial_WaitFor(),
   2064          *               Serial_IF_Rx().
   2065          *
   2066          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2067          *********************************************************************************************************
   2068          */
   2069          

   \                                 In section .text, align 2, keep-with-next
   2070          static  void  Serial_IF_RxReset (SERIAL_IF  *pif)
   2071          {
   \                     Serial_IF_RxReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2072              Serial_IF_RxStop(pif);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       Serial_IF_RxStop
   2073              pif->RdState = SERIAL_RD_STATE_OPENED;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xF884 0x006C      STRB     R0,[R4, #+108]
   2074              Serial_IF_RdClr(pif);
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       Serial_IF_RdClr
   2075          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   2076          
   2077          
   2078          /*$PAGE*/
   2079          /*
   2080          *********************************************************************************************************
   2081          *                                         Serial_IF_RxStart()
   2082          *
   2083          * Description : Start receiver.
   2084          *
   2085          * Argument(s) : pif         Pointer to interface.
   2086          *
   2087          * Return(s)   : None.
   2088          *
   2089          * Caller(s)   : Serial_RdStart(),
   2090          *               Serial_WaitFor().
   2091          *
   2092          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2093          *********************************************************************************************************
   2094          */
   2095          

   \                                 In section .text, align 2, keep-with-next
   2096          static  void  Serial_IF_RxStart (SERIAL_IF  *pif)
   2097          {
   \                     Serial_IF_RxStart: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2098              SERIAL_DEV  *pdev;
   2099              SERIAL_ERR   err;
   2100          
   2101          
   2102              pdev = &pif->Dev;
   \   00000004   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000008   0x0005             MOVS     R5,R0
   2103                                                                          /* Start rx'er, if necessary.                           */
   2104          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2105              if (pif->RdBufEn == DEF_NO) {
   \   0000000A   0xF894 0x00C0      LDRB     R0,[R4, #+192]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??Serial_IF_RxStart_0
   2106                  pdev->Dev_Cfg->Drv_API->RxStart(pdev, &err);
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x686A             LDR      R2,[R5, #+4]
   \   00000018   0x6852             LDR      R2,[R2, #+4]
   \   0000001A   0x68D2             LDR      R2,[R2, #+12]
   \   0000001C   0x4790             BLX      R2
   2107              }
   2108          #else
   2109              pdev->Dev_Cfg->Drv_API->RxStart(pdev, &err);
   2110          #endif
   2111          }
   \                     ??Serial_IF_RxStart_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2112          
   2113          
   2114          /*$PAGE*/
   2115          /*
   2116          *********************************************************************************************************
   2117          *                                         Serial_IF_RxStop()
   2118          *
   2119          * Description : Stop receiver.
   2120          *
   2121          * Argument(s) : pif         Pointer to interface.
   2122          *
   2123          * Return(s)   : None.
   2124          *
   2125          * Caller(s)   : Serial_IF_RxReset().
   2126          *
   2127          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2128          *********************************************************************************************************
   2129          */
   2130          

   \                                 In section .text, align 2, keep-with-next
   2131          static  void  Serial_IF_RxStop (SERIAL_IF  *pif)
   2132          {
   \                     Serial_IF_RxStop: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2133              SERIAL_DEV  *pdev;
   2134              SERIAL_ERR   err;
   2135          
   2136          
   2137              pdev = &pif->Dev;
   \   00000004   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000008   0x0005             MOVS     R5,R0
   2138                                                                          /* Stop rx'er, if necessary.                            */
   2139          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2140              if (pif->RdBufEn == DEF_NO) {
   \   0000000A   0xF894 0x00C0      LDRB     R0,[R4, #+192]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE.N    ??Serial_IF_RxStop_0
   2141                  pdev->Dev_Cfg->Drv_API->RxStop(pdev, &err);
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x686A             LDR      R2,[R5, #+4]
   \   00000018   0x6852             LDR      R2,[R2, #+4]
   \   0000001A   0x6912             LDR      R2,[R2, #+16]
   \   0000001C   0x4790             BLX      R2
   2142              }
   2143          #else
   2144              pdev->Dev_Cfg->Drv_API->RxStop(pdev, &err);
   2145          #endif
   2146          }
   \                     ??Serial_IF_RxStop_0: (+1)
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2147          
   2148          
   2149          /*$PAGE*/
   2150          /*
   2151          *********************************************************************************************************
   2152          *                                          Serial_RdHandler()
   2153          *
   2154          * Description : Read asynchronously or synchronously from a serial interface.
   2155          *
   2156          * Argument(s) : pif         Pointer to interface.
   2157          *
   2158          *               pdest       Pointer to destination buffer.
   2159          *
   2160          *               len         Number of octets to read.
   2161          *
   2162          *               phandler    Address of read complete callback function.
   2163          *
   2164          *               parg        Pointer to read complete callback context.
   2165          *
   2166          *               async       Select asynchronously or synchronously method.
   2167          *
   2168          *               timeout_ms  Optional timeout period in milliseconds for synchronous operation.
   2169          *                           If specified 0, wait indefinitely.
   2170          *
   2171          *               perr        Pointer to variable that will receive the return error code from this function :
   2172          *
   2173          *                               SERIAL_ERR_NONE                 Read operation completed successfully.
   2174          *                               SERIAL_ERR_NULL_PTR             NULL pointer passed for argument 'pdest'.
   2175          *                               SERIAL_ERR_NULL_FNCT            NULL pointer passed for argument 'phandler'.
   2176          *                               SERIAL_ERR_IF_IN_USE            Serial interface is in use.
   2177          *
   2178          *                                                               ---- RETURNED BY Serial_IF_IsValid() : ----
   2179          *                               SERIAL_ERR_IF_INVALID_NBR       Invalid serial interface number.
   2180          *                               SERIAL_ERR_IF_NOT_OPEN          Serial interface NOT open.
   2181          *
   2182          * Return(s)   : None.
   2183          *
   2184          * Caller(s)   : Application.
   2185          *
   2186          * Note(s)     : (1) Only ONE task/context can read from the same serial interface at a time.  If the receiver
   2187          *                   is busy when this function is called, an error will be returned.
   2188          *********************************************************************************************************
   2189          */
   2190          

   \                                 In section .text, align 2, keep-with-next
   2191          static  void  Serial_RdHandler (SERIAL_IF             *pif,
   2192                                          void                  *pdest,
   2193                                          CPU_SIZE_T             len,
   2194                                          SERIAL_CALLBACK_FNCT  *phandler,
   2195                                          void                  *parg,
   2196                                          CPU_BOOLEAN            async,
   2197                                          CPU_INT32U             timeout_ms,
   2198                                          SERIAL_ERR            *perr)
   2199          {
   \                     Serial_RdHandler: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
   \   0000000E   0xF8DD 0x8044      LDR      R8,[SP, #+68]
   2200          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2201              CPU_SIZE_T    buf_len;
   2202              CPU_SIZE_T    buf_rem;
   2203              CPU_SIZE_T    buf_copy;
   2204              SERIAL_ERR    buf_err;
   2205              CPU_BOOLEAN   use_rd_buf;
   2206          #endif
   2207              CPU_BOOLEAN   lock;
   2208              CPU_SIZE_T    rd_rem;
   2209              void         *pbuf;
   2210              CPU_SR_ALLOC();
   \   00000012   0xF05F 0x0B00      MOVS     R11,#+0
   2211          
   2212          
   2213          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   2214              if (pdest == (void *)0) {                                   /* Validate dest buf ptr.                               */
   2215                 *perr = SERIAL_ERR_NULL_PTR;
   2216                  return;
   2217              }
   2218              if (phandler == (void *)0) {                                /* Validate callback fnct ptr.                          */
   2219                 *perr = SERIAL_ERR_NULL_FNCT;
   2220                  return;
   2221              }
   2222          #endif
   2223          
   2224          
   2225          #if 0                                                           /* Chk'd at caller.                                     */
   2226              if (len == (CPU_SIZE_T)0) {                                 /* Chk for zero len.                                    */
   2227                 *perr = SERIAL_ERR_NONE;
   2228                  return;
   2229              }
   2230          #endif
   2231          
   2232          
   2233                                                                          /* ------------------ ACQUIRE RD LOCK ----------------- */
   2234              if (async == DEF_YES) {
   \   00000016   0xF89D 0x003C      LDRB     R0,[SP, #+60]
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD116             BNE.N    ??Serial_RdHandler_0
   2235                  CPU_CRITICAL_ENTER();
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   \   00000022   0x4683             MOV      R11,R0
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStart
   2236                  lock = SerialOS_SemTryLock(pif->RdSem);
   \   00000028   0x6F20             LDR      R0,[R4, #+112]
   \   0000002A   0x.... 0x....      BL       SerialOS_SemTryLock
   \   0000002E   0xF88D 0x0005      STRB     R0,[SP, #+5]
   2237                  if (lock != DEF_OK) {
   \   00000032   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD017             BEQ.N    ??Serial_RdHandler_1
   2238                      CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x4658             MOV      R0,R11
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
   2239                     *perr = SERIAL_ERR_IF_IN_USE;
   \   00000044   0x202A             MOVS     R0,#+42
   \   00000046   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   2240                      return;
   \   0000004A   0xE08F             B.N      ??Serial_RdHandler_2
   2241                  }
   2242          
   2243              } else {
   2244          
   2245                  SerialOS_SemWait(pif->RdSem, timeout_ms, perr);
   \                     ??Serial_RdHandler_0: (+1)
   \   0000004C   0x4642             MOV      R2,R8
   \   0000004E   0x9910             LDR      R1,[SP, #+64]
   \   00000050   0x6F20             LDR      R0,[R4, #+112]
   \   00000052   0x.... 0x....      BL       SerialOS_SemWait
   2246                  if (*perr != SERIAL_OS_ERR_NONE) {
   \   00000056   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000005A   0x283C             CMP      R0,#+60
   \   0000005C   0xF040 0x8086      BNE.W    ??Serial_RdHandler_2
   2247                       return;
   2248                  }
   2249          
   2250                  CPU_CRITICAL_ENTER();
   \                     ??Serial_RdHandler_3: (+1)
   \   00000060   0x.... 0x....      BL       CPU_SR_Save
   \   00000064   0x4683             MOV      R11,R0
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStart
   2251              }
   2252          
   2253          
   2254              rd_rem = len;                                               /* Save len.                                            */
   \                     ??Serial_RdHandler_1: (+1)
   \   0000006A   0x46B2             MOV      R10,R6
   2255              pbuf   = pdest;                                             /* Save dest buf ptr.                                   */
   \   0000006C   0x9502             STR      R5,[SP, #+8]
   2256          
   2257          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* -------------------- CHK RD BUF -------------------- */
   2258              use_rd_buf = DEF_NO;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2259              buf_copy   = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x4681             MOV      R9,R0
   2260              buf_err    = SERIAL_ERR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2261          
   2262              if (pif->RdBufEn == DEF_YES) {
   \   0000007E   0xF894 0x00C0      LDRB     R0,[R4, #+192]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD13E             BNE.N    ??Serial_RdHandler_4
   2263                  buf_len  = SerialBuf_DataLen(&(pif->RdBuf));
   \   00000086   0xF114 0x00C4      ADDS     R0,R4,#+196
   \   0000008A   0x.... 0x....      BL       SerialBuf_DataLen
   \   0000008E   0x9003             STR      R0,[SP, #+12]
   2264                  buf_copy = DEF_MIN(buf_len, len);
   \   00000090   0x9803             LDR      R0,[SP, #+12]
   \   00000092   0x42B0             CMP      R0,R6
   \   00000094   0xD202             BCS.N    ??Serial_RdHandler_5
   \   00000096   0xF8DD 0x900C      LDR      R9,[SP, #+12]
   \   0000009A   0xE000             B.N      ??Serial_RdHandler_6
   \                     ??Serial_RdHandler_5: (+1)
   \   0000009C   0x46B1             MOV      R9,R6
   2265                  rd_rem   = len - buf_copy;
   \                     ??Serial_RdHandler_6: (+1)
   \   0000009E   0xEBB6 0x0009      SUBS     R0,R6,R9
   \   000000A2   0x4682             MOV      R10,R0
   2266                  pdest    = (CPU_INT08U *)pdest + buf_copy;
   \   000000A4   0x444D             ADD      R5,R5,R9
   2267          
   2268                  if (buf_copy > 0) {
   \   000000A6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AA   0xD002             BEQ.N    ??Serial_RdHandler_7
   2269                      use_rd_buf = DEF_YES;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2270                  }
   2271          
   2272                  if (rd_rem > 0) {
   \                     ??Serial_RdHandler_7: (+1)
   \   000000B2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000B6   0xD025             BEQ.N    ??Serial_RdHandler_4
   2273                      if (pif->RdBufErr == SERIAL_ERR_OVERFLOW) {         /* Flush rd buf if overflow.                            */
   \   000000B8   0xF8B4 0x00C2      LDRH     R0,[R4, #+194]
   \   000000BC   0x2805             CMP      R0,#+5
   \   000000BE   0xD10D             BNE.N    ??Serial_RdHandler_8
   2274                          use_rd_buf    = DEF_NO;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF88D 0x0004      STRB     R0,[SP, #+4]
   2275                          pif->RdBufErr = SERIAL_ERR_NONE;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF8A4 0x00C2      STRH     R0,[R4, #+194]
   2276                          SerialBuf_Clr(&(pif->RdBuf));
   \   000000CC   0xF114 0x00C4      ADDS     R0,R4,#+196
   \   000000D0   0x.... 0x....      BL       SerialBuf_Clr
   2277          
   2278                          rd_rem = len;
   \   000000D4   0x46B2             MOV      R10,R6
   2279                          pdest  = pbuf;
   \   000000D6   0x9802             LDR      R0,[SP, #+8]
   \   000000D8   0x0005             MOVS     R5,R0
   \   000000DA   0xE013             B.N      ??Serial_RdHandler_4
   2280          
   2281          
   2282                      } else if (pif->RdBufErr != SERIAL_ERR_NONE) {      /* Inform callback on any other err if rd buf is empty. */
   \                     ??Serial_RdHandler_8: (+1)
   \   000000DC   0xF8B4 0x00C2      LDRH     R0,[R4, #+194]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD00F             BEQ.N    ??Serial_RdHandler_4
   2283          
   2284                          buf_rem = buf_len - buf_copy;
   \   000000E4   0x9803             LDR      R0,[SP, #+12]
   \   000000E6   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   000000EA   0x9004             STR      R0,[SP, #+16]
   2285                          if (buf_rem == 0) {
   \   000000EC   0x9804             LDR      R0,[SP, #+16]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD108             BNE.N    ??Serial_RdHandler_4
   2286                              buf_err = pif->RdBufErr;
   \   000000F2   0xF8B4 0x00C2      LDRH     R0,[R4, #+194]
   \   000000F6   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   2287                              pif->RdBufErr = SERIAL_ERR_NONE;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF8A4 0x00C2      STRH     R0,[R4, #+194]
   2288                              rd_rem = 0;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x4682             MOV      R10,R0
   2289                          }
   2290                      }
   2291                  }
   2292              }
   2293          #endif
   2294          
   2295          
   2296              if (rd_rem > 0) {
   \                     ??Serial_RdHandler_4: (+1)
   \   00000104   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000108   0xD010             BEQ.N    ??Serial_RdHandler_9
   2297                                                                          /* --------------------- START RD --------------------- */
   2298                  pif->RdCallback    = phandler;                          /* Callback called upon completion.                     */
   \   0000010A   0x6767             STR      R7,[R4, #+116]
   2299                  pif->RdCallbackArg = parg;                              /* Arg     passed to callback.                          */
   \   0000010C   0x980E             LDR      R0,[SP, #+56]
   \   0000010E   0x67A0             STR      R0,[R4, #+120]
   2300                  pif->RdCallbackBuf = pbuf;                              /* Buf     passed to callback.                          */
   \   00000110   0x9802             LDR      R0,[SP, #+8]
   \   00000112   0x67E0             STR      R0,[R4, #+124]
   2301          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2302                  pif->RdCallbackLen = len - rd_rem;                      /* Buf len passed to callback.                          */
   \   00000114   0xEBB6 0x000A      SUBS     R0,R6,R10
   \   00000118   0xF8C4 0x0080      STR      R0,[R4, #+128]
   2303          #endif
   2304                  pif->RdState       = SERIAL_RD_STATE_RD;
   \   0000011C   0x2002             MOVS     R0,#+2
   \   0000011E   0xF884 0x006C      STRB     R0,[R4, #+108]
   2305          
   2306                  Serial_RdStart(pif, pdest, rd_rem);                     /* Start rd.                                            */
   \   00000122   0x4652             MOV      R2,R10
   \   00000124   0x0029             MOVS     R1,R5
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       Serial_RdStart
   2307              }
   2308          
   2309              CPU_CRITICAL_EXIT();
   \                     ??Serial_RdHandler_9: (+1)
   \   0000012C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000130   0x4658             MOV      R0,R11
   \   00000132   0x.... 0x....      BL       CPU_SR_Restore
   2310          
   2311             *perr = SERIAL_ERR_NONE;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   2312          
   2313          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)                       /* -------------------- RD FROM BUF ------------------- */
   2314              if (use_rd_buf == DEF_YES) {
   \   0000013C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD113             BNE.N    ??Serial_RdHandler_10
   2315                  SerialBuf_Rd(&(pif->RdBuf), pbuf, buf_copy);
   \   00000144   0x464A             MOV      R2,R9
   \   00000146   0x9902             LDR      R1,[SP, #+8]
   \   00000148   0xF114 0x00C4      ADDS     R0,R4,#+196
   \   0000014C   0x.... 0x....      BL       SerialBuf_Rd
   2316          
   2317                  if (rd_rem == 0) {
   \   00000150   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000154   0xD10A             BNE.N    ??Serial_RdHandler_10
   2318                      SerialOS_SemSignal(pif->RdSem);
   \   00000156   0x6F20             LDR      R0,[R4, #+112]
   \   00000158   0x.... 0x....      BL       SerialOS_SemSignal
   2319          
   2320                    (*phandler)(pif->Nbr,                                 /* Call callback fnct.                                  */
   2321                                parg,
   2322                                pbuf,
   2323                                buf_copy,
   2324                                buf_err);
   \   0000015C   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   00000160   0x9000             STR      R0,[SP, #+0]
   \   00000162   0x464B             MOV      R3,R9
   \   00000164   0x9A02             LDR      R2,[SP, #+8]
   \   00000166   0x990E             LDR      R1,[SP, #+56]
   \   00000168   0x7860             LDRB     R0,[R4, #+1]
   \   0000016A   0x47B8             BLX      R7
   2325                  }
   2326              }
   2327          #endif
   2328          }
   \                     ??Serial_RdHandler_10: (+1)
   \                     ??Serial_RdHandler_2: (+1)
   \   0000016C   0xB005             ADD      SP,SP,#+20
   \   0000016E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2329          
   2330          
   2331          /*$PAGE*/
   2332          /*
   2333          *********************************************************************************************************
   2334          *                                          Serial_RdStart()
   2335          *
   2336          * Description : Start read.
   2337          *
   2338          * Argument(s) : pif         Pointer to interface.
   2339          *
   2340          *               pdest       Pointer to destination buffer.
   2341          *
   2342          *               len         Number of octets to read.
   2343          *
   2344          * Return(s)   : None.
   2345          *
   2346          * Caller(s)   : Serial_Rd().
   2347          *
   2348          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2349          *********************************************************************************************************
   2350          */
   2351          

   \                                 In section .text, align 2, keep-with-next
   2352          static  void  Serial_RdStart (SERIAL_IF   *pif,
   2353                                        void        *pdest,
   2354                                        CPU_SIZE_T   len)
   2355          {
   \                     Serial_RdStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2356              SerialBuf_Init((SERIAL_BUF  *)&(pif->RdUserBuf),            /* Init buf.                                            */
   2357                             (CPU_INT08U  *)  pdest,
   2358                             (CPU_SIZE_T   )  len,
   2359                             (CPU_BOOLEAN  )  DEF_NO);
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xF114 0x0084      ADDS     R0,R4,#+132
   \   00000012   0x.... 0x....      BL       SerialBuf_Init
   2360          
   2361              Serial_IF_RxStart(pif);
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       Serial_IF_RxStart
   2362          }
   \   0000001C   0xBD70             POP      {R4-R6,PC}       ;; return
   2363          
   2364          
   2365          /*$PAGE*/
   2366          /*
   2367          *********************************************************************************************************
   2368          *                                           Serial_RdEnd()
   2369          *
   2370          * Description : Wait for read to complete.
   2371          *
   2372          * Argument(s) : pif         Pointer to interface.
   2373          *
   2374          *               pinfo       Pointer to callback information structure.
   2375          *
   2376          *               perr        Pointer to variable that will receive the return error code from this function :
   2377          *
   2378          *                               SERIAL_ERR_NONE                 Device successfully read.
   2379          *                               SERIAL_ERR_FAIL                 Device read failed.
   2380          *                               SERIAL_ERR_TIMEOUT              Device read timed out.
   2381          *
   2382          * Return(s)   : Number of octets read.
   2383          *
   2384          * Caller(s)   : Serial_Rd().
   2385          *
   2386          * Note(s)     : None.
   2387          *********************************************************************************************************
   2388          */
   2389          

   \                                 In section .text, align 2, keep-with-next
   2390          static  CPU_SIZE_T  Serial_RdEnd (SERIAL_IF             *pif,
   2391                                            SERIAL_CALLBACK_INFO  *pinfo,
   2392                                            SERIAL_ERR            *perr)
   2393          {
   \                     Serial_RdEnd: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2394              CPU_SIZE_T  len;
   2395              CPU_SR_ALLOC();
   \   0000000A   0x2700             MOVS     R7,#+0
   2396          
   2397          
   2398              SerialOS_SemWait(pinfo->SignalPtr, pinfo->Timeout, perr);
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x6869             LDR      R1,[R5, #+4]
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x.... 0x....      BL       SerialOS_SemWait
   2399              switch (*perr) {
   \   00000016   0x8830             LDRH     R0,[R6, #+0]
   \   00000018   0x283C             CMP      R0,#+60
   \   0000001A   0xD002             BEQ.N    ??Serial_RdEnd_0
   \   0000001C   0x283E             CMP      R0,#+62
   \   0000001E   0xD005             BEQ.N    ??Serial_RdEnd_1
   \   00000020   0xE020             B.N      ??Serial_RdEnd_2
   2400                  case SERIAL_OS_ERR_NONE:
   2401          #if 0
   2402                       SerialOS_SemSignal(pif->RdSem);                    /* Signal'd before callback.                            */
   2403          #endif
   2404                      *perr = pinfo->Err;
   \                     ??Serial_RdEnd_0: (+1)
   \   00000022   0x89A8             LDRH     R0,[R5, #+12]
   \   00000024   0x8030             STRH     R0,[R6, #+0]
   2405                       len  = pinfo->Len;
   \   00000026   0x68A8             LDR      R0,[R5, #+8]
   \   00000028   0x4680             MOV      R8,R0
   2406                       break;
   \   0000002A   0xE036             B.N      ??Serial_RdEnd_3
   2407          
   2408          
   2409                  case SERIAL_OS_ERR_TIMEOUT:
   2410                       CPU_CRITICAL_ENTER();
   \                     ??Serial_RdEnd_1: (+1)
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   \   00000030   0x0007             MOVS     R7,R0
   \   00000032   0x.... 0x....      BL       CPU_IntDisMeasStart
   2411                       len  = SerialBuf_DataLen(&(pif->RdUserBuf));
   \   00000036   0xF114 0x0084      ADDS     R0,R4,#+132
   \   0000003A   0x.... 0x....      BL       SerialBuf_DataLen
   \   0000003E   0x4680             MOV      R8,R0
   2412          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2413                       len += pif->RdCallbackLen;
   \   00000040   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000044   0xEB10 0x0808      ADDS     R8,R0,R8
   2414          #endif
   2415                       Serial_IF_RxReset(pif);
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       Serial_IF_RxReset
   2416                       CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
   2417          
   2418                       SerialOS_SemSignal(pif->RdSem);
   \   00000058   0x6F20             LDR      R0,[R4, #+112]
   \   0000005A   0x.... 0x....      BL       SerialOS_SemSignal
   2419                      *perr = SERIAL_ERR_TIMEOUT;
   \   0000005E   0x200B             MOVS     R0,#+11
   \   00000060   0x8030             STRH     R0,[R6, #+0]
   2420                       break;
   \   00000062   0xE01A             B.N      ??Serial_RdEnd_3
   2421          
   2422          
   2423                  case SERIAL_OS_ERR_SIGNAL:
   2424                  default:
   2425                       CPU_CRITICAL_ENTER();
   \                     ??Serial_RdEnd_2: (+1)
   \   00000064   0x.... 0x....      BL       CPU_SR_Save
   \   00000068   0x0007             MOVS     R7,R0
   \   0000006A   0x.... 0x....      BL       CPU_IntDisMeasStart
   2426                       len  = SerialBuf_DataLen(&(pif->RdUserBuf));
   \   0000006E   0xF114 0x0084      ADDS     R0,R4,#+132
   \   00000072   0x.... 0x....      BL       SerialBuf_DataLen
   \   00000076   0x4680             MOV      R8,R0
   2427          #if (SERIAL_CFG_RD_BUF_EN == DEF_ENABLED)
   2428                       len += pif->RdCallbackLen;
   \   00000078   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   0000007C   0xEB10 0x0808      ADDS     R8,R0,R8
   2429          #endif
   2430                       Serial_IF_RxReset(pif);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       Serial_IF_RxReset
   2431                       CPU_CRITICAL_EXIT();
   \   00000086   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008A   0x0038             MOVS     R0,R7
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
   2432          
   2433                       SerialOS_SemSignal(pif->RdSem);
   \   00000090   0x6F20             LDR      R0,[R4, #+112]
   \   00000092   0x.... 0x....      BL       SerialOS_SemSignal
   2434                      *perr = SERIAL_ERR_FAIL;
   \   00000096   0x200A             MOVS     R0,#+10
   \   00000098   0x8030             STRH     R0,[R6, #+0]
   2435                       break;
   2436              }
   2437          
   2438              return (len);
   \                     ??Serial_RdEnd_3: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2439          }
   2440          
   2441          
   2442          /*$PAGE*/
   2443          /*
   2444          *********************************************************************************************************
   2445          *                                         Serial_RdCallback()
   2446          *
   2447          * Description : Internal read complete callback.
   2448          *
   2449          * Argument(s) : if_nbr      Interface number.
   2450          *               ------      Argument validated in Serial_RdAsync().
   2451          *
   2452          *               parg        Pointer to argument.
   2453          *
   2454          *               pbuf        Pointer to buffer passed to read function.
   2455          *
   2456          *               len         Number of octets read.
   2457          *
   2458          *               err         Read error.
   2459          *
   2460          * Return(s)   : None.
   2461          *
   2462          * Caller(s)   : Serial_Rd().
   2463          *
   2464          * Note(s)     : None.
   2465          *********************************************************************************************************
   2466          */
   2467          

   \                                 In section .text, align 4, keep-with-next
   2468          static  void  Serial_RdCallback (SERIAL_IF_NBR   if_nbr,
   2469                                           void           *parg,
   2470                                           void           *pbuf,
   2471                                           CPU_SIZE_T      len,
   2472                                           SERIAL_ERR      err)
   2473          {
   \                     Serial_RdCallback: (+1)
   \   00000000   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9C08             LDR      R4,[SP, #+32]
   2474              SERIAL_CALLBACK_INFO  *rd_info;
   2475          
   2476          
   2477             (void)&if_nbr;
   \   0000000A   0xA801             ADD      R0,SP,#+4
   2478             (void)&pbuf;
   \   0000000C   0xA802             ADD      R0,SP,#+8
   2479          
   2480              rd_info      = (SERIAL_CALLBACK_INFO *)parg;
   \   0000000E   0x002F             MOVS     R7,R5
   2481              rd_info->Len =  len;
   \   00000010   0x60BE             STR      R6,[R7, #+8]
   2482              rd_info->Err =  err;
   \   00000012   0x81BC             STRH     R4,[R7, #+12]
   2483          
   2484             (void)SerialOS_SemSignal(rd_info->SignalPtr);
   \   00000014   0x6838             LDR      R0,[R7, #+0]
   \   00000016   0x.... 0x....      BL       SerialOS_SemSignal
   2485          }
   \   0000001A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2486          
   2487          
   2488          /*$PAGE*/
   2489          /*
   2490          *********************************************************************************************************
   2491          *                                        Serial_WrBufInsert()
   2492          *
   2493          * Description : Insert write buffer at the end of the transmit list.
   2494          *
   2495          * Argument(s) : pif         Pointer to interface.
   2496          *
   2497          *               pbuf        Pointer to buffer descriptor.
   2498          *
   2499          *               perr        Pointer to variable that will receive the return error code from this function :
   2500          *
   2501          *                               SERIAL_ERR_NONE             Write buffer successfully queued.
   2502          *                               SERIAL_ERR_BUF_ALLOC        Buffer structure could NOT be allocated.
   2503          *
   2504          * Return(s)   : None.
   2505          *
   2506          * Caller(s)   : Serial_WrStart().
   2507          *
   2508          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2509          *********************************************************************************************************
   2510          */

   \                                 In section .text, align 2, keep-with-next
   2511          static  void  Serial_WrBufInsert (SERIAL_IF        *pif,
   2512                                            SERIAL_BUF_DESC  *pbuf,
   2513                                            SERIAL_ERR       *perr)
   2514          {
   \                     Serial_WrBufInsert: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0014             MOVS     R4,R2
   2515          #if (SERIAL_CFG_TX_DESC_NBR > 0)
   2516              SERIAL_BUF_DESC  *pbuf_new;
   2517              SERIAL_BUF_DESC  *plist_end;
   2518              CPU_BOOLEAN       list_empty;
   2519              LIB_ERR           lib_err;
   2520          #endif
   2521          
   2522          
   2523             (void)&pif;
   \   00000006   0xA801             ADD      R0,SP,#+4
   2524             (void)&pbuf;
   \   00000008   0xA802             ADD      R0,SP,#+8
   2525          
   2526          #if (SERIAL_CFG_TX_DESC_NBR > 0)
   2527              pbuf_new = (SERIAL_BUF_DESC *)Mem_PoolBlkGet((MEM_POOL *)&pif->TxBufPool,
   2528                                                           (CPU_SIZE_T) sizeof(SERIAL_BUF_DESC),
   2529                                                           (LIB_ERR  *)&lib_err);
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x211C             MOVS     R1,#+28
   \   0000000E   0x9801             LDR      R0,[SP, #+4]
   \   00000010   0x301C             ADDS     R0,R0,#+28
   \   00000012   0x.... 0x....      BL       Mem_PoolBlkGet
   \   00000016   0x0005             MOVS     R5,R0
   2530              if (lib_err != LIB_MEM_ERR_NONE) {
   \   00000018   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000001C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD002             BEQ.N    ??Serial_WrBufInsert_0
   2531                 *perr = SERIAL_ERR_BUF_ALLOC;
   \   00000024   0x2008             MOVS     R0,#+8
   \   00000026   0x8020             STRH     R0,[R4, #+0]
   2532                  return;
   \   00000028   0xE02D             B.N      ??Serial_WrBufInsert_1
   2533              }
   2534          
   2535          
   2536              pbuf_new->Len         = pbuf->Len;
   \                     ??Serial_WrBufInsert_0: (+1)
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x6028             STR      R0,[R5, #+0]
   2537              pbuf_new->DataPtr     = pbuf->DataPtr;
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0x6840             LDR      R0,[R0, #+4]
   \   00000034   0x6068             STR      R0,[R5, #+4]
   2538              pbuf_new->Callback    = pbuf->Callback;                     /* Callback called upon completion.                     */
   \   00000036   0x9802             LDR      R0,[SP, #+8]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x60A8             STR      R0,[R5, #+8]
   2539              pbuf_new->CallbackArg = pbuf->CallbackArg;                  /* Argument passed to callback.                         */
   \   0000003C   0x9802             LDR      R0,[SP, #+8]
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0x60E8             STR      R0,[R5, #+12]
   2540              pbuf_new->CallbackBuf = pbuf->CallbackBuf;                  /* Buf      passed to callback.                         */
   \   00000042   0x9802             LDR      R0,[SP, #+8]
   \   00000044   0x6900             LDR      R0,[R0, #+16]
   \   00000046   0x6128             STR      R0,[R5, #+16]
   2541          
   2542          
   2543              list_empty = DEF_FALSE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0007             MOVS     R7,R0
   2544              if ((pif->TxBufListStart == (SERIAL_BUF_DESC *)0) &&
   2545                  (pif->TxBufListEnd   == (SERIAL_BUF_DESC *)0)) {
   \   0000004C   0x9801             LDR      R0,[SP, #+4]
   \   0000004E   0x6E40             LDR      R0,[R0, #+100]
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD105             BNE.N    ??Serial_WrBufInsert_2
   \   00000054   0x9801             LDR      R0,[SP, #+4]
   \   00000056   0x6E80             LDR      R0,[R0, #+104]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD101             BNE.N    ??Serial_WrBufInsert_2
   2546                  list_empty = DEF_TRUE;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x0007             MOVS     R7,R0
   2547              }
   2548          
   2549              plist_end     =  pif->TxBufListEnd;
   \                     ??Serial_WrBufInsert_2: (+1)
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x6E80             LDR      R0,[R0, #+104]
   \   00000064   0x0006             MOVS     R6,R0
   2550              pbuf->PrevPtr =  plist_end;
   \   00000066   0x9802             LDR      R0,[SP, #+8]
   \   00000068   0x6186             STR      R6,[R0, #+24]
   2551              pbuf->NextPtr = (SERIAL_BUF_DESC *)0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9902             LDR      R1,[SP, #+8]
   \   0000006E   0x6148             STR      R0,[R1, #+20]
   2552          
   2553              if (list_empty == DEF_TRUE) {
   \   00000070   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000072   0x2F01             CMP      R7,#+1
   \   00000074   0xD102             BNE.N    ??Serial_WrBufInsert_3
   2554                  pif->TxBufListStart = pbuf_new;
   \   00000076   0x9801             LDR      R0,[SP, #+4]
   \   00000078   0x6645             STR      R5,[R0, #+100]
   \   0000007A   0xE000             B.N      ??Serial_WrBufInsert_4
   2555              } else {
   2556                  plist_end->NextPtr  = pbuf_new;
   \                     ??Serial_WrBufInsert_3: (+1)
   \   0000007C   0x6175             STR      R5,[R6, #+20]
   2557              }
   2558              pif->TxBufListEnd = pbuf_new;
   \                     ??Serial_WrBufInsert_4: (+1)
   \   0000007E   0x9801             LDR      R0,[SP, #+4]
   \   00000080   0x6685             STR      R5,[R0, #+104]
   2559          
   2560          
   2561             *perr = SERIAL_ERR_NONE;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8020             STRH     R0,[R4, #+0]
   2562          #else
   2563             *perr = SERIAL_ERR_BUF_ALLOC;
   2564          #endif
   2565          }
   \                     ??Serial_WrBufInsert_1: (+1)
   \   00000086   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   2566          
   2567          
   2568          /*$PAGE*/
   2569          /*
   2570          *********************************************************************************************************
   2571          *                                        Serial_WrBufRemove()
   2572          *
   2573          * Description : Remove write buffer from start of the transmit list.
   2574          *
   2575          * Argument(s) : pif         Pointer to interface.
   2576          *
   2577          *               pbuf        Pointer to buffer descriptor.
   2578          *
   2579          * Return(s)   : Pointer to write buffer removed, if successful.
   2580          *
   2581          *               Pointer to NULL,                 otherwise.
   2582          *
   2583          * Caller(s)   : Serial_WrStartNext().
   2584          *
   2585          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2586          *********************************************************************************************************
   2587          */
   2588          

   \                                 In section .text, align 2, keep-with-next
   2589          static  CPU_BOOLEAN  Serial_WrBufRemove (SERIAL_IF        *pif,
   2590                                                   SERIAL_BUF_DESC  *pbuf)
   2591          {
   \                     Serial_WrBufRemove: (+1)
   \   00000000   0xB533             PUSH     {R0,R1,R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2592              CPU_BOOLEAN       valid;
   2593          #if (SERIAL_CFG_TX_DESC_NBR > 0)
   2594              SERIAL_BUF_DESC  *pbuf_next;
   2595              LIB_ERR           lib_err;
   2596          #endif
   2597          
   2598          
   2599          #if (SERIAL_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                  /* ------------------- VALIDATE ARGS ------------------ */
   2600              if (pbuf == (SERIAL_BUF_DESC *)0) {
   2601                  return (DEF_NO);
   2602              }
   2603          #endif
   2604          
   2605             (void)&pif;
   \   00000004   0xA801             ADD      R0,SP,#+4
   2606             (void)&pbuf;
   \   00000006   0xA802             ADD      R0,SP,#+8
   2607              valid = DEF_NO;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0005             MOVS     R5,R0
   2608          
   2609          #if (SERIAL_CFG_TX_DESC_NBR > 0)
   2610              pbuf_next = pif->TxBufListStart;
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x6E40             LDR      R0,[R0, #+100]
   \   00000010   0x0004             MOVS     R4,R0
   2611          
   2612              if (pbuf_next == (SERIAL_BUF_DESC *)0) {
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD102             BNE.N    ??Serial_WrBufRemove_0
   2613                  return (valid);
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xE030             B.N      ??Serial_WrBufRemove_1
   2614              }
   2615          
   2616              if (pif->TxBufListStart == pif->TxBufListEnd) {
   \                     ??Serial_WrBufRemove_0: (+1)
   \   0000001C   0x9801             LDR      R0,[SP, #+4]
   \   0000001E   0x6E40             LDR      R0,[R0, #+100]
   \   00000020   0x9901             LDR      R1,[SP, #+4]
   \   00000022   0x6E89             LDR      R1,[R1, #+104]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD106             BNE.N    ??Serial_WrBufRemove_2
   2617                  pif->TxBufListStart = (SERIAL_BUF_DESC *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x9901             LDR      R1,[SP, #+4]
   \   0000002C   0x6648             STR      R0,[R1, #+100]
   2618                  pif->TxBufListEnd   = (SERIAL_BUF_DESC *)0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x9901             LDR      R1,[SP, #+4]
   \   00000032   0x6688             STR      R0,[R1, #+104]
   \   00000034   0xE002             B.N      ??Serial_WrBufRemove_3
   2619              } else {
   2620                  pif->TxBufListStart = pbuf_next->NextPtr;
   \                     ??Serial_WrBufRemove_2: (+1)
   \   00000036   0x6960             LDR      R0,[R4, #+20]
   \   00000038   0x9901             LDR      R1,[SP, #+4]
   \   0000003A   0x6648             STR      R0,[R1, #+100]
   2621              }
   2622          
   2623              pbuf->Len         = pbuf_next->Len;
   \                     ??Serial_WrBufRemove_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x9902             LDR      R1,[SP, #+8]
   \   00000040   0x6008             STR      R0,[R1, #+0]
   2624              pbuf->DataPtr     = pbuf_next->DataPtr;
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x9902             LDR      R1,[SP, #+8]
   \   00000046   0x6048             STR      R0,[R1, #+4]
   2625              pbuf->Callback    = pbuf_next->Callback;
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x9902             LDR      R1,[SP, #+8]
   \   0000004C   0x6088             STR      R0,[R1, #+8]
   2626              pbuf->CallbackArg = pbuf_next->CallbackArg;
   \   0000004E   0x68E0             LDR      R0,[R4, #+12]
   \   00000050   0x9902             LDR      R1,[SP, #+8]
   \   00000052   0x60C8             STR      R0,[R1, #+12]
   2627              pbuf->CallbackBuf = pbuf_next->CallbackBuf;
   \   00000054   0x6920             LDR      R0,[R4, #+16]
   \   00000056   0x9902             LDR      R1,[SP, #+8]
   \   00000058   0x6108             STR      R0,[R1, #+16]
   2628          
   2629              Mem_PoolBlkFree(&pif->TxBufPool, pbuf_next, &lib_err);
   \   0000005A   0x466A             MOV      R2,SP
   \   0000005C   0x0021             MOVS     R1,R4
   \   0000005E   0x9801             LDR      R0,[SP, #+4]
   \   00000060   0x301C             ADDS     R0,R0,#+28
   \   00000062   0x.... 0x....      BL       Mem_PoolBlkFree
   2630              if (lib_err != LIB_MEM_ERR_NONE)  {
   \   00000066   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   0000006A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD001             BEQ.N    ??Serial_WrBufRemove_4
   2631                  return (DEF_NO);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE003             B.N      ??Serial_WrBufRemove_1
   2632              }
   2633          
   2634              valid = DEF_YES;
   \                     ??Serial_WrBufRemove_4: (+1)
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x0005             MOVS     R5,R0
   2635          #endif
   2636          
   2637              return (valid);
   \   0000007A   0x0028             MOVS     R0,R5
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Serial_WrBufRemove_1: (+1)
   \   0000007E   0xBD3E             POP      {R1-R5,PC}       ;; return
   2638          }
   2639          
   2640          
   2641          /*$PAGE*/
   2642          /*
   2643          *********************************************************************************************************
   2644          *                                        Serial_WrBufTxStart()
   2645          *
   2646          * Description : Initialize write buffer and transmit first octet.
   2647          *
   2648          * Argument(s) : pif         Pointer to interface.
   2649          *
   2650          *               pbuf        Pointer to buffer descriptor.
   2651          *
   2652          *               perr        Pointer to variable that will receive the return error code from this function :
   2653          *
   2654          *                               SERIAL_ERR_NONE             Write buffer successfully initialized.
   2655          *
   2656          * Return(s)   : None.
   2657          *
   2658          * Caller(s)   : Serial_WrStart(),
   2659          *               Serial_WrNext().
   2660          *
   2661          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2662          *********************************************************************************************************
   2663          */
   2664          

   \                                 In section .text, align 2, keep-with-next
   2665          static  void  Serial_WrBufTxStart (SERIAL_IF        *pif,
   2666                                             SERIAL_BUF_DESC  *pbuf,
   2667                                             SERIAL_ERR       *perr)
   2668          {
   \                     Serial_WrBufTxStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2669              SERIAL_DEV  *pdev;
   2670              CPU_INT08U   datum;
   2671          
   2672          
   2673              SerialBuf_Init((SERIAL_BUF  *)&(pif->WrUserBuf),            /* Init buf.                                            */
   2674                             (CPU_INT08U  *)  pbuf->DataPtr,
   2675                             (CPU_SIZE_T   )  pbuf->Len,
   2676                             (CPU_BOOLEAN  )  DEF_YES);
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x682A             LDR      R2,[R5, #+0]
   \   0000000C   0x6869             LDR      R1,[R5, #+4]
   \   0000000E   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   00000012   0x.... 0x....      BL       SerialBuf_Init
   2677          
   2678              pif->WrCallback    = pbuf->Callback;
   \   00000016   0x68A8             LDR      R0,[R5, #+8]
   \   00000018   0xF8C4 0x00A0      STR      R0,[R4, #+160]
   2679              pif->WrCallbackArg = pbuf->CallbackArg;
   \   0000001C   0x68E8             LDR      R0,[R5, #+12]
   \   0000001E   0xF8C4 0x00A4      STR      R0,[R4, #+164]
   2680              pif->WrCallbackBuf = pbuf->CallbackBuf;
   \   00000022   0x6928             LDR      R0,[R5, #+16]
   \   00000024   0xF8C4 0x00A8      STR      R0,[R4, #+168]
   2681          
   2682              pdev = &pif->Dev;
   \   00000028   0xF114 0x0008      ADDS     R0,R4,#+8
   \   0000002C   0x0007             MOVS     R7,R0
   2683              pdev->LineDrv_API->RdOctet(pdev,                            /* Get octet.                                           */
   2684                                       &(pif->WrUserBuf),
   2685                                        &datum,
   2686                                         perr);
   \   0000002E   0x0033             MOVS     R3,R6
   \   00000030   0x466A             MOV      R2,SP
   \   00000032   0xF114 0x01AC      ADDS     R1,R4,#+172
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0xF8D7 0xC00C      LDR      R12,[R7, #+12]
   \   0000003C   0xF8DC 0xC008      LDR      R12,[R12, #+8]
   \   00000040   0x47E0             BLX      R12
   2687              if (*perr != SERIAL_ERR_NONE) {
   \   00000042   0x8830             LDRH     R0,[R6, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD107             BNE.N    ??Serial_WrBufTxStart_0
   2688                   return;
   2689              }
   2690          
   2691              pdev->Dev_Cfg->Drv_API->TxOctet(pdev, datum, perr);         /* Tx first octet.                                      */
   \                     ??Serial_WrBufTxStart_1: (+1)
   \   00000048   0x0032             MOVS     R2,R6
   \   0000004A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000004E   0x0038             MOVS     R0,R7
   \   00000050   0x687B             LDR      R3,[R7, #+4]
   \   00000052   0x685B             LDR      R3,[R3, #+4]
   \   00000054   0x6A1B             LDR      R3,[R3, #+32]
   \   00000056   0x4798             BLX      R3
   2692          }
   \                     ??Serial_WrBufTxStart_0: (+1)
   \   00000058   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2693          
   2694          
   2695          /*$PAGE*/
   2696          /*
   2697          *********************************************************************************************************
   2698          *                                          Serial_WrStart()
   2699          *
   2700          * Description : Start write operation.
   2701          *
   2702          * Argument(s) : pif         Pointer to interface.
   2703          *
   2704          *               pbuf        Pointer to buffer descriptor.
   2705          *
   2706          *               perr        Pointer to variable that will receive the return error code from this function :
   2707          *
   2708          *                               SERIAL_ERR_NONE             Device successfully written.
   2709          *                               SERIAL_ERR_IF_NOT_OPEN      Serial interface NOT open.
   2710          *
   2711          * Return(s)   : None.
   2712          *
   2713          * Caller(s)   : Serial_WrAsync().
   2714          *
   2715          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2716          *********************************************************************************************************
   2717          */
   2718          

   \                                 In section .text, align 2, keep-with-next
   2719          static  void  Serial_WrStart (SERIAL_IF        *pif,
   2720                                        SERIAL_BUF_DESC  *pbuf,
   2721                                        SERIAL_ERR       *perr)
   2722          {
   \                     Serial_WrStart: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2723              SERIAL_DEV  *pdev;
   2724              SERIAL_ERR   err;
   2725          
   2726          
   2727              switch (pif->WrState) {
   \   00000008   0xF894 0x0098      LDRB     R0,[R4, #+152]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD020             BEQ.N    ??Serial_WrStart_0
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD018             BEQ.N    ??Serial_WrStart_1
   \   00000014   0xD302             BCC.N    ??Serial_WrStart_2
   \   00000016   0x2803             CMP      R0,#+3
   \   00000018   0xD015             BEQ.N    ??Serial_WrStart_1
   \   0000001A   0xE01C             B.N      ??Serial_WrStart_3
   2728                  case SERIAL_WR_STATE_OPENED:
   2729                       pif->WrState = SERIAL_WR_STATE_WR;
   \                     ??Serial_WrStart_2: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF884 0x0098      STRB     R0,[R4, #+152]
   2730                       Serial_WrBufTxStart(pif, pbuf, perr);              /* Init buf to start tx'er.                             */
   \   00000022   0x0032             MOVS     R2,R6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       Serial_WrBufTxStart
   2731                       if (*perr != SERIAL_ERR_NONE) {
   \   0000002C   0x8830             LDRH     R0,[R6, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD111             BNE.N    ??Serial_WrStart_4
   2732                           return;
   2733                       }
   2734          
   2735                       pdev = &pif->Dev;
   \                     ??Serial_WrStart_5: (+1)
   \   00000032   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000036   0x0007             MOVS     R7,R0
   2736                       pdev->Dev_Cfg->Drv_API->TxStart(pdev, &err);       /* Start tx'er.                                         */
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x687A             LDR      R2,[R7, #+4]
   \   0000003E   0x6852             LDR      R2,[R2, #+4]
   \   00000040   0x6992             LDR      R2,[R2, #+24]
   \   00000042   0x4790             BLX      R2
   2737                       break;
   \   00000044   0xE007             B.N      ??Serial_WrStart_3
   2738          
   2739          
   2740          
   2741                  case SERIAL_WR_STATE_WR:
   2742                  case SERIAL_WR_STATE_WR_BUF:
   2743                       Serial_WrBufInsert(pif, pbuf, perr);               /* Insert buf at the end of tx list.                    */
   \                     ??Serial_WrStart_1: (+1)
   \   00000046   0x0032             MOVS     R2,R6
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       Serial_WrBufInsert
   2744                       break;
   \   00000050   0xE001             B.N      ??Serial_WrStart_3
   2745          
   2746          
   2747                  case SERIAL_WR_STATE_CLOSED:
   2748                      *perr = SERIAL_ERR_IF_NOT_OPEN;
   \                     ??Serial_WrStart_0: (+1)
   \   00000052   0x2029             MOVS     R0,#+41
   \   00000054   0x8030             STRH     R0,[R6, #+0]
   2749                       break;
   2750              }
   2751          }
   \                     ??Serial_WrStart_3: (+1)
   \                     ??Serial_WrStart_4: (+1)
   \   00000056   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2752          
   2753          
   2754          /*$PAGE*/
   2755          /*
   2756          *********************************************************************************************************
   2757          *                                           Serial_WrNext()
   2758          *
   2759          * Description : Retrieve write buffer from transmit list and start write.
   2760          *
   2761          * Argument(s) : pif         Pointer to interface.
   2762          *
   2763          * Return(s)   : None.
   2764          *
   2765          * Caller(s)   : Serial_IF_Tx().
   2766          *
   2767          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   2768          *
   2769          *               (2) If write buffer is enabled, first check if there is data waiting to be transfer from
   2770          *                   the write buffer.
   2771          *********************************************************************************************************
   2772          */
   2773          

   \                                 In section .text, align 2, keep-with-next
   2774          static  void  Serial_WrNext (SERIAL_IF  *pif)
   2775          {
   \                     Serial_WrNext: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x0004             MOVS     R4,R0
   2776              SERIAL_BUF_DESC   buf;
   2777              SERIAL_DEV       *pdev;
   2778              SERIAL_ERR        err;
   2779              CPU_BOOLEAN       valid;
   2780          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)
   2781              SERIAL_BUF       *pbuf;
   2782              CPU_INT08U        datum;
   2783              CPU_BOOLEAN       read;
   2784          #endif
   2785          
   2786          
   2787          #if (SERIAL_CFG_WR_BUF_EN == DEF_ENABLED)
   2788              if (pif->WrBufEn == DEF_YES) {
   \   00000008   0xF894 0x00D8      LDRB     R0,[R4, #+216]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD11C             BNE.N    ??Serial_WrNext_0
   2789                  pbuf = &(pif->WrBuf);
   \   00000010   0xF114 0x00DC      ADDS     R0,R4,#+220
   \   00000014   0x0007             MOVS     R7,R0
   2790                  read = SerialBuf_RdOctet(pbuf, &datum);
   \   00000016   0xF10D 0x0102      ADD      R1,SP,#+2
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0x.... 0x....      BL       SerialBuf_RdOctet
   \   00000020   0x4680             MOV      R8,R0
   2791                  if (read == DEF_YES) {
   \   00000022   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000026   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000002A   0xD10E             BNE.N    ??Serial_WrNext_0
   2792                      pif->WrState = SERIAL_WR_STATE_WR_BUF;
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xF884 0x0098      STRB     R0,[R4, #+152]
   2793                      pdev         = &pif->Dev;
   \   00000032   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000036   0x0005             MOVS     R5,R0
   2794                      pdev->Dev_Cfg->Drv_API->TxOctet(pdev, datum, &err); /* Tx first octet.                                      */
   \   00000038   0x466A             MOV      R2,SP
   \   0000003A   0xF89D 0x1002      LDRB     R1,[SP, #+2]
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x686B             LDR      R3,[R5, #+4]
   \   00000042   0x685B             LDR      R3,[R3, #+4]
   \   00000044   0x6A1B             LDR      R3,[R3, #+32]
   \   00000046   0x4798             BLX      R3
   2795                      return;
   \   00000048   0xE01C             B.N      ??Serial_WrNext_1
   2796                  }
   2797              }
   2798          #endif
   2799          
   2800              valid = Serial_WrBufRemove(pif, &buf);
   \                     ??Serial_WrNext_0: (+1)
   \   0000004A   0xA901             ADD      R1,SP,#+4
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       Serial_WrBufRemove
   \   00000052   0x0006             MOVS     R6,R0
   2801              if (valid != DEF_YES) {                                     /* If no wr buf avail, stop tx'er.                      */
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x2E01             CMP      R6,#+1
   \   00000058   0xD00C             BEQ.N    ??Serial_WrNext_2
   2802                  pif->WrState = SERIAL_WR_STATE_OPENED;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xF884 0x0098      STRB     R0,[R4, #+152]
   2803                  pdev         = &pif->Dev;
   \   00000060   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000064   0x0005             MOVS     R5,R0
   2804                  pdev->Dev_Cfg->Drv_API->TxStop(pdev, &err);
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x686A             LDR      R2,[R5, #+4]
   \   0000006C   0x6852             LDR      R2,[R2, #+4]
   \   0000006E   0x69D2             LDR      R2,[R2, #+28]
   \   00000070   0x4790             BLX      R2
   \   00000072   0xE007             B.N      ??Serial_WrNext_3
   2805              } else {                                                    /* Start next wr.                                       */
   2806                  pif->WrState = SERIAL_WR_STATE_WR;
   \                     ??Serial_WrNext_2: (+1)
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0xF884 0x0098      STRB     R0,[R4, #+152]
   2807                  Serial_WrBufTxStart(pif, &buf, &err);
   \   0000007A   0x466A             MOV      R2,SP
   \   0000007C   0xA901             ADD      R1,SP,#+4
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       Serial_WrBufTxStart
   2808              }
   2809          }
   \                     ??Serial_WrNext_3: (+1)
   \                     ??Serial_WrNext_1: (+1)
   \   00000084   0xB008             ADD      SP,SP,#+32
   \   00000086   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2810          
   2811          
   2812          /*$PAGE*/
   2813          /*
   2814          *********************************************************************************************************
   2815          *                                           Serial_WrEnd()
   2816          *
   2817          * Description : Wait for write to complete.
   2818          *
   2819          * Argument(s) : pif         Pointer to interface.
   2820          *
   2821          *               pinfo       Pointer to callback information structure.
   2822          *
   2823          *               perr        Pointer to variable that will receive the return error code from this function :
   2824          *
   2825          *                               SERIAL_ERR_NONE                 Device successfully written.
   2826          *                               SERIAL_ERR_FAIL                 Device write failed.
   2827          *                               SERIAL_ERR_TIMEOUT              Device write timed out.
   2828          *
   2829          * Return(s)   : Number of octets written.
   2830          *
   2831          * Caller(s)   : Serial_Wr().
   2832          *
   2833          * Note(s)     : None.
   2834          *********************************************************************************************************
   2835          */
   2836          

   \                                 In section .text, align 2, keep-with-next
   2837          static  CPU_SIZE_T  Serial_WrEnd (SERIAL_IF             *pif,
   2838                                            SERIAL_CALLBACK_INFO  *pinfo,
   2839                                            SERIAL_ERR            *perr)
   2840          {
   \                     Serial_WrEnd: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   2841              CPU_SIZE_T  len;
   2842              CPU_SIZE_T  buf_size;
   2843              CPU_SIZE_T  data_len;
   2844              CPU_SR_ALLOC();
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
   2845          
   2846          
   2847              SerialOS_SemWait(pinfo->SignalPtr, pinfo->Timeout, perr);
   \   0000000E   0x0032             MOVS     R2,R6
   \   00000010   0x6869             LDR      R1,[R5, #+4]
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       SerialOS_SemWait
   2848              switch (*perr) {
   \   00000018   0x8830             LDRH     R0,[R6, #+0]
   \   0000001A   0x283C             CMP      R0,#+60
   \   0000001C   0xD002             BEQ.N    ??Serial_WrEnd_0
   \   0000001E   0x283E             CMP      R0,#+62
   \   00000020   0xD005             BEQ.N    ??Serial_WrEnd_1
   \   00000022   0xE028             B.N      ??Serial_WrEnd_2
   2849                  case SERIAL_OS_ERR_NONE:
   2850          #if 0
   2851                       SerialOS_SemSignal(pif->WrSem);                    /* Signal'd before callback.                            */
   2852          #endif
   2853                      *perr = pinfo->Err;
   \                     ??Serial_WrEnd_0: (+1)
   \   00000024   0x89A8             LDRH     R0,[R5, #+12]
   \   00000026   0x8030             STRH     R0,[R6, #+0]
   2854                       len  = pinfo->Len;
   \   00000028   0x68A8             LDR      R0,[R5, #+8]
   \   0000002A   0x0007             MOVS     R7,R0
   2855                       break;
   \   0000002C   0xE046             B.N      ??Serial_WrEnd_3
   2856          
   2857          
   2858                  case SERIAL_OS_ERR_TIMEOUT:
   2859                       CPU_CRITICAL_ENTER();
   \                     ??Serial_WrEnd_1: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_SR_Save
   \   00000032   0x4682             MOV      R10,R0
   \   00000034   0x.... 0x....      BL       CPU_IntDisMeasStart
   2860                       buf_size = SerialBuf_Size(&(pif->WrUserBuf));
   \   00000038   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   0000003C   0x.... 0x....      BL       SerialBuf_Size
   \   00000040   0x4680             MOV      R8,R0
   2861                       data_len = SerialBuf_DataLen(&(pif->WrUserBuf));
   \   00000042   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   00000046   0x.... 0x....      BL       SerialBuf_DataLen
   \   0000004A   0x4681             MOV      R9,R0
   2862                       len      = buf_size - data_len;
   \   0000004C   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   00000050   0x0007             MOVS     R7,R0
   2863          
   2864                       Serial_IF_WrClr(pif);                              /* Clr wr info.                                         */
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       Serial_IF_WrClr
   2865                       Serial_WrNext(pif);
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       Serial_WrNext
   2866                       CPU_CRITICAL_EXIT();
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x4650             MOV      R0,R10
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
   2867          
   2868                       SerialOS_SemSignal(pif->WrSem);
   \   00000068   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \   0000006C   0x.... 0x....      BL       SerialOS_SemSignal
   2869                      *perr = SERIAL_ERR_TIMEOUT;
   \   00000070   0x200B             MOVS     R0,#+11
   \   00000072   0x8030             STRH     R0,[R6, #+0]
   2870                       break;
   \   00000074   0xE022             B.N      ??Serial_WrEnd_3
   2871          
   2872          
   2873                  case SERIAL_OS_ERR_SIGNAL:
   2874                  default:
   2875                       CPU_CRITICAL_ENTER();
   \                     ??Serial_WrEnd_2: (+1)
   \   00000076   0x.... 0x....      BL       CPU_SR_Save
   \   0000007A   0x4682             MOV      R10,R0
   \   0000007C   0x.... 0x....      BL       CPU_IntDisMeasStart
   2876                       buf_size = SerialBuf_Size(&(pif->WrUserBuf));
   \   00000080   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   00000084   0x.... 0x....      BL       SerialBuf_Size
   \   00000088   0x4680             MOV      R8,R0
   2877                       data_len = SerialBuf_DataLen(&(pif->WrUserBuf));
   \   0000008A   0xF114 0x00AC      ADDS     R0,R4,#+172
   \   0000008E   0x.... 0x....      BL       SerialBuf_DataLen
   \   00000092   0x4681             MOV      R9,R0
   2878                       len      = buf_size - data_len;
   \   00000094   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   00000098   0x0007             MOVS     R7,R0
   2879          
   2880                       Serial_IF_WrClr(pif);                              /* Clr wr info.                                         */
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       Serial_IF_WrClr
   2881                       Serial_WrNext(pif);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       Serial_WrNext
   2882                       CPU_CRITICAL_EXIT();
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
   2883          
   2884                       SerialOS_SemSignal(pif->WrSem);
   \   000000B0   0xF8D4 0x009C      LDR      R0,[R4, #+156]
   \   000000B4   0x.... 0x....      BL       SerialOS_SemSignal
   2885                      *perr = SERIAL_ERR_FAIL;
   \   000000B8   0x200A             MOVS     R0,#+10
   \   000000BA   0x8030             STRH     R0,[R6, #+0]
   2886                       break;
   2887              }
   2888          
   2889              return (len);
   \                     ??Serial_WrEnd_3: (+1)
   \   000000BC   0x0038             MOVS     R0,R7
   \   000000BE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2890          }
   2891          
   2892          
   2893          /*$PAGE*/
   2894          /*
   2895          *********************************************************************************************************
   2896          *                                         Serial_WrCallback()
   2897          *
   2898          * Description : Internal write complete callback.
   2899          *
   2900          * Argument(s) : if_nbr      Interface number.
   2901          *               ------      Argument validated in Serial_WrAsync().
   2902          *
   2903          *               parg        Pointer to argument.
   2904          *
   2905          *               pbuf        Pointer to buffer passed to write function.
   2906          *
   2907          *               len         Number of octets written.
   2908          *
   2909          *               err         Write error.
   2910          *
   2911          * Return(s)   : None.
   2912          *
   2913          * Caller(s)   : Serial_Wr().
   2914          *
   2915          * Note(s)     : None.
   2916          *********************************************************************************************************
   2917          */
   2918          

   \                                 In section .text, align 4, keep-with-next
   2919          static  void  Serial_WrCallback (SERIAL_IF_NBR   if_nbr,
   2920                                           void           *parg,
   2921                                           void           *pbuf,
   2922                                           CPU_SIZE_T      len,
   2923                                           SERIAL_ERR      err)
   2924          {
   \                     Serial_WrCallback: (+1)
   \   00000000   0xB5F5             PUSH     {R0,R2,R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
   \   00000008   0x9C08             LDR      R4,[SP, #+32]
   2925              SERIAL_CALLBACK_INFO  *wr_info;
   2926          
   2927          
   2928             (void)&if_nbr;
   \   0000000A   0xA801             ADD      R0,SP,#+4
   2929             (void)&pbuf;
   \   0000000C   0xA802             ADD      R0,SP,#+8
   2930          
   2931              wr_info      = (SERIAL_CALLBACK_INFO *)parg;
   \   0000000E   0x002F             MOVS     R7,R5
   2932              wr_info->Len =  len;
   \   00000010   0x60BE             STR      R6,[R7, #+8]
   2933              wr_info->Err =  err;
   \   00000012   0x81BC             STRH     R4,[R7, #+12]
   2934          
   2935             (void)SerialOS_SemSignal(wr_info->SignalPtr);
   \   00000014   0x6838             LDR      R0,[R7, #+0]
   \   00000016   0x.... 0x....      BL       SerialOS_SemSignal
   2936          }
   \   0000001A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     Serial_IF_Tbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     SerialIF_NbrNext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     SerialLine_Dflt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     Serial_IF_Tbl
   2937          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SerialIF_GetDevPtr
        24   -> Serial_IF_IsValid
      64   SerialIF_Rx
        64   -- Indirect call
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> SerialBuf_Clr
        64   -> SerialBuf_Cmp
        64   -> SerialBuf_DataLen
        64   -> SerialBuf_Init
        64   -> SerialBuf_IsFull
        64   -> SerialBuf_RdOctet
        64   -> SerialOS_SemSignal
        64   -> Serial_IF_RxReset
      56   SerialIF_Tx
        56   -- Indirect call
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> SerialBuf_DataLen
        56   -> SerialBuf_Size
        56   -> SerialOS_SemSignal
        56   -> Serial_IF_WrClr
        56   -> Serial_WrNext
      24   SerialIF_TxWrBuf
        24   -- Indirect call
        24   -> SerialBuf_WrOctet
      64   Serial_Close
        64   -- Indirect call
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> Mem_PoolBlkFree
        64   -> SerialBuf_Clr
        64   -> SerialOS_SemDel
        64   -> Serial_IF_Clr
        64   -> Serial_IF_IsValid
      72   Serial_DevDrvAdd
        72   -- Indirect call
        72   -> CPU_IntDisMeasStart
        72   -> CPU_IntDisMeasStop
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> Mem_HeapAlloc
        72   -> Mem_PoolCreate
        72   -> SerialBuf_Init
        72   -> SerialOS_SemCreate
        72   -> Str_Cmp
       8   Serial_IF_Clr
         8   -> Serial_IF_RdClr
         8   -> Serial_IF_WrClr
       4   Serial_IF_IsValid
       8   Serial_IF_RdClr
         8   -> SerialBuf_Clr
       8   Serial_IF_RxReset
         8   -> Serial_IF_RdClr
         8   -> Serial_IF_RxStop
      16   Serial_IF_RxStart
        16   -- Indirect call
      16   Serial_IF_RxStop
        16   -- Indirect call
       8   Serial_IF_WrClr
         8   -> SerialBuf_Clr
      16   Serial_Init
        16   -> Mem_PoolClr
        16   -> SerialOS_Init
        16   -> Serial_IF_Clr
      48   Serial_Open
        48   -- Indirect call
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Str_Cmp
      72   Serial_Rd
        72   -> SerialOS_SemCreate
        72   -> SerialOS_SemDel
        72   -> Serial_RdEnd
        72   -> Serial_RdHandler
      48   Serial_RdAsync
        48   -> Serial_RdHandler
      32   Serial_RdCallback
        32   -> SerialOS_SemSignal
      24   Serial_RdEnd
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> SerialBuf_DataLen
        24   -> SerialOS_SemSignal
        24   -> SerialOS_SemWait
        24   -> Serial_IF_RxReset
      56   Serial_RdHandler
        56   -- Indirect call
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> SerialBuf_Clr
        56   -> SerialBuf_DataLen
        56   -> SerialBuf_Rd
        56   -> SerialOS_SemSignal
        56   -> SerialOS_SemTryLock
        56   -> SerialOS_SemWait
        56   -> Serial_RdStart
      16   Serial_RdStart
        16   -> SerialBuf_Init
        16   -> Serial_IF_RxStart
      40   Serial_SetLineDrv
        40   -- Indirect call
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> SerialBuf_Clr
        40   -> Serial_IF_IsValid
      64   Serial_WaitFor
        64   -> CPU_IntDisMeasStart
        64   -> CPU_IntDisMeasStop
        64   -> CPU_SR_Restore
        64   -> CPU_SR_Save
        64   -> SerialBuf_Clr
        64   -> SerialBuf_Cmp
        64   -> SerialBuf_Init
        64   -> SerialBuf_IsEmpty
        64   -> SerialBuf_RdOctet
        64   -> SerialOS_SemCreate
        64   -> SerialOS_SemDel
        64   -> SerialOS_SemSignal
        64   -> SerialOS_SemWait
        64   -> Serial_IF_IsValid
        64   -> Serial_IF_RxStart
        64   -> Serial_RdEnd
      88   Serial_Wr
        88   -> CPU_IntDisMeasStart
        88   -> CPU_IntDisMeasStop
        88   -> CPU_SR_Restore
        88   -> CPU_SR_Save
        88   -> SerialOS_SemCreate
        88   -> SerialOS_SemDel
        88   -> SerialOS_SemSignal
        88   -> SerialOS_SemWait
        88   -> Serial_IF_IsValid
        88   -> Serial_WrEnd
        88   -> Serial_WrStart
      72   Serial_WrAsync
        72   -> CPU_IntDisMeasStart
        72   -> CPU_IntDisMeasStop
        72   -> CPU_SR_Restore
        72   -> CPU_SR_Save
        72   -> SerialOS_SemTryLock
        72   -> Serial_IF_IsValid
        72   -> Serial_WrStart
      32   Serial_WrBufInsert
        32   -> Mem_PoolBlkGet
      24   Serial_WrBufRemove
        24   -> Mem_PoolBlkFree
      24   Serial_WrBufTxStart
        24   -- Indirect call
        24   -> SerialBuf_Init
      32   Serial_WrCallback
        32   -> SerialOS_SemSignal
      32   Serial_WrEnd
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> SerialBuf_DataLen
        32   -> SerialBuf_Size
        32   -> SerialOS_SemSignal
        32   -> SerialOS_SemWait
        32   -> Serial_IF_WrClr
        32   -> Serial_WrNext
      56   Serial_WrNext
        56   -- Indirect call
        56   -> SerialBuf_RdOctet
        56   -> Serial_WrBufRemove
        56   -> Serial_WrBufTxStart
      24   Serial_WrStart
        24   -- Indirect call
        24   -> Serial_WrBufInsert
        24   -> Serial_WrBufTxStart


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
      64  SerialIF_GetDevPtr
       1  SerialIF_NbrNext
     472  SerialIF_Rx
     264  SerialIF_Tx
      82  SerialIF_TxWrBuf
     382  Serial_Close
     600  Serial_DevDrvAdd
      46  Serial_IF_Clr
      80  Serial_IF_IsValid
      32  Serial_IF_RdClr
      24  Serial_IF_RxReset
      32  Serial_IF_RxStart
      32  Serial_IF_RxStop
     960  Serial_IF_Tbl
      32  Serial_IF_WrClr
     114  Serial_Init
     336  Serial_Open
     156  Serial_Rd
      80  Serial_RdAsync
      28  Serial_RdCallback
     160  Serial_RdEnd
     370  Serial_RdHandler
      30  Serial_RdStart
     204  Serial_SetLineDrv
     494  Serial_WaitFor
     234  Serial_Wr
     172  Serial_WrAsync
     136  Serial_WrBufInsert
     128  Serial_WrBufRemove
      90  Serial_WrBufTxStart
      28  Serial_WrCallback
     194  Serial_WrEnd
     138  Serial_WrNext
      88  Serial_WrStart

 
   961 bytes in section .bss
 5 338 bytes in section .text
 
 5 338 bytes of CODE memory
   961 bytes of DATA memory

Errors: none
Warnings: none
