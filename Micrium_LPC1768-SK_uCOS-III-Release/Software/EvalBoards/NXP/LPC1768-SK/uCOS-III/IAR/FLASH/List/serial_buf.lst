###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:12
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial_buf.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial_buf.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\serial_buf.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\serial_buf.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Source\serial_buf.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     SERIAL (BYTE) COMMUNICATION
      4          *
      5          *                         (c) Copyright 2007-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     SERIAL (BYTE) COMMUNICATION
     18          *
     19          * Filename      : serial.c
     20          * Version       : V2.00
     21          * Programmer(s) : FGK
     22          *********************************************************************************************************
     23          */
     24          
     25          
     26          /*
     27          *********************************************************************************************************
     28          *                                            INCLUDE FILES
     29          *********************************************************************************************************
     30          */
     31          
     32          #define    SERIAL_BUF_MODULE
     33          #include  <serial.h>
     34          
     35          
     36          /*$PAGE*/
     37          /*
     38          *********************************************************************************************************
     39          *                                          SerialBuf_Init()
     40          *
     41          * Description : Initialize buffer.
     42          *
     43          * Argument(s) : pbuf        Pointer to buffer.
     44          *
     45          *               pdata       Pointer to buffer data.
     46          *
     47          *               len         Buffer length.
     48          *
     49          *               full        Indicates that buffer is full upon initialization.
     50          *
     51          * Return(s)   : None.
     52          *
     53          * Caller(s)   : Application.
     54          *
     55          * Note(s)     : None.
     56          *********************************************************************************************************
     57          */
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void  SerialBuf_Init (SERIAL_BUF   *pbuf,
     60                                CPU_INT08U   *pdata,
     61                                CPU_SIZE_T    len,
     62                                CPU_BOOLEAN   full)
     63          {
   \                     SerialBuf_Init: (+1)
   \   00000000   0xB410             PUSH     {R4}
     64              pbuf->Len      = len;
   \   00000002   0x6002             STR      R2,[R0, #+0]
     65              pbuf->EmptyCnt = ((full == DEF_YES) ? (0) : (len));
   \   00000004   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??SerialBuf_Init_0
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xE000             B.N      ??SerialBuf_Init_1
   \                     ??SerialBuf_Init_0: (+1)
   \   0000000E   0x0014             MOVS     R4,R2
   \                     ??SerialBuf_Init_1: (+1)
   \   00000010   0x6044             STR      R4,[R0, #+4]
     66              pbuf->IxRd     = 0;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x6084             STR      R4,[R0, #+8]
     67              pbuf->IxWr     = 0;
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x60C4             STR      R4,[R0, #+12]
     68              pbuf->DataPtr  = pdata;
   \   0000001A   0x6101             STR      R1,[R0, #+16]
     69          }
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
     70          
     71          
     72          /*$PAGE*/
     73          /*
     74          *********************************************************************************************************
     75          *                                           SerialBuf_Clr()
     76          *
     77          * Description : Clear buffer.
     78          *
     79          * Argument(s) : pbuf        Pointer to buffer.
     80          *
     81          * Return(s)   : None.
     82          *
     83          * Caller(s)   : Application.
     84          *
     85          * Note(s)     : (1) Write index is moved to read index to reset circular buffer.
     86          *********************************************************************************************************
     87          */
     88          

   \                                 In section .text, align 2, keep-with-next
     89          void  SerialBuf_Clr  (SERIAL_BUF  *pbuf)
     90          {
     91              pbuf->EmptyCnt = pbuf->Len;
   \                     SerialBuf_Clr: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x6041             STR      R1,[R0, #+4]
     92              pbuf->IxWr     = pbuf->IxRd;
   \   00000004   0x6881             LDR      R1,[R0, #+8]
   \   00000006   0x60C1             STR      R1,[R0, #+12]
     93          }
   \   00000008   0x4770             BX       LR               ;; return
     94          
     95          
     96          /*$PAGE*/
     97          /*
     98          *********************************************************************************************************
     99          *                                           SerialBuf_Rd()
    100          *
    101          * Description : Read from buffer.
    102          *
    103          * Argument(s) : pbuf        Pointer to buffer.
    104          *
    105          *               pdest       Pointer to destination buffer.
    106          *
    107          *               len         Number of octets to read.
    108          *
    109          * Return(s)   : The number of octets read from buffer.
    110          *
    111          * Caller(s)   : Application.
    112          *
    113          * Note(s)     : None.
    114          *********************************************************************************************************
    115          */
    116          

   \                                 In section .text, align 2, keep-with-next
    117          CPU_SIZE_T  SerialBuf_Rd (SERIAL_BUF  *pbuf,
    118                                    CPU_INT08U  *pdest,
    119                                    CPU_SIZE_T   len)
    120          {
   \                     SerialBuf_Rd: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    121              CPU_SIZE_T   buf_avail;
    122              CPU_SIZE_T   buf_copy_start;
    123              CPU_SIZE_T   buf_copy_end;
    124              CPU_SIZE_T   buf_copy_tot;
    125              CPU_SIZE_T   ix_rd;
    126              CPU_SIZE_T   ix_rd_new;
    127              CPU_SIZE_T   buf_len;
    128              CPU_INT08U  *pdest_08;
    129              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    130          
    131          
    132              CPU_CRITICAL_ENTER();
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x4681             MOV      R9,R0
   \   00000016   0x.... 0x....      BL       CPU_IntDisMeasStart
    133              buf_len   = pbuf->Len;
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x0007             MOVS     R7,R0
    134              buf_avail = buf_len - pbuf->EmptyCnt;                       /* Calc nbr data octets in buf.                         */
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x1A38             SUBS     R0,R7,R0
   \   00000022   0x9002             STR      R0,[SP, #+8]
    135              pdest_08  = (CPU_INT08U *)pdest;
   \   00000024   0x46A8             MOV      R8,R5
    136          
    137          
    138          
    139              if (buf_avail == 0) {                                       /* ------------------ HANDLE EMPTY BUF ---------------- */
   \   00000026   0x9802             LDR      R0,[SP, #+8]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD106             BNE.N    ??SerialBuf_Rd_0
    140                  CPU_CRITICAL_EXIT();
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000030   0x4648             MOV      R0,R9
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
    141                  return ((CPU_SIZE_T)0);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE047             B.N      ??SerialBuf_Rd_1
    142              }
    143          
    144          
    145          
    146                                                                          /* ------------- CALC BUF IX & LEN TO COPY ------------ */
    147              ix_rd          = pbuf->IxRd;
   \                     ??SerialBuf_Rd_0: (+1)
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    148              buf_copy_tot   = DEF_MIN(buf_avail,    len);                /* Calc nbr data octets tot to copy.                    */
   \   0000003E   0x9802             LDR      R0,[SP, #+8]
   \   00000040   0x42B0             CMP      R0,R6
   \   00000042   0xD202             BCS.N    ??SerialBuf_Rd_2
   \   00000044   0xF8DD 0xA008      LDR      R10,[SP, #+8]
   \   00000048   0xE000             B.N      ??SerialBuf_Rd_3
   \                     ??SerialBuf_Rd_2: (+1)
   \   0000004A   0x46B2             MOV      R10,R6
    149              buf_copy_end   = DEF_MIN(buf_copy_tot, buf_len - ix_rd);    /* Calc nbr data octets to copy from buf end.           */
   \                     ??SerialBuf_Rd_3: (+1)
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x1A38             SUBS     R0,R7,R0
   \   00000050   0x4582             CMP      R10,R0
   \   00000052   0xD201             BCS.N    ??SerialBuf_Rd_4
   \   00000054   0x46D3             MOV      R11,R10
   \   00000056   0xE002             B.N      ??SerialBuf_Rd_5
   \                     ??SerialBuf_Rd_4: (+1)
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0xEBB7 0x0B00      SUBS     R11,R7,R0
    150              buf_copy_start = buf_copy_tot - buf_copy_end;               /* Calc nbr data octets to copy from buf start.         */
   \                     ??SerialBuf_Rd_5: (+1)
   \   0000005E   0xEBBA 0x000B      SUBS     R0,R10,R11
   \   00000062   0x9001             STR      R0,[SP, #+4]
    151              if (buf_copy_start > 0) {                                   /* Update buf ix rd.                                    */
   \   00000064   0x9801             LDR      R0,[SP, #+4]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??SerialBuf_Rd_6
    152                  pbuf->IxRd = buf_copy_start;
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x60A0             STR      R0,[R4, #+8]
   \   0000006E   0xE00B             B.N      ??SerialBuf_Rd_7
    153              } else {
    154                  ix_rd_new = ix_rd + buf_copy_tot;
   \                     ??SerialBuf_Rd_6: (+1)
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0xEB1A 0x0000      ADDS     R0,R10,R0
   \   00000076   0x9003             STR      R0,[SP, #+12]
    155                  if (ix_rd_new == buf_len) {
   \   00000078   0x9803             LDR      R0,[SP, #+12]
   \   0000007A   0x42B8             CMP      R0,R7
   \   0000007C   0xD102             BNE.N    ??SerialBuf_Rd_8
    156                      pbuf->IxRd = 0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x60A0             STR      R0,[R4, #+8]
   \   00000082   0xE001             B.N      ??SerialBuf_Rd_7
    157                  } else {
    158                      pbuf->IxRd = ix_rd_new;
   \                     ??SerialBuf_Rd_8: (+1)
   \   00000084   0x9803             LDR      R0,[SP, #+12]
   \   00000086   0x60A0             STR      R0,[R4, #+8]
    159                  }
    160              }
    161              CPU_CRITICAL_EXIT();
   \                     ??SerialBuf_Rd_7: (+1)
   \   00000088   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008C   0x4648             MOV      R0,R9
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
    162          
    163                                                                          /* --------------- COPY DATA AT BUF END --------------- */
    164                                                                          /* Copy data.                                           */
    165              Mem_Copy((void *)pdest_08, (void *)&pbuf->DataPtr[ix_rd], buf_copy_end);
   \   00000092   0x465A             MOV      R2,R11
   \   00000094   0x6920             LDR      R0,[R4, #+16]
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x4401             ADD      R1,R0,R1
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x.... 0x....      BL       Mem_Copy
    166                                                                          /* -------------- COPY DATA AT BUF START -------------- */
    167              pdest_08 += buf_copy_end;                                   /* Adj buf ptr.                                         */
   \   000000A0   0x44D8             ADD      R8,R8,R11
    168                                                                          /* Copy data.                                           */
    169              Mem_Copy((void *)pdest_08, (void *)&pbuf->DataPtr[0], buf_copy_start);
   \   000000A2   0x9A01             LDR      R2,[SP, #+4]
   \   000000A4   0x6921             LDR      R1,[R4, #+16]
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x.... 0x....      BL       Mem_Copy
    170          
    171          
    172          
    173              CPU_CRITICAL_ENTER();
   \   000000AC   0x.... 0x....      BL       CPU_SR_Save
   \   000000B0   0x4681             MOV      R9,R0
   \   000000B2   0x.... 0x....      BL       CPU_IntDisMeasStart
    174              pbuf->EmptyCnt += buf_copy_tot;                             /* Update buf empty octets rem.                         */
   \   000000B6   0x6860             LDR      R0,[R4, #+4]
   \   000000B8   0xEB1A 0x0000      ADDS     R0,R10,R0
   \   000000BC   0x6060             STR      R0,[R4, #+4]
    175              CPU_CRITICAL_EXIT();
   \   000000BE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C2   0x4648             MOV      R0,R9
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
    176          
    177              return (buf_copy_tot);
   \   000000C8   0x4650             MOV      R0,R10
   \                     ??SerialBuf_Rd_1: (+1)
   \   000000CA   0xB005             ADD      SP,SP,#+20
   \   000000CC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    178          }
    179          
    180          
    181          /*$PAGE*/
    182          /*
    183          *********************************************************************************************************
    184          *                                         SerialBuf_RdOctet()
    185          *
    186          * Description : Read octet from buffer.
    187          *
    188          * Argument(s) : pbuf        Pointer to buffer.
    189          *
    190          *               pdatum      Pointer to variable that will receive octet.
    191          *
    192          * Return(s)   : DEF_YES, if a octet was read from the buffer.
    193          *               DEF_NO,  otherwise.
    194          *
    195          * Caller(s)   : Application.
    196          *
    197          * Note(s)     : None.
    198          *********************************************************************************************************
    199          */
    200          

   \                                 In section .text, align 2, keep-with-next
    201          CPU_BOOLEAN  SerialBuf_RdOctet (SERIAL_BUF  *pbuf,
    202                                          CPU_INT08U  *pdatum)
    203          {
   \                     SerialBuf_RdOctet: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    204              CPU_SIZE_T  empty_cnt;
    205              CPU_SIZE_T  ix_rd;
    206              CPU_SIZE_T  len;
    207              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    208          
    209          
    210              CPU_CRITICAL_ENTER();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStart
    211              len       = pbuf->Len;
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x4680             MOV      R8,R0
    212              empty_cnt = pbuf->EmptyCnt;
   \   0000001A   0x6860             LDR      R0,[R4, #+4]
   \   0000001C   0x0006             MOVS     R6,R0
    213          
    214              if (empty_cnt == len) {
   \   0000001E   0x4546             CMP      R6,R8
   \   00000020   0xD106             BNE.N    ??SerialBuf_RdOctet_0
    215                  CPU_CRITICAL_EXIT();
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000026   0x4648             MOV      R0,R9
   \   00000028   0x.... 0x....      BL       CPU_SR_Restore
    216                  return (DEF_NO);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE014             B.N      ??SerialBuf_RdOctet_1
    217              }
    218          
    219              ix_rd          = pbuf->IxRd;
   \                     ??SerialBuf_RdOctet_0: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x0007             MOVS     R7,R0
    220             *pdatum         = pbuf->DataPtr[ix_rd];
   \   00000034   0x6920             LDR      R0,[R4, #+16]
   \   00000036   0x5DC0             LDRB     R0,[R0, R7]
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    221              pbuf->EmptyCnt = empty_cnt + 1;
   \   0000003A   0x1C70             ADDS     R0,R6,#+1
   \   0000003C   0x6060             STR      R0,[R4, #+4]
    222          
    223              if (ix_rd + 1 == len) {
   \   0000003E   0x1C78             ADDS     R0,R7,#+1
   \   00000040   0x4540             CMP      R0,R8
   \   00000042   0xD102             BNE.N    ??SerialBuf_RdOctet_2
    224                  pbuf->IxRd = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x60A0             STR      R0,[R4, #+8]
   \   00000048   0xE001             B.N      ??SerialBuf_RdOctet_3
    225              } else {
    226                  pbuf->IxRd = ix_rd + 1;
   \                     ??SerialBuf_RdOctet_2: (+1)
   \   0000004A   0x1C78             ADDS     R0,R7,#+1
   \   0000004C   0x60A0             STR      R0,[R4, #+8]
    227              }
    228              CPU_CRITICAL_EXIT();
   \                     ??SerialBuf_RdOctet_3: (+1)
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x4648             MOV      R0,R9
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    229          
    230              return (DEF_YES);
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??SerialBuf_RdOctet_1: (+1)
   \   0000005A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    231          }
    232          
    233          
    234          /*$PAGE*/
    235          /*
    236          *********************************************************************************************************
    237          *                                         SerialBuf_WrOctet()
    238          *
    239          * Description : Write octet to buffer.
    240          *
    241          * Argument(s) : pbuf        Pointer to buffer.
    242          *
    243          *               datum       Octet to write.
    244          *
    245          * Return(s)   : DEF_YES, if the octet was stored in buffer.
    246          *               DEF_NO,  otherwise.
    247          *
    248          * Caller(s)   : Application.
    249          *
    250          * Note(s)     : None.
    251          *********************************************************************************************************
    252          */
    253          

   \                                 In section .text, align 2, keep-with-next
    254          CPU_BOOLEAN  SerialBuf_WrOctet (SERIAL_BUF  *pbuf,
    255                                          CPU_INT08U   datum)
    256          {
   \                     SerialBuf_WrOctet: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    257              CPU_SIZE_T  empty_cnt;
    258              CPU_SIZE_T  ix_wr;
    259              CPU_SIZE_T  len;
    260              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
    261          
    262          
    263              CPU_CRITICAL_ENTER();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0x.... 0x....      BL       CPU_IntDisMeasStart
    264              empty_cnt = pbuf->EmptyCnt;
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x0006             MOVS     R6,R0
    265          
    266              if (empty_cnt == 0) {
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD106             BNE.N    ??SerialBuf_WrOctet_0
    267                  CPU_CRITICAL_EXIT();
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000022   0x4648             MOV      R0,R9
   \   00000024   0x.... 0x....      BL       CPU_SR_Restore
    268                  return (DEF_NO);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE015             B.N      ??SerialBuf_WrOctet_1
    269              }
    270          
    271              ix_wr                = pbuf->IxWr;
   \                     ??SerialBuf_WrOctet_0: (+1)
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0x0007             MOVS     R7,R0
    272              pbuf->DataPtr[ix_wr] = datum;
   \   00000030   0x6920             LDR      R0,[R4, #+16]
   \   00000032   0x55C5             STRB     R5,[R0, R7]
    273              pbuf->EmptyCnt       = empty_cnt - 1;
   \   00000034   0x1E70             SUBS     R0,R6,#+1
   \   00000036   0x6060             STR      R0,[R4, #+4]
    274              len                  = pbuf->Len;
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x4680             MOV      R8,R0
    275          
    276              if (ix_wr + 1 == len) {
   \   0000003C   0x1C78             ADDS     R0,R7,#+1
   \   0000003E   0x4540             CMP      R0,R8
   \   00000040   0xD102             BNE.N    ??SerialBuf_WrOctet_2
    277                  pbuf->IxWr = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x60E0             STR      R0,[R4, #+12]
   \   00000046   0xE001             B.N      ??SerialBuf_WrOctet_3
    278              } else {
    279                  pbuf->IxWr = ix_wr + 1;
   \                     ??SerialBuf_WrOctet_2: (+1)
   \   00000048   0x1C78             ADDS     R0,R7,#+1
   \   0000004A   0x60E0             STR      R0,[R4, #+12]
    280              }
    281              CPU_CRITICAL_EXIT();
   \                     ??SerialBuf_WrOctet_3: (+1)
   \   0000004C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000050   0x4648             MOV      R0,R9
   \   00000052   0x.... 0x....      BL       CPU_SR_Restore
    282          
    283              return (DEF_YES);
   \   00000056   0x2001             MOVS     R0,#+1
   \                     ??SerialBuf_WrOctet_1: (+1)
   \   00000058   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    284          }
    285          
    286          
    287          /*$PAGE*/
    288          /*
    289          *********************************************************************************************************
    290          *                                         SerialBuf_Cmp()
    291          *
    292          * Description : Compare incoming octets to buffer.
    293          *
    294          * Argument(s) : pbuf        Pointer to buffer.
    295          *
    296          *               datum       Octet to compare.
    297          *
    298          * Return(s)   : DEF_YES, if compare finished successfully.
    299          *               DEF_NO,  otherwise.
    300          *
    301          * Caller(s)   : Application.
    302          *
    303          * Note(s)     : None.
    304          *********************************************************************************************************
    305          */
    306          

   \                                 In section .text, align 2, keep-with-next
    307          CPU_BOOLEAN  SerialBuf_Cmp (SERIAL_BUF  *pbuf,
    308                                      CPU_INT08U   datum)
    309          {
   \                     SerialBuf_Cmp: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
    310              CPU_SIZE_T   ix_rd;
    311              CPU_BOOLEAN  full;
    312              CPU_SR_ALLOC();
   \   00000008   0x2700             MOVS     R7,#+0
    313          
    314          
    315              CPU_CRITICAL_ENTER();
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x.... 0x....      BL       CPU_IntDisMeasStart
    316              full = SerialBuf_IsFull(pbuf);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       SerialBuf_IsFull
   \   0000001A   0x0006             MOVS     R6,R0
    317              if (full == DEF_NO) {
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD106             BNE.N    ??SerialBuf_Cmp_0
    318                  CPU_CRITICAL_EXIT();
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x.... 0x....      BL       CPU_SR_Restore
    319                  return (DEF_NO);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE024             B.N      ??SerialBuf_Cmp_1
    320              }
    321          
    322              ix_rd = pbuf->IxRd;
   \                     ??SerialBuf_Cmp_0: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x0005             MOVS     R5,R0
    323              if(pbuf->DataPtr[ix_rd] != datum) {
   \   00000034   0x6920             LDR      R0,[R4, #+16]
   \   00000036   0x5D40             LDRB     R0,[R0, R5]
   \   00000038   0x4641             MOV      R1,R8
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD008             BEQ.N    ??SerialBuf_Cmp_2
    324                  pbuf->IxRd = 0;                                         /* Reset comparison.                                    */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x60A0             STR      R0,[R4, #+8]
    325                  CPU_CRITICAL_EXIT();
   \   00000044   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
    326                  return (DEF_NO);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE013             B.N      ??SerialBuf_Cmp_1
    327              }
    328          
    329              ix_rd++;
   \                     ??SerialBuf_Cmp_2: (+1)
   \   00000052   0x1C6D             ADDS     R5,R5,#+1
    330          
    331              if (ix_rd == pbuf->Len) {
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x4285             CMP      R5,R0
   \   00000058   0xD108             BNE.N    ??SerialBuf_Cmp_3
    332                  pbuf->IxRd = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x60A0             STR      R0,[R4, #+8]
    333                  CPU_CRITICAL_EXIT();
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       CPU_SR_Restore
    334                  return (DEF_YES);
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE006             B.N      ??SerialBuf_Cmp_1
    335              }
    336          
    337              pbuf->IxRd = ix_rd;
   \                     ??SerialBuf_Cmp_3: (+1)
   \   0000006C   0x60A5             STR      R5,[R4, #+8]
    338              CPU_CRITICAL_EXIT();
   \   0000006E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000072   0x0038             MOVS     R0,R7
   \   00000074   0x.... 0x....      BL       CPU_SR_Restore
    339              return (DEF_NO);
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??SerialBuf_Cmp_1: (+1)
   \   0000007A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    340          }
    341          
    342          
    343          /*$PAGE*/
    344          /*
    345          *********************************************************************************************************
    346          *                                         SerialBuf_IsEmpty()
    347          *
    348          * Description : Determine whether buffer is empty.
    349          *
    350          * Argument(s) : pbuf        Pointer to buffer.
    351          *
    352          * Return(s)   : DEF_YES, if buffer is empty.
    353          *               DEF_NO,  otherwise.
    354          *
    355          * Caller(s)   : Application.
    356          *
    357          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    358          *********************************************************************************************************
    359          */
    360          

   \                                 In section .text, align 2, keep-with-next
    361          CPU_BOOLEAN  SerialBuf_IsEmpty (SERIAL_BUF  *pbuf)
    362          {
   \                     SerialBuf_IsEmpty: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    363              CPU_BOOLEAN  empty;
    364          
    365          
    366              empty = ((pbuf->EmptyCnt == pbuf->Len) ? (DEF_YES) : (DEF_NO));
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x680B             LDR      R3,[R1, #+0]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xD101             BNE.N    ??SerialBuf_IsEmpty_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??SerialBuf_IsEmpty_1
   \                     ??SerialBuf_IsEmpty_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
    367              return (empty);
   \                     ??SerialBuf_IsEmpty_1: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
    368          }
    369          
    370          
    371          /*$PAGE*/
    372          /*
    373          *********************************************************************************************************
    374          *                                         SerialBuf_IsFull()
    375          *
    376          * Description : Determine whether buffer is full.
    377          *
    378          * Argument(s) : pbuf        Pointer to buffer.
    379          *
    380          * Return(s)   : DEF_YES, if buffer is full.
    381          *               DEF_NO,  otherwise.
    382          *
    383          * Caller(s)   : Application.
    384          *
    385          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    386          *********************************************************************************************************
    387          */
    388          

   \                                 In section .text, align 2, keep-with-next
    389          CPU_BOOLEAN  SerialBuf_IsFull (SERIAL_BUF  *pbuf)
    390          {
   \                     SerialBuf_IsFull: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    391              CPU_BOOLEAN  full;
    392          
    393          
    394              full = ((pbuf->EmptyCnt == 0) ? (DEF_YES) : (DEF_NO));
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??SerialBuf_IsFull_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??SerialBuf_IsFull_1
   \                     ??SerialBuf_IsFull_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
    395              return (full);
   \                     ??SerialBuf_IsFull_1: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
    396          }
    397          
    398          
    399          /*$PAGE*/
    400          /*
    401          *********************************************************************************************************
    402          *                                          SerialBuf_Size()
    403          *
    404          * Description : Retrieve buffer size.
    405          *
    406          * Argument(s) : pbuf        Pointer to buffer.
    407          *
    408          * Return(s)   : Size of buffer in octets.
    409          *
    410          * Caller(s)   : Application.
    411          *
    412          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    413          *********************************************************************************************************
    414          */
    415          

   \                                 In section .text, align 2, keep-with-next
    416          CPU_SIZE_T  SerialBuf_Size (SERIAL_BUF  *pbuf)
    417          {
   \                     SerialBuf_Size: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    418              CPU_SIZE_T  size;
    419          
    420          
    421              size = pbuf->Len;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x0010             MOVS     R0,R2
    422              return (size);
   \   00000006   0x4770             BX       LR               ;; return
    423          }
    424          
    425          
    426          /*$PAGE*/
    427          /*
    428          *********************************************************************************************************
    429          *                                         SerialBuf_DataLen()
    430          *
    431          * Description : Determine buffer data area length.
    432          *
    433          * Argument(s) : pbuf        Pointer to buffer.
    434          *
    435          * Return(s)   : Number of octets in buffer data area.
    436          *
    437          * Caller(s)   : Application.
    438          *
    439          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    440          *********************************************************************************************************
    441          */
    442          

   \                                 In section .text, align 2, keep-with-next
    443          CPU_SIZE_T  SerialBuf_DataLen (SERIAL_BUF  *pbuf)
    444          {
   \                     SerialBuf_DataLen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    445              CPU_SIZE_T  len;
    446          
    447          
    448              len = pbuf->Len - pbuf->EmptyCnt;
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x684B             LDR      R3,[R1, #+4]
   \   00000006   0x1AD2             SUBS     R2,R2,R3
   \   00000008   0x0010             MOVS     R0,R2
    449              return (len);
   \   0000000A   0x4770             BX       LR               ;; return
    450          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SerialBuf_Clr
      24   SerialBuf_Cmp
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> SerialBuf_IsFull
       0   SerialBuf_DataLen
       4   SerialBuf_Init
       0   SerialBuf_IsEmpty
       0   SerialBuf_IsFull
      56   SerialBuf_Rd
        56   -> CPU_IntDisMeasStart
        56   -> CPU_IntDisMeasStop
        56   -> CPU_SR_Restore
        56   -> CPU_SR_Save
        56   -> Mem_Copy
      32   SerialBuf_RdOctet
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
       0   SerialBuf_Size
      32   SerialBuf_WrOctet
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      10  SerialBuf_Clr
     126  SerialBuf_Cmp
      12  SerialBuf_DataLen
      32  SerialBuf_Init
      20  SerialBuf_IsEmpty
      18  SerialBuf_IsFull
     208  SerialBuf_Rd
      94  SerialBuf_RdOctet
       8  SerialBuf_Size
      92  SerialBuf_WrOctet

 
 620 bytes in section .text
 
 620 bytes of CODE memory

Errors: none
Warnings: none
