###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:13
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Driver\NXP\serial_drv_lpcxxxx.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Driver\NXP\serial_drv_lpcxxxx.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\serial_drv_lpcxxxx.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\serial_drv_lpcxxxx.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Driver\NXP\serial_drv_lpcxxxx.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     SERIAL (BYTE) COMMUNICATION
      4          *
      5          *                         (c) Copyright 2007-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     SERIAL (BYTE) COMMUNICATION
     18          *                                            DEVICE DRIVER
     19          *
     20          *                                             NXP LPCxxxx
     21          *
     22          * Filename      : serial_drv_lpcxxxx.c
     23          * Version       : V2.00
     24          * Programmer(s) : FT
     25          *********************************************************************************************************
     26          * Note(s)       : (1) With an appropriate BSP, this device driver will support the UARTs on the NXP LPC
     27          *                     MCUs & MPUs, including :
     28          *
     29          *                         NXP LPC23xx     series.
     30          *                         NXP LPC24xx     series.
     31          *                         NXP LPC17xx     series.
     32          *                         NXP LPC3180/81  series. (see note #2)
     33          *                         NXP LPC32x0     series. (see note #2)
     34          *
     35          *                 (2) The LPC32x0 series and the LPC3180/81 use the 'SerialDrv_LPC3xxx_API' API, this 
     36          *                     is because there are small differences in the register definition.
     37          *********************************************************************************************************
     38          */
     39          
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            INCLUDE FILES
     44          *********************************************************************************************************
     45          */
     46          
     47          #define   SERIAL_DRV_LPCXXXX_MODULE
     48          #include  <serial.h>
     49          #include  <serial_drv_lpcxxxx.h>
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                        BAUD RATE CALCULATION ALGORITHM CONSTANST
     55          *********************************************************************************************************
     56          */
     57          
     58          #define  SERIAL_DRV_LPCXXXX_VAL_MULVAL                       15u
     59          #define  SERIAL_DRV_LPCXXXX_VAL_DIVAL_MAX_IX                 14u
     60          
     61          
     62          /*
     63          *********************************************************************************************************
     64          *                                                   REGISTER BIT DEFINES
     65          *********************************************************************************************************
     66          */
     67                                                                          /* --------- LINE CONTROL REGISTER BIT DEFINES -------- */
     68          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_05                DEF_BIT_NONE
     69          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_06                DEF_BIT_MASK(1u, 0u)
     70          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_07                DEF_BIT_MASK(2u, 0u)
     71          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_08                DEF_BIT_MASK(3u, 0u)
     72          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_STOP_BIT              DEF_BIT_02
     73          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN                DEF_BIT_03
     74          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_ODD               DEF_BIT_NONE
     75          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EVEN              DEF_BIT_MASK(1u, 4)
     76          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ONE        DEF_BIT_MASK(2u, 4)
     77          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ZERO       DEF_BIT_MASK(3u, 4)
     78          #define  SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB                  DEF_BIT_07
     79          
     80                                                                          /* ------------- FIFO REGISTER BIT DEFINES ------------ */
     81          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_FIFO_EN               DEF_BIT_00
     82          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_RX_FIFO_RST           DEF_BIT_01
     83          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_TX_FIFO_RST           DEF_BIT_02
     84          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_FIFO_CTRL             DEF_BIT_03
     85          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_RX_TRIG_LEVEL_01      DEF_BIT_NONE
     86          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_RX_TRIG_LEVEL_04      DEF_BIT_MASK(1u, 6)
     87          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_RX_TRIG_LEVEL_08      DEF_BIT_MASK(2u, 6)
     88          #define  SERIAL_DRV_LPCXXXX_BIT_FCR_RX_TRIG_LEVEL_14      DEF_BIT_MASK(3u, 6)
     89          
     90                                                                          /* ------ INTERRUPT ENABLE REGISTER BIT DEFINES ------- */
     91          #define  SERIAL_DRV_LPCXXXX_BIT_IER_RBR                   DEF_BIT_00
     92          #define  SERIAL_DRV_LPCXXXX_BIT_IER_THRE                  DEF_BIT_01
     93          #define  SERIAL_DRV_LPCXXXX_BIT_IER_RX_LINE               DEF_BIT_02
     94          
     95                                                                          /* ---------- LINE STATUS REGISTER BIT DEFINES -------- */
     96          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_RDR                   DEF_BIT_00
     97          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_OE                    DEF_BIT_01
     98          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_PE                    DEF_BIT_02
     99          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_FE                    DEF_BIT_03
    100          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_RX_ERR               (SERIAL_DRV_LPCXXXX_BIT_LSR_OE | \
    101                                                                    SERIAL_DRV_LPCXXXX_BIT_LSR_PE | \
    102                                                                    SERIAL_DRV_LPCXXXX_BIT_LSR_FE)
    103          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_BI                    DEF_BIT_04
    104          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_THRE                  DEF_BIT_05
    105          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_TEMT                  DEF_BIT_06
    106          #define  SERIAL_DRV_LPCXXXX_BIT_LSR_RXFE                  DEF_BIT_07
    107          
    108                                                                          /* -- INTERRUPT IDENTIFICATION REGISTER BIT DEFINES  -- */
    109          #define  SERIAL_DRV_LPCXXXX_BIT_IIR_INT_STAT              DEF_BIT_00
    110          #define  SERIAL_DRV_LPCXXXX_MSK_IIR_INT_ID                DEF_BIT_FIELD(3u, 1u)
    111          #define  SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_RLS            3u    /* Receive Line Status (RLS)                            */
    112          #define  SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_RDA            2u    /* Receive Data Available (RDA)                         */
    113          #define  SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_THRE           1u    /* Transmit Holding Register Interrupt                  */
    114          #define  SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_CTI            6u    /* Character Time-Out indicator                         */
    115          
    116                                                                          /* ------- TRANSMIT ENABLE REGISTER BIT DEFINES ------- */
    117          #define  SERIAL_DRV_LPCXXXX_BIT_TER_TXEN                  DEF_BIT_07
    118          
    119          
    120          /*
    121          *********************************************************************************************************
    122          *                                          LOCAL DATA TYPES
    123          *********************************************************************************************************
    124          */
    125          
    126          typedef  struct  serial_drv_reg {
    127              CPU_REG32  RBR;                                             /* Receive buffer     Register.                         */
    128              CPU_REG32  DLM;                                             /* Divisor Latch MSB  Register.                         */
    129              CPU_REG32  IIR;                                             /* Interrupt ID       Register.                         */
    130              CPU_REG32  LCR;                                             /* Line Control       Register.                         */
    131              CPU_REG32  MCR;                                             /* Modem Control      Register.                         */
    132              CPU_REG32  LSR;                                             /* Line Status        Register.                         */
    133              CPU_REG32  MSR;                                             /* Modem Status       Register.                         */
    134              CPU_REG32  SCR;                                             /* Scratch Pad        Register.                         */
    135              CPU_REG32  ACR;                                             /* Auto-baud control  Register.                         */
    136              CPU_REG32  RESERVED0;
    137              CPU_REG32  FDR;                                             /* Fractional Divider Register.                         */
    138              CPU_REG32  TER;                                             /* Transmit Enable    Register.                         */
    139              CPU_REG32  RESERVED1[9u];
    140              CPU_REG32  FIFOLVL;                                         /* FIFO Level         Register.                         */
    141          } SERIAL_DRV_REG;
    142          
    143          
    144          typedef  struct  serial_drv_reg_lpc3xxx {
    145              CPU_REG32  RBR;                                             /* Receive buffer     Register.                         */
    146              CPU_REG32  DLM;                                             /* Divisor Latch MSB  Register.                         */
    147              CPU_REG32  IIR;                                             /* Interrupt ID       Register.                         */
    148              CPU_REG32  LCR;                                             /* Line Control       Register.                         */
    149              CPU_REG32  MCR;                                             /* Modem Control      Register.                         */
    150              CPU_REG32  LSR;                                             /* Line Status        Register.                         */
    151              CPU_REG32  MSR;                                             /* Modem Status       Register.                         */
    152              CPU_REG32  FIFOLVL;                                         /* FIFO Level         Register.                         */
    153          } SERIAL_DRV_REG_LPC3xxx;
    154          
    155          
    156          /*
    157          *********************************************************************************************************
    158          *                                      LOCAL FUNCTION PROTOTYPES
    159          *********************************************************************************************************
    160          */
    161                                                                          /* Driver initialization.                               */
    162          static  void        SerialDrv_Init            (SERIAL_ERR     *perr);
    163          
    164                                                                          /* Driver open.                                         */
    165          static  void        SerialDrv_Open            (SERIAL_DEV     *pdev,
    166                                                         SERIAL_IF_CFG  *pcfg,
    167                                                         SERIAL_ERR     *perr);
    168          
    169          static  void        SerialDrv_LPC3xxx_Open    (SERIAL_DEV     *pdev,
    170                                                         SERIAL_IF_CFG  *pcfg,
    171                                                         SERIAL_ERR     *perr);
    172          
    173                                                                          /* Driver close.                                        */
    174          static  void        SerialDrv_Close           (SERIAL_DEV     *pdev,
    175                                                         SERIAL_ERR     *perr);
    176          
    177          static  void        SerialDrv_LPC3xxx_Close   (SERIAL_DEV     *pdev,
    178                                                         SERIAL_ERR     *perr);
    179          
    180          
    181                                                                          /* Driver receiver start.                               */
    182          static  void        SerialDrv_RxStart          (SERIAL_DEV     *pdev,
    183                                                          SERIAL_ERR     *perr);
    184          
    185                                                                          /* Driver receiver stop.                                */
    186          static  void        SerialDrv_RxStop           (SERIAL_DEV     *pdev,
    187                                                          SERIAL_ERR     *perr);
    188          
    189                                                                          /* Driver octet receive.                                */
    190          static  void        SerialDrv_RxOctet          (SERIAL_DEV     *pdev,
    191                                                          CPU_INT08U     *pdatum,
    192                                                          SERIAL_ERR     *perr);
    193          
    194                                                                          /* Driver transmitter start.                            */
    195          static  void        SerialDrv_TxStart          (SERIAL_DEV     *pdev,
    196                                                          SERIAL_ERR     *perr);
    197          
    198          static  void        SerialDrv_LPC3xxx_TxStart  (SERIAL_DEV     *pdev,
    199                                                          SERIAL_ERR     *perr);
    200          
    201                                                                          /* Driver transmitter stop.                             */
    202          static  void        SerialDrv_TxStop           (SERIAL_DEV     *pdev,
    203                                                          SERIAL_ERR     *perr);
    204          
    205          static  void        SerialDrv_LPC3xxx_TxStop   (SERIAL_DEV     *pdev,
    206                                                          SERIAL_ERR     *perr);
    207          
    208                                                                          /* Driver octet transmit.                               */
    209          static  void        SerialDrv_TxOctet          (SERIAL_DEV     *pdev,
    210                                                          CPU_INT08U      datum,
    211                                                          SERIAL_ERR     *perr);
    212          
    213                                                                          /* Driver ISR handler.                                  */
    214          static  void        SerialDrv_ISR_Handler      (SERIAL_DEV     *pdev,
    215                                                          CPU_INT08U      type);
    216          
    217          
    218          /*
    219          *********************************************************************************************************
    220          *********************************************************************************************************
    221          *                                 SERIAL INTERFACE DEVICE DRIVER API
    222          *********************************************************************************************************
    223          *********************************************************************************************************
    224          */
    225          

   \                                 In section .rodata, align 4
    226          SERIAL_DRV_API  SerialDrv_LPCxxxx_API = {
   \                     SerialDrv_LPCxxxx_API:
   \   00000000   0x........         DC32 SerialDrv_Init, SerialDrv_Open, SerialDrv_Close, SerialDrv_RxStart
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 SerialDrv_RxStop, SerialDrv_RxOctet, SerialDrv_TxStart
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 SerialDrv_TxStop, SerialDrv_TxOctet, SerialDrv_ISR_Handler
   \              0x........   
   \              0x........   
    227              SerialDrv_Init,
    228              SerialDrv_Open,
    229              SerialDrv_Close,
    230              SerialDrv_RxStart,
    231              SerialDrv_RxStop,
    232              SerialDrv_RxOctet,
    233              SerialDrv_TxStart,
    234              SerialDrv_TxStop,
    235              SerialDrv_TxOctet,
    236              SerialDrv_ISR_Handler
    237          };
    238          

   \                                 In section .rodata, align 4
    239          SERIAL_DRV_API  SerialDrv_LPC3xxx_API = {
   \                     SerialDrv_LPC3xxx_API:
   \   00000000   0x........         DC32 SerialDrv_Init, SerialDrv_LPC3xxx_Open, SerialDrv_LPC3xxx_Close
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 SerialDrv_RxStart, SerialDrv_RxStop, SerialDrv_RxOctet
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 SerialDrv_LPC3xxx_TxStart, SerialDrv_LPC3xxx_TxStop
   \              0x........   
   \   00000020   0x........         DC32 SerialDrv_TxOctet, SerialDrv_ISR_Handler
   \              0x........   
    240              SerialDrv_Init,
    241              SerialDrv_LPC3xxx_Open,
    242              SerialDrv_LPC3xxx_Close,
    243              SerialDrv_RxStart,
    244              SerialDrv_RxStop,
    245              SerialDrv_RxOctet,
    246              SerialDrv_LPC3xxx_TxStart,
    247              SerialDrv_LPC3xxx_TxStop,
    248              SerialDrv_TxOctet,
    249              SerialDrv_ISR_Handler
    250          };
    251          
    252          
    253          /*$PAGE*/
    254          /*
    255          *********************************************************************************************************
    256          *********************************************************************************************************
    257          *                                     DRIVER INTERFACE FUNCTIONS
    258          *********************************************************************************************************
    259          *********************************************************************************************************
    260          */
    261          
    262          /*
    263          *********************************************************************************************************
    264          *                                          SerialDrv_Init()
    265          *
    266          * Description : Initialize serial device driver.
    267          *
    268          * Argument(s) : perr        Pointer to variable that will receive the return error code from this function :
    269          *
    270          *                               SERIAL_ERR_NONE                 Driver initialized.
    271          *
    272          * Return(s)   : None.
    273          *
    274          * Caller(s)   : Serial_DrvAdd() via 'pdrv_api->Init()'.
    275          *
    276          * Note(s)     : None.
    277          *********************************************************************************************************
    278          */
    279          

   \                                 In section .text, align 2, keep-with-next
    280          static  void  SerialDrv_Init (SERIAL_ERR  *perr)
    281          {
    282             *perr = SERIAL_ERR_NONE;
   \                     SerialDrv_Init: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    283          }
   \   00000004   0x4770             BX       LR               ;; return
    284          
    285          
    286          /*$PAGE*/
    287          /*
    288          *********************************************************************************************************
    289          *                                          SerialDrv_Open()
    290          *                                       SerialDrv_LPC3xxx_Open()
    291          *
    292          * Description : Open a serial device for communication.
    293          *
    294          * Argument(s) : pdev        Pointer to device.
    295          *
    296          *               pcfg        Pointer to interface configuration.
    297          *
    298          *               perr        Pointer to variable that will receive the return error code from this function :
    299          *
    300          *                               SERIAL_ERR_NONE                 Device              opened.
    301          *                               SERIAL_ERR_DRV_OPEN             Device could NOT be opened.
    302          *                               SERIAL_ERR_DRV_INVALID          Device configuration invalid.
    303          *                               SERIAL_ERR_MEM_ALLOC            Memory could NOT be allocated for device
    304          *                                                                   internal data.
    305          *
    306          * Return(s)   : None.
    307          *
    308          * Caller(s)   : Serial_Open() via 'pdev->Drv_API->Open()'.
    309          *
    310          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    311          *
    312          *               (2) The LPCxxx UART baud rate can be calculated as:
    313          *
    314          *                                             PCLK
    315          *                   BAUD_RATE  =  ---------------------------------
    316          *                                                      DivAddval
    317          *                                  16 x  BRD  x ( 1 + ----------- )
    318          *                                                       MulVal 
    319          *
    320          *                  where PCLK      = UART Peripheral Clock.
    321          *                        BRD       = Baud rate divider (integer)
    322          *                        DivAddVal = Fractional Baud rate divider.
    323          *                        MulVal    = Fractional Baud rate multiplier.
    324          *
    325          *              (3) The LPC3xxx UART baud rate can be calculated as:
    326          *
    327          *                                         Source Clock
    328          *                   BAUD_RATE  =  ---------------------------------
    329          *                                           16 x  BRD  
    330          *                                             
    331          *                  where Source Clock  = Is either HCLK or PCLK divided with the preescaler.
    332          *                        BRD           = Baud rate divider (integer)
    333          *********************************************************************************************************
    334          */
    335          

   \                                 In section .text, align 2, keep-with-next
    336          static  void  SerialDrv_Open (SERIAL_DEV     *pdev,
    337                                        SERIAL_IF_CFG  *pcfg,
    338                                        SERIAL_ERR     *perr)
    339          {
   \                     SerialDrv_Open: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    340          
    341              CPU_INT32U       br_div_num;                                /* Baud Rate divider numerator.                         */
    342              CPU_INT32U       br_div_den;                                /* Baud Rate divider denominator.                       */   
    343              CPU_INT32U       br_div;                                    /* Baud Rate divider.                                   */
    344              CPU_INT32U       br_div_tmp;                                /* Baud Rate divider temporal.                          */    
    345              CPU_INT32U       br_val_err;                                /* Baud Rate value error.                               */
    346              CPU_INT32U       br_val_err_max;                            /* Baud Rate Maximum error.                             */    
    347              CPU_INT32U       br_val;                                    /* Baud Rate Maximum error.                             */    
    348              CPU_BOOLEAN      div_found;
    349              CPU_INT08U       fp_div;                                    /* Fractional part multiplier.                          */
    350              CPU_INT08U       fp_div_ix;                                 /* Fractional part multiplier index.                    */
    351              CPU_BOOLEAN      flow_ctrl;
    352              CPU_INT32U       per_clk_freq;                              /* Peripheral Clock frequency.                          */
    353              CPU_INT32U       reg_val;
    354              SERIAL_DRV_REG  *p_reg;
    355              SERIAL_DEV_CFG  *p_cfg;
    356              
    357              
    358              p_cfg         = pdev->Dev_Cfg;
   \   0000000A   0x9808             LDR      R0,[SP, #+32]
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    359                                                                          /* -------------- BAUD RATE CALCULATION --------------- */
    360              per_clk_freq  = p_cfg->BSP_API->ClkFreqGet();               /* Get the UART peripheral clock                        */
   \   00000010   0x9801             LDR      R0,[SP, #+4]
   \   00000012   0x6880             LDR      R0,[R0, #+8]
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0x4780             BLX      R0
   \   00000018   0x9006             STR      R0,[SP, #+24]
    361          
    362              if (pcfg->Baudrate > per_clk_freq) {                        /* If baud rate higher than peripheral clock?           */
   \   0000001A   0x9806             LDR      R0,[SP, #+24]
   \   0000001C   0x6821             LDR      R1,[R4, #+0]
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD201             BCS.N    ??SerialDrv_Open_0
    363                  *perr =  SERIAL_ERR_DRV_INVALID;
   \   00000022   0x2014             MOVS     R0,#+20
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    364              }
    365              
    366              br_div_num     = (per_clk_freq);
   \                     ??SerialDrv_Open_0: (+1)
   \   00000026   0x9806             LDR      R0,[SP, #+24]
   \   00000028   0x4683             MOV      R11,R0
    367              br_div_den     = (pcfg->Baudrate * 16u);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x0100             LSLS     R0,R0,#+4
   \   0000002E   0x9004             STR      R0,[SP, #+16]
    368              div_found      = DEF_NO;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
    369              br_val_err     = DEF_INT_32U_MAX_VAL;
   \   00000036   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000003A   0x9005             STR      R0,[SP, #+20]
    370              br_div_tmp     = (br_div_num / br_div_den); 
   \   0000003C   0x9804             LDR      R0,[SP, #+16]
   \   0000003E   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000042   0x0006             MOVS     R6,R0
    371              br_div         = 0u;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9003             STR      R0,[SP, #+12]
    372              br_val_err_max = DEF_INT_32U_MAX_VAL;
   \   00000048   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004C   0x9002             STR      R0,[SP, #+8]
    373              fp_div         = 0u;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF88D 0x0001      STRB     R0,[SP, #+1]
    374          
    375              if ((br_div_tmp != 0u             ) &&                     /* If the baud rate divider is valid.                   */
    376                  (br_div_tmp <= DEF_INT_16_MASK)) {
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD018             BEQ.N    ??SerialDrv_Open_1
   \   00000058   0xF5B6 0x3F80      CMP      R6,#+65536
   \   0000005C   0xD215             BCS.N    ??SerialDrv_Open_1
    377                  br_div    = br_div_tmp;                                /* ... store the result.                                */
   \   0000005E   0x9603             STR      R6,[SP, #+12]
    378                  fp_div    = 0u; 
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF88D 0x0001      STRB     R0,[SP, #+1]
    379                  div_found = DEF_YES;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0000      STRB     R0,[SP, #+0]
    380                  br_val    = (br_div_num / (16u * br_div));
   \   0000006C   0x9803             LDR      R0,[SP, #+12]
   \   0000006E   0x0100             LSLS     R0,R0,#+4
   \   00000070   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000074   0x0007             MOVS     R7,R0
    381                  if (br_val > pcfg->Baudrate) {
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x42B8             CMP      R0,R7
   \   0000007A   0xD203             BCS.N    ??SerialDrv_Open_2
    382                      br_val_err_max = br_val - pcfg->Baudrate;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x1A38             SUBS     R0,R7,R0
   \   00000080   0x9002             STR      R0,[SP, #+8]
   \   00000082   0xE002             B.N      ??SerialDrv_Open_1
    383                  } else {
    384                      br_val_err_max = pcfg->Baudrate - br_val;        
   \                     ??SerialDrv_Open_2: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x1BC0             SUBS     R0,R0,R7
   \   00000088   0x9002             STR      R0,[SP, #+8]
    385                  }
    386              }
    387              
    388              if ((br_val_err_max != 0u     ) ||
    389                  (div_found      != DEF_YES)) {
   \                     ??SerialDrv_Open_1: (+1)
   \   0000008A   0x9802             LDR      R0,[SP, #+8]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD103             BNE.N    ??SerialDrv_Open_3
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD03F             BEQ.N    ??SerialDrv_Open_4
    390              
    391                  br_div_num *= SERIAL_DRV_LPCXXXX_VAL_MULVAL;            /* Pre-calculate the numerator                          */
   \                     ??SerialDrv_Open_3: (+1)
   \   00000098   0x200F             MOVS     R0,#+15
   \   0000009A   0xFB00 0xFB0B      MUL      R11,R0,R11
    392                                                                          /* Try from divider 1 to maximum divider                */
    393                  for (fp_div_ix = 1u; fp_div_ix <= SERIAL_DRV_LPCXXXX_VAL_DIVAL_MAX_IX; fp_div_ix++) {
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x4680             MOV      R8,R0
   \                     ??SerialDrv_Open_5: (+1)
   \   000000A2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A6   0xF1B8 0x0F0F      CMP      R8,#+15
   \   000000AA   0xD235             BCS.N    ??SerialDrv_Open_4
    394                      br_div_den = (pcfg->Baudrate * 16u)
    395                                 * (SERIAL_DRV_LPCXXXX_VAL_MULVAL + (CPU_INT32U)fp_div_ix);
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B2   0xF118 0x010F      ADDS     R1,R8,#+15
   \   000000B6   0x4348             MULS     R0,R1,R0
   \   000000B8   0x0100             LSLS     R0,R0,#+4
   \   000000BA   0x9004             STR      R0,[SP, #+16]
    396                      br_div_tmp = (br_div_num / br_div_den);             /* Calculate the baud rate divider                      */
   \   000000BC   0x9804             LDR      R0,[SP, #+16]
   \   000000BE   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   000000C2   0x0006             MOVS     R6,R0
    397                      
    398                      if ((br_div_tmp != 0u             ) &&              /* Check if the baud rate is valid                      */
    399                          (br_div_tmp <= DEF_INT_16_MASK)) {
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD024             BEQ.N    ??SerialDrv_Open_6
   \   000000C8   0xF5B6 0x3F80      CMP      R6,#+65536
   \   000000CC   0xD221             BCS.N    ??SerialDrv_Open_6
    400                                                                          /* Calculate the remainer                               */
    401                          br_div_den = ((br_div_tmp * 16u)
    402                                     * ((CPU_INT32U)fp_div_ix + SERIAL_DRV_LPCXXXX_VAL_MULVAL));
   \   000000CE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D2   0xF118 0x000F      ADDS     R0,R8,#+15
   \   000000D6   0xFB00 0xF006      MUL      R0,R0,R6
   \   000000DA   0x0100             LSLS     R0,R0,#+4
   \   000000DC   0x9004             STR      R0,[SP, #+16]
    403                          br_val     = (br_div_num / br_div_den);
   \   000000DE   0x9804             LDR      R0,[SP, #+16]
   \   000000E0   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   000000E4   0x0007             MOVS     R7,R0
    404                                                                          /* Calculate the error between the found value and ...  */
    405                                                                          /* ... and the expected value.                          */                
    406                          if (br_val > pcfg->Baudrate) {
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x42B8             CMP      R0,R7
   \   000000EA   0xD203             BCS.N    ??SerialDrv_Open_7
    407                              br_val_err = br_val - pcfg->Baudrate;
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x1A38             SUBS     R0,R7,R0
   \   000000F0   0x9005             STR      R0,[SP, #+20]
   \   000000F2   0xE002             B.N      ??SerialDrv_Open_8
    408                          } else {
    409                              br_val_err = pcfg->Baudrate - br_val;        
   \                     ??SerialDrv_Open_7: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x1BC0             SUBS     R0,R0,R7
   \   000000F8   0x9005             STR      R0,[SP, #+20]
    410                          }
    411                          
    412                          if (br_val_err < br_val_err_max) {              /* If the value found reduces the error ...             */
   \                     ??SerialDrv_Open_8: (+1)
   \   000000FA   0x9805             LDR      R0,[SP, #+20]
   \   000000FC   0x9902             LDR      R1,[SP, #+8]
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xD207             BCS.N    ??SerialDrv_Open_6
    413                              br_div         = br_div_tmp;                /* ... Store the result to be written to the registers  */
   \   00000102   0x9603             STR      R6,[SP, #+12]
    414                              fp_div         = fp_div_ix;
   \   00000104   0xF88D 0x8001      STRB     R8,[SP, #+1]
    415                              div_found      = DEF_YES;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    416                              br_val_err_max = br_val_err;
   \   0000010E   0x9805             LDR      R0,[SP, #+20]
   \   00000110   0x9002             STR      R0,[SP, #+8]
    417                          }
    418                      }
    419                  }                
   \                     ??SerialDrv_Open_6: (+1)
   \   00000112   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000116   0xE7C4             B.N      ??SerialDrv_Open_5
    420              }
    421              
    422              if (div_found == DEF_NO) {
   \                     ??SerialDrv_Open_4: (+1)
   \   00000118   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD102             BNE.N    ??SerialDrv_Open_9
    423                 *perr = SERIAL_ERR_DRV_INVALID;
   \   00000120   0x2014             MOVS     R0,#+20
   \   00000122   0x8028             STRH     R0,[R5, #+0]
    424                  return;
   \   00000124   0xE09A             B.N      ??SerialDrv_Open_10
    425              }
    426           
    427                                                                          /* ---------------- UART LINE CONFIGUARTION ----------- */
    428              reg_val = DEF_BIT_NONE;
   \                     ??SerialDrv_Open_9: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x4681             MOV      R9,R0
    429              
    430              switch (pcfg->DataBits) {                                   /* ... World Length Configuration.                      */
   \   0000012A   0x7920             LDRB     R0,[R4, #+4]
   \   0000012C   0x2805             CMP      R0,#+5
   \   0000012E   0xD006             BEQ.N    ??SerialDrv_Open_11
   \   00000130   0xD311             BCC.N    ??SerialDrv_Open_12
   \   00000132   0x2807             CMP      R0,#+7
   \   00000134   0xD009             BEQ.N    ??SerialDrv_Open_13
   \   00000136   0xD305             BCC.N    ??SerialDrv_Open_14
   \   00000138   0x2808             CMP      R0,#+8
   \   0000013A   0xD009             BEQ.N    ??SerialDrv_Open_15
   \   0000013C   0xE00B             B.N      ??SerialDrv_Open_12
    431                  case SERIAL_DATABITS_5:
    432                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_05;
   \                     ??SerialDrv_Open_11: (+1)
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x4681             MOV      R9,R0
    433                       break;
   \   00000142   0xE00B             B.N      ??SerialDrv_Open_16
    434          
    435                  case SERIAL_DATABITS_6:
    436                       reg_val =SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_06;
   \                     ??SerialDrv_Open_14: (+1)
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0x4681             MOV      R9,R0
    437                       break;
   \   00000148   0xE008             B.N      ??SerialDrv_Open_16
    438                       
    439                  case SERIAL_DATABITS_7:
    440                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_07;
   \                     ??SerialDrv_Open_13: (+1)
   \   0000014A   0x2002             MOVS     R0,#+2
   \   0000014C   0x4681             MOV      R9,R0
    441                       break;
   \   0000014E   0xE005             B.N      ??SerialDrv_Open_16
    442          
    443                  case SERIAL_DATABITS_8:
    444                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_08;
   \                     ??SerialDrv_Open_15: (+1)
   \   00000150   0x2003             MOVS     R0,#+3
   \   00000152   0x4681             MOV      R9,R0
    445                       break;
   \   00000154   0xE002             B.N      ??SerialDrv_Open_16
    446                 
    447                  default:
    448                       *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_Open_12: (+1)
   \   00000156   0x2014             MOVS     R0,#+20
   \   00000158   0x8028             STRH     R0,[R5, #+0]
    449                       return;             
   \   0000015A   0xE07F             B.N      ??SerialDrv_Open_10
    450              }
    451              
    452              switch (pcfg->StopBits) {                                   /* ... Stop Bits configuration.                         */
   \                     ??SerialDrv_Open_16: (+1)
   \   0000015C   0x7960             LDRB     R0,[R4, #+5]
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD003             BEQ.N    ??SerialDrv_Open_17
   \   00000162   0x2802             CMP      R0,#+2
   \   00000164   0xD00B             BEQ.N    ??SerialDrv_Open_18
   \   00000166   0xD301             BCC.N    ??SerialDrv_Open_19
   \   00000168   0xE00C             B.N      ??SerialDrv_Open_20
    453                  case SERIAL_STOPBITS_1:
    454                       break;
   \                     ??SerialDrv_Open_17: (+1)
   \   0000016A   0xE00E             B.N      ??SerialDrv_Open_21
    455          
    456                  case SERIAL_STOPBITS_1_5:
    457                       if (pcfg->DataBits == (CPU_INT08U)SERIAL_DATABITS_5) {
   \                     ??SerialDrv_Open_19: (+1)
   \   0000016C   0x7920             LDRB     R0,[R4, #+4]
   \   0000016E   0x2805             CMP      R0,#+5
   \   00000170   0xD102             BNE.N    ??SerialDrv_Open_22
    458                           DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_STOP_BIT);
   \   00000172   0xF059 0x0904      ORRS     R9,R9,#0x4
    459                       } else {             
    460                           *perr = SERIAL_ERR_DRV_INVALID;
    461                            return;
    462                       }
    463                       break;
   \   00000176   0xE008             B.N      ??SerialDrv_Open_21
   \                     ??SerialDrv_Open_22: (+1)
   \   00000178   0x2014             MOVS     R0,#+20
   \   0000017A   0x8028             STRH     R0,[R5, #+0]
   \   0000017C   0xE06E             B.N      ??SerialDrv_Open_10
    464          
    465                  case SERIAL_STOPBITS_2:
    466                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_STOP_BIT);
   \                     ??SerialDrv_Open_18: (+1)
   \   0000017E   0xF059 0x0904      ORRS     R9,R9,#0x4
    467                       break;
   \   00000182   0xE002             B.N      ??SerialDrv_Open_21
    468          
    469                  default:
    470                      *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_Open_20: (+1)
   \   00000184   0x2014             MOVS     R0,#+20
   \   00000186   0x8028             STRH     R0,[R5, #+0]
    471                      return; 
   \   00000188   0xE068             B.N      ??SerialDrv_Open_10
    472              }
    473              
    474              switch (pcfg->Parity) {
   \                     ??SerialDrv_Open_21: (+1)
   \   0000018A   0x79A0             LDRB     R0,[R4, #+6]
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD012             BEQ.N    ??SerialDrv_Open_23
   \   00000190   0x2802             CMP      R0,#+2
   \   00000192   0xD007             BEQ.N    ??SerialDrv_Open_24
   \   00000194   0xD303             BCC.N    ??SerialDrv_Open_25
   \   00000196   0x2804             CMP      R0,#+4
   \   00000198   0xD00A             BEQ.N    ??SerialDrv_Open_26
   \   0000019A   0xD306             BCC.N    ??SerialDrv_Open_27
   \   0000019C   0xE00C             B.N      ??SerialDrv_Open_28
    475                  case SERIAL_PARITY_ODD:
    476                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    477                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_ODD);
   \                     ??SerialDrv_Open_25: (+1)
   \   0000019E   0xF059 0x0908      ORRS     R9,R9,#0x8
    478                       break;
   \   000001A2   0xE00C             B.N      ??SerialDrv_Open_29
    479          
    480          
    481                  case SERIAL_PARITY_EVEN:
    482                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    483                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_ODD);
   \                     ??SerialDrv_Open_24: (+1)
   \   000001A4   0xF059 0x0908      ORRS     R9,R9,#0x8
    484                       break;
   \   000001A8   0xE009             B.N      ??SerialDrv_Open_29
    485          
    486          
    487                  case SERIAL_PARITY_MARK:
    488                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    489                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ONE);
   \                     ??SerialDrv_Open_27: (+1)
   \   000001AA   0xF059 0x0928      ORRS     R9,R9,#0x28
    490                       break;
   \   000001AE   0xE006             B.N      ??SerialDrv_Open_29
    491          
    492                  case SERIAL_PARITY_SPACE:
    493                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    494                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ZERO);
   \                     ??SerialDrv_Open_26: (+1)
   \   000001B0   0xF059 0x0938      ORRS     R9,R9,#0x38
    495                       break;
   \   000001B4   0xE003             B.N      ??SerialDrv_Open_29
    496          
    497                  case SERIAL_PARITY_NONE:
    498                       break;
   \                     ??SerialDrv_Open_23: (+1)
   \   000001B6   0xE002             B.N      ??SerialDrv_Open_29
    499                       
    500                  default:
    501                      *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_Open_28: (+1)
   \   000001B8   0x2014             MOVS     R0,#+20
   \   000001BA   0x8028             STRH     R0,[R5, #+0]
    502                       return; 
   \   000001BC   0xE04E             B.N      ??SerialDrv_Open_10
    503              }
    504          
    505              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \                     ??SerialDrv_Open_29: (+1)
   \   000001BE   0x9801             LDR      R0,[SP, #+4]
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0x4682             MOV      R10,R0
    506          
    507              p_cfg->BSP_API->ClkEn(perr);                                /* En dev-specific HW clk.                              */
   \   000001C4   0x0028             MOVS     R0,R5
   \   000001C6   0x9901             LDR      R1,[SP, #+4]
   \   000001C8   0x6889             LDR      R1,[R1, #+8]
   \   000001CA   0x6809             LDR      R1,[R1, #+0]
   \   000001CC   0x4788             BLX      R1
    508              if (*perr != SERIAL_ERR_NONE) {
   \   000001CE   0x8828             LDRH     R0,[R5, #+0]
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD143             BNE.N    ??SerialDrv_Open_10
    509                   return;
    510              }
    511                  
    512              p_reg->LCR = DEF_BIT_NONE;                                  /* Disable Interrupts.                                  */
   \                     ??SerialDrv_Open_30: (+1)
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0xF8CA 0x000C      STR      R0,[R10, #+12]
    513              p_reg->DLM = DEF_BIT_NONE;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0xF8CA 0x0004      STR      R0,[R10, #+4]
    514          
    515              p_reg->LCR = reg_val;                                       /* Configure the Line control register.                 */
   \   000001E0   0xF8CA 0x900C      STR      R9,[R10, #+12]
    516                       
    517                                                                          /* Baud Rate configuration ...                          */
    518              DEF_BIT_SET(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Enable DLAB bit (access Divisor Latch register ) */
   \   000001E4   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   000001E8   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001EC   0xF8CA 0x000C      STR      R0,[R10, #+12]
    519              p_reg->RBR   = (br_div      ) & DEF_INT_08_MASK;            /* ... Set LSB Divisor Latch                            */
   \   000001F0   0x9803             LDR      R0,[SP, #+12]
   \   000001F2   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000001F6   0xF8CA 0x0000      STR      R0,[R10, #+0]
    520              p_reg->DLM   = (br_div >> 8u) & DEF_INT_08_MASK;            /* ... Set MSB Divisor Latch                            */
   \   000001FA   0x9803             LDR      R0,[SP, #+12]
   \   000001FC   0xF3C0 0x2007      UBFX     R0,R0,#+8,#+8
   \   00000200   0xF8CA 0x0004      STR      R0,[R10, #+4]
    521              DEF_BIT_CLR(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Disable DLAB bit                                 */    
   \   00000204   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000208   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000020C   0xF8CA 0x000C      STR      R0,[R10, #+12]
    522              p_reg->FDR   = SERIAL_DRV_LPCXXXX_VAL_MULVAL << 4u          /* ... Set the fractional divider                       */
    523                           | fp_div;
   \   00000210   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000214   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \   00000218   0xF8CA 0x0028      STR      R0,[R10, #+40]
    524          
    525                                                                          /* --------------- FIFOs CONFIGURATION  --------------- */
    526              p_reg->IIR   = SERIAL_DRV_LPCXXXX_BIT_FCR_RX_FIFO_RST       /* Reset the TX and RX FIFOs. FIFO is disabled          */
    527                           | SERIAL_DRV_LPCXXXX_BIT_FCR_TX_FIFO_RST;
   \   0000021C   0x2006             MOVS     R0,#+6
   \   0000021E   0xF8CA 0x0008      STR      R0,[R10, #+8]
    528              
    529              p_reg->IIR   = SERIAL_DRV_LPCXXXX_BIT_FCR_FIFO_EN           /* Enable the FIFO & Set the Rx trigger level to 1      */
    530                           | SERIAL_DRV_LPCXXXX_BIT_FCR_RX_TRIG_LEVEL_01;      
   \   00000222   0x2001             MOVS     R0,#+1
   \   00000224   0xF8CA 0x0008      STR      R0,[R10, #+8]
    531              
    532                             
    533              switch (pcfg->FlowCtrl) {
   \   00000228   0x79E0             LDRB     R0,[R4, #+7]
   \   0000022A   0x2801             CMP      R0,#+1
   \   0000022C   0xD103             BNE.N    ??SerialDrv_Open_31
    534                  case SERIAL_FLOW_CTRL_HARDWARE:
    535                       flow_ctrl  = DEF_ENABLED;
   \   0000022E   0x2001             MOVS     R0,#+1
   \   00000230   0xF88D 0x0002      STRB     R0,[SP, #+2]
    536                       break;
   \   00000234   0xE002             B.N      ??SerialDrv_Open_32
    537          
    538                  case SERIAL_FLOW_CTRL_NONE:
    539                  default:
    540                       flow_ctrl  = DEF_DISABLED;
   \                     ??SerialDrv_Open_31: (+1)
   \   00000236   0x2000             MOVS     R0,#+0
   \   00000238   0xF88D 0x0002      STRB     R0,[SP, #+2]
    541                       break;
    542              }
    543          
    544              p_cfg->BSP_API->CfgGPIO(flow_ctrl, perr);                   /* Cfg dev-specific GPIO.                               */
   \                     ??SerialDrv_Open_32: (+1)
   \   0000023C   0x0029             MOVS     R1,R5
   \   0000023E   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000242   0x9A01             LDR      R2,[SP, #+4]
   \   00000244   0x6892             LDR      R2,[R2, #+8]
   \   00000246   0x6892             LDR      R2,[R2, #+8]
   \   00000248   0x4790             BLX      R2
    545              if (*perr != SERIAL_ERR_NONE) {
   \   0000024A   0x8828             LDRH     R0,[R5, #+0]
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD105             BNE.N    ??SerialDrv_Open_10
    546                   return;
    547              }
    548              p_cfg->BSP_API->CfgInt(pdev, perr);                         /* Cfg dev-specific int.                                */
   \                     ??SerialDrv_Open_33: (+1)
   \   00000250   0x0029             MOVS     R1,R5
   \   00000252   0x9808             LDR      R0,[SP, #+32]
   \   00000254   0x9A01             LDR      R2,[SP, #+4]
   \   00000256   0x6892             LDR      R2,[R2, #+8]
   \   00000258   0x68D2             LDR      R2,[R2, #+12]
   \   0000025A   0x4790             BLX      R2
    549          }
   \                     ??SerialDrv_Open_10: (+1)
   \   0000025C   0xB009             ADD      SP,SP,#+36
   \   0000025E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    550          
    551          
    552          

   \                                 In section .text, align 2, keep-with-next
    553          static  void  SerialDrv_LPC3xxx_Open (SERIAL_DEV     *pdev,
    554                                                SERIAL_IF_CFG  *pcfg,
    555                                                SERIAL_ERR    *perr)
    556          {
   \                     SerialDrv_LPC3xxx_Open: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    557          
    558              CPU_INT32U       br_div;                                    /* Baud Rate divider.                                   */
    559              CPU_BOOLEAN      flow_ctrl;
    560              CPU_INT32U       per_clk_freq;                              /* Peripheral Clock frequency.                          */
    561              CPU_INT32U       reg_val;
    562              SERIAL_DRV_REG  *p_reg;
    563              SERIAL_DEV_CFG  *p_cfg;
    564              
    565              
    566              p_cfg  = pdev->Dev_Cfg;        
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x4683             MOV      R11,R0
    567                                                                          /* -------------- BAUD RATE CALCULATION --------------- */
    568              per_clk_freq  = p_cfg->BSP_API->ClkFreqGet();               /* Get the UART peripheral clock                        */
   \   0000000E   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000012   0x6900             LDR      R0,[R0, #+16]
   \   00000014   0x4780             BLX      R0
   \   00000016   0x4680             MOV      R8,R0
    569          
    570              if (pcfg->Baudrate > per_clk_freq) {                        /* If baud rate higher than peripheral clock?           */
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x4580             CMP      R8,R0
   \   0000001C   0xD201             BCS.N    ??SerialDrv_LPC3xxx_Open_0
    571                  *perr =  SERIAL_ERR_DRV_INVALID;
   \   0000001E   0x2014             MOVS     R0,#+20
   \   00000020   0x8030             STRH     R0,[R6, #+0]
    572              }
    573          
    574              br_div         =  (((per_clk_freq) / (8u * pcfg->Baudrate)) + 1u) / 2u;
   \                     ??SerialDrv_LPC3xxx_Open_0: (+1)
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x00C0             LSLS     R0,R0,#+3
   \   00000026   0xFBB8 0xF0F0      UDIV     R0,R8,R0
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x0840             LSRS     R0,R0,#+1
   \   0000002E   0x9000             STR      R0,[SP, #+0]
    575                                                                          /* ---------------- UART LINE CONFIGUARTION ----------- */
    576              reg_val = DEF_BIT_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4681             MOV      R9,R0
    577              
    578              switch (pcfg->DataBits) {                                   /* ... World Length Configuration.                      */
   \   00000034   0x7928             LDRB     R0,[R5, #+4]
   \   00000036   0x2805             CMP      R0,#+5
   \   00000038   0xD006             BEQ.N    ??SerialDrv_LPC3xxx_Open_1
   \   0000003A   0xD311             BCC.N    ??SerialDrv_LPC3xxx_Open_2
   \   0000003C   0x2807             CMP      R0,#+7
   \   0000003E   0xD009             BEQ.N    ??SerialDrv_LPC3xxx_Open_3
   \   00000040   0xD305             BCC.N    ??SerialDrv_LPC3xxx_Open_4
   \   00000042   0x2808             CMP      R0,#+8
   \   00000044   0xD009             BEQ.N    ??SerialDrv_LPC3xxx_Open_5
   \   00000046   0xE00B             B.N      ??SerialDrv_LPC3xxx_Open_2
    579                  case SERIAL_DATABITS_5:
    580                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_05;
   \                     ??SerialDrv_LPC3xxx_Open_1: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4681             MOV      R9,R0
    581                       break;
   \   0000004C   0xE00B             B.N      ??SerialDrv_LPC3xxx_Open_6
    582          
    583                  case SERIAL_DATABITS_6:
    584                       reg_val =SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_06;
   \                     ??SerialDrv_LPC3xxx_Open_4: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x4681             MOV      R9,R0
    585                       break;
   \   00000052   0xE008             B.N      ??SerialDrv_LPC3xxx_Open_6
    586                       
    587                  case SERIAL_DATABITS_7:
    588                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_07;
   \                     ??SerialDrv_LPC3xxx_Open_3: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4681             MOV      R9,R0
    589                       break;
   \   00000058   0xE005             B.N      ??SerialDrv_LPC3xxx_Open_6
    590          
    591                  case SERIAL_DATABITS_8:
    592                       reg_val = SERIAL_DRV_LPCXXXX_BIT_LCR_WLS_08;
   \                     ??SerialDrv_LPC3xxx_Open_5: (+1)
   \   0000005A   0x2003             MOVS     R0,#+3
   \   0000005C   0x4681             MOV      R9,R0
    593                       break;
   \   0000005E   0xE002             B.N      ??SerialDrv_LPC3xxx_Open_6
    594                 
    595                  default:
    596                       *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_LPC3xxx_Open_2: (+1)
   \   00000060   0x2014             MOVS     R0,#+20
   \   00000062   0x8030             STRH     R0,[R6, #+0]
    597                       return;             
   \   00000064   0xE074             B.N      ??SerialDrv_LPC3xxx_Open_7
    598              }
    599              
    600              switch (pcfg->StopBits) {                                   /* ... Stop Bits configuration.                         */
   \                     ??SerialDrv_LPC3xxx_Open_6: (+1)
   \   00000066   0x7968             LDRB     R0,[R5, #+5]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD003             BEQ.N    ??SerialDrv_LPC3xxx_Open_8
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD00B             BEQ.N    ??SerialDrv_LPC3xxx_Open_9
   \   00000070   0xD301             BCC.N    ??SerialDrv_LPC3xxx_Open_10
   \   00000072   0xE00C             B.N      ??SerialDrv_LPC3xxx_Open_11
    601                  case SERIAL_STOPBITS_1:
    602                       break;
   \                     ??SerialDrv_LPC3xxx_Open_8: (+1)
   \   00000074   0xE00E             B.N      ??SerialDrv_LPC3xxx_Open_12
    603          
    604                  case SERIAL_STOPBITS_1_5:
    605                       if (pcfg->DataBits == (CPU_INT08U)SERIAL_DATABITS_5) {
   \                     ??SerialDrv_LPC3xxx_Open_10: (+1)
   \   00000076   0x7928             LDRB     R0,[R5, #+4]
   \   00000078   0x2805             CMP      R0,#+5
   \   0000007A   0xD102             BNE.N    ??SerialDrv_LPC3xxx_Open_13
    606                           DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_STOP_BIT);
   \   0000007C   0xF059 0x0904      ORRS     R9,R9,#0x4
    607                       } else {             
    608                           *perr = SERIAL_ERR_DRV_INVALID;
    609                            return;
    610                       }
    611                       break;
   \   00000080   0xE008             B.N      ??SerialDrv_LPC3xxx_Open_12
   \                     ??SerialDrv_LPC3xxx_Open_13: (+1)
   \   00000082   0x2014             MOVS     R0,#+20
   \   00000084   0x8030             STRH     R0,[R6, #+0]
   \   00000086   0xE063             B.N      ??SerialDrv_LPC3xxx_Open_7
    612          
    613                  case SERIAL_STOPBITS_2:
    614                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_STOP_BIT);
   \                     ??SerialDrv_LPC3xxx_Open_9: (+1)
   \   00000088   0xF059 0x0904      ORRS     R9,R9,#0x4
    615                       break;
   \   0000008C   0xE002             B.N      ??SerialDrv_LPC3xxx_Open_12
    616          
    617                  default:
    618                      *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_LPC3xxx_Open_11: (+1)
   \   0000008E   0x2014             MOVS     R0,#+20
   \   00000090   0x8030             STRH     R0,[R6, #+0]
    619                      return; 
   \   00000092   0xE05D             B.N      ??SerialDrv_LPC3xxx_Open_7
    620              }
    621              
    622              switch (pcfg->Parity) {
   \                     ??SerialDrv_LPC3xxx_Open_12: (+1)
   \   00000094   0x79A8             LDRB     R0,[R5, #+6]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD012             BEQ.N    ??SerialDrv_LPC3xxx_Open_14
   \   0000009A   0x2802             CMP      R0,#+2
   \   0000009C   0xD007             BEQ.N    ??SerialDrv_LPC3xxx_Open_15
   \   0000009E   0xD303             BCC.N    ??SerialDrv_LPC3xxx_Open_16
   \   000000A0   0x2804             CMP      R0,#+4
   \   000000A2   0xD00A             BEQ.N    ??SerialDrv_LPC3xxx_Open_17
   \   000000A4   0xD306             BCC.N    ??SerialDrv_LPC3xxx_Open_18
   \   000000A6   0xE00C             B.N      ??SerialDrv_LPC3xxx_Open_19
    623                  case SERIAL_PARITY_ODD:
    624                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    625                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_ODD);
   \                     ??SerialDrv_LPC3xxx_Open_16: (+1)
   \   000000A8   0xF059 0x0908      ORRS     R9,R9,#0x8
    626                       break;
   \   000000AC   0xE00C             B.N      ??SerialDrv_LPC3xxx_Open_20
    627          
    628          
    629                  case SERIAL_PARITY_EVEN:
    630                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    631                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_ODD);
   \                     ??SerialDrv_LPC3xxx_Open_15: (+1)
   \   000000AE   0xF059 0x0908      ORRS     R9,R9,#0x8
    632                       break;
   \   000000B2   0xE009             B.N      ??SerialDrv_LPC3xxx_Open_20
    633          
    634          
    635                  case SERIAL_PARITY_MARK:
    636                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    637                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ONE);
   \                     ??SerialDrv_LPC3xxx_Open_18: (+1)
   \   000000B4   0xF059 0x0928      ORRS     R9,R9,#0x28
    638                       break;
   \   000000B8   0xE006             B.N      ??SerialDrv_LPC3xxx_Open_20
    639          
    640                  case SERIAL_PARITY_SPACE:
    641                       DEF_BIT_SET(reg_val, SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_EN | 
    642                                            SERIAL_DRV_LPCXXXX_BIT_LCR_PAR_FORCED_ZERO);
   \                     ??SerialDrv_LPC3xxx_Open_17: (+1)
   \   000000BA   0xF059 0x0938      ORRS     R9,R9,#0x38
    643                       break;
   \   000000BE   0xE003             B.N      ??SerialDrv_LPC3xxx_Open_20
    644          
    645                  case SERIAL_PARITY_NONE:
    646                       break;
   \                     ??SerialDrv_LPC3xxx_Open_14: (+1)
   \   000000C0   0xE002             B.N      ??SerialDrv_LPC3xxx_Open_20
    647                       
    648                  default:
    649                      *perr = SERIAL_ERR_DRV_INVALID;
   \                     ??SerialDrv_LPC3xxx_Open_19: (+1)
   \   000000C2   0x2014             MOVS     R0,#+20
   \   000000C4   0x8030             STRH     R0,[R6, #+0]
    650                       return; 
   \   000000C6   0xE043             B.N      ??SerialDrv_LPC3xxx_Open_7
    651              }
    652          
    653              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \                     ??SerialDrv_LPC3xxx_Open_20: (+1)
   \   000000C8   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000000CC   0x4682             MOV      R10,R0
    654          
    655              p_cfg->BSP_API->ClkEn(perr);                                /* En dev-specific HW clk.                              */
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0xF8DB 0x1008      LDR      R1,[R11, #+8]
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x4788             BLX      R1
    656              if (*perr != SERIAL_ERR_NONE) {
   \   000000D8   0x8830             LDRH     R0,[R6, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD138             BNE.N    ??SerialDrv_LPC3xxx_Open_7
    657                   return;
    658              }
    659                  
    660              p_reg->LCR = DEF_BIT_NONE;                                  /* Disable Interrupts.                                  */
   \                     ??SerialDrv_LPC3xxx_Open_21: (+1)
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF8CA 0x000C      STR      R0,[R10, #+12]
    661              p_reg->DLM = DEF_BIT_NONE;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF8CA 0x0004      STR      R0,[R10, #+4]
    662          
    663              p_reg->LCR = reg_val;                                       /* Configure the Line control register.                 */
   \   000000EA   0xF8CA 0x900C      STR      R9,[R10, #+12]
    664                       
    665                                                                          /* Baud Rate configuration ...                          */
    666              DEF_BIT_SET(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Enable DLAB bit (access Divisor Latch register ) */
   \   000000EE   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   000000F2   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F6   0xF8CA 0x000C      STR      R0,[R10, #+12]
    667              p_reg->RBR   = (br_div      ) & DEF_INT_08_MASK;            /* ... Set LSB Divisor Latch                            */
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000100   0xF8CA 0x0000      STR      R0,[R10, #+0]
    668              p_reg->DLM   = (br_div >> 8u) & DEF_INT_08_MASK;            /* ... Set MSB Divisor Latch                            */
   \   00000104   0x9800             LDR      R0,[SP, #+0]
   \   00000106   0xF3C0 0x2007      UBFX     R0,R0,#+8,#+8
   \   0000010A   0xF8CA 0x0004      STR      R0,[R10, #+4]
    669              DEF_BIT_CLR(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Disable DLAB bit                                 */    
   \   0000010E   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000112   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000116   0xF8CA 0x000C      STR      R0,[R10, #+12]
    670              
    671                                                                          /* --------------- FIFOs CONFIGURATION  --------------- */
    672              p_reg->IIR   = SERIAL_DRV_LPCXXXX_BIT_FCR_RX_FIFO_RST       /* Reset the TX and RX FIFOs. FIFO is disabled          */
    673                           | SERIAL_DRV_LPCXXXX_BIT_FCR_TX_FIFO_RST;
   \   0000011A   0x2006             MOVS     R0,#+6
   \   0000011C   0xF8CA 0x0008      STR      R0,[R10, #+8]
    674                  
    675                             
    676              switch (pcfg->FlowCtrl) {
   \   00000120   0x79E8             LDRB     R0,[R5, #+7]
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xD102             BNE.N    ??SerialDrv_LPC3xxx_Open_22
    677                  case SERIAL_FLOW_CTRL_HARDWARE:
    678                       flow_ctrl  = DEF_ENABLED;
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0x0007             MOVS     R7,R0
    679                       break;
   \   0000012A   0xE001             B.N      ??SerialDrv_LPC3xxx_Open_23
    680          
    681                  case SERIAL_FLOW_CTRL_NONE:
    682                  default:
    683                       flow_ctrl  = DEF_DISABLED;
   \                     ??SerialDrv_LPC3xxx_Open_22: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x0007             MOVS     R7,R0
    684                       break;
    685              }
    686          
    687              p_cfg->BSP_API->CfgGPIO(flow_ctrl, perr);                   /* Cfg dev-specific GPIO.                               */
   \                     ??SerialDrv_LPC3xxx_Open_23: (+1)
   \   00000130   0x0031             MOVS     R1,R6
   \   00000132   0x0038             MOVS     R0,R7
   \   00000134   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000136   0xF8DB 0x2008      LDR      R2,[R11, #+8]
   \   0000013A   0x6892             LDR      R2,[R2, #+8]
   \   0000013C   0x4790             BLX      R2
    688              if (*perr != SERIAL_ERR_NONE) {
   \   0000013E   0x8830             LDRH     R0,[R6, #+0]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD105             BNE.N    ??SerialDrv_LPC3xxx_Open_7
    689                   return;
    690              }
    691              p_cfg->BSP_API->CfgInt(pdev, perr);                         /* Cfg dev-specific int.                                */
   \                     ??SerialDrv_LPC3xxx_Open_24: (+1)
   \   00000144   0x0031             MOVS     R1,R6
   \   00000146   0x0020             MOVS     R0,R4
   \   00000148   0xF8DB 0x2008      LDR      R2,[R11, #+8]
   \   0000014C   0x68D2             LDR      R2,[R2, #+12]
   \   0000014E   0x4790             BLX      R2
    692          }
   \                     ??SerialDrv_LPC3xxx_Open_7: (+1)
   \   00000150   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    693          
    694          
    695          /*$PAGE*/
    696          /*
    697          *********************************************************************************************************
    698          *                                          SerialDrv_Close()
    699          *                                      SerialDrv_Close_LPC3xxx()
    700          *
    701          * Description : Close a serial device for communication.
    702          *
    703          * Argument(s) : pdev        Pointer to device.
    704          *
    705          *               perr        Pointer to variable that will receive the return error code from this function :
    706          *
    707          *                               SERIAL_ERR_NONE                 Device closed.
    708          *
    709          * Return(s)   : None.
    710          *
    711          * Caller(s)   : Serial_Close() via 'pdev->Drv_API->Close()'.
    712          *
    713          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    714          *********************************************************************************************************
    715          */
    716          

   \                                 In section .text, align 2, keep-with-next
    717          static  void  SerialDrv_Close (SERIAL_DEV  *pdev,
    718                                         SERIAL_ERR  *perr)
    719          {
   \                     SerialDrv_Close: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    720              SERIAL_DRV_REG  *p_reg;
    721              SERIAL_DEV_CFG  *p_cfg;
    722          
    723              
    724              p_cfg = pdev->Dev_Cfg;
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x0007             MOVS     R7,R0
    725              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   0000000A   0x6838             LDR      R0,[R7, #+0]
   \   0000000C   0x0006             MOVS     R6,R0
    726              
    727              DEF_BIT_CLR(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Disable DLAB bit.                                */
   \   0000000E   0x68F0             LDR      R0,[R6, #+12]
   \   00000010   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000014   0x60F0             STR      R0,[R6, #+12]
    728              p_reg->DLM = DEF_BIT_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6070             STR      R0,[R6, #+4]
    729              p_reg->IIR = DEF_BIT_NONE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60B0             STR      R0,[R6, #+8]
    730              p_reg->LCR = DEF_BIT_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60F0             STR      R0,[R6, #+12]
    731              p_reg->FDR = DEF_BIT_NONE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x62B0             STR      R0,[R6, #+40]
    732          
    733              p_cfg->BSP_API->ClkDis(perr);                               /* Dis dev-specific HW clk.                             */
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x68B9             LDR      R1,[R7, #+8]
   \   0000002A   0x6849             LDR      R1,[R1, #+4]
   \   0000002C   0x4788             BLX      R1
    734              if (*perr != SERIAL_ERR_NONE) {
   \   0000002E   0x8828             LDRH     R0,[R5, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD101             BNE.N    ??SerialDrv_Close_0
    735                   return;
    736              }
    737          
    738             *perr = SERIAL_ERR_NONE;
   \                     ??SerialDrv_Close_1: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    739          }
   \                     ??SerialDrv_Close_0: (+1)
   \   00000038   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    740          
    741          

   \                                 In section .text, align 2, keep-with-next
    742          static  void  SerialDrv_LPC3xxx_Close (SERIAL_DEV  *pdev,
    743                                                 SERIAL_ERR  *perr)
    744          {
   \                     SerialDrv_LPC3xxx_Close: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    745              SERIAL_DRV_REG  *p_reg;
    746              SERIAL_DEV_CFG  *p_cfg;
    747              
    748              
    749              p_cfg  = pdev->Dev_Cfg;   
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x0007             MOVS     R7,R0
    750              p_reg  = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   0000000A   0x6838             LDR      R0,[R7, #+0]
   \   0000000C   0x0006             MOVS     R6,R0
    751          
    752              DEF_BIT_CLR(p_reg->LCR, SERIAL_DRV_LPCXXXX_BIT_LCR_DLAB);   /* ... Disable DLAB bit.                                */
   \   0000000E   0x68F0             LDR      R0,[R6, #+12]
   \   00000010   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000014   0x60F0             STR      R0,[R6, #+12]
    753              p_reg->DLM = DEF_BIT_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6070             STR      R0,[R6, #+4]
    754              p_reg->IIR = DEF_BIT_NONE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60B0             STR      R0,[R6, #+8]
    755              p_reg->LCR = DEF_BIT_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x60F0             STR      R0,[R6, #+12]
    756          
    757              p_cfg->BSP_API->ClkDis(perr);                               /* Dis dev-specific HW clk.                             */
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x68B9             LDR      R1,[R7, #+8]
   \   00000026   0x6849             LDR      R1,[R1, #+4]
   \   00000028   0x4788             BLX      R1
    758              if (*perr != SERIAL_ERR_NONE) {
   \   0000002A   0x8828             LDRH     R0,[R5, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??SerialDrv_LPC3xxx_Close_0
    759                   return;
    760              }
    761          
    762             *perr = SERIAL_ERR_NONE;
   \                     ??SerialDrv_LPC3xxx_Close_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x8028             STRH     R0,[R5, #+0]
    763          }
   \                     ??SerialDrv_LPC3xxx_Close_0: (+1)
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    764          
    765          /*$PAGE*/
    766          /*
    767          *********************************************************************************************************
    768          *                                         SerialDrv_RxStart()
    769          *
    770          * Description : Start receiving data & getting data received interrupts.
    771          *
    772          * Argument(s) : pdev        Pointer to device.
    773          *
    774          *               perr        Pointer to variable that will receive the return error code from this function :
    775          *
    776          *                               SERIAL_ERR_NONE                 Device reception started.
    777          *
    778          * Return(s)   : None.
    779          *
    780          * Caller(s)   : Serial_Open(),
    781          *               Serial_IF_RxStart() via 'pdev->Drv_API->RxStart()'.
    782          *
    783          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    784          *********************************************************************************************************
    785          */
    786          

   \                                 In section .text, align 2, keep-with-next
    787          static  void  SerialDrv_RxStart (SERIAL_DEV  *pdev,
    788                                           SERIAL_ERR  *perr)
    789          {
   \                     SerialDrv_RxStart: (+1)
   \   00000000   0xB410             PUSH     {R4}
    790              SERIAL_DRV_REG  *p_reg;
    791              SERIAL_DEV_CFG  *p_cfg;
    792              
    793              
    794              p_cfg = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
    795              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;    
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
    796                                                                          /* Enable the Receive Data available & RX line Status.  */
    797              DEF_BIT_SET(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_RBR | SERIAL_DRV_LPCXXXX_BIT_IER_RX_LINE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF054 0x0405      ORRS     R4,R4,#0x5
   \   00000010   0x6054             STR      R4,[R2, #+4]
    798          
    799             *perr = SERIAL_ERR_NONE;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x800C             STRH     R4,[R1, #+0]
    800          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    801          
    802          
    803          /*$PAGE*/
    804          /*
    805          *********************************************************************************************************
    806          *                                         SerialDrv_RxStop()
    807          *
    808          * Description : Stop receiving data and data received interrupts.
    809          *
    810          * Argument(s) : pdev        Pointer to device.
    811          *
    812          *               perr        Pointer to variable that will receive the return error code from this function :
    813          *
    814          *                               SERIAL_ERR_NONE                 Device reception stopped.
    815          *
    816          * Return(s)   : None.
    817          *
    818          * Caller(s)   : Serial_Close(),
    819          *               Serial_IF_Rx(),
    820          *               Serial_IF_RxStop() via 'pdev->Drv_API->RxStop()'.
    821          *
    822          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    823          *********************************************************************************************************
    824          */
    825          

   \                                 In section .text, align 2, keep-with-next
    826          static  void  SerialDrv_RxStop (SERIAL_DEV  *pdev,
    827                                          SERIAL_ERR  *perr)
    828          {
   \                     SerialDrv_RxStop: (+1)
   \   00000000   0xB410             PUSH     {R4}
    829              SERIAL_DRV_REG  *p_reg;
    830              SERIAL_DEV_CFG  *p_cfg;
    831              
    832              
    833              p_cfg = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
    834              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
    835                  
    836                                                                          /* Disable the Receive Data available & RX line Status.  */
    837              DEF_BIT_CLR(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_RBR | SERIAL_DRV_LPCXXXX_BIT_IER_RX_LINE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF034 0x0405      BICS     R4,R4,#0x5
   \   00000010   0x6054             STR      R4,[R2, #+4]
    838          
    839             *perr = SERIAL_ERR_NONE;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x800C             STRH     R4,[R1, #+0]
    840          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    841          
    842          
    843          /*$PAGE*/
    844          /*
    845          *********************************************************************************************************
    846          *                                         SerialDrv_RxOctet()
    847          *
    848          * Description : Receive data octet.
    849          *
    850          * Argument(s) : pdev        Pointer to device.
    851          *
    852          *               pdatum      Pointer to variable that will receive the received data octet.
    853          *
    854          *               perr        Pointer to variable that will receive the return error code from this function :
    855          *
    856          *                               SERIAL_ERR_NONE                 Device octet     transmitted,
    857          *                               SERIAL_ERR_DRV_IO_ERR           Device octet NOT transmitted.
    858          *
    859          * Return(s)   : None.
    860          *
    861          * Caller(s)   : Serial_IF_Rx() via 'pdrv_api->RxOctet()'.
    862          *
    863          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    864          *********************************************************************************************************
    865          */
    866          

   \                                 In section .text, align 2, keep-with-next
    867          static  void  SerialDrv_RxOctet (SERIAL_DEV  *pdev,
    868                                           CPU_INT08U  *pdatum,
    869                                           SERIAL_ERR  *perr)
    870          {
   \                     SerialDrv_RxOctet: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    871              CPU_INT32U       reg_val;
    872              SERIAL_DRV_REG  *p_reg;
    873              SERIAL_DEV_CFG  *p_cfg;
    874              
    875              
    876              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6846             LDR      R6,[R0, #+4]
   \   00000004   0x0035             MOVS     R5,R6
    877              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x682E             LDR      R6,[R5, #+0]
   \   00000008   0x0034             MOVS     R4,R6
    878              reg_val = p_reg->LSR;
   \   0000000A   0x6966             LDR      R6,[R4, #+20]
   \   0000000C   0x0033             MOVS     R3,R6
    879              
    880                                                                          /* If the receive data doesn't contain data ...         */
    881              if (DEF_BIT_IS_CLR(reg_val, SERIAL_DRV_LPCXXXX_BIT_LSR_RDR)) {
   \   0000000E   0xF013 0x0601      ANDS     R6,R3,#0x1
   \   00000012   0xF096 0x0601      EORS     R6,R6,#0x1
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD002             BEQ.N    ??SerialDrv_RxOctet_0
    882                  *perr = SERIAL_ERR_DRV_IO_ERR;
   \   0000001C   0x2616             MOVS     R6,#+22
   \   0000001E   0x8016             STRH     R6,[R2, #+0]
    883                  return;    
   \   00000020   0xE009             B.N      ??SerialDrv_RxOctet_1
    884              }
    885                                                                          /* Check for Rx errors.                                 */
    886              if (DEF_BIT_IS_SET_ANY(reg_val, SERIAL_DRV_LPCXXXX_BIT_LSR_RX_ERR)) {
   \                     ??SerialDrv_RxOctet_0: (+1)
   \   00000022   0xF013 0x0F0E      TST      R3,#0xE
   \   00000026   0xD002             BEQ.N    ??SerialDrv_RxOctet_2
    887                  *perr = SERIAL_ERR_DRV_IO_ERR;
   \   00000028   0x2616             MOVS     R6,#+22
   \   0000002A   0x8016             STRH     R6,[R2, #+0]
    888                  return;    
   \   0000002C   0xE003             B.N      ??SerialDrv_RxOctet_1
    889              }
    890              
    891              *pdatum = (CPU_INT08U)(p_reg->RBR & DEF_INT_08_MASK);
   \                     ??SerialDrv_RxOctet_2: (+1)
   \   0000002E   0x6826             LDR      R6,[R4, #+0]
   \   00000030   0x700E             STRB     R6,[R1, #+0]
    892              *perr  = SERIAL_ERR_NONE;    
   \   00000032   0x2600             MOVS     R6,#+0
   \   00000034   0x8016             STRH     R6,[R2, #+0]
    893          }
   \                     ??SerialDrv_RxOctet_1: (+1)
   \   00000036   0xBC70             POP      {R4-R6}
   \   00000038   0x4770             BX       LR               ;; return
    894          
    895          
    896          
    897          /*$PAGE*/
    898          /*
    899          *********************************************************************************************************
    900          *                                         SerialDrv_TxStart()
    901          *                                     SerialDrv_LPC3xxx_TxStart()
    902          *
    903          * Description : Start transmitting data & getting data transmitted interrupts.
    904          *
    905          * Argument(s) : pdev        Pointer to device.
    906          *
    907          *               perr        Pointer to variable that will receive the return error code from this function :
    908          *
    909          *                               SERIAL_ERR_NONE                 Device transmission started.
    910          *
    911          * Return(s)   : None.
    912          *
    913          * Caller(s)   : Serial_IF_Tx(),
    914          *               Serial_WrStart() via 'pdev->Drv_API->TxStart()'.
    915          *
    916          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    917          *********************************************************************************************************
    918          */
    919          

   \                                 In section .text, align 2, keep-with-next
    920          static  void  SerialDrv_TxStart (SERIAL_DEV  *pdev,
    921                                           SERIAL_ERR  *perr)
    922          {
   \                     SerialDrv_TxStart: (+1)
   \   00000000   0xB410             PUSH     {R4}
    923              SERIAL_DRV_REG  *p_reg;
    924              SERIAL_DEV_CFG  *p_cfg;
    925              
    926              
    927              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
    928              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
    929               
    930                                                                          /* Enable the transmit holding register empty interrupt */
    931              DEF_BIT_SET(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_THRE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   00000010   0x6054             STR      R4,[R2, #+4]
    932              DEF_BIT_SET(p_reg->TER, SERIAL_DRV_LPCXXXX_BIT_TER_TXEN);
   \   00000012   0x6AD4             LDR      R4,[R2, #+44]
   \   00000014   0xF054 0x0480      ORRS     R4,R4,#0x80
   \   00000018   0x62D4             STR      R4,[R2, #+44]
    933             *perr = SERIAL_ERR_NONE;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x800C             STRH     R4,[R1, #+0]
    934          }
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    935          
    936          

   \                                 In section .text, align 2, keep-with-next
    937          static  void  SerialDrv_LPC3xxx_TxStart (SERIAL_DEV  *pdev,
    938                                                   SERIAL_ERR  *perr)
    939          {
   \                     SerialDrv_LPC3xxx_TxStart: (+1)
   \   00000000   0xB410             PUSH     {R4}
    940              SERIAL_DRV_REG  *p_reg;
    941              SERIAL_DEV_CFG  *p_cfg;
    942              
    943              
    944              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
    945              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
    946               
    947                                                                          /* Enable the transmit holding register empty interrupt */
    948              DEF_BIT_SET(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_THRE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   00000010   0x6054             STR      R4,[R2, #+4]
    949             *perr = SERIAL_ERR_NONE;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x800C             STRH     R4,[R1, #+0]
    950          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
    951          
    952          
    953          /*$PAGE*/
    954          /*
    955          *********************************************************************************************************
    956          *                                         SerialDrv_TxStop()
    957          *                                     SerialDrv_LPC3xxx_TxStop()
    958          *
    959          * Description : Stop transmitting data & getting data transmitted interrupts.
    960          *
    961          * Argument(s) : pdev        Pointer to device.
    962          *
    963          *               perr        Pointer to variable that will receive the return error code from this function :
    964          *
    965          *                               SERIAL_ERR_NONE                 Device transmission stopped.
    966          *
    967          * Return(s)   : None.
    968          *
    969          * Caller(s)   : Serial_Close(),
    970          *               Serial_IF_Tx(),
    971          *               Serial_WrStartNext() via 'pdev->Drv_API->TxStop()'.
    972          *
    973          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    974          *********************************************************************************************************
    975          */
    976          

   \                                 In section .text, align 2, keep-with-next
    977          static  void  SerialDrv_TxStop (SERIAL_DEV  *pdev,
    978                                          SERIAL_ERR  *perr)
    979          {
   \                     SerialDrv_TxStop: (+1)
   \   00000000   0xB410             PUSH     {R4}
    980              SERIAL_DRV_REG  *p_reg;
    981              SERIAL_DEV_CFG  *p_cfg;
    982              
    983              
    984              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
    985              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
    986               
    987                                                                          /* Disable transmit holding register empty interrupt.   */
    988              DEF_BIT_CLR(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_THRE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF034 0x0402      BICS     R4,R4,#0x2
   \   00000010   0x6054             STR      R4,[R2, #+4]
    989              DEF_BIT_CLR(p_reg->TER, SERIAL_DRV_LPCXXXX_BIT_TER_TXEN);
   \   00000012   0x6AD4             LDR      R4,[R2, #+44]
   \   00000014   0xF034 0x0480      BICS     R4,R4,#0x80
   \   00000018   0x62D4             STR      R4,[R2, #+44]
    990          
    991             *perr = SERIAL_ERR_NONE;
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0x800C             STRH     R4,[R1, #+0]
    992          }
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    993          
    994          

   \                                 In section .text, align 2, keep-with-next
    995          static  void  SerialDrv_LPC3xxx_TxStop (SERIAL_DEV  *pdev,
    996                                                  SERIAL_ERR  *perr)
    997          {
   \                     SerialDrv_LPC3xxx_TxStop: (+1)
   \   00000000   0xB410             PUSH     {R4}
    998              SERIAL_DRV_REG  *p_reg;
    999              SERIAL_DEV_CFG  *p_cfg;
   1000              
   1001              
   1002              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6844             LDR      R4,[R0, #+4]
   \   00000004   0x0023             MOVS     R3,R4
   1003              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x681C             LDR      R4,[R3, #+0]
   \   00000008   0x0022             MOVS     R2,R4
   1004               
   1005                                                                          /* Disable transmit holding register empty interrupt.   */
   1006              DEF_BIT_CLR(p_reg->DLM, SERIAL_DRV_LPCXXXX_BIT_IER_THRE);
   \   0000000A   0x6854             LDR      R4,[R2, #+4]
   \   0000000C   0xF034 0x0402      BICS     R4,R4,#0x2
   \   00000010   0x6054             STR      R4,[R2, #+4]
   1007          
   1008             *perr = SERIAL_ERR_NONE;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0x800C             STRH     R4,[R1, #+0]
   1009          }
   \   00000016   0xBC10             POP      {R4}
   \   00000018   0x4770             BX       LR               ;; return
   1010          
   1011          
   1012          /*$PAGE*/
   1013          /*
   1014          *********************************************************************************************************
   1015          *                                         SerialDrv_TxOctet()
   1016          *
   1017          * Description : Transmit data octet.
   1018          *
   1019          * Argument(s) : pdev        Pointer to device.
   1020          *
   1021          *               datum       Data octet to transmit.
   1022          *
   1023          *               perr        Pointer to variable that will receive the return error code from this function :
   1024          *
   1025          *                               SERIAL_ERR_NONE                 Device octet     transmitted,
   1026          *                               SERIAL_ERR_DRV_IO_ERR           Device octet NOT transmitted.
   1027          *
   1028          * Return(s)   : None.
   1029          *
   1030          * Caller(s)   : Serial_IF_Tx()   via      'pdrv_api->TxOctet()',
   1031          *               Serial_WrStart() via 'pdev->Drv_API->TxOctet()'.
   1032          *
   1033          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
   1034          *********************************************************************************************************
   1035          */
   1036          

   \                                 In section .text, align 2, keep-with-next
   1037          static  void  SerialDrv_TxOctet (SERIAL_DEV  *pdev,
   1038                                           CPU_INT08U   datum,
   1039                                           SERIAL_ERR  *perr)
   1040          {
   \                     SerialDrv_TxOctet: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1041              CPU_INT08U       reg_val;
   1042              SERIAL_DRV_REG  *p_reg;
   1043              SERIAL_DEV_CFG  *p_cfg;    
   1044              
   1045              p_cfg   = pdev->Dev_Cfg;           
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0x001E             MOVS     R6,R3
   1046              p_reg   = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   00000006   0x6833             LDR      R3,[R6, #+0]
   \   00000008   0x001D             MOVS     R5,R3
   1047              reg_val = p_reg->LSR;
   \   0000000A   0x696B             LDR      R3,[R5, #+20]
   \   0000000C   0x001C             MOVS     R4,R3
   1048              
   1049              if (DEF_BIT_IS_CLR(reg_val, SERIAL_DRV_LPCXXXX_BIT_LSR_THRE)) {
   \   0000000E   0x0023             MOVS     R3,R4
   \   00000010   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000012   0x095B             LSRS     R3,R3,#+5
   \   00000014   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000018   0xF093 0x0301      EORS     R3,R3,#0x1
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD002             BEQ.N    ??SerialDrv_TxOctet_0
   1050                  *perr = SERIAL_ERR_DRV_IO_ERR;
   \   00000022   0x2316             MOVS     R3,#+22
   \   00000024   0x8013             STRH     R3,[R2, #+0]
   1051                  return;    
   \   00000026   0xE003             B.N      ??SerialDrv_TxOctet_1
   1052              }
   1053              
   1054              p_reg->RBR = datum;
   \                     ??SerialDrv_TxOctet_0: (+1)
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x6029             STR      R1,[R5, #+0]
   1055          
   1056             *perr = SERIAL_ERR_NONE;
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x8013             STRH     R3,[R2, #+0]
   1057          }
   \                     ??SerialDrv_TxOctet_1: (+1)
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
   1058          
   1059          
   1060          /*$PAGE*/
   1061          /*
   1062          *********************************************************************************************************
   1063          *                                       SerialDrv_ISR_Handler()
   1064          *
   1065          * Description : Handle serial interface's device interrupt service routine (ISR) function(s).
   1066          *
   1067          * Argument(s) : pdev        Pointer to device.
   1068          *
   1069          *               type        Device  interrupt type(s) to handle :
   1070          *
   1071          *                               SERIAL_ISR_TYPE_UNKNOWN         Handle unknown device           ISR(s).
   1072          *                               SERIAL_ISR_TYPE_RX              Handle device receive           ISR(s).
   1073          *                               SERIAL_ISR_TYPE_RX_OVERRUN      Handle device receive  overrun  ISR(s).
   1074          *                               SERIAL_ISR_TYPE_TX_RDY          Handle device transmit ready    ISR(s).
   1075          *                               SERIAL_ISR_TYPE_TX_COMPLETE     Handle device transmit complete ISR(s).
   1076          *                               SERIAL_ISR_TYPE_ERR             Handle device error             ISR(s).
   1077          *
   1078          * Return(s)   : None.
   1079          *
   1080          * Caller(s)   : Device driver(s)' Board Support Package (BSP) Interrupt Service Routine (ISR) handler(s).
   1081          *
   1082          * Note(s)     : None.
   1083          *********************************************************************************************************
   1084          */
   1085          

   \                                 In section .text, align 2, keep-with-next
   1086          static  void  SerialDrv_ISR_Handler (SERIAL_DEV  *pdev,
   1087                                               CPU_INT08U   type)
   1088          {
   \                     SerialDrv_ISR_Handler: (+1)
   \   00000000   0xE92D 0x47F3      PUSH     {R0,R1,R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1089              CPU_INT08U       datum;
   1090              CPU_INT32U       lsr;
   1091              CPU_INT32U       iir;
   1092              CPU_INT08U       iir_int_id;
   1093              SERIAL_DRV_REG  *p_reg;
   1094              SERIAL_DEV_CFG  *p_cfg;
   1095              
   1096          
   1097              (void)&type;
   \   00000006   0xA801             ADD      R0,SP,#+4
   1098              p_cfg = pdev->Dev_Cfg;           
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x4682             MOV      R10,R0
   1099              p_reg = (SERIAL_DRV_REG *)p_cfg->BaseAddr;
   \   0000000C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000010   0x4681             MOV      R9,R0
   1100              iir   = p_reg->IIR;                                         /* Read te interrupt indentification register           */
   \   00000012   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000016   0x0007             MOVS     R7,R0
   1101                                                                          /* If at least one interrupt is pending ...             */
   1102              while (DEF_BIT_IS_CLR(iir, SERIAL_DRV_LPCXXXX_BIT_IIR_INT_STAT)) {
   \                     ??SerialDrv_ISR_Handler_0: (+1)
   \   00000018   0xF017 0x0001      ANDS     R0,R7,#0x1
   \   0000001C   0xF090 0x0001      EORS     R0,R0,#0x1
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD02E             BEQ.N    ??SerialDrv_ISR_Handler_1
   1103                  iir_int_id = (CPU_INT08U)((iir & SERIAL_DRV_LPCXXXX_MSK_IIR_INT_ID) >> 1u);
   \   00000026   0xF3C7 0x0042      UBFX     R0,R7,#+1,#+3
   \   0000002A   0x4680             MOV      R8,R0
   1104                  switch (iir_int_id) {
   \   0000002C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD01E             BEQ.N    ??SerialDrv_ISR_Handler_2
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD008             BEQ.N    ??SerialDrv_ISR_Handler_3
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD002             BEQ.N    ??SerialDrv_ISR_Handler_4
   \   0000003E   0x2806             CMP      R0,#+6
   \   00000040   0xD004             BEQ.N    ??SerialDrv_ISR_Handler_3
   \   00000042   0xE01B             B.N      ??SerialDrv_ISR_Handler_5
   1105                      case SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_RLS:         /*Rx Line Status                                        */
   1106                           lsr = p_reg->LSR;                 
   \                     ??SerialDrv_ISR_Handler_4: (+1)
   \   00000044   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   00000048   0x0006             MOVS     R6,R0
   1107                           break;
   \   0000004A   0xE017             B.N      ??SerialDrv_ISR_Handler_6
   1108                     
   1109                      case SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_CTI:         /* Character time-out                                   */
   1110                      case SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_RDA:         /* Rx data available                                    */
   1111                           lsr = p_reg->LSR;                             
   \                     ??SerialDrv_ISR_Handler_3: (+1)
   \   0000004C   0xF8D9 0x0014      LDR      R0,[R9, #+20]
   \   00000050   0x0006             MOVS     R6,R0
   1112                           if (DEF_BIT_IS_CLR(lsr, SERIAL_DRV_LPCXXXX_BIT_LSR_RX_ERR)) {
   \   00000052   0xF016 0x0F0E      TST      R6,#0xE
   \   00000056   0xD101             BNE.N    ??SerialDrv_ISR_Handler_7
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE000             B.N      ??SerialDrv_ISR_Handler_8
   \                     ??SerialDrv_ISR_Handler_7: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??SerialDrv_ISR_Handler_8: (+1)
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD007             BEQ.N    ??SerialDrv_ISR_Handler_9
   1113                               datum = (CPU_INT08U)(p_reg->RBR & DEF_INT_08_MASK);    
   \   00000062   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000066   0x0005             MOVS     R5,R0
   1114                               SerialIF_Rx(pdev, datum);                 
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       SerialIF_Rx
   1115                           }            
   1116                           break;
   \                     ??SerialDrv_ISR_Handler_9: (+1)
   \   00000072   0xE003             B.N      ??SerialDrv_ISR_Handler_6
   1117                           
   1118                      case SERIAL_DRV_LPCXXXX_BIT_IIR_INT_ID_THRE:        /* Transmit Holding register                            */
   1119                           SerialIF_Tx(pdev);                             /* Inform serial core of wr completion.                 */
   \                     ??SerialDrv_ISR_Handler_2: (+1)
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       SerialIF_Tx
   1120                           break;
   \   0000007A   0xE7FF             B.N      ??SerialDrv_ISR_Handler_6
   1121                           
   1122                      default:
   1123                          break;
   1124                  }
   1125                  iir = p_reg->IIR;
   \                     ??SerialDrv_ISR_Handler_5: (+1)
   \                     ??SerialDrv_ISR_Handler_6: (+1)
   \   0000007C   0xF8D9 0x0008      LDR      R0,[R9, #+8]
   \   00000080   0x0007             MOVS     R7,R0
   \   00000082   0xE7C9             B.N      ??SerialDrv_ISR_Handler_0
   1126              }
   1127          }
   \                     ??SerialDrv_ISR_Handler_1: (+1)
   \   00000084   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SerialDrv_Close
        24   -- Indirect call
      40   SerialDrv_ISR_Handler
        40   -> SerialIF_Rx
        40   -> SerialIF_Tx
       0   SerialDrv_Init
      24   SerialDrv_LPC3xxx_Close
        24   -- Indirect call
      40   SerialDrv_LPC3xxx_Open
        40   -- Indirect call
       4   SerialDrv_LPC3xxx_TxStart
       4   SerialDrv_LPC3xxx_TxStop
      72   SerialDrv_Open
        72   -- Indirect call
      12   SerialDrv_RxOctet
       4   SerialDrv_RxStart
       4   SerialDrv_RxStop
      12   SerialDrv_TxOctet
       4   SerialDrv_TxStart
       4   SerialDrv_TxStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      58  SerialDrv_Close
     136  SerialDrv_ISR_Handler
       6  SerialDrv_Init
      40  SerialDrv_LPC3xxx_API
      54  SerialDrv_LPC3xxx_Close
     340  SerialDrv_LPC3xxx_Open
      26  SerialDrv_LPC3xxx_TxStart
      26  SerialDrv_LPC3xxx_TxStop
      40  SerialDrv_LPCxxxx_API
     610  SerialDrv_Open
      58  SerialDrv_RxOctet
      26  SerialDrv_RxStart
      26  SerialDrv_RxStop
      52  SerialDrv_TxOctet
      34  SerialDrv_TxStart
      34  SerialDrv_TxStop

 
    80 bytes in section .rodata
 1 486 bytes in section .text
 
 1 486 bytes of CODE  memory
    80 bytes of CONST memory

Errors: none
Warnings: none
