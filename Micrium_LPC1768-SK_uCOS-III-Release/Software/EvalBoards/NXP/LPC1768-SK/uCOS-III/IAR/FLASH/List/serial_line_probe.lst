###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:13
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Line\serial_line_probe.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Line\serial_line_probe.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\serial_line_probe.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\serial_line_probe.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\Line\serial_line_probe.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     SERIAL (BYTE) COMMUNICATION
      4          *
      5          *                         (c) Copyright 2007-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     SERIAL (BYTE) COMMUNICATION
     18          *
     19          *                                         SERIAL LINE DRIVER
     20          *                                                PROBE
     21          *
     22          * Filename      : serial_line_probe.c
     23          * Version       : V2.00
     24          * Programmer(s) : FGK
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                            INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define    SERIAL_LINE_PROBE_MODULE
     35          #include  <serial.h>
     36          #include  <serial_line_probe.h>
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          
     46          /*
     47          *********************************************************************************************************
     48          *                                        SERIAL PACKET FORMAT
     49          *
     50          * Note(s):  (1) All packets include the following parts:
     51          *
     52          *                   (A)  4 1-byte start delimiters, forming the ASCII representation of "uCPr".  These
     53          *                        are the constants PROBE_SERIAL_PROTOCOL_?X_SD0-PROBE_SERIAL_PROTOCOL_?X_SD4;
     54          *                   (B)  1 2-byte length, the length of the data segment;
     55          *                   (C)  1 2-byte padding, unused;
     56          *                   (D)  n   bytes of data; and
     57          *                   (E)  1 1-byte checksum; and
     58          *                   (F)  1 1-byte end delimiter, the character '/', which is the constant PROBE_SERIAL_PROTOCOL_?X_ED.
     59          *
     60          *                                       +-------------------+-------------------+
     61          *                                       |   'u'   |   'C'   |   'P'   |   'r'   |
     62          *                                       +-------------------+-------------------+
     63          *                                       |       Length      | PktCtr  | Padding |
     64          *                                       +-------------------+-------------------+
     65          *                                       |                  Data                 |   The data segment does not need to end on
     66          *                                       |                   .                   |   a four-byte boundary, as might be inferred
     67          *                                       |                   .                   |   from this diagram.
     68          *                                       |                   .                   |
     69          *                                       +-------------------+-------------------+
     70          *                                       | Checksum|   '/'   |
     71          *                                       +-------------------+
     72          *********************************************************************************************************
     73          */
     74          
     75                                                                          /* ------------- INBOUND PACKET DELIMITERS ------------ */
     76          #define  SERIAL_LINE_PROBE_PROTOCOL_RX_SD0              0x75    /* Start delimiters.                                    */
     77          #define  SERIAL_LINE_PROBE_PROTOCOL_RX_SD1              0x43
     78          #define  SERIAL_LINE_PROBE_PROTOCOL_RX_SD2              0x50
     79          #define  SERIAL_LINE_PROBE_PROTOCOL_RX_SD3              0x72
     80          #define  SERIAL_LINE_PROBE_PROTOCOL_RX_ED               0x2F    /* End   delimiter.                                     */
     81          
     82                                                                          /* ------------ OUTBOUND PACKET DELIMITERS ------------ */
     83          #define  SERIAL_LINE_PROBE_PROTOCOL_TX_SD0              0x75    /* Start delimiters.                                    */
     84          #define  SERIAL_LINE_PROBE_PROTOCOL_TX_SD1              0x43
     85          #define  SERIAL_LINE_PROBE_PROTOCOL_TX_SD2              0x50
     86          #define  SERIAL_LINE_PROBE_PROTOCOL_TX_SD3              0x72
     87          #define  SERIAL_LINE_PROBE_PROTOCOL_TX_ED               0x2F    /* End   delimiter.                                     */
     88          
     89                                                                          /* ----------- RECEIVE STATE MACHINE STATES ----------- */
     90          #define  SERIAL_LINE_PROBE_RX_STATE_SD0                    0    /* Waiting for start first  start delimiter (SD0).      */
     91          #define  SERIAL_LINE_PROBE_RX_STATE_SD1                    1    /* Waiting for start second start delimiter (SD1).      */
     92          #define  SERIAL_LINE_PROBE_RX_STATE_SD2                    2    /* Waiting for start third  start delimiter (SD2).      */
     93          #define  SERIAL_LINE_PROBE_RX_STATE_SD3                    3    /* Waiting for start fourth start delimiter (SD3).      */
     94          #define  SERIAL_LINE_PROBE_RX_STATE_LEN1                   4    /* Waiting for length,  first  byte.                    */
     95          #define  SERIAL_LINE_PROBE_RX_STATE_LEN2                   5    /* Waiting for length,  second byte.                    */
     96          #define  SERIAL_LINE_PROBE_RX_STATE_CTR                    6    /* Waiting for packet counter.                          */
     97          #define  SERIAL_LINE_PROBE_RX_STATE_PAD                    7    /* Waiting for padding byte.                            */
     98          #define  SERIAL_LINE_PROBE_RX_STATE_DATA                   8    /* Waiting for data.                                    */
     99          #define  SERIAL_LINE_PROBE_RX_STATE_CHKSUM                 9    /* Waiting for checksum.                                */
    100          #define  SERIAL_LINE_PROBE_RX_STATE_ED                    10    /* Waiting for end delimiter.                           */
    101          
    102                                                                          /* ---------- TRANSMIT STATE MACHINE STATES ----------- */
    103          #define  SERIAL_LINE_PROBE_TX_STATE_SD0                    0    /* Waiting to send start first  start delim. (SD0).     */
    104          #define  SERIAL_LINE_PROBE_TX_STATE_SD1                    1    /* Waiting to send start second start delim. (SD1).     */
    105          #define  SERIAL_LINE_PROBE_TX_STATE_SD2                    2    /* Waiting to send start third  start delim. (SD2).     */
    106          #define  SERIAL_LINE_PROBE_TX_STATE_SD3                    3    /* Waiting to send start fourth start delim. (SD3).     */
    107          #define  SERIAL_LINE_PROBE_TX_STATE_LEN1                   4    /* Waiting to send length,  first  byte.                */
    108          #define  SERIAL_LINE_PROBE_TX_STATE_LEN2                   5    /* Waiting to send length,  second byte.                */
    109          #define  SERIAL_LINE_PROBE_TX_STATE_CTR                    6    /* Waiting to send packet counter.                      */
    110          #define  SERIAL_LINE_PROBE_TX_STATE_PAD                    7    /* Waiting to send padding byte.                        */
    111          #define  SERIAL_LINE_PROBE_TX_STATE_DATA                   8    /* Waiting to send data.                                */
    112          #define  SERIAL_LINE_PROBE_TX_STATE_CHKSUM                 9    /* Waiting to send checksum.                            */
    113          #define  SERIAL_LINE_PROBE_TX_STATE_ED                    10    /* Waiting to send end delimiter.                       */
    114          #define  SERIAL_LINE_PROBE_TX_STATE_LAST                  11    /* Final byte sent.                                     */
    115          
    116          #define  SERIAL_LINE_PROBE_USE_CHECKSUM            DEF_FALSE    /* DO NOT CHANGE.                                       */
    117          
    118          
    119          /*
    120          *********************************************************************************************************
    121          *                                        FORWARD DECLARATIONS
    122          *********************************************************************************************************
    123          */
    124          
    125          typedef  struct  serial_line_probe_info  SERIAL_LINE_INFO;
    126          
    127          
    128          /*
    129          *********************************************************************************************************
    130          *                                          LOCAL DATA TYPES
    131          *********************************************************************************************************
    132          */
    133          
    134          struct  serial_line_probe_info {
    135              SERIAL_LINE_INFO  *NextPtr;                                 /* Ptr to next serial line info struct.                 */
    136          
    137              CPU_INT08U         RxState;                                 /* Rx state machine state.                              */
    138              CPU_SIZE_T         RxLenRem;
    139              CPU_INT08U         RxPktCtr;
    140          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    141              CPU_INT08U         RxChkSum;
    142          #endif
    143              CPU_INT08U         TxState;                                 /* Tx state machine state.                              */
    144          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    145              CPU_INT08U         TxChkSum;
    146          #endif    
    147          };
    148          
    149          
    150          /*
    151          *********************************************************************************************************
    152          *                                       LOCAL GLOBAL VARIABLES
    153          *********************************************************************************************************
    154          */
    155          

   \                                 In section .bss, align 4
    156          static  SERIAL_LINE_INFO  *SerialLine_Probe_Info = (SERIAL_LINE_INFO *)0;
   \                     SerialLine_Probe_Info:
   \   00000000                      DS8 4
    157          
    158          
    159          /*
    160          *********************************************************************************************************
    161          *                                      LOCAL FUNCTION PROTOTYPES
    162          *********************************************************************************************************
    163          */
    164                                                                          /* Open  line driver.                                   */
    165          static  void  *SerialLine_Open   (SERIAL_DEV  *pdev,
    166                                            SERIAL_ERR  *perr);
    167                                                                          /* Close line driver.                                   */
    168          static  void   SerialLine_Close  (SERIAL_DEV  *pdev,
    169                                            void        *pline_data,
    170                                            SERIAL_ERR  *perr);
    171                                                                          /* Rd octet from buf via protocol.                      */
    172          static  void   SerialLine_RdOctet(SERIAL_DEV  *pdev,
    173                                            SERIAL_BUF  *pbuf,
    174                                            CPU_INT08U  *pdatum,
    175                                            SERIAL_ERR  *perr);
    176                                                                          /* Wr octet into buf via protocol.                      */
    177          static  void   SerialLine_WrOctet(SERIAL_DEV  *pdev,
    178                                            SERIAL_BUF  *pbuf,
    179                                            CPU_INT08U   datum,
    180                                            SERIAL_ERR  *perr);
    181          
    182          
    183          /*
    184          *********************************************************************************************************
    185          *********************************************************************************************************
    186          *                                  SERIAL INTERFACE LINE DRIVER API
    187          *********************************************************************************************************
    188          *********************************************************************************************************
    189          */
    190          

   \                                 In section .rodata, align 4
    191          SERIAL_LINE_DRV_API  SerialLine_Probe = {
   \                     SerialLine_Probe:
   \   00000000   0x........         DC32 SerialLine_Open, SerialLine_Close, SerialLine_RdOctet
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 SerialLine_WrOctet
    192              SerialLine_Open,
    193              SerialLine_Close,
    194              SerialLine_RdOctet,
    195              SerialLine_WrOctet
    196          };
    197          
    198          
    199          /*$PAGE*/
    200          /*
    201          *********************************************************************************************************
    202          *********************************************************************************************************
    203          *                                     DRIVER INTERFACE FUNCTIONS
    204          *********************************************************************************************************
    205          *********************************************************************************************************
    206          */
    207          
    208          /*
    209          *********************************************************************************************************
    210          *                                          SerialLine_Open()
    211          *
    212          * Description : Open serial line driver.
    213          *
    214          * Argument(s) : pdev        Pointer to device.
    215          *
    216          *               perr        Pointer to variable that will receive the return error code from this function :
    217          *
    218          *                               SERIAL_ERR_NONE                 Serial line driver              opened.
    219          *                               SERIAL_ERR_LINE_OPEN            Serial line driver could NOT be opened.
    220          *
    221          * Return(s)   : Pointer to line driver data.
    222          *
    223          * Caller(s)   : Serial_Open().
    224          *
    225          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    226          *********************************************************************************************************
    227          */
    228          

   \                                 In section .text, align 2, keep-with-next
    229          static  void  *SerialLine_Open (SERIAL_DEV  *pdev,
    230                                          SERIAL_ERR  *perr)
    231          {
   \                     SerialLine_Open: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    232              SERIAL_LINE_INFO  *pinfo;
    233              CPU_SIZE_T         octets_reqd;
    234              LIB_ERR            lib_err;
    235          
    236          
    237             (void)&pdev;
   \   00000006   0xA802             ADD      R0,SP,#+8
    238          
    239              pinfo = SerialLine_Probe_Info;
   \   00000008   0x....             LDR.N    R0,??DataTable1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x0005             MOVS     R5,R0
    240              if (pinfo == (SERIAL_LINE_INFO *)0) {                       /* Find avail Probe info struct.                        */
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD10C             BNE.N    ??SerialLine_Open_0
    241                  pinfo  = (SERIAL_LINE_INFO *)Mem_HeapAlloc((CPU_SIZE_T  ) sizeof(SERIAL_LINE_INFO),
    242                                                             (CPU_SIZE_T  ) sizeof(CPU_ALIGN),
    243                                                             (CPU_SIZE_T *)&octets_reqd,
    244                                                             (LIB_ERR    *)&lib_err);
   \   00000012   0x466B             MOV      R3,SP
   \   00000014   0xAA01             ADD      R2,SP,#+4
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0x2010             MOVS     R0,#+16
   \   0000001A   0x.... 0x....      BL       Mem_HeapAlloc
   \   0000001E   0x0005             MOVS     R5,R0
    245                  if (pinfo == (SERIAL_LINE_INFO *)0) {
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD106             BNE.N    ??SerialLine_Open_1
    246                     *perr = SERIAL_ERR_LINE_DRV_OPEN;
   \   00000024   0x2034             MOVS     R0,#+52
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    247                      return ((void *)0);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE00F             B.N      ??SerialLine_Open_2
    248                  }
    249              } else {
    250                  SerialLine_Probe_Info = pinfo->NextPtr;
   \                     ??SerialLine_Open_0: (+1)
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0x....             LDR.N    R1,??DataTable1
   \   00000030   0x6008             STR      R0,[R1, #+0]
    251              }
    252          
    253              pinfo->NextPtr  = (SERIAL_LINE_INFO *)0;
   \                     ??SerialLine_Open_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6028             STR      R0,[R5, #+0]
    254          
    255              pinfo->RxState  = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7128             STRB     R0,[R5, #+4]
    256              pinfo->RxLenRem = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x60A8             STR      R0,[R5, #+8]
    257              pinfo->RxPktCtr = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7328             STRB     R0,[R5, #+12]
    258          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    259              pinfo->RxChkSum = 0;
    260          #endif
    261          
    262              pinfo->TxState  = SERIAL_LINE_PROBE_TX_STATE_SD0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7368             STRB     R0,[R5, #+13]
    263          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    264              pinfo->TxChkSum = 0;
    265          #endif
    266          
    267             *perr = SERIAL_ERR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x8020             STRH     R0,[R4, #+0]
    268          
    269              return ((void *)pinfo);
   \   0000004A   0x0028             MOVS     R0,R5
   \                     ??SerialLine_Open_2: (+1)
   \   0000004C   0xBD3E             POP      {R1-R5,PC}       ;; return
    270          }
    271          
    272          
    273          /*$PAGE*/
    274          /*
    275          *********************************************************************************************************
    276          *                                         SerialLine_Close()
    277          *
    278          * Description : Close serial line driver.
    279          *
    280          * Argument(s) : pdev        Pointer to device.
    281          *
    282          *               pline_data  Pointer to line driver data structure.
    283          *
    284          *               perr        Pointer to variable that will receive the return error code from this function :
    285          *
    286          *                               SERIAL_ERR_NONE                 Serial line driver closed.
    287          *
    288          * Return(s)   : None.
    289          *
    290          * Caller(s)   : Serial_Close().
    291          *
    292          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    293          *********************************************************************************************************
    294          */
    295          

   \                                 In section .text, align 2, keep-with-next
    296          static  void  SerialLine_Close (SERIAL_DEV  *pdev,
    297                                          void        *pline_data,
    298                                          SERIAL_ERR  *perr)
    299          {
   \                     SerialLine_Close: (+1)
   \   00000000   0xB401             PUSH     {R0}
    300              SERIAL_LINE_INFO  *pinfo;
    301          
    302          
    303             (void)&pdev;
   \   00000002   0x466B             MOV      R3,SP
    304          
    305              pinfo = (SERIAL_LINE_INFO *)pline_data;
   \   00000004   0x0008             MOVS     R0,R1
    306          
    307              pinfo->RxState  = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x7103             STRB     R3,[R0, #+4]
    308              pinfo->RxLenRem = 0;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x6083             STR      R3,[R0, #+8]
    309          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    310              pinfo->RxChkSum = 0;
    311          #endif
    312          
    313              pinfo->TxState  = SERIAL_LINE_PROBE_TX_STATE_SD0;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x7343             STRB     R3,[R0, #+13]
    314          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    315              pinfo->TxChkSum = 0;
    316          #endif
    317          
    318          
    319              pinfo->NextPtr        = SerialLine_Probe_Info;
   \   00000012   0x....             LDR.N    R3,??DataTable1
   \   00000014   0x681B             LDR      R3,[R3, #+0]
   \   00000016   0x6003             STR      R3,[R0, #+0]
    320              SerialLine_Probe_Info = pinfo;
   \   00000018   0x....             LDR.N    R3,??DataTable1
   \   0000001A   0x6018             STR      R0,[R3, #+0]
    321          
    322          
    323             *perr = SERIAL_ERR_NONE;
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x8013             STRH     R3,[R2, #+0]
    324          }
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0x4770             BX       LR               ;; return
    325          
    326          
    327          /*$PAGE*/
    328          /*
    329          *********************************************************************************************************
    330          *                                        SerialLine_RdOctet()
    331          *
    332          * Description : Get next octet to transmit.
    333          *
    334          * Argument(s) : pdev        Pointer to device .
    335          *
    336          *               pbuf        Pointer to buffer.
    337          *
    338          *               pdatum      Pointer to variable that will receive data octet.
    339          *
    340          *               perr        Pointer to variable that will receive the return error code from this function :
    341          *
    342          *                               SERIAL_ERR_NONE                 Octet supplied.
    343          *                               SERIAL_ERR_UNDERFLOW            Buffer underflow.
    344          *
    345          * Return(s)   : None.
    346          *
    347          * Caller(s)   : Serial_IF_Tx().
    348          *
    349          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    350          *********************************************************************************************************
    351          */
    352          

   \                                 In section .text, align 2, keep-with-next
    353          static  void  SerialLine_RdOctet (SERIAL_DEV  *pdev,
    354                                            SERIAL_BUF  *pbuf,
    355                                            CPU_INT08U  *pdatum,
    356                                            SERIAL_ERR  *perr)
    357          {
   \                     SerialLine_RdOctet: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    358              CPU_BOOLEAN        empty;
    359              CPU_INT08U         datum;
    360              CPU_BOOLEAN        rd;
    361              CPU_INT08U         state;
    362              CPU_INT08U         state_next;
    363              SERIAL_LINE_INFO  *pinfo;
    364          
    365          
    366              pinfo = (SERIAL_LINE_INFO *)pdev->LineDrv_Data;
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x4683             MOV      R11,R0
    367          
    368              state      = pinfo->TxState;
   \   00000010   0xF89B 0x000D      LDRB     R0,[R11, #+13]
   \   00000014   0x4681             MOV      R9,R0
    369              state_next = state;
   \   00000016   0x46CA             MOV      R10,R9
    370          
    371              switch (state) {
   \   00000018   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000020   0xD014             BEQ.N    ??SerialLine_RdOctet_0
   \   00000022   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000026   0xD029             BEQ.N    ??SerialLine_RdOctet_1
   \   00000028   0xD322             BCC.N    ??SerialLine_RdOctet_2
   \   0000002A   0xF1B9 0x0F04      CMP      R9,#+4
   \   0000002E   0xD031             BEQ.N    ??SerialLine_RdOctet_3
   \   00000030   0xD32A             BCC.N    ??SerialLine_RdOctet_4
   \   00000032   0xF1B9 0x0F06      CMP      R9,#+6
   \   00000036   0xD03E             BEQ.N    ??SerialLine_RdOctet_5
   \   00000038   0xD334             BCC.N    ??SerialLine_RdOctet_6
   \   0000003A   0xF1B9 0x0F08      CMP      R9,#+8
   \   0000003E   0xD047             BEQ.N    ??SerialLine_RdOctet_7
   \   00000040   0xD340             BCC.N    ??SerialLine_RdOctet_8
   \   00000042   0xF1B9 0x0F0A      CMP      R9,#+10
   \   00000046   0xD05C             BEQ.N    ??SerialLine_RdOctet_9
   \   00000048   0xD355             BCC.N    ??SerialLine_RdOctet_10
   \   0000004A   0xE060             B.N      ??SerialLine_RdOctet_11
    372                  case SERIAL_LINE_PROBE_TX_STATE_SD0:                    /* Tx start 1st start delimiter (SD0).                  */
    373                       empty = SerialBuf_IsEmpty(pbuf);
   \                     ??SerialLine_RdOctet_0: (+1)
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       SerialBuf_IsEmpty
   \   00000052   0xF88D 0x0001      STRB     R0,[SP, #+1]
    374                       if (empty == DEF_YES) {
   \   00000056   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD102             BNE.N    ??SerialLine_RdOctet_12
    375                          *perr = SERIAL_ERR_UNDERFLOW;
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x8038             STRH     R0,[R7, #+0]
    376                           return;
   \   00000062   0xE063             B.N      ??SerialLine_RdOctet_13
    377                       }
    378          
    379                       datum      = SERIAL_LINE_PROBE_PROTOCOL_TX_SD0;
   \                     ??SerialLine_RdOctet_12: (+1)
   \   00000064   0x2075             MOVS     R0,#+117
   \   00000066   0xF88D 0x0000      STRB     R0,[SP, #+0]
    380                       state_next = SERIAL_LINE_PROBE_TX_STATE_SD1;
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x4682             MOV      R10,R0
    381                       break;
   \   0000006E   0xE056             B.N      ??SerialLine_RdOctet_14
    382          
    383          
    384                  case SERIAL_LINE_PROBE_TX_STATE_SD1:                    /* Tx start 2nd start delimiter (SD1).                  */
    385                       datum      = SERIAL_LINE_PROBE_PROTOCOL_TX_SD1;
   \                     ??SerialLine_RdOctet_2: (+1)
   \   00000070   0x2043             MOVS     R0,#+67
   \   00000072   0xF88D 0x0000      STRB     R0,[SP, #+0]
    386                       state_next = SERIAL_LINE_PROBE_TX_STATE_SD2;
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x4682             MOV      R10,R0
    387                       break;
   \   0000007A   0xE050             B.N      ??SerialLine_RdOctet_14
    388          
    389          
    390                  case SERIAL_LINE_PROBE_TX_STATE_SD2:                    /* Tx start 3rd start delimiter (SD2).                  */
    391                       datum      = SERIAL_LINE_PROBE_PROTOCOL_TX_SD2;
   \                     ??SerialLine_RdOctet_1: (+1)
   \   0000007C   0x2050             MOVS     R0,#+80
   \   0000007E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    392                       state_next = SERIAL_LINE_PROBE_TX_STATE_SD3;
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0x4682             MOV      R10,R0
    393                       break;
   \   00000086   0xE04A             B.N      ??SerialLine_RdOctet_14
    394          
    395          
    396                  case SERIAL_LINE_PROBE_TX_STATE_SD3:                    /* Tx start 4th start delimiter (SD3).                  */
    397                       datum      = SERIAL_LINE_PROBE_PROTOCOL_TX_SD3;
   \                     ??SerialLine_RdOctet_4: (+1)
   \   00000088   0x2072             MOVS     R0,#+114
   \   0000008A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    398                       state_next = SERIAL_LINE_PROBE_TX_STATE_LEN1;
   \   0000008E   0x2004             MOVS     R0,#+4
   \   00000090   0x4682             MOV      R10,R0
    399                       break;
   \   00000092   0xE044             B.N      ??SerialLine_RdOctet_14
    400          
    401          
    402                  case SERIAL_LINE_PROBE_TX_STATE_LEN1:                   /* Tx 1st len byte.                                     */
    403                       datum      = SerialBuf_Size(pbuf) & 0xFF;
   \                     ??SerialLine_RdOctet_3: (+1)
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0x.... 0x....      BL       SerialBuf_Size
   \   0000009A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    404                       state_next = SERIAL_LINE_PROBE_TX_STATE_LEN2;
   \   0000009E   0x2005             MOVS     R0,#+5
   \   000000A0   0x4682             MOV      R10,R0
    405          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    406                       pinfo->TxChkSum = datum;
    407          #endif
    408                       break;
   \   000000A2   0xE03C             B.N      ??SerialLine_RdOctet_14
    409          
    410          
    411                  case SERIAL_LINE_PROBE_TX_STATE_LEN2:                   /* Tx 2nd len byte.                                     */
    412                       datum      = (CPU_INT08U)(SerialBuf_Size(pbuf) >> 8);
   \                     ??SerialLine_RdOctet_6: (+1)
   \   000000A4   0x0028             MOVS     R0,R5
   \   000000A6   0x.... 0x....      BL       SerialBuf_Size
   \   000000AA   0x0A00             LSRS     R0,R0,#+8
   \   000000AC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    413                       state_next =  SERIAL_LINE_PROBE_TX_STATE_CTR;
   \   000000B0   0x2006             MOVS     R0,#+6
   \   000000B2   0x4682             MOV      R10,R0
    414          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    415                       pinfo->TxChkSum += datum;
    416          #endif
    417                       break;
   \   000000B4   0xE033             B.N      ??SerialLine_RdOctet_14
    418          
    419          
    420                  case SERIAL_LINE_PROBE_TX_STATE_CTR:                   /* Tx packet counter.                                    */                          
    421                       datum      = pinfo->RxPktCtr;
   \                     ??SerialLine_RdOctet_5: (+1)
   \   000000B6   0xF89B 0x000C      LDRB     R0,[R11, #+12]
   \   000000BA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    422                       state_next = SERIAL_LINE_PROBE_TX_STATE_PAD;
   \   000000BE   0x2007             MOVS     R0,#+7
   \   000000C0   0x4682             MOV      R10,R0
    423          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    424                       pinfo->TxChkSum += datum;
    425          #endif
    426                       break;
   \   000000C2   0xE02C             B.N      ??SerialLine_RdOctet_14
    427          
    428          
    429                  case SERIAL_LINE_PROBE_TX_STATE_PAD:                    /* Tx padding byte.                                     */
    430                       datum      = 0;
   \                     ??SerialLine_RdOctet_8: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    431                       state_next = SERIAL_LINE_PROBE_TX_STATE_DATA;
   \   000000CA   0x2008             MOVS     R0,#+8
   \   000000CC   0x4682             MOV      R10,R0
    432          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    433                       pinfo->TxChkSum += datum;
    434          #endif
    435                       break;
   \   000000CE   0xE026             B.N      ??SerialLine_RdOctet_14
    436          
    437          
    438                  case SERIAL_LINE_PROBE_TX_STATE_DATA:                   /* Tx data.                                             */
    439                       rd = SerialBuf_RdOctet(pbuf, &datum);
   \                     ??SerialLine_RdOctet_7: (+1)
   \   000000D0   0x4669             MOV      R1,SP
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x.... 0x....      BL       SerialBuf_RdOctet
   \   000000D8   0x4680             MOV      R8,R0
    440                       if (rd == DEF_NO) {
   \   000000DA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000E2   0xD105             BNE.N    ??SerialLine_RdOctet_15
    441                           datum      = 0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    442                           state_next = SERIAL_LINE_PROBE_TX_STATE_ED;
   \   000000EA   0x200A             MOVS     R0,#+10
   \   000000EC   0x4682             MOV      R10,R0
   \   000000EE   0xE001             B.N      ??SerialLine_RdOctet_16
    443                       } else {
    444          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    445                           pinfo->TxChkSum += datum;
    446          #endif
    447                           state_next = SERIAL_LINE_PROBE_TX_STATE_DATA;
   \                     ??SerialLine_RdOctet_15: (+1)
   \   000000F0   0x2008             MOVS     R0,#+8
   \   000000F2   0x4682             MOV      R10,R0
    448                       }
    449                       break;
   \                     ??SerialLine_RdOctet_16: (+1)
   \   000000F4   0xE013             B.N      ??SerialLine_RdOctet_14
    450          
    451          
    452                  case SERIAL_LINE_PROBE_TX_STATE_CHKSUM:                 /* Tx checksum.                                         */
    453          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    454                       datum      = pinfo->TxChkSum;
    455          #else
    456                       datum      = 0;
   \                     ??SerialLine_RdOctet_10: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    457          #endif
    458                       state_next = SERIAL_LINE_PROBE_TX_STATE_ED;
   \   000000FC   0x200A             MOVS     R0,#+10
   \   000000FE   0x4682             MOV      R10,R0
    459                       break;
   \   00000100   0xE00D             B.N      ??SerialLine_RdOctet_14
    460          
    461          
    462                  case SERIAL_LINE_PROBE_TX_STATE_ED:                     /* Tx end delimiter.                                    */
    463                       datum      = SERIAL_LINE_PROBE_PROTOCOL_TX_ED;
   \                     ??SerialLine_RdOctet_9: (+1)
   \   00000102   0x202F             MOVS     R0,#+47
   \   00000104   0xF88D 0x0000      STRB     R0,[SP, #+0]
    464                       state_next = SERIAL_LINE_PROBE_TX_STATE_LAST;
   \   00000108   0x200B             MOVS     R0,#+11
   \   0000010A   0x4682             MOV      R10,R0
    465                       break;
   \   0000010C   0xE007             B.N      ??SerialLine_RdOctet_14
    466          
    467          
    468                  default:
    469                  case SERIAL_LINE_PROBE_TX_STATE_LAST:
    470                       pinfo->TxState = SERIAL_LINE_PROBE_TX_STATE_SD0;
   \                     ??SerialLine_RdOctet_11: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xF88B 0x000D      STRB     R0,[R11, #+13]
    471                      *pdatum         = 0;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x7030             STRB     R0,[R6, #+0]
    472                      *perr = SERIAL_ERR_UNDERFLOW;
   \   00000118   0x2004             MOVS     R0,#+4
   \   0000011A   0x8038             STRH     R0,[R7, #+0]
    473                       return;
   \   0000011C   0xE006             B.N      ??SerialLine_RdOctet_13
    474              }
    475          
    476              pinfo->TxState = state_next;
   \                     ??SerialLine_RdOctet_14: (+1)
   \   0000011E   0xF88B 0xA00D      STRB     R10,[R11, #+13]
    477             *pdatum         = datum;
   \   00000122   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000126   0x7030             STRB     R0,[R6, #+0]
    478             *perr = SERIAL_ERR_NONE;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x8038             STRH     R0,[R7, #+0]
    479          }
   \                     ??SerialLine_RdOctet_13: (+1)
   \   0000012C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    480          
    481          
    482          /*$PAGE*/
    483          /*
    484          *********************************************************************************************************
    485          *                                        SerialLine_WrOctet()
    486          *
    487          * Description : Handle octet received from serial port.
    488          *
    489          * Argument(s) : pdev        Pointer to device.
    490          *
    491          *               pbuf        Pointer to buffer.
    492          *
    493          *               datum       Data octet to write.
    494          *
    495          *               perr        Pointer to variable that will receive the return error code from this function :
    496          *
    497          *                               SERIAL_ERR_NONE                 Octet handled.
    498          *                               SERIAL_ERR_OVERFLOW             Buffer overflow.
    499          *                               SERIAL_ERR_LINE_END             End of line detected.
    500          *
    501          * Return(s)   : None.
    502          *
    503          * Caller(s)   : Serial_IF_Rx().
    504          *
    505          * Note(s)     : (1) Interrupts are assumed to be disabled when this function is called.
    506          *********************************************************************************************************
    507          */
    508          

   \                                 In section .text, align 2, keep-with-next
    509          static  void  SerialLine_WrOctet (SERIAL_DEV  *pdev,
    510                                            SERIAL_BUF  *pbuf,
    511                                            CPU_INT08U   datum,
    512                                            SERIAL_ERR  *perr)
    513          {
   \                     SerialLine_WrOctet: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    514              CPU_SIZE_T         len_rem;
    515              CPU_INT08U         state_next;
    516              CPU_BOOLEAN        wr;
    517              CPU_SIZE_T         len;
    518              SERIAL_LINE_INFO  *pinfo;
    519          
    520          
    521              pinfo = (SERIAL_LINE_INFO *)pdev->LineDrv_Data;
   \   0000000C   0x6920             LDR      R0,[R4, #+16]
   \   0000000E   0x4683             MOV      R11,R0
    522          
    523              switch (pinfo->RxState) {
   \   00000010   0xF89B 0x0004      LDRB     R0,[R11, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD00F             BEQ.N    ??SerialLine_WrOctet_0
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD01F             BEQ.N    ??SerialLine_WrOctet_1
   \   0000001C   0xD315             BCC.N    ??SerialLine_WrOctet_2
   \   0000001E   0x2804             CMP      R0,#+4
   \   00000020   0xD02E             BEQ.N    ??SerialLine_WrOctet_3
   \   00000022   0xD324             BCC.N    ??SerialLine_WrOctet_4
   \   00000024   0x2806             CMP      R0,#+6
   \   00000026   0xD04A             BEQ.N    ??SerialLine_WrOctet_5
   \   00000028   0xD330             BCC.N    ??SerialLine_WrOctet_6
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xD04F             BEQ.N    ??SerialLine_WrOctet_7
   \   0000002E   0xD34B             BCC.N    ??SerialLine_WrOctet_8
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xD06F             BEQ.N    ??SerialLine_WrOctet_9
   \   00000034   0xD36B             BCC.N    ??SerialLine_WrOctet_10
   \   00000036   0xE079             B.N      ??SerialLine_WrOctet_11
    524                  case SERIAL_LINE_PROBE_RX_STATE_SD0:                    /* Receive the start first  start delimiter (SD0).      */
    525                       if (datum == SERIAL_LINE_PROBE_PROTOCOL_RX_SD0) {
   \                     ??SerialLine_WrOctet_0: (+1)
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0x2E75             CMP      R6,#+117
   \   0000003C   0xD102             BNE.N    ??SerialLine_WrOctet_12
    526                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x4681             MOV      R9,R0
   \   00000042   0xE001             B.N      ??SerialLine_WrOctet_13
    527                       } else {
    528                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_12: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x4681             MOV      R9,R0
    529                       }
    530                       break;
   \                     ??SerialLine_WrOctet_13: (+1)
   \   00000048   0xE072             B.N      ??SerialLine_WrOctet_14
    531          
    532          
    533                  case SERIAL_LINE_PROBE_RX_STATE_SD1:                    /* Receive the start second start delimiter (SD1).      */
    534                       if (datum == SERIAL_LINE_PROBE_PROTOCOL_RX_SD1) {
   \                     ??SerialLine_WrOctet_2: (+1)
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x2E43             CMP      R6,#+67
   \   0000004E   0xD102             BNE.N    ??SerialLine_WrOctet_15
    535                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD2;
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x4681             MOV      R9,R0
   \   00000054   0xE001             B.N      ??SerialLine_WrOctet_16
    536                       } else {
    537                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_15: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4681             MOV      R9,R0
    538                       }
    539                       break;
   \                     ??SerialLine_WrOctet_16: (+1)
   \   0000005A   0xE069             B.N      ??SerialLine_WrOctet_14
    540          
    541          
    542                  case SERIAL_LINE_PROBE_RX_STATE_SD2:                    /* Receive the start third  start delimiter (SD2).      */
    543                       if (datum == SERIAL_LINE_PROBE_PROTOCOL_RX_SD2) {
   \                     ??SerialLine_WrOctet_1: (+1)
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x2E50             CMP      R6,#+80
   \   00000060   0xD102             BNE.N    ??SerialLine_WrOctet_17
    544                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD3;
   \   00000062   0x2003             MOVS     R0,#+3
   \   00000064   0x4681             MOV      R9,R0
   \   00000066   0xE001             B.N      ??SerialLine_WrOctet_18
    545                       } else {
    546                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_17: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4681             MOV      R9,R0
    547                       }
    548                       break;
   \                     ??SerialLine_WrOctet_18: (+1)
   \   0000006C   0xE060             B.N      ??SerialLine_WrOctet_14
    549          
    550          
    551                  case SERIAL_LINE_PROBE_RX_STATE_SD3:                    /* Receive the start fourth start delimiter (SD3).      */
    552                       if (datum == SERIAL_LINE_PROBE_PROTOCOL_RX_SD3) {
   \                     ??SerialLine_WrOctet_4: (+1)
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E72             CMP      R6,#+114
   \   00000072   0xD102             BNE.N    ??SerialLine_WrOctet_19
    553                           state_next = SERIAL_LINE_PROBE_RX_STATE_LEN1;
   \   00000074   0x2004             MOVS     R0,#+4
   \   00000076   0x4681             MOV      R9,R0
   \   00000078   0xE001             B.N      ??SerialLine_WrOctet_20
    554                       } else {
    555                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_19: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x4681             MOV      R9,R0
    556                       }
    557                       break;
   \                     ??SerialLine_WrOctet_20: (+1)
   \   0000007E   0xE057             B.N      ??SerialLine_WrOctet_14
    558          
    559          
    560                  case SERIAL_LINE_PROBE_RX_STATE_LEN1:                   /* Receive the first  length byte.                      */
    561          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    562                       pinfo->RxChkSum = datum;
    563          #endif
    564                       pinfo->RxLenRem = datum;
   \                     ??SerialLine_WrOctet_3: (+1)
   \   00000080   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000082   0xF8CB 0x6008      STR      R6,[R11, #+8]
    565                       state_next      = SERIAL_LINE_PROBE_RX_STATE_LEN2;
   \   00000086   0x2005             MOVS     R0,#+5
   \   00000088   0x4681             MOV      R9,R0
    566                       break;
   \   0000008A   0xE051             B.N      ??SerialLine_WrOctet_14
    567          
    568          
    569                  case SERIAL_LINE_PROBE_RX_STATE_LEN2:                   /* Receive the second length byte.                      */
    570          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    571                       pinfo->RxChkSum += datum;
    572          #endif
    573                       pinfo->RxLenRem |= datum << 8;
   \                     ??SerialLine_WrOctet_6: (+1)
   \   0000008C   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0xEA50 0x2006      ORRS     R0,R0,R6, LSL #+8
   \   00000096   0xF8CB 0x0008      STR      R0,[R11, #+8]
    574          
    575                       len = SerialBuf_Size(pbuf);
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0x.... 0x....      BL       SerialBuf_Size
   \   000000A0   0x4682             MOV      R10,R0
    576          
    577                       if ((pinfo->RxLenRem == 0) ||
    578                           (pinfo->RxLenRem > len)) {
   \   000000A2   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD003             BEQ.N    ??SerialLine_WrOctet_21
   \   000000AA   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000000AE   0x4582             CMP      R10,R0
   \   000000B0   0xD202             BCS.N    ??SerialLine_WrOctet_22
    579                                                                          /* ... Cannot handle a packet of this size.             */
    580                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_21: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x4681             MOV      R9,R0
   \   000000B6   0xE001             B.N      ??SerialLine_WrOctet_23
    581                       } else {
    582                           state_next = SERIAL_LINE_PROBE_RX_STATE_CTR;
   \                     ??SerialLine_WrOctet_22: (+1)
   \   000000B8   0x2006             MOVS     R0,#+6
   \   000000BA   0x4681             MOV      R9,R0
    583                       }
    584                       break;
   \                     ??SerialLine_WrOctet_23: (+1)
   \   000000BC   0xE038             B.N      ??SerialLine_WrOctet_14
    585          
    586          
    587                  case SERIAL_LINE_PROBE_RX_STATE_CTR:                    /* Receive packet counter.                              */
    588                       pinfo->RxPktCtr = datum;             
   \                     ??SerialLine_WrOctet_5: (+1)
   \   000000BE   0xF88B 0x600C      STRB     R6,[R11, #+12]
    589                       state_next      = SERIAL_LINE_PROBE_RX_STATE_PAD;
   \   000000C2   0x2007             MOVS     R0,#+7
   \   000000C4   0x4681             MOV      R9,R0
    590                       break;
   \   000000C6   0xE033             B.N      ??SerialLine_WrOctet_14
    591          
    592          
    593                  case SERIAL_LINE_PROBE_RX_STATE_PAD:                    /* Receive the padding byte.                            */
    594                       state_next = SERIAL_LINE_PROBE_RX_STATE_DATA;
   \                     ??SerialLine_WrOctet_8: (+1)
   \   000000C8   0x2008             MOVS     R0,#+8
   \   000000CA   0x4681             MOV      R9,R0
    595                       break;
   \   000000CC   0xE030             B.N      ??SerialLine_WrOctet_14
    596          
    597          
    598                  case SERIAL_LINE_PROBE_RX_STATE_DATA:                   /* Receive the data.                                    */
    599                       wr = SerialBuf_WrOctet(pbuf, datum);
   \                     ??SerialLine_WrOctet_7: (+1)
   \   000000CE   0x0031             MOVS     R1,R6
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x.... 0x....      BL       SerialBuf_WrOctet
   \   000000D8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    600                       if (wr == DEF_NO) {
   \   000000DC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD105             BNE.N    ??SerialLine_WrOctet_24
    601                           pinfo->RxState = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0xF88B 0x0004      STRB     R0,[R11, #+4]
    602                          *perr = SERIAL_ERR_OVERFLOW;
   \   000000EA   0x2005             MOVS     R0,#+5
   \   000000EC   0x8038             STRH     R0,[R7, #+0]
    603                           return;
   \   000000EE   0xE023             B.N      ??SerialLine_WrOctet_25
    604                       }
    605          
    606          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    607                       pinfo->RxChkSum += datum;
    608          #endif
    609                       len_rem = pinfo->RxLenRem - 1;
   \                     ??SerialLine_WrOctet_24: (+1)
   \   000000F0   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000000F4   0x1E40             SUBS     R0,R0,#+1
   \   000000F6   0x4680             MOV      R8,R0
    610                       if (len_rem == 0) {
   \   000000F8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000FC   0xD102             BNE.N    ??SerialLine_WrOctet_26
    611                           state_next = SERIAL_LINE_PROBE_RX_STATE_CHKSUM;
   \   000000FE   0x2009             MOVS     R0,#+9
   \   00000100   0x4681             MOV      R9,R0
   \   00000102   0xE001             B.N      ??SerialLine_WrOctet_27
    612                       } else {
    613                           state_next = SERIAL_LINE_PROBE_RX_STATE_DATA;
   \                     ??SerialLine_WrOctet_26: (+1)
   \   00000104   0x2008             MOVS     R0,#+8
   \   00000106   0x4681             MOV      R9,R0
    614                       }
    615                       pinfo->RxLenRem = len_rem;
   \                     ??SerialLine_WrOctet_27: (+1)
   \   00000108   0xF8CB 0x8008      STR      R8,[R11, #+8]
    616                       break;
   \   0000010C   0xE010             B.N      ??SerialLine_WrOctet_14
    617          
    618          
    619                  case SERIAL_LINE_PROBE_RX_STATE_CHKSUM:             /* Receive the checksum.                                */
    620          #if (SERIAL_LINE_PROBE_USE_CHECKSUM == DEF_TRUE)
    621                       pinfo->RxChkSum += datum;
    622                       if ((pinfo->RxChkSum & 0xFF) == 0x00) {
    623                           state_next = SERIAL_LINE_PROBE_RX_STATE_ED;
    624                       } else {
    625                           state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
    626                          *perr = SERIAL_ERR_LINE_INVALID;
    627                           return;
    628                       }
    629          #else
    630                       state_next = SERIAL_LINE_PROBE_RX_STATE_ED;
   \                     ??SerialLine_WrOctet_10: (+1)
   \   0000010E   0x200A             MOVS     R0,#+10
   \   00000110   0x4681             MOV      R9,R0
    631          #endif
    632                       break;
   \   00000112   0xE00D             B.N      ??SerialLine_WrOctet_14
    633          
    634          
    635                  case SERIAL_LINE_PROBE_RX_STATE_ED:                     /* Receive the end delimiter.                           */
    636                       if (datum == SERIAL_LINE_PROBE_PROTOCOL_RX_ED) {
   \                     ??SerialLine_WrOctet_9: (+1)
   \   00000114   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000116   0x2E2F             CMP      R6,#+47
   \   00000118   0xD102             BNE.N    ??SerialLine_WrOctet_28
    637                          *perr = SERIAL_ERR_LINE_END;
   \   0000011A   0x2032             MOVS     R0,#+50
   \   0000011C   0x8038             STRH     R0,[R7, #+0]
   \   0000011E   0xE001             B.N      ??SerialLine_WrOctet_29
    638                       } else {
    639                          *perr = SERIAL_ERR_LINE_INVALID;
   \                     ??SerialLine_WrOctet_28: (+1)
   \   00000120   0x2033             MOVS     R0,#+51
   \   00000122   0x8038             STRH     R0,[R7, #+0]
    640                       }
    641                       pinfo->RxState = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_29: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF88B 0x0004      STRB     R0,[R11, #+4]
    642                       return;
   \   0000012A   0xE005             B.N      ??SerialLine_WrOctet_25
    643          
    644          
    645                  default:
    646                       state_next = SERIAL_LINE_PROBE_RX_STATE_SD0;
   \                     ??SerialLine_WrOctet_11: (+1)
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0x4681             MOV      R9,R0
    647                       break;
    648              }
    649          
    650              pinfo->RxState = state_next;
   \                     ??SerialLine_WrOctet_14: (+1)
   \   00000130   0xF88B 0x9004      STRB     R9,[R11, #+4]
    651             *perr = SERIAL_ERR_NONE;
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0x8038             STRH     R0,[R7, #+0]
    652          }
   \                     ??SerialLine_WrOctet_25: (+1)
   \   00000138   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     SerialLine_Probe_Info

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   SerialLine_Close
      24   SerialLine_Open
        24   -> Mem_HeapAlloc
      40   SerialLine_RdOctet
        40   -> SerialBuf_IsEmpty
        40   -> SerialBuf_RdOctet
        40   -> SerialBuf_Size
      40   SerialLine_WrOctet
        40   -> SerialBuf_Size
        40   -> SerialBuf_WrOctet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      36  SerialLine_Close
      78  SerialLine_Open
      16  SerialLine_Probe
       4  SerialLine_Probe_Info
     304  SerialLine_RdOctet
     316  SerialLine_WrOctet

 
   4 bytes in section .bss
  16 bytes in section .rodata
 738 bytes in section .text
 
 738 bytes of CODE  memory
  16 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
