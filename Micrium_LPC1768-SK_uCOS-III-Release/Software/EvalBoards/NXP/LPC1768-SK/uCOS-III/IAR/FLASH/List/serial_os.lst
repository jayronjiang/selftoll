###############################################################################
#
# IAR ANSI C/C++ Compiler V7.70.1.11437/W32 for ARM       06/Apr/2017  11:01:13
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\OS\uCOS-III\serial_os.c
#    Command line =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\OS\uCOS-III\serial_os.c
#        -lCN
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\CoreSupport\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Core\CM3\DeviceSupport\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\EvalBoards\NXP\LPC1768-SK\LPC17XXCMSIS\Drivers\include\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\LPC17xx\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Driver\NXP\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Line\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\uCOS-III\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\OS\
#        -I
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-Serial\Source\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\serial_os.lst
#    Object file  =  
#        E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\serial_os.o
#
###############################################################################

E:\新项目\移交资料LHT\自助缴费机\软件\Micrium_LPC1768-SK_uCOS-III-Release\Software\uC-Serial\OS\uCOS-III\serial_os.c
      1          /*
      2          *********************************************************************************************************
      3          *                                     SERIAL (BYTE) COMMUNICATION
      4          *
      5          *                         (c) Copyright 2007-2009; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                     SERIAL (BYTE) COMMUNICATION
     18          *
     19          *                                       OPERATING SYSTEM LAYER
     20          *                                          Micrium uC/OS-III
     21          *
     22          * Filename      : serial_os.c
     23          * Version       : V2.00
     24          * Programmer(s) : FGK
     25          *                 FT
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #include  <serial.h>
     36          #include  <serial_os.h>
     37          #include  <os.h>
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                              DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          #define  SERIAL_OS_MAX_NBR_SEM                  ((4u + SERIAL_CFG_TX_DESC_NBR) * SERIAL_CFG_MAX_NBR_IF)
     46          
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                       LOCAL GLOBAL VARIABLES
     51          *********************************************************************************************************
     52          */
     53          

   \                                 In section .bss, align 4
     54          static  MEM_POOL  OS_SemPool;
   \                     OS_SemPool:
   \   00000000                      DS8 72
     55          
     56          
     57          /*$PAGE*/
     58          /*
     59          *********************************************************************************************************
     60          *                                           SerialOS_Init()
     61          *
     62          * Description : Initialize OS layer.
     63          *
     64          * Argument(s) : perr        Pointer to variable that will receive the return error code from this function :
     65          *
     66          *                               SERIAL_OS_ERR_NONE          Initialization of OS layer successful.
     67          *                               SERIAL_OS_ERR_INIT          Initialization of OS layer failed.
     68          *
     69          * Return(s)   : None.
     70          *
     71          * Caller(s)   : Serial_Init().
     72          *
     73          * Note(s)     : None.
     74          *********************************************************************************************************
     75          */
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void  SerialOS_Init (SERIAL_ERR  *perr)
     78          {
   \                     SerialOS_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
     79              LIB_ERR     lib_err;
     80              CPU_SIZE_T  octects_reqd;
     81          
     82          
     83              Mem_PoolCreate((MEM_POOL    *)&OS_SemPool,
     84                             (void        *) 0,
     85                             (CPU_SIZE_T   ) 0u,
     86                             (CPU_SIZE_T   ) SERIAL_OS_MAX_NBR_SEM,
     87                             (CPU_SIZE_T   ) sizeof(OS_SEM),
     88                             (CPU_SIZE_T   ) 1u,
     89                             (CPU_SIZE_T  *)&octects_reqd,
     90                             (LIB_ERR     *)&lib_err);
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0xA805             ADD      R0,SP,#+20
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x2028             MOVS     R0,#+40
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x2338             MOVS     R3,#+56
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x....             LDR.N    R0,??DataTable3
   \   0000001E   0x.... 0x....      BL       Mem_PoolCreate
     91          
     92              if (lib_err != LIB_MEM_ERR_NONE) {
   \   00000022   0xF9BD 0x0010      LDRSH    R0,[SP, #+16]
   \   00000026   0xF242 0x7110      MOVW     R1,#+10000
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD002             BEQ.N    ??SerialOS_Init_0
     93                 *perr = SERIAL_OS_ERR_INIT;
   \   0000002E   0x203F             MOVS     R0,#+63
   \   00000030   0x8020             STRH     R0,[R4, #+0]
     94                  return;
   \   00000032   0xE001             B.N      ??SerialOS_Init_1
     95              }
     96          
     97             *perr = SERIAL_OS_ERR_NONE;
   \                     ??SerialOS_Init_0: (+1)
   \   00000034   0x203C             MOVS     R0,#+60
   \   00000036   0x8020             STRH     R0,[R4, #+0]
     98          }
   \                     ??SerialOS_Init_1: (+1)
   \   00000038   0xB006             ADD      SP,SP,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
     99          
    100          
    101          /*$PAGE*/
    102          /*
    103          *********************************************************************************************************
    104          *                                        SerialOS_SemCreate()
    105          *
    106          * Description : Create a semaphore.
    107          *
    108          * Argument(s) : cnt         Initial value for the semaphore.
    109          *
    110          * Return(s)   : Pointer to semaphore, if NO errors.
    111          *               Pointer to NULL,      otherwise.
    112          *
    113          * Caller(s)   : Serial_Wr().
    114          *
    115          * Note(s)     : None.
    116          *********************************************************************************************************
    117          */
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void  *SerialOS_SemCreate (CPU_INT16U  cnt)
    120          {
   \                     SerialOS_SemCreate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    121              OS_SEM   *psem;
    122              LIB_ERR   lib_err;
    123              OS_ERR    os_err;
    124          
    125          
    126              psem = (OS_SEM *)Mem_PoolBlkGet((MEM_POOL    *)&OS_SemPool,
    127                                              (CPU_SIZE_T   ) sizeof(OS_SEM),
    128                                              (LIB_ERR     *)&lib_err);
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x2128             MOVS     R1,#+40
   \   00000008   0x....             LDR.N    R0,??DataTable3
   \   0000000A   0x.... 0x....      BL       Mem_PoolBlkGet
   \   0000000E   0x0005             MOVS     R5,R0
    129          
    130              if (lib_err != LIB_MEM_ERR_NONE) {
   \   00000010   0xF9BD 0x0000      LDRSH    R0,[SP, #+0]
   \   00000014   0xF242 0x7110      MOVW     R1,#+10000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD001             BEQ.N    ??SerialOS_SemCreate_0
    131                  return ((void *)0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE013             B.N      ??SerialOS_SemCreate_1
    132              }
    133          
    134              OSSemCreate((OS_SEM      *)psem,
    135                          (CPU_CHAR    *)0,
    136                          (OS_SEM_CTR   )cnt,
    137                          (OS_ERR      *)&os_err);
   \                     ??SerialOS_SemCreate_0: (+1)
   \   00000020   0xF10D 0x0302      ADD      R3,SP,#+2
   \   00000024   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000026   0x0022             MOVS     R2,R4
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       OSSemCreate
    138          
    139              if (os_err != OS_ERR_NONE) {
   \   00000030   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD006             BEQ.N    ??SerialOS_SemCreate_2
    140                  Mem_PoolBlkFree((MEM_POOL  *)&OS_SemPool,
    141                                  (void      *) psem,
    142                                  (LIB_ERR   *)&lib_err);
   \   00000038   0x466A             MOV      R2,SP
   \   0000003A   0x0029             MOVS     R1,R5
   \   0000003C   0x....             LDR.N    R0,??DataTable3
   \   0000003E   0x.... 0x....      BL       Mem_PoolBlkFree
    143                  return ((void *)0);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE000             B.N      ??SerialOS_SemCreate_1
    144              }
    145          
    146              return ((void *)psem);
   \                     ??SerialOS_SemCreate_2: (+1)
   \   00000046   0x0028             MOVS     R0,R5
   \                     ??SerialOS_SemCreate_1: (+1)
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    147          }
    148          
    149          
    150          /*$PAGE*/
    151          /*
    152          *********************************************************************************************************
    153          *                                          SerialOS_SemDel()
    154          *
    155          * Description : Delete a semaphore.
    156          *
    157          * Argument(s) : psem        Pointer to semaphore to delete.
    158          *
    159          * Return(s)   : None.
    160          *
    161          * Caller(s)   : Serial_WrCallback().
    162          *
    163          * Note(s)     : (1) Always delete the semaphore even if tasks are pending on it.
    164          *
    165          *               (2) MUST NOT be called within a critical section.
    166          *********************************************************************************************************
    167          */
    168          

   \                                 In section .text, align 2, keep-with-next
    169          void  SerialOS_SemDel (void  *psem)
    170          {
   \                     SerialOS_SemDel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    171              LIB_ERR  lib_err;
    172              OS_ERR   os_err;
    173          
    174          
    175              OSSemPendAbort((OS_SEM  *)psem,
    176                             (OS_OPT   )OS_OPT_PEND_ABORT_ALL,
    177                             (OS_ERR  *)&os_err);
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0xF44F 0x7180      MOV      R1,#+256
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       OSSemPendAbort
    178          
    179              OSSemDel((OS_SEM  *)psem,
    180                       (OS_OPT   )OS_OPT_DEL_ALWAYS,
    181                       (OS_ERR  *)&os_err);
   \   00000012   0x466A             MOV      R2,SP
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       OSSemDel
    182          
    183              Mem_PoolBlkFree((MEM_POOL  *)&OS_SemPool,
    184                              (void      *) psem,
    185                              (LIB_ERR   *)&lib_err);
   \   0000001C   0xF10D 0x0202      ADD      R2,SP,#+2
   \   00000020   0x0021             MOVS     R1,R4
   \   00000022   0x....             LDR.N    R0,??DataTable3
   \   00000024   0x.... 0x....      BL       Mem_PoolBlkFree
    186          }
   \   00000028   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    187          
    188          
    189          /*$PAGE*/
    190          /*
    191          *********************************************************************************************************
    192          *                                         SerialOS_SemWait()
    193          *
    194          * Description : Wait for a semaphore to become available.
    195          *
    196          * Argument(s) : psem        Pointer to semaphore to wait.
    197          *
    198          *               timeout_ms  Optional timeout period in milliseconds. If specified 0, wait indefinitely.
    199          *
    200          *               perr        Pointer to variable that will receive the return error code from this function :
    201          *
    202          *                               SERIAL_OS_ERR_NONE              The wait on semaphore was successful.
    203          *                               SERIAL_OS_ERR_TIMEOUT           Semaphore not recv'd within specified 'timeout'.
    204          *                               SERIAL_OS_ERR_SIGNAL            Waiting on semaphore could not be performed.
    205          *
    206          * Return(s)   : None.
    207          *
    208          * Caller(s)   : Serial_Wr().
    209          *
    210          * Note(s)     : None.
    211          *********************************************************************************************************
    212          */
    213          

   \                                 In section .text, align 2, keep-with-next
    214          void  SerialOS_SemWait (void        *psem,
    215                                  CPU_INT32U   timeout_ms,
    216                                  SERIAL_ERR  *perr)
    217          {
   \                     SerialOS_SemWait: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    218              OS_TICK  ticks;
    219              OS_ERR   os_err;
    220          
    221          
    222              ticks = (timeout_ms * OSCfg_TickRate_Hz + (DEF_TIME_NBR_mS_PER_SEC - 1u)) / DEF_TIME_NBR_mS_PER_SEC;
   \   0000000A   0x....             LDR.N    R0,??DataTable3_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xFB00 0xF005      MUL      R0,R0,R5
   \   00000012   0xF200 0x30E7      ADDW     R0,R0,#+999
   \   00000016   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001E   0x0007             MOVS     R7,R0
    223          
    224              (void)OSSemPend((OS_SEM   *) psem,
    225                              (OS_TICK   ) ticks,
    226                              (OS_OPT    ) OS_OPT_PEND_BLOCKING,
    227                              (CPU_TS   *) 0,
    228                              (OS_ERR   *)&os_err);
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x2200             MOVS     R2,#+0
   \   00000028   0x0039             MOVS     R1,R7
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       OSSemPend
    229          
    230              switch (os_err) {
   \   00000030   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD004             BEQ.N    ??SerialOS_SemWait_0
   \   00000038   0xF247 0x21D9      MOVW     R1,#+29401
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD003             BEQ.N    ??SerialOS_SemWait_1
   \   00000040   0xE005             B.N      ??SerialOS_SemWait_2
    231                  case OS_ERR_NONE:
    232                      *perr = SERIAL_OS_ERR_NONE;
   \                     ??SerialOS_SemWait_0: (+1)
   \   00000042   0x203C             MOVS     R0,#+60
   \   00000044   0x8030             STRH     R0,[R6, #+0]
    233                       break;
   \   00000046   0xE004             B.N      ??SerialOS_SemWait_3
    234          
    235                  case OS_ERR_TIMEOUT:
    236                      *perr = SERIAL_OS_ERR_TIMEOUT;
   \                     ??SerialOS_SemWait_1: (+1)
   \   00000048   0x203E             MOVS     R0,#+62
   \   0000004A   0x8030             STRH     R0,[R6, #+0]
    237                       break;
   \   0000004C   0xE001             B.N      ??SerialOS_SemWait_3
    238          
    239                  default:
    240                      *perr = SERIAL_OS_ERR_SIGNAL;
   \                     ??SerialOS_SemWait_2: (+1)
   \   0000004E   0x203D             MOVS     R0,#+61
   \   00000050   0x8030             STRH     R0,[R6, #+0]
    241                       break;
    242              }
    243          }
   \                     ??SerialOS_SemWait_3: (+1)
   \   00000052   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    244          
    245          
    246          /*$PAGE*/
    247          /*
    248          *********************************************************************************************************
    249          *                                        SerialOS_SemTryLock()
    250          *
    251          * Description : Try to acquire semaphore if available.
    252          *
    253          * Argument(s) : psem        Pointer to semaphore to acquire.
    254          *
    255          * Return(s)   : DEF_OK,   if semaphore acquired.
    256          *               DEF_FAIL, otherwise.
    257          *
    258          * Caller(s)   : Serial_WrAsync().
    259          *
    260          * Note(s)     : None.
    261          *********************************************************************************************************
    262          */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          CPU_BOOLEAN  SerialOS_SemTryLock (void  *psem)
    265          {
   \                     SerialOS_SemTryLock: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266              OS_ERR  os_err;
    267          
    268          
    269              (void)OSSemPend((OS_SEM   *) psem,
    270                              (OS_TICK   ) 0u,
    271                              (OS_OPT    ) OS_OPT_PEND_NON_BLOCKING,
    272                              (CPU_TS   *) 0,
    273                              (OS_ERR   *)&os_err);
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xF44F 0x4200      MOV      R2,#+32768
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       OSSemPend
    274          
    275              if (os_err != OS_ERR_NONE) {
   \   00000016   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??SerialOS_SemTryLock_0
    276                  return (DEF_FAIL);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE000             B.N      ??SerialOS_SemTryLock_1
    277              }
    278          
    279              return (DEF_OK);
   \                     ??SerialOS_SemTryLock_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \                     ??SerialOS_SemTryLock_1: (+1)
   \   00000024   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    280          }
    281          
    282          
    283          /*$PAGE*/
    284          /*
    285          *********************************************************************************************************
    286          *                                        SerialOS_SemSignal()
    287          *
    288          * Description : Signal a semaphore.
    289          *
    290          * Argument(s) : psem        Pointer to semaphore to signal.
    291          *
    292          * Return(s)   : DEF_OK,   if semaphore signaled.
    293          *               DEF_FAIL, otherwise.
    294          *
    295          * Caller(s)   : Serial_WrCallback().
    296          *
    297          * Note(s)     : None.
    298          *********************************************************************************************************
    299          */
    300          

   \                                 In section .text, align 2, keep-with-next
    301          CPU_BOOLEAN  SerialOS_SemSignal (void  *psem)
    302          {
   \                     SerialOS_SemSignal: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    303              OS_ERR  os_err;
    304          
    305          
    306              (void)OSSemPost((OS_SEM  *)psem,
    307                              (OS_OPT   )OS_OPT_POST_1,
    308                              (OS_ERR  *)&os_err);
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       OSSemPost
    309          
    310              if (os_err != OS_ERR_NONE) {
   \   00000010   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??SerialOS_SemSignal_0
    311                  return (DEF_FAIL);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??SerialOS_SemSignal_1
    312              }
    313          
    314              return (DEF_OK);
   \                     ??SerialOS_SemSignal_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??SerialOS_SemSignal_1: (+1)
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    315          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OS_SemPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SerialOS_Init
        32   -> Mem_PoolCreate
      16   SerialOS_SemCreate
        16   -> Mem_PoolBlkFree
        16   -> Mem_PoolBlkGet
        16   -> OSSemCreate
      16   SerialOS_SemDel
        16   -> Mem_PoolBlkFree
        16   -> OSSemDel
        16   -> OSSemPendAbort
      16   SerialOS_SemSignal
        16   -> OSSemPost
      16   SerialOS_SemTryLock
        16   -> OSSemPend
      32   SerialOS_SemWait
        32   -> OSSemPend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
      72  OS_SemPool
      60  SerialOS_Init
      74  SerialOS_SemCreate
      42  SerialOS_SemDel
      32  SerialOS_SemSignal
      38  SerialOS_SemTryLock
      84  SerialOS_SemWait

 
  72 bytes in section .bss
 338 bytes in section .text
 
 338 bytes of CODE memory
  72 bytes of DATA memory

Errors: none
Warnings: none
